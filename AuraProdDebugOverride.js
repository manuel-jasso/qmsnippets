(function () {
  'use strict';

  /**
   * Copyright (c) 2024 Salesforce, Inc.
   */
  if (!globalThis.lwcRuntimeFlags) {
    Object.defineProperty(globalThis, 'lwcRuntimeFlags', { value: Object.create(null) });
  }
  if (!lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE) {
  /**
   * Copyright (c) 2024 Salesforce, Inc.
   */
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
   *
   * @param value
   * @param msg
   */
  function invariant(value, msg) {
      if (!value) {
          throw new Error(`Invariant Violation: ${msg}`);
      }
  }
  /**
   *
   * @param value
   * @param msg
   */
  function isTrue$1(value, msg) {
      if (!value) {
          throw new Error(`Assert Violation: ${msg}`);
      }
  }
  /**
   *
   * @param value
   * @param msg
   */
  function isFalse$1(value, msg) {
      if (value) {
          throw new Error(`Assert Violation: ${msg}`);
      }
  }
  /**
   *
   * @param msg
   */
  function fail(msg) {
      throw new Error(msg);
  }

  var assert = /*#__PURE__*/Object.freeze({
      __proto__: null,
      fail: fail,
      invariant: invariant,
      isFalse: isFalse$1,
      isTrue: isTrue$1
  });

  /*
   * Copyright (c) 2024, Salesforce, Inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const { 
  /** Detached {@linkcode Object.assign}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign MDN Reference}. */
  assign, 
  /** Detached {@linkcode Object.create}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create MDN Reference}. */
  create, 
  /** Detached {@linkcode Object.defineProperties}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties MDN Reference}. */
  defineProperties, 
  /** Detached {@linkcode Object.defineProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty MDN Reference}. */
  defineProperty, 
  /** Detached {@linkcode Object.entries}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries MDN Reference}. */
  entries, 
  /** Detached {@linkcode Object.freeze}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze MDN Reference}. */
  freeze, 
  /** Detached {@linkcode Object.getOwnPropertyDescriptor}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor MDN Reference}. */
  getOwnPropertyDescriptor, 
  /** Detached {@linkcode Object.getOwnPropertyDescriptors}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors MDN Reference}. */
  getOwnPropertyDescriptors, 
  /** Detached {@linkcode Object.getOwnPropertyNames}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames MDN Reference}. */
  getOwnPropertyNames, 
  /** Detached {@linkcode Object.getPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf MDN Reference}. */
  getPrototypeOf, 
  /** Detached {@linkcode Object.hasOwnProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty MDN Reference}. */
  hasOwnProperty, 
  /** Detached {@linkcode Object.isFrozen}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen MDN Reference}. */
  isFrozen, 
  /** Detached {@linkcode Object.keys}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys MDN Reference}. */
  keys, 
  /** Detached {@linkcode Object.seal}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal MDN Reference}. */
  seal, 
  /** Detached {@linkcode Object.setPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf MDN Reference}. */
  setPrototypeOf, } = Object;
  /** Detached {@linkcode Array.isArray}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray MDN Reference}. */
  const { isArray } = Array;
  // For some reason, JSDoc don't get picked up for multiple renamed destructured constants (even
  // though it works fine for one, e.g. isArray), so comments for these are added to the export
  // statement, rather than this declaration.
  const { concat: ArrayConcat, copyWithin: ArrayCopyWithin, every: ArrayEvery, fill: ArrayFill, filter: ArrayFilter, find: ArrayFind, findIndex: ArrayFindIndex, includes: ArrayIncludes, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush, reduce: ArrayReduce, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, // Weird anomaly!
   } = Array.prototype;
  /**
   * Determines whether the argument is `undefined`.
   * @param obj Value to test
   * @returns `true` if the value is `undefined`.
   */
  function isUndefined(obj) {
      return obj === undefined;
  }
  /**
   * Determines whether the argument is `null`.
   * @param obj Value to test
   * @returns `true` if the value is `null`.
   */
  function isNull(obj) {
      return obj === null;
  }
  /**
   * Determines whether the argument is `true`.
   * @param obj Value to test
   * @returns `true` if the value is `true`.
   */
  function isTrue(obj) {
      return obj === true;
  }
  /**
   * Determines whether the argument is `false`.
   * @param obj Value to test
   * @returns `true` if the value is `false`.
   */
  function isFalse(obj) {
      return obj === false;
  }
  /**
   * Determines whether the argument is a function.
   * @param obj Value to test
   * @returns `true` if the value is a function.
   */
  // Replacing `Function` with a narrower type that works for all our use cases is tricky...
  // eslint-disable-next-line @typescript-eslint/ban-types
  function isFunction(obj) {
      return typeof obj === 'function';
  }
  /**
   * Determines whether the argument is an object or null.
   * @param obj Value to test
   * @returns `true` if the value is an object or null.
   */
  function isObject(obj) {
      return typeof obj === 'object';
  }
  const OtS = {}.toString;
  /**
   * Converts the argument to a string, safely accounting for objects with "null" prototype.
   * Note that `toString(null)` returns `"[object Null]"` rather than `"null"`.
   * @param obj Value to convert to a string.
   * @returns String representation of the value.
   */
  function toString(obj) {
      if (obj?.toString) {
          // Arrays might hold objects with "null" prototype So using
          // Array.prototype.toString directly will cause an error Iterate through
          // all the items and handle individually.
          if (isArray(obj)) {
              // This behavior is slightly different from Array#toString:
              // 1. Array#toString calls `this.join`, rather than Array#join
              // Ex: arr = []; arr.join = () => 1; arr.toString() === 1; toString(arr) === ''
              // 2. Array#toString delegates to Object#toString if `this.join` is not a function
              // Ex: arr = []; arr.join = 'no'; arr.toString() === '[object Array]; toString(arr) = ''
              // 3. Array#toString converts null/undefined to ''
              // Ex: arr = [null, undefined]; arr.toString() === ','; toString(arr) === '[object Null],undefined'
              // 4. Array#toString converts recursive references to arrays to ''
              // Ex: arr = [1]; arr.push(arr, 2); arr.toString() === '1,,2'; toString(arr) throws
              // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString
              return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
          }
          return obj.toString();
      }
      else if (typeof obj === 'object') {
          // This catches null and returns "[object Null]". Weird, but kept for backwards compatibility.
          return OtS.call(obj);
      }
      else {
          return String(obj);
      }
  }

  /*
   * Copyright (c) 2023, Salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const KEY__SHADOW_RESOLVER = '$shadowResolver$';
  const KEY__SHADOW_RESOLVER_PRIVATE = '$$ShadowResolverKey$$';
  const KEY__SHADOW_STATIC = '$shadowStaticNode$';
  const KEY__SHADOW_STATIC_PRIVATE = '$shadowStaticNodeKey$';
  const KEY__SHADOW_TOKEN = '$shadowToken$';
  const KEY__SHADOW_TOKEN_PRIVATE = '$$ShadowTokenKey$$';
  // TODO [#3733]: remove support for legacy scope tokens
  const KEY__LEGACY_SHADOW_TOKEN = '$legacyShadowToken$';
  const KEY__LEGACY_SHADOW_TOKEN_PRIVATE = '$$LegacyShadowTokenKey$$';
  const KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';
  const KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';
  const KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';
  /** version: 6.4.5 */

  /**
   * Copyright (c) 2024 Salesforce, Inc.
   */
  if (!globalThis.lwcRuntimeFlags) {
      Object.defineProperty(globalThis, 'lwcRuntimeFlags', { value: create(null) });
  }
  /** version: 6.4.5 */

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // TODO [#2472]: Remove this workaround when appropriate.
  // eslint-disable-next-line @lwc/lwc-internal/no-global-node
  const _Node = Node;
  const nodePrototype = _Node.prototype;
  const { DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, ELEMENT_NODE, TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, } = _Node;
  const { appendChild, cloneNode, compareDocumentPosition, insertBefore, removeChild, replaceChild, hasChildNodes, } = nodePrototype;
  const { contains } = HTMLElement.prototype;
  const firstChildGetter = getOwnPropertyDescriptor(nodePrototype, 'firstChild').get;
  const lastChildGetter = getOwnPropertyDescriptor(nodePrototype, 'lastChild').get;
  const textContentGetter = getOwnPropertyDescriptor(nodePrototype, 'textContent').get;
  const parentNodeGetter = getOwnPropertyDescriptor(nodePrototype, 'parentNode').get;
  const ownerDocumentGetter = getOwnPropertyDescriptor(nodePrototype, 'ownerDocument').get;
  const parentElementGetter = getOwnPropertyDescriptor(nodePrototype, 'parentElement').get;
  const textContextSetter = getOwnPropertyDescriptor(nodePrototype, 'textContent').set;
  const childNodesGetter = getOwnPropertyDescriptor(nodePrototype, 'childNodes').get;
  const nextSiblingGetter = getOwnPropertyDescriptor(nodePrototype, 'nextSibling').get;
  const isConnected = hasOwnProperty.call(nodePrototype, 'isConnected')
      ? getOwnPropertyDescriptor(nodePrototype, 'isConnected').get
      : function () {
          const doc = ownerDocumentGetter.call(this);
          // IE11
          return (
          // if doc is null, it means `this` is actually a document instance which
          // is always connected
          doc === null ||
              (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0);
      };

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const { getAttribute, getBoundingClientRect, getElementsByTagName: getElementsByTagName$1, getElementsByTagNameNS: getElementsByTagNameNS$1, hasAttribute, querySelector, querySelectorAll: querySelectorAll$1, removeAttribute, setAttribute, } = Element.prototype;
  const attachShadow$1 = hasOwnProperty.call(Element.prototype, 'attachShadow')
      ? Element.prototype.attachShadow
      : () => {
          throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');
      };
  const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
  const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
  const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
  const innerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'innerText');
  const innerTextGetter = innerTextDescriptor
      ? innerTextDescriptor.get
      : null;
  const innerTextSetter = innerTextDescriptor
      ? innerTextDescriptor.set
      : null;
  // Note: Firefox does not have outerText, https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText
  const outerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'outerText');
  const outerTextGetter = outerTextDescriptor
      ? outerTextDescriptor.get
      : null;
  const outerTextSetter = outerTextDescriptor
      ? outerTextDescriptor.set
      : null;
  const innerHTMLDescriptor = getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
  const innerHTMLGetter = innerHTMLDescriptor.get;
  const innerHTMLSetter = innerHTMLDescriptor.set;
  const outerHTMLDescriptor = getOwnPropertyDescriptor(Element.prototype, 'outerHTML');
  const outerHTMLGetter = outerHTMLDescriptor.get;
  const outerHTMLSetter = outerHTMLDescriptor.set;
  const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
  const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
  const tabIndexGetter = tabIndexDescriptor.get;
  const tabIndexSetter = tabIndexDescriptor.set;
  const matches = Element.prototype.matches;
  const childrenGetter = getOwnPropertyDescriptor(Element.prototype, 'children').get;
  // for IE11, access from HTMLElement
  // for all other browsers access the method from the parent Element interface
  const { getElementsByClassName: getElementsByClassName$1 } = HTMLElement.prototype;
  const shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot')
      ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get
      : () => null;
  const assignedSlotGetter$1 = hasOwnProperty.call(Element.prototype, 'assignedSlot')
      ? getOwnPropertyDescriptor(Element.prototype, 'assignedSlot').get
      : () => null;

  /*
   * Copyright (c) 2023, Salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const assignedNodes = HTMLSlotElement.prototype.assignedNodes;
  const assignedElements = HTMLSlotElement.prototype.assignedElements;

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
  const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
  const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;
  // IE does not implement composedPath() but that's ok because we only use this instead of our
  // composedPath() polyfill when dealing with native shadow DOM components in mixed mode. Defaulting
  // to a NOOP just to be safe, even though this is almost guaranteed to be defined such a scenario.
  const composedPath = hasOwnProperty.call(Event.prototype, 'composedPath')
      ? Event.prototype.composedPath
      : () => [];

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
  const elementFromPoint = Document.prototype.elementFromPoint;
  const elementsFromPoint = Document.prototype.elementsFromPoint;
  // defaultView can be null when a document has no browsing context. For example, the owner document
  // of a node in a template doesn't have a default view: https://jsfiddle.net/hv9z0q5a/
  const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
  const { querySelectorAll, getElementById, getElementsByClassName, getElementsByTagName, getElementsByTagNameNS, } = Document.prototype;
  // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
  // In all other browsers have the method on Document.prototype
  const { getElementsByName } = HTMLDocument.prototype;

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const { addEventListener: windowAddEventListener, removeEventListener: windowRemoveEventListener, getComputedStyle: windowGetComputedStyle, getSelection: windowGetSelection, } = window;

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // There is code in the polyfills that requires access to the unpatched
  // Mutation Observer constructor, this the code for that.
  // Eventually, the polyfill should uses the patched version, and this file can be removed.
  const MO = MutationObserver;
  const MutationObserverObserve = MO.prototype.observe;

  /*
   * Copyright (c) 2023, Salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // Capture the global `ShadowRoot` since synthetic shadow will override it later
  const NativeShadowRoot = ShadowRoot;
  const isInstanceOfNativeShadowRoot = (node) => node instanceof NativeShadowRoot;

  /*
   * Copyright (c) 2023, Salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const eventTargetPrototype = EventTarget.prototype;
  const { addEventListener, dispatchEvent, removeEventListener } = eventTargetPrototype;

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // Used as a back reference to identify the host element
  const HostElementKey = '$$HostElementKey$$';
  const ShadowedNodeKey = '$$ShadowedNodeKey$$';
  function fastDefineProperty(node, propName, config) {
      const shadowedNode = node;
      {
          // in dev, we are more restrictive
          defineProperty(shadowedNode, propName, config);
      }
  }
  function setNodeOwnerKey(node, value) {
      fastDefineProperty(node, HostElementKey, { value, configurable: true });
  }
  function setNodeKey(node, value) {
      fastDefineProperty(node, ShadowedNodeKey, { value });
  }
  function getNodeOwnerKey(node) {
      return node[HostElementKey];
  }
  function getNodeNearestOwnerKey(node) {
      let host = node;
      let hostKey;
      // search for the first element with owner identity
      // in case of manually inserted elements and elements slotted from Light DOM
      while (!isNull(host)) {
          hostKey = getNodeOwnerKey(host);
          if (!isUndefined(hostKey)) {
              return hostKey;
          }
          host = parentNodeGetter.call(host);
          // Elements slotted from top level light DOM into synthetic shadow
          // reach the slot tag from the shadow element first
          if (!isNull(host) && isSyntheticSlotElement(host)) {
              return undefined;
          }
      }
  }
  function getNodeKey(node) {
      return node[ShadowedNodeKey];
  }
  /**
   * This function does not traverse up for performance reasons, but is sufficient for most use
   * cases. If we need to traverse up and verify those nodes that don't have owner key, use
   * isNodeDeepShadowed instead.
   * @param node
   */
  function isNodeShadowed(node) {
      return !isUndefined(getNodeOwnerKey(node));
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // when finding a slot in the DOM, we can fold it if it is contained
  // inside another slot.
  function foldSlotElement(slot) {
      let parent = parentElementGetter.call(slot);
      while (!isNull(parent) && isSlotElement(parent)) {
          slot = parent;
          parent = parentElementGetter.call(slot);
      }
      return slot;
  }
  function isNodeSlotted(host, node) {
      {
          if (!(host instanceof HTMLElement)) {
              // eslint-disable-next-line no-console
              console.error(`isNodeSlotted() should be called with a host as the first argument`);
          }
          if (!(node instanceof _Node)) {
              // eslint-disable-next-line no-console
              console.error(`isNodeSlotted() should be called with a node as the second argument`);
          }
          if (!(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS)) {
              // eslint-disable-next-line no-console
              console.error(`isNodeSlotted() should never be called with a node that is not a child node of the given host`);
          }
      }
      const hostKey = getNodeKey(host);
      // this routine assumes that the node is coming from a different shadow (it is not owned by the host)
      // just in case the provided node is not an element
      let currentElement = node instanceof Element ? node : parentElementGetter.call(node);
      while (!isNull(currentElement) && currentElement !== host) {
          const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
          const parent = parentElementGetter.call(currentElement);
          if (elmOwnerKey === hostKey) {
              // we have reached an element inside the host's template, and only if
              // that element is an slot, then the node is considered slotted
              return isSlotElement(currentElement);
          }
          else if (parent === host) {
              return false;
          }
          else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
              // we are crossing a boundary of some sort since the elm and its parent
              // have different owner key. for slotted elements, this is possible
              // if the parent happens to be a slot.
              if (isSlotElement(parent)) {
                  /*
                   * the slot parent might be allocated inside another slot, think of:
                   * <x-root> (<--- root element)
                   *    <x-parent> (<--- own by x-root)
                   *       <x-child> (<--- own by x-root)
                   *           <slot> (<--- own by x-child)
                   *               <slot> (<--- own by x-parent)
                   *                  <div> (<--- own by x-root)
                   *
                   * while checking if x-parent has the div slotted, we need to traverse
                   * up, but when finding the first slot, we skip that one in favor of the
                   * most outer slot parent before jumping into its corresponding host.
                   */
                  currentElement = getNodeOwner(foldSlotElement(parent));
                  if (!isNull(currentElement)) {
                      if (currentElement === host) {
                          // the slot element is a top level element inside the shadow
                          // of a host that was allocated into host in question
                          return true;
                      }
                      else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
                          // the slot element is an element inside the shadow
                          // of a host that was allocated into host in question
                          return true;
                      }
                  }
              }
              else {
                  return false;
              }
          }
          else {
              currentElement = parent;
          }
      }
      return false;
  }
  function getNodeOwner(node) {
      if (!(node instanceof _Node)) {
          return null;
      }
      const ownerKey = getNodeNearestOwnerKey(node);
      if (isUndefined(ownerKey)) {
          return null;
      }
      let nodeOwner = node;
      // At this point, node is a valid node with owner identity, now we need to find the owner node
      // search for a custom element with a VM that owns the first element with owner identity attached to it
      while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
          nodeOwner = parentNodeGetter.call(nodeOwner);
      }
      if (isNull(nodeOwner)) {
          return null;
      }
      return nodeOwner;
  }
  function isSyntheticSlotElement(node) {
      return isSlotElement(node) && isNodeShadowed(node);
  }
  function isSlotElement(node) {
      return node instanceof HTMLSlotElement;
  }
  function isNodeOwnedBy(owner, node) {
      {
          if (!(owner instanceof HTMLElement)) {
              // eslint-disable-next-line no-console
              console.error(`isNodeOwnedBy() should be called with an element as the first argument`);
          }
          if (!(node instanceof _Node)) {
              // eslint-disable-next-line no-console
              console.error(`isNodeOwnedBy() should be called with a node as the second argument`);
          }
          if (!(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS)) {
              // eslint-disable-next-line no-console
              console.error(`isNodeOwnedBy() should never be called with a node that is not a child node of of the given owner`);
          }
      }
      const ownerKey = getNodeNearestOwnerKey(node);
      if (isUndefined(ownerKey)) {
          // in case of root level light DOM element slotting into a synthetic shadow
          const host = parentNodeGetter.call(node);
          if (!isNull(host) && isSyntheticSlotElement(host)) {
              return false;
          }
          // in case of manually inserted elements
          return true;
      }
      return getNodeKey(owner) === ownerKey;
  }
  function shadowRootChildNodes(root) {
      const elm = getHost(root);
      return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }
  function getAllSlottedMatches(host, nodeList) {
      const filteredAndPatched = [];
      for (let i = 0, len = nodeList.length; i < len; i += 1) {
          const node = nodeList[i];
          if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
              ArrayPush.call(filteredAndPatched, node);
          }
      }
      return filteredAndPatched;
  }
  function getFirstSlottedMatch(host, nodeList) {
      for (let i = 0, len = nodeList.length; i < len; i += 1) {
          const node = nodeList[i];
          if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
              return node;
          }
      }
      return null;
  }
  function getAllMatches(owner, nodeList) {
      const filteredAndPatched = [];
      for (let i = 0, len = nodeList.length; i < len; i += 1) {
          const node = nodeList[i];
          const isOwned = isNodeOwnedBy(owner, node);
          if (isOwned) {
              // Patch querySelector, querySelectorAll, etc
              // if element is owned by VM
              ArrayPush.call(filteredAndPatched, node);
          }
      }
      return filteredAndPatched;
  }
  function getFirstMatch(owner, nodeList) {
      for (let i = 0, len = nodeList.length; i < len; i += 1) {
          if (isNodeOwnedBy(owner, nodeList[i])) {
              return nodeList[i];
          }
      }
      return null;
  }
  function shadowRootQuerySelector(root, selector) {
      const elm = getHost(root);
      const nodeList = arrayFromCollection(querySelectorAll$1.call(elm, selector));
      return getFirstMatch(elm, nodeList);
  }
  function shadowRootQuerySelectorAll(root, selector) {
      const elm = getHost(root);
      const nodeList = querySelectorAll$1.call(elm, selector);
      return getAllMatches(elm, arrayFromCollection(nodeList));
  }
  function getFilteredChildNodes(node) {
      if (!isSyntheticShadowHost(node) && !isSlotElement(node)) {
          // regular element - fast path
          const children = childNodesGetter.call(node);
          return arrayFromCollection(children);
      }
      if (isSyntheticShadowHost(node)) {
          // we need to get only the nodes that were slotted
          const slots = arrayFromCollection(querySelectorAll$1.call(node, 'slot'));
          const resolver = getShadowRootResolver(getShadowRoot(node));
          // Typescript is inferring the wrong function type for this particular
          // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
          // @ts-expect-error type-mismatch
          return ArrayReduce.call(slots, (seed, slot) => {
              if (resolver === getShadowRootResolver(slot)) {
                  ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
              }
              return seed;
          }, []);
      }
      else {
          // slot element
          const children = arrayFromCollection(childNodesGetter.call(node));
          const resolver = getShadowRootResolver(node);
          return ArrayFilter.call(children, (child) => resolver === getShadowRootResolver(child));
      }
  }
  function getFilteredSlotAssignedNodes(slot) {
      const owner = getNodeOwner(slot);
      if (isNull(owner)) {
          return [];
      }
      const childNodes = arrayFromCollection(childNodesGetter.call(slot));
      return ArrayFilter.call(childNodes, (child) => !isNodeShadowed(child) || !isNodeOwnedBy(owner, child));
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  // This code is inspired by Polymer ShadyDOM Polyfill
  function getInnerHTML(node) {
      let s = '';
      const childNodes = getFilteredChildNodes(node);
      for (let i = 0, len = childNodes.length; i < len; i += 1) {
          s += getOuterHTML(childNodes[i]);
      }
      return s;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  // This code is inspired by Polymer ShadyDOM Polyfill
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
  const escapeAttrRegExp = /[&\u00A0"]/g;
  const escapeDataRegExp = /[&\u00A0<>]/g;
  const { replace, toLowerCase } = String.prototype;
  function escapeReplace(c) {
      switch (c) {
          case '&':
              return '&amp;';
          case '<':
              return '&lt;';
          case '>':
              return '&gt;';
          case '"':
              return '&quot;';
          case '\u00A0':
              return '&nbsp;';
          default:
              return '';
      }
  }
  function escapeAttr(s) {
      return replace.call(s, escapeAttrRegExp, escapeReplace);
  }
  function escapeData(s) {
      return replace.call(s, escapeDataRegExp, escapeReplace);
  }
  // http://www.whatwg.org/specs/web-apps/current-work/#void-elements
  const voidElements = new Set([
      'AREA',
      'BASE',
      'BR',
      'COL',
      'COMMAND',
      'EMBED',
      'HR',
      'IMG',
      'INPUT',
      'KEYGEN',
      'LINK',
      'META',
      'PARAM',
      'SOURCE',
      'TRACK',
      'WBR',
  ]);
  const plaintextParents = new Set([
      'STYLE',
      'SCRIPT',
      'XMP',
      'IFRAME',
      'NOEMBED',
      'NOFRAMES',
      'PLAINTEXT',
      'NOSCRIPT',
  ]);
  function getOuterHTML(node) {
      switch (node.nodeType) {
          case ELEMENT_NODE: {
              const { attributes: attrs } = node;
              const tagName = tagNameGetter.call(node);
              let s = '<' + toLowerCase.call(tagName);
              for (let i = 0, attr; (attr = attrs[i]); i++) {
                  s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
              }
              s += '>';
              if (voidElements.has(tagName)) {
                  return s;
              }
              return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
          }
          case TEXT_NODE: {
              const { data, parentNode } = node;
              if (parentNode instanceof Element &&
                  plaintextParents.has(tagNameGetter.call(parentNode))) {
                  return data;
              }
              return escapeData(data);
          }
          case CDATA_SECTION_NODE: {
              return `<!CDATA[[${node.data}]]>`;
          }
          case PROCESSING_INSTRUCTION_NODE: {
              return `<?${node.target} ${node.data}?>`;
          }
          case COMMENT_NODE: {
              return `<!--${node.data}-->`;
          }
          default: {
              // intentionally ignoring unknown node types
              // Note: since this routine is always invoked for childNodes
              // we can safety ignore type 9, 10 and 99 (document, fragment and doctype)
              return '';
          }
      }
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  // This code is inspired by Polymer ShadyDOM Polyfill
  function getTextContent(node) {
      switch (node.nodeType) {
          case ELEMENT_NODE: {
              const childNodes = getFilteredChildNodes(node);
              let content = '';
              for (let i = 0, len = childNodes.length; i < len; i += 1) {
                  const currentNode = childNodes[i];
                  if (currentNode.nodeType !== COMMENT_NODE) {
                      content += getTextContent(currentNode);
                  }
              }
              return content;
          }
          default:
              return node.nodeValue;
      }
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const Items$1 = new WeakMap();
  function StaticNodeList() {
      throw new TypeError('Illegal constructor');
  }
  StaticNodeList.prototype = create(NodeList.prototype, {
      constructor: {
          writable: true,
          configurable: true,
          value: StaticNodeList,
      },
      item: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(index) {
              return this[index];
          },
      },
      length: {
          enumerable: true,
          configurable: true,
          get() {
              return Items$1.get(this).length;
          },
      },
      // Iterator protocol
      forEach: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(cb, thisArg) {
              forEach.call(Items$1.get(this), cb, thisArg);
          },
      },
      entries: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              return ArrayMap.call(Items$1.get(this), (v, i) => [i, v]);
          },
      },
      keys: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              return ArrayMap.call(Items$1.get(this), (_v, i) => i);
          },
      },
      values: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              return Items$1.get(this);
          },
      },
      [Symbol.iterator]: {
          writable: true,
          configurable: true,
          value() {
              let nextIndex = 0;
              return {
                  next: () => {
                      const items = Items$1.get(this);
                      return nextIndex < items.length
                          ? {
                              value: items[nextIndex++],
                              done: false,
                          }
                          : {
                              done: true,
                          };
                  },
              };
          },
      },
      [Symbol.toStringTag]: {
          configurable: true,
          get() {
              return 'NodeList';
          },
      },
      // IE11 doesn't support Symbol.toStringTag, in which case we
      // provide the regular toString method.
      toString: {
          writable: true,
          configurable: true,
          value() {
              return '[object NodeList]';
          },
      },
  });
  // prototype inheritance dance
  setPrototypeOf(StaticNodeList, NodeList);
  function createStaticNodeList(items) {
      const nodeList = create(StaticNodeList.prototype);
      Items$1.set(nodeList, items);
      // setting static indexes
      forEach.call(items, (item, index) => {
          defineProperty(nodeList, index, {
              value: item,
              enumerable: true,
              configurable: true,
          });
      });
      return nodeList;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // Walk up the DOM tree, collecting all shadow roots plus the document root
  function getAllRootNodes(node) {
      const rootNodes = [];
      let currentRootNode = node.getRootNode();
      while (!isUndefined(currentRootNode)) {
          rootNodes.push(currentRootNode);
          currentRootNode = currentRootNode.host?.getRootNode();
      }
      return rootNodes;
  }
  // Keep searching up the host tree until we find an element that is within the immediate shadow root
  const findAncestorHostInImmediateShadowRoot = (rootNode, targetRootNode) => {
      let host;
      while (!isUndefined((host = rootNode.host))) {
          const thisRootNode = host.getRootNode();
          if (thisRootNode === targetRootNode) {
              return host;
          }
          rootNode = thisRootNode;
      }
  };
  function fauxElementsFromPoint(context, doc, left, top) {
      const elements = elementsFromPoint.call(doc, left, top);
      const result = [];
      const rootNodes = getAllRootNodes(context);
      // Filter the elements array to only include those elements that are in this shadow root or in one of its
      // ancestor roots. This matches Chrome and Safari's implementation (but not Firefox's, which only includes
      // elements in the immediate shadow root: https://crbug.com/1207863#c4).
      if (!isNull(elements)) {
          // can be null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint#browser_compatibility
          for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              if (isSyntheticSlotElement(element)) {
                  continue;
              }
              const elementRootNode = element.getRootNode();
              if (ArrayIndexOf.call(rootNodes, elementRootNode) !== -1) {
                  ArrayPush.call(result, element);
                  continue;
              }
              // In cases where the host element is not visible but its shadow descendants are, then
              // we may get the shadow descendant instead of the host element here. (The
              // browser doesn't know the difference in synthetic shadow DOM.)
              // In native shadow DOM, however, elementsFromPoint would return the host but not
              // the child. So we need to detect if this shadow element's host is accessible from
              // the context's shadow root. Note we also need to be careful not to add the host
              // multiple times.
              const ancestorHost = findAncestorHostInImmediateShadowRoot(elementRootNode, rootNodes[0]);
              if (!isUndefined(ancestorHost) &&
                  ArrayIndexOf.call(elements, ancestorHost) === -1 &&
                  ArrayIndexOf.call(result, ancestorHost) === -1) {
                  ArrayPush.call(result, ancestorHost);
              }
          }
      }
      return result;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const Items = new WeakMap();
  function StaticHTMLCollection() {
      throw new TypeError('Illegal constructor');
  }
  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
      constructor: {
          writable: true,
          configurable: true,
          value: StaticHTMLCollection,
      },
      item: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(index) {
              return this[index];
          },
      },
      length: {
          enumerable: true,
          configurable: true,
          get() {
              return Items.get(this).length;
          },
      },
      // https://dom.spec.whatwg.org/#dom-htmlcollection-nameditem-key
      namedItem: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(name) {
              if (name === '') {
                  return null;
              }
              const items = Items.get(this);
              for (let i = 0, len = items.length; i < len; i++) {
                  const item = items[len];
                  if (name === getAttribute.call(item, 'id') ||
                      name === getAttribute.call(item, 'name')) {
                      return item;
                  }
              }
              return null;
          },
      },
      [Symbol.toStringTag]: {
          configurable: true,
          get() {
              return 'HTMLCollection';
          },
      },
      // IE11 doesn't support Symbol.toStringTag, in which case we
      // provide the regular toString method.
      toString: {
          writable: true,
          configurable: true,
          value() {
              return '[object HTMLCollection]';
          },
      },
  });
  // prototype inheritance dance
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);
  function createStaticHTMLCollection(items) {
      const collection = create(StaticHTMLCollection.prototype);
      Items.set(collection, items);
      // setting static indexes
      forEach.call(items, (item, index) => {
          defineProperty(collection, index, {
              value: item,
              enumerable: true,
              configurable: true,
          });
      });
      return collection;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
   * This method checks whether or not the content of the node is computed
   * based on the light-dom slotting mechanism. This applies to synthetic slot elements
   * and elements with shadow dom attached to them. It doesn't apply to native slot elements
   * because we don't want to patch the children getters for those elements.
   * @param node
   */
  function hasMountedChildren(node) {
      return isSyntheticSlotElement(node) || isSyntheticShadowHost(node);
  }
  function getShadowParent(node, value) {
      const owner = getNodeOwner(node);
      if (value === owner) {
          // walking up via parent chain might end up in the shadow root element
          return getShadowRoot(owner);
      }
      else if (value instanceof Element) {
          if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
              // the element and its parent node belong to the same shadow root
              return value;
          }
          else if (!isNull(owner) && isSlotElement(value)) {
              // slotted elements must be top level childNodes of the slot element
              // where they slotted into, but its shadowed parent is always the
              // owner of the slot.
              const slotOwner = getNodeOwner(value);
              if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
                  // it is a slotted element, and therefore its parent is always going to be the host of the slot
                  return slotOwner;
              }
          }
      }
      return null;
  }
  function hasChildNodesPatched() {
      return getInternalChildNodes(this).length > 0;
  }
  function firstChildGetterPatched() {
      const childNodes = getInternalChildNodes(this);
      return childNodes[0] || null;
  }
  function lastChildGetterPatched() {
      const childNodes = getInternalChildNodes(this);
      return childNodes[childNodes.length - 1] || null;
  }
  function textContentGetterPatched() {
      return getTextContent(this);
  }
  function textContentSetterPatched(value) {
      textContextSetter.call(this, value);
  }
  function parentNodeGetterPatched() {
      const value = parentNodeGetter.call(this);
      if (isNull(value)) {
          return value;
      }
      // TODO [#1635]: this needs optimization, maybe implementing it based on this.assignedSlot
      return getShadowParent(this, value);
  }
  function parentElementGetterPatched() {
      const value = parentNodeGetter.call(this);
      if (isNull(value)) {
          return null;
      }
      const parentNode = getShadowParent(this, value);
      // it could be that the parentNode is the shadowRoot, in which case
      // we need to return null.
      // TODO [#1635]: this needs optimization, maybe implementing it based on this.assignedSlot
      return parentNode instanceof Element ? parentNode : null;
  }
  function compareDocumentPositionPatched(otherNode) {
      if (this === otherNode) {
          return 0;
      }
      else if (this.getRootNode() === otherNode) {
          // "this" is in a shadow tree where the shadow root is the "otherNode".
          return 10; // Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING
      }
      else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
          // "this" and "otherNode" belongs to 2 different shadow tree.
          return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING
      }
      // Since "this" and "otherNode" are part of the same shadow tree we can safely rely to the native
      // Node.compareDocumentPosition implementation.
      return compareDocumentPosition.call(this, otherNode);
  }
  function containsPatched(otherNode) {
      if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
          // it is from another shadow
          return false;
      }
      return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }
  function cloneNodePatched(deep) {
      const clone = cloneNode.call(this, false);
      // Per spec, browsers only care about truthy values
      // Not strict true or false
      if (!deep) {
          return clone;
      }
      const childNodes = getInternalChildNodes(this);
      for (let i = 0, len = childNodes.length; i < len; i += 1) {
          clone.appendChild(childNodes[i].cloneNode(true));
      }
      return clone;
  }
  /**
   * This method only applies to elements with a shadow or slots
   */
  function childNodesGetterPatched() {
      if (isSyntheticShadowHost(this)) {
          const owner = getNodeOwner(this);
          const filteredChildNodes = getFilteredChildNodes(this);
          // No need to filter by owner for non-shadowed nodes
          const childNodes = isNull(owner)
              ? filteredChildNodes
              : getAllMatches(owner, filteredChildNodes);
          return createStaticNodeList(childNodes);
      }
      // nothing to do here since this does not have a synthetic shadow attached to it
      // TODO [#1636]: what about slot elements?
      return childNodesGetter.call(this);
  }
  const nativeGetRootNode = _Node.prototype.getRootNode;
  /**
   * Get the root by climbing up the dom tree, beyond the shadow root
   * If Node.prototype.getRootNode is supported, use it
   * else, assume we are working in non-native shadow mode and climb using parentNode
   */
  const getDocumentOrRootNode = !isUndefined(nativeGetRootNode)
      ? nativeGetRootNode
      : function () {
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          let node = this;
          let nodeParent;
          while (!isNull((nodeParent = parentNodeGetter.call(node)))) {
              node = nodeParent;
          }
          return node;
      };
  /**
   * Get the shadow root
   * getNodeOwner() returns the host element that owns the given node
   * Note: getNodeOwner() returns null when running in native-shadow mode.
   * Fallback to using the native getRootNode() to discover the root node.
   * This is because, it is not possible to inspect the node and decide if it is part
   * of a native shadow or the synthetic shadow.
   * @param node
   */
  function getNearestRoot(node) {
      const ownerNode = getNodeOwner(node);
      if (isNull(ownerNode)) {
          // we hit a wall, either we are in native shadow mode or the node is not in lwc boundary.
          return getDocumentOrRootNode.call(node);
      }
      return getShadowRoot(ownerNode);
  }
  /**
   * If looking for a root node beyond shadow root by calling `node.getRootNode({composed: true})`, use the original `Node.prototype.getRootNode` method
   * to return the root of the dom tree. In IE11 and Edge, Node.prototype.getRootNode is
   * [not supported](https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode#Browser_compatibility). The root node is discovered by manually
   * climbing up the dom tree.
   *
   * If looking for a shadow root of a node by calling `node.getRootNode({composed: false})` or `node.getRootNode()`,
   *
   * 1. Try to identify the host element that owns the give node.
   * i. Identify the shadow tree that the node belongs to
   * ii. If the node belongs to a shadow tree created by engine, return the shadowRoot of the host element that owns the shadow tree
   * 2. The host identification logic returns null in two cases:
   * i. The node does not belong to a shadow tree created by engine
   * ii. The engine is running in native shadow dom mode
   * If so, use the original Node.prototype.getRootNode to fetch the root node(or manually climb up the dom tree where getRootNode() is unsupported)
   *
   * _Spec_: https://dom.spec.whatwg.org/#dom-node-getrootnode
   * @param options
   */
  function getRootNodePatched(options) {
      const composed = isUndefined(options) ? false : !!options.composed;
      return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }
  // Non-deep-traversing patches: this descriptor map includes all descriptors that
  // do not give access to nodes beyond the immediate children.
  defineProperties(_Node.prototype, {
      firstChild: {
          get() {
              if (hasMountedChildren(this)) {
                  return firstChildGetterPatched.call(this);
              }
              return firstChildGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      lastChild: {
          get() {
              if (hasMountedChildren(this)) {
                  return lastChildGetterPatched.call(this);
              }
              return lastChildGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      textContent: {
          get() {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
                  return textContentGetterPatched.call(this);
              }
              return textContentGetter.call(this);
          },
          set: textContentSetterPatched,
          enumerable: true,
          configurable: true,
      },
      parentNode: {
          get() {
              if (isNodeShadowed(this)) {
                  return parentNodeGetterPatched.call(this);
              }
              const parentNode = parentNodeGetter.call(this);
              // Handle the case where a top level light DOM element is slotted into a synthetic
              // shadow slot.
              if (!isNull(parentNode) && isSyntheticSlotElement(parentNode)) {
                  return getNodeOwner(parentNode);
              }
              return parentNode;
          },
          enumerable: true,
          configurable: true,
      },
      parentElement: {
          get() {
              if (isNodeShadowed(this)) {
                  return parentElementGetterPatched.call(this);
              }
              const parentElement = parentElementGetter.call(this);
              // Handle the case where a top level light DOM element is slotted into a synthetic
              // shadow slot.
              if (!isNull(parentElement) && isSyntheticSlotElement(parentElement)) {
                  return getNodeOwner(parentElement);
              }
              return parentElement;
          },
          enumerable: true,
          configurable: true,
      },
      childNodes: {
          get() {
              if (hasMountedChildren(this)) {
                  return childNodesGetterPatched.call(this);
              }
              return childNodesGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      hasChildNodes: {
          value() {
              if (hasMountedChildren(this)) {
                  return hasChildNodesPatched.call(this);
              }
              return hasChildNodes.call(this);
          },
          enumerable: true,
          writable: true,
          configurable: true,
      },
      compareDocumentPosition: {
          value(otherNode) {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              if (isGlobalPatchingSkipped(this)) {
                  return compareDocumentPosition.call(this, otherNode);
              }
              return compareDocumentPositionPatched.call(this, otherNode);
          },
          enumerable: true,
          writable: true,
          configurable: true,
      },
      contains: {
          value(otherNode) {
              // 1. Node.prototype.contains() returns true if otherNode is an inclusive descendant
              //    spec: https://dom.spec.whatwg.org/#dom-node-contains
              // 2. This normalizes the behavior of this api across all browsers.
              //    In IE11, a disconnected dom element without children invoking contains() on self, returns false
              if (this === otherNode) {
                  return true;
              }
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              if (otherNode == null) {
                  return false;
              }
              if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
                  return containsPatched.call(this, otherNode);
              }
              return contains.call(this, otherNode);
          },
          enumerable: true,
          writable: true,
          configurable: true,
      },
      cloneNode: {
          value(deep) {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
                  return cloneNodePatched.call(this, deep);
              }
              return cloneNode.call(this, deep);
          },
          enumerable: true,
          writable: true,
          configurable: true,
      },
      getRootNode: {
          value: getRootNodePatched,
          enumerable: true,
          configurable: true,
          writable: true,
      },
      isConnected: {
          enumerable: true,
          configurable: true,
          get() {
              return isConnected.call(this);
          },
      },
  });
  const getInternalChildNodes = function (node) {
      return node.childNodes;
  };
  // IE11 extra patches for wrong prototypes
  if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
      defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(_Node.prototype, 'contains'));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
      defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(_Node.prototype, 'parentElement'));
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const EventListenerMap = new WeakMap();
  const ComposedPathMap = new WeakMap();
  function isEventListenerOrEventListenerObject$1(fnOrObj) {
      return (isFunction(fnOrObj) ||
          (isObject(fnOrObj) &&
              !isNull(fnOrObj) &&
              isFunction(fnOrObj.handleEvent)));
  }
  function shouldInvokeListener(event, target, currentTarget) {
      // Subsequent logic assumes that `currentTarget` must be contained in the composed path for the listener to be
      // invoked, but this is not always the case. `composedPath()` will sometimes return an empty array, even when the
      // listener should be invoked (e.g., a disconnected instance of EventTarget, an instance of XMLHttpRequest, etc).
      if (target === currentTarget) {
          return true;
      }
      let composedPath = ComposedPathMap.get(event);
      if (isUndefined(composedPath)) {
          composedPath = event.composedPath();
          ComposedPathMap.set(event, composedPath);
      }
      return composedPath.includes(currentTarget);
  }
  function getEventListenerWrapper(fnOrObj) {
      if (!isEventListenerOrEventListenerObject$1(fnOrObj)) {
          return fnOrObj;
      }
      let wrapperFn = EventListenerMap.get(fnOrObj);
      if (isUndefined(wrapperFn)) {
          wrapperFn = function (event) {
              // This function is invoked from an event listener and currentTarget is always defined.
              const currentTarget = eventCurrentTargetGetter.call(event);
              {
                  assert.invariant(isFalse(isSyntheticShadowHost(currentTarget)), 'This routine should not be used to wrap event listeners for host elements and shadow roots.');
              }
              const actualTarget = getActualTarget(event);
              if (!shouldInvokeListener(event, actualTarget, currentTarget)) {
                  return;
              }
              return isFunction(fnOrObj)
                  ? fnOrObj.call(this, event)
                  : fnOrObj.handleEvent && fnOrObj.handleEvent(event);
          };
          EventListenerMap.set(fnOrObj, wrapperFn);
      }
      return wrapperFn;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const eventToContextMap = new WeakMap();
  function getEventHandler(listener) {
      if (isFunction(listener)) {
          return listener;
      }
      else {
          return listener.handleEvent;
      }
  }
  function isEventListenerOrEventListenerObject(listener) {
      return isFunction(listener) || isFunction(listener?.handleEvent);
  }
  const customElementToWrappedListeners = new WeakMap();
  function getEventMap(elm) {
      let listenerInfo = customElementToWrappedListeners.get(elm);
      if (isUndefined(listenerInfo)) {
          listenerInfo = create(null);
          customElementToWrappedListeners.set(elm, listenerInfo);
      }
      return listenerInfo;
  }
  /**
   * Events dispatched on shadow roots actually end up being dispatched on their hosts. This means that the event.target
   * property of events dispatched on shadow roots always resolve to their host. This function understands this
   * abstraction and properly returns a reference to the shadow root when appropriate.
   * @param event
   */
  function getActualTarget(event) {
      return eventToShadowRootMap.get(event) ?? eventTargetGetter.call(event);
  }
  const shadowRootEventListenerMap = new WeakMap();
  function getManagedShadowRootListener(listener) {
      if (!isEventListenerOrEventListenerObject(listener)) {
          throw new TypeError(); // avoiding problems with non-valid listeners
      }
      let managedListener = shadowRootEventListenerMap.get(listener);
      if (isUndefined(managedListener)) {
          managedListener = {
              identity: listener,
              placement: 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */,
              handleEvent(event) {
                  // currentTarget is always defined inside an event listener
                  let currentTarget = eventCurrentTargetGetter.call(event);
                  // If currentTarget is not an instance of a native shadow root then we're dealing with a
                  // host element whose synthetic shadow root must be accessed via getShadowRoot().
                  if (!isInstanceOfNativeShadowRoot(currentTarget)) {
                      currentTarget = getShadowRoot(currentTarget);
                  }
                  const actualTarget = getActualTarget(event);
                  if (shouldInvokeListener(event, actualTarget, currentTarget)) {
                      getEventHandler(listener).call(currentTarget, event);
                  }
              },
          };
          shadowRootEventListenerMap.set(listener, managedListener);
      }
      return managedListener;
  }
  const customElementEventListenerMap = new WeakMap();
  function getManagedCustomElementListener(listener) {
      if (!isEventListenerOrEventListenerObject(listener)) {
          throw new TypeError(); // avoiding problems with non-valid listeners
      }
      let managedListener = customElementEventListenerMap.get(listener);
      if (isUndefined(managedListener)) {
          managedListener = {
              identity: listener,
              placement: 0 /* EventListenerContext.CUSTOM_ELEMENT_LISTENER */,
              handleEvent(event) {
                  // currentTarget is always defined inside an event listener
                  const currentTarget = eventCurrentTargetGetter.call(event);
                  const actualTarget = getActualTarget(event);
                  if (shouldInvokeListener(event, actualTarget, currentTarget)) {
                      getEventHandler(listener).call(currentTarget, event);
                  }
              },
          };
          customElementEventListenerMap.set(listener, managedListener);
      }
      return managedListener;
  }
  function indexOfManagedListener(listeners, listener) {
      return ArrayFindIndex.call(listeners, (l) => l.identity === listener.identity);
  }
  function domListener(evt) {
      let immediatePropagationStopped = false;
      let propagationStopped = false;
      const { type, stopImmediatePropagation, stopPropagation } = evt;
      // currentTarget is always defined
      const currentTarget = eventCurrentTargetGetter.call(evt);
      const listenerMap = getEventMap(currentTarget);
      const listeners = listenerMap[type]; // it must have listeners at this point
      defineProperty(evt, 'stopImmediatePropagation', {
          value() {
              immediatePropagationStopped = true;
              stopImmediatePropagation.call(evt);
          },
          writable: true,
          enumerable: true,
          configurable: true,
      });
      defineProperty(evt, 'stopPropagation', {
          value() {
              propagationStopped = true;
              stopPropagation.call(evt);
          },
          writable: true,
          enumerable: true,
          configurable: true,
      });
      // in case a listener adds or removes other listeners during invocation
      const bookkeeping = ArraySlice.call(listeners);
      function invokeListenersByPlacement(placement) {
          forEach.call(bookkeeping, (listener) => {
              if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
                  // making sure that the listener was not removed from the original listener queue
                  if (indexOfManagedListener(listeners, listener) !== -1) {
                      // all handlers on the custom element should be called with undefined 'this'
                      listener.handleEvent.call(undefined, evt);
                  }
              }
          });
      }
      eventToContextMap.set(evt, 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */);
      invokeListenersByPlacement(1 /* EventListenerContext.SHADOW_ROOT_LISTENER */);
      if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
          // doing the second iteration only if the first one didn't interrupt the event propagation
          eventToContextMap.set(evt, 0 /* EventListenerContext.CUSTOM_ELEMENT_LISTENER */);
          invokeListenersByPlacement(0 /* EventListenerContext.CUSTOM_ELEMENT_LISTENER */);
      }
      eventToContextMap.set(evt, 2 /* EventListenerContext.UNKNOWN_LISTENER */);
  }
  function attachDOMListener(elm, type, managedListener) {
      const listenerMap = getEventMap(elm);
      let listeners = listenerMap[type];
      if (isUndefined(listeners)) {
          listeners = listenerMap[type] = [];
      }
      // Prevent identical listeners from subscribing to the same event type.
      // TODO [#1824]: Options will also play a factor in deduping if we introduce options support
      if (indexOfManagedListener(listeners, managedListener) !== -1) {
          return;
      }
      // only add to DOM if there is no other listener on the same placement yet
      if (listeners.length === 0) {
          addEventListener.call(elm, type, domListener);
      }
      ArrayPush.call(listeners, managedListener);
  }
  function detachDOMListener(elm, type, managedListener) {
      const listenerMap = getEventMap(elm);
      let index;
      let listeners;
      if (!isUndefined((listeners = listenerMap[type])) &&
          (index = indexOfManagedListener(listeners, managedListener)) !== -1) {
          ArraySplice.call(listeners, index, 1);
          // only remove from DOM if there is no other listener on the same placement
          if (listeners.length === 0) {
              removeEventListener.call(elm, type, domListener);
          }
      }
  }
  function addCustomElementEventListener(type, listener, _options) {
      {
          if (!isEventListenerOrEventListenerObject(listener)) {
              throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(this)} for event "${type}". Expected EventListener or EventListenerObject but received ${toString(listener)}.`);
          }
      }
      if (isEventListenerOrEventListenerObject(listener)) {
          const managedListener = getManagedCustomElementListener(listener);
          attachDOMListener(this, type, managedListener);
      }
  }
  function removeCustomElementEventListener(type, listener, _options) {
      if (isEventListenerOrEventListenerObject(listener)) {
          const managedListener = getManagedCustomElementListener(listener);
          detachDOMListener(this, type, managedListener);
      }
  }
  function addShadowRootEventListener(sr, type, listener, _options) {
      {
          if (!isEventListenerOrEventListenerObject(listener)) {
              throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event "${type}". Expected EventListener or EventListenerObject but received ${toString(listener)}.`);
          }
      }
      if (isEventListenerOrEventListenerObject(listener)) {
          const elm = getHost(sr);
          const managedListener = getManagedShadowRootListener(listener);
          attachDOMListener(elm, type, managedListener);
      }
  }
  function removeShadowRootEventListener(sr, type, listener, _options) {
      if (isEventListenerOrEventListenerObject(listener)) {
          const elm = getHost(sr);
          const managedListener = getManagedShadowRootListener(listener);
          detachDOMListener(elm, type, managedListener);
      }
  }

  /*
   * Copyright (c) 2023, Salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const InternalSlot = new WeakMap();
  const { createDocumentFragment } = document;
  function hasInternalSlot(root) {
      return InternalSlot.has(root);
  }
  function getInternalSlot(root) {
      const record = InternalSlot.get(root);
      if (isUndefined(record)) {
          throw new TypeError();
      }
      return record;
  }
  defineProperty(_Node.prototype, KEY__SHADOW_RESOLVER, {
      set(fn) {
          if (isUndefined(fn))
              return;
          this[KEY__SHADOW_RESOLVER_PRIVATE] = fn;
          // TODO [#1164]: temporary propagation of the key
          setNodeOwnerKey(this, fn.nodeKey);
      },
      get() {
          return this[KEY__SHADOW_RESOLVER_PRIVATE];
      },
      configurable: true,
      enumerable: true,
  });
  // The isUndefined check is because two copies of synthetic shadow may be loaded on the same page, and this
  // would throw an error if we tried to redefine it. Plus the whole point is to expose the native method.
  if (isUndefined(globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID])) {
      defineProperty(globalThis, KEY__NATIVE_GET_ELEMENT_BY_ID, {
          value: getElementById,
          configurable: true,
      });
  }
  // See note above.
  if (isUndefined(globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL])) {
      defineProperty(globalThis, KEY__NATIVE_QUERY_SELECTOR_ALL, {
          value: querySelectorAll,
          configurable: true,
      });
  }
  function getShadowRootResolver(node) {
      return node[KEY__SHADOW_RESOLVER];
  }
  function setShadowRootResolver(node, fn) {
      node[KEY__SHADOW_RESOLVER] = fn;
  }
  function isDelegatingFocus(host) {
      return getInternalSlot(host).delegatesFocus;
  }
  function getHost(root) {
      return getInternalSlot(root).host;
  }
  function getShadowRoot(elm) {
      return getInternalSlot(elm).shadowRoot;
  }
  // Intentionally adding `Node` here in addition to `Element` since this check is harmless for nodes
  // and we can avoid having to cast the type before calling this method in a few places.
  function isSyntheticShadowHost(node) {
      const shadowRootRecord = InternalSlot.get(node);
      return !isUndefined(shadowRootRecord) && node === shadowRootRecord.host;
  }
  function isSyntheticShadowRoot(node) {
      const shadowRootRecord = InternalSlot.get(node);
      return !isUndefined(shadowRootRecord) && node === shadowRootRecord.shadowRoot;
  }
  let uid = 0;
  function attachShadow(elm, options) {
      if (InternalSlot.has(elm)) {
          throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
      }
      const { mode, delegatesFocus } = options;
      // creating a real fragment for shadowRoot instance
      const doc = getOwnerDocument(elm);
      const sr = createDocumentFragment.call(doc);
      // creating shadow internal record
      const record = {
          mode,
          delegatesFocus: !!delegatesFocus,
          host: elm,
          shadowRoot: sr,
      };
      InternalSlot.set(sr, record);
      InternalSlot.set(elm, record);
      const shadowResolver = () => sr;
      const x = (shadowResolver.nodeKey = uid++);
      setNodeKey(elm, x);
      setShadowRootResolver(sr, shadowResolver);
      // correcting the proto chain
      setPrototypeOf(sr, SyntheticShadowRoot.prototype);
      return sr;
  }
  const SyntheticShadowRootDescriptors = {
      constructor: {
          writable: true,
          configurable: true,
          value: SyntheticShadowRoot,
      },
      toString: {
          writable: true,
          configurable: true,
          value() {
              return `[object ShadowRoot]`;
          },
      },
      synthetic: {
          writable: false,
          enumerable: false,
          configurable: false,
          value: true,
      },
  };
  const ShadowRootDescriptors = {
      activeElement: {
          enumerable: true,
          configurable: true,
          get() {
              const host = getHost(this);
              const doc = getOwnerDocument(host);
              const activeElement = DocumentPrototypeActiveElement.call(doc);
              if (isNull(activeElement)) {
                  return activeElement;
              }
              if ((compareDocumentPosition.call(host, activeElement) &
                  DOCUMENT_POSITION_CONTAINED_BY) ===
                  0) {
                  return null;
              }
              // activeElement must be child of the host and owned by it
              let node = activeElement;
              while (!isNodeOwnedBy(host, node)) {
                  // parentElement is always an element because we are talking up the tree knowing
                  // that it is a child of the host.
                  node = parentElementGetter.call(node);
              }
              // If we have a slot element here that means that we were dealing
              // with an element that was passed to one of our slots. In this
              // case, activeElement returns null.
              if (isSlotElement(node)) {
                  return null;
              }
              return node;
          },
      },
      delegatesFocus: {
          configurable: true,
          get() {
              return getInternalSlot(this).delegatesFocus;
          },
      },
      elementFromPoint: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(left, top) {
              const host = getHost(this);
              const doc = getOwnerDocument(host);
              return fauxElementFromPoint(this, doc, left, top);
          },
      },
      elementsFromPoint: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(left, top) {
              const host = getHost(this);
              const doc = getOwnerDocument(host);
              return fauxElementsFromPoint(this, doc, left, top);
          },
      },
      getSelection: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              throw new Error('Disallowed method "getSelection" on ShadowRoot.');
          },
      },
      host: {
          enumerable: true,
          configurable: true,
          get() {
              return getHost(this);
          },
      },
      mode: {
          configurable: true,
          get() {
              return getInternalSlot(this).mode;
          },
      },
      styleSheets: {
          enumerable: true,
          configurable: true,
          get() {
              throw new Error();
          },
      },
  };
  const eventToShadowRootMap = new WeakMap();
  const NodePatchDescriptors = {
      insertBefore: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(newChild, refChild) {
              insertBefore.call(getHost(this), newChild, refChild);
              return newChild;
          },
      },
      removeChild: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(oldChild) {
              removeChild.call(getHost(this), oldChild);
              return oldChild;
          },
      },
      appendChild: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(newChild) {
              appendChild.call(getHost(this), newChild);
              return newChild;
          },
      },
      replaceChild: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(newChild, oldChild) {
              replaceChild.call(getHost(this), newChild, oldChild);
              return oldChild;
          },
      },
      addEventListener: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(type, listener, options) {
              addShadowRootEventListener(this, type, listener);
          },
      },
      dispatchEvent: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(evt) {
              eventToShadowRootMap.set(evt, this);
              // Typescript does not like it when you treat the `arguments` object as an array
              // @ts-expect-error type-mismatch
              return dispatchEvent.apply(getHost(this), arguments);
          },
      },
      removeEventListener: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(type, listener, options) {
              removeShadowRootEventListener(this, type, listener);
          },
      },
      baseURI: {
          enumerable: true,
          configurable: true,
          get() {
              return getHost(this).baseURI;
          },
      },
      childNodes: {
          enumerable: true,
          configurable: true,
          get() {
              return createStaticNodeList(shadowRootChildNodes(this));
          },
      },
      cloneNode: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              throw new Error('Disallowed method "cloneNode" on ShadowRoot.');
          },
      },
      compareDocumentPosition: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(otherNode) {
              const host = getHost(this);
              if (this === otherNode) {
                  // "this" and "otherNode" are the same shadow root.
                  return 0;
              }
              else if (this.contains(otherNode)) {
                  // "otherNode" belongs to the shadow tree where "this" is the shadow root.
                  return 20; // Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING
              }
              else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
                  // "otherNode" is in a different shadow tree contained by the shadow tree where "this" is the shadow root.
                  return 37; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
              }
              else {
                  // "otherNode" is in a different shadow tree that is not contained by the shadow tree where "this" is the shadow root.
                  return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
              }
          },
      },
      contains: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(otherNode) {
              if (this === otherNode) {
                  return true;
              }
              const host = getHost(this);
              // must be child of the host and owned by it.
              return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                  0 && isNodeOwnedBy(host, otherNode));
          },
      },
      firstChild: {
          enumerable: true,
          configurable: true,
          get() {
              const childNodes = getInternalChildNodes(this);
              return childNodes[0] || null;
          },
      },
      lastChild: {
          enumerable: true,
          configurable: true,
          get() {
              const childNodes = getInternalChildNodes(this);
              return childNodes[childNodes.length - 1] || null;
          },
      },
      hasChildNodes: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              const childNodes = getInternalChildNodes(this);
              return childNodes.length > 0;
          },
      },
      isConnected: {
          enumerable: true,
          configurable: true,
          get() {
              return isConnected.call(getHost(this));
          },
      },
      nextSibling: {
          enumerable: true,
          configurable: true,
          get() {
              return null;
          },
      },
      previousSibling: {
          enumerable: true,
          configurable: true,
          get() {
              return null;
          },
      },
      nodeName: {
          enumerable: true,
          configurable: true,
          get() {
              return '#document-fragment';
          },
      },
      nodeType: {
          enumerable: true,
          configurable: true,
          get() {
              return 11; // Node.DOCUMENT_FRAGMENT_NODE
          },
      },
      nodeValue: {
          enumerable: true,
          configurable: true,
          get() {
              return null;
          },
      },
      ownerDocument: {
          enumerable: true,
          configurable: true,
          get() {
              return getHost(this).ownerDocument;
          },
      },
      parentElement: {
          enumerable: true,
          configurable: true,
          get() {
              return null;
          },
      },
      parentNode: {
          enumerable: true,
          configurable: true,
          get() {
              return null;
          },
      },
      textContent: {
          enumerable: true,
          configurable: true,
          get() {
              const childNodes = getInternalChildNodes(this);
              let textContent = '';
              for (let i = 0, len = childNodes.length; i < len; i += 1) {
                  const currentNode = childNodes[i];
                  if (currentNode.nodeType !== COMMENT_NODE) {
                      textContent += getTextContent(currentNode);
                  }
              }
              return textContent;
          },
          set(v) {
              const host = getHost(this);
              textContextSetter.call(host, v);
          },
      },
      // Since the synthetic shadow root is a detached DocumentFragment, short-circuit the getRootNode behavior
      getRootNode: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(options) {
              return !isUndefined(options) && isTrue(options.composed)
                  ? getHost(this).getRootNode(options)
                  : this;
          },
      },
  };
  const ElementPatchDescriptors = {
      innerHTML: {
          enumerable: true,
          configurable: true,
          get() {
              const childNodes = getInternalChildNodes(this);
              let innerHTML = '';
              for (let i = 0, len = childNodes.length; i < len; i += 1) {
                  innerHTML += getOuterHTML(childNodes[i]);
              }
              return innerHTML;
          },
          set(v) {
              const host = getHost(this);
              innerHTMLSetter.call(host, v);
          },
      },
  };
  const ParentNodePatchDescriptors = {
      childElementCount: {
          enumerable: true,
          configurable: true,
          get() {
              return this.children.length;
          },
      },
      children: {
          enumerable: true,
          configurable: true,
          get() {
              return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));
          },
      },
      firstElementChild: {
          enumerable: true,
          configurable: true,
          get() {
              return this.children[0] || null;
          },
      },
      lastElementChild: {
          enumerable: true,
          configurable: true,
          get() {
              const { children } = this;
              return children.item(children.length - 1) || null;
          },
      },
      getElementById: {
          writable: true,
          enumerable: true,
          configurable: true,
          value() {
              throw new Error('Disallowed method "getElementById" on ShadowRoot.');
          },
      },
      querySelector: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(selectors) {
              return shadowRootQuerySelector(this, selectors);
          },
      },
      querySelectorAll: {
          writable: true,
          enumerable: true,
          configurable: true,
          value(selectors) {
              return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
          },
      },
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
  function SyntheticShadowRoot() {
      throw new TypeError('Illegal constructor');
  }
  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
  // `this.shadowRoot instanceof ShadowRoot` should evaluate to true even for synthetic shadow
  defineProperty(SyntheticShadowRoot, Symbol.hasInstance, {
      value: function (object) {
          // Technically we should walk up the entire prototype chain, but with SyntheticShadowRoot
          // it's reasonable to assume that no one is doing any deep subclasses here.
          return (isObject(object) &&
              !isNull(object) &&
              (isInstanceOfNativeShadowRoot(object) ||
                  getPrototypeOf(object) === SyntheticShadowRoot.prototype));
      },
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function isSyntheticOrNativeShadowRoot(node) {
      return isSyntheticShadowRoot(node) || isInstanceOfNativeShadowRoot(node);
  }
  // Helpful for tests running with jsdom
  function getOwnerDocument(node) {
      const doc = ownerDocumentGetter.call(node);
      // if doc is null, it means `this` is actually a document instance
      return doc === null ? node : doc;
  }
  function getOwnerWindow(node) {
      const doc = getOwnerDocument(node);
      const win = defaultViewGetter.call(doc);
      if (win === null) {
          // this method should never be called with a node that is not part
          // of a qualifying connected node.
          throw new TypeError();
      }
      return win;
  }
  let skipGlobalPatching;
  // Note: we deviate from native shadow here, but are not fixing
  // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
  function isGlobalPatchingSkipped(node) {
      // we lazily compute this value instead of doing it during evaluation, this helps
      // for apps that are setting this after the engine code is evaluated.
      if (isUndefined(skipGlobalPatching)) {
          const ownerDocument = getOwnerDocument(node);
          skipGlobalPatching =
              ownerDocument.body &&
                  getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') ===
                      'temporary-bypass';
      }
      return isTrue(skipGlobalPatching);
  }
  function arrayFromCollection(collection) {
      const size = collection.length;
      const cloned = [];
      if (size > 0) {
          for (let i = 0; i < size; i++) {
              cloned[i] = collection[i];
          }
      }
      return cloned;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function pathComposer(startNode, composed) {
      const composedPath = [];
      let startRoot;
      if (startNode instanceof Window) {
          startRoot = startNode;
      }
      else if (startNode instanceof _Node) {
          startRoot = startNode.getRootNode();
      }
      else {
          return composedPath;
      }
      let current = startNode;
      while (!isNull(current)) {
          composedPath.push(current);
          if (current instanceof Element || current instanceof Text) {
              const assignedSlot = current.assignedSlot;
              if (!isNull(assignedSlot)) {
                  current = assignedSlot;
              }
              else {
                  current = current.parentNode;
              }
          }
          else if (isSyntheticOrNativeShadowRoot(current) && (composed || current !== startRoot)) {
              current = current.host;
          }
          else if (current instanceof _Node) {
              current = current.parentNode;
          }
          else {
              // could be Window
              current = null;
          }
      }
      let doc;
      if (startNode instanceof Window) {
          doc = startNode.document;
      }
      else {
          doc = getOwnerDocument(startNode);
      }
      // event composedPath includes window when startNode's ownerRoot is document
      if (composedPath[composedPath.length - 1] === doc) {
          composedPath.push(window);
      }
      return composedPath;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function retarget(refNode, path) {
      if (isNull(refNode)) {
          return null;
      }
      // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
      // shadow-including inclusive ancestor, return ANCESTOR.
      const refNodePath = pathComposer(refNode, true);
      const p$ = path;
      for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
          ancestor = p$[i];
          root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();
          // Retarget to ancestor if ancestor is not shadowed
          if (!isSyntheticOrNativeShadowRoot(root)) {
              return ancestor;
          }
          if (root !== lastRoot) {
              rootIdx = refNodePath.indexOf(root);
              lastRoot = root;
          }
          // Retarget to ancestor if ancestor is shadowed by refNode's shadow root
          if (!isUndefined(rootIdx) && rootIdx > -1) {
              return ancestor;
          }
      }
      return null;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function fauxElementFromPoint(context, doc, left, top) {
      const element = elementFromPoint.call(doc, left, top);
      if (isNull(element)) {
          return element;
      }
      return retarget(context, pathComposer(element, true));
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function elemFromPoint(left, top) {
      return fauxElementFromPoint(this, this, left, top);
  }
  Document.prototype.elementFromPoint = elemFromPoint;
  function elemsFromPoint(left, top) {
      return fauxElementsFromPoint(this, this, left, top);
  }
  Document.prototype.elementsFromPoint = elemsFromPoint;
  // Go until we reach to top of the LWC tree
  defineProperty(Document.prototype, 'activeElement', {
      get() {
          let node = DocumentPrototypeActiveElement.call(this);
          if (isNull(node)) {
              return node;
          }
          while (!isUndefined(getNodeOwnerKey(node))) {
              node = parentElementGetter.call(node);
              if (isNull(node)) {
                  return null;
              }
          }
          if (node.tagName === 'HTML') {
              // IE 11. Active element should never be html element
              node = this.body;
          }
          return node;
      },
      enumerable: true,
      configurable: true,
  });
  // The following patched methods hide shadowed elements from global
  // traversing mechanisms. They are simplified for performance reasons to
  // filter by ownership and do not account for slotted elements. This
  // compromise is fine for our synthetic shadow dom because root elements
  // cannot have slotted elements.
  // Another compromise here is that all these traversing methods will return
  // static HTMLCollection or static NodeList. We decided that this compromise
  // is not a big problem considering the amount of code that is relying on
  // the liveliness of these results are rare.
  defineProperty(Document.prototype, 'getElementById', {
      value() {
          const elm = getElementById.apply(this, ArraySlice.call(arguments));
          if (isNull(elm)) {
              return null;
          }
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });
  defineProperty(Document.prototype, 'querySelector', {
      value() {
          const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
          const filtered = ArrayFind.call(elements, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
          return !isUndefined(filtered) ? filtered : null;
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });
  defineProperty(Document.prototype, 'querySelectorAll', {
      value() {
          const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
          const filtered = ArrayFilter.call(elements, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
          return createStaticNodeList(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });
  defineProperty(Document.prototype, 'getElementsByClassName', {
      value() {
          const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));
          const filtered = ArrayFilter.call(elements, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
          return createStaticHTMLCollection(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });
  defineProperty(Document.prototype, 'getElementsByTagName', {
      value() {
          const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));
          const filtered = ArrayFilter.call(elements, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
          return createStaticHTMLCollection(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });
  defineProperty(Document.prototype, 'getElementsByTagNameNS', {
      value() {
          const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));
          const filtered = ArrayFilter.call(elements, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
          return createStaticHTMLCollection(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });
  defineProperty(
  // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
  getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')
      ? HTMLDocument.prototype
      : Document.prototype, 'getElementsByName', {
      value() {
          const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
          const filtered = ArrayFilter.call(elements, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
          return createStaticNodeList(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true,
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  Object.defineProperty(window, 'ShadowRoot', {
      value: SyntheticShadowRoot,
      configurable: true,
      writable: true,
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const CustomEventConstructor = CustomEvent;
  function PatchedCustomEvent(type, eventInitDict) {
      const event = new CustomEventConstructor(type, eventInitDict);
      const isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
          composed: {
              get() {
                  return isComposed;
              },
              configurable: true,
              enumerable: true,
          },
      });
      return event;
  }
  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;

  /*
   * Copyright (c) 2023, Salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // Note that ClipboardEvent is undefined in Jest/jsdom
  // See: https://github.com/jsdom/jsdom/issues/1568
  if (typeof ClipboardEvent !== 'undefined') {
      const isComposedType = assign(create(null), {
          copy: 1,
          cut: 1,
          paste: 1,
      });
      // Patch the prototype to override the composed property on user-agent dispatched events
      defineProperties(ClipboardEvent.prototype, {
          composed: {
              get() {
                  const { type } = this;
                  return isComposedType[type] === 1;
              },
              configurable: true,
              enumerable: true,
          },
      });
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const OriginalMutationObserver = MutationObserver;
  const { disconnect: originalDisconnect, observe: originalObserve, takeRecords: originalTakeRecords, } = OriginalMutationObserver.prototype;
  // Internal fields to maintain relationships
  const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
  const observerLookupField = '$$lwcNodeObservers$$';
  const observerToNodesMap = new WeakMap();
  function getNodeObservers(node) {
      return node[observerLookupField];
  }
  function setNodeObservers(node, observers) {
      node[observerLookupField] = observers;
  }
  /**
   * Retarget the mutation record's target value to its shadowRoot
   * @param originalRecord
   */
  function retargetMutationRecord(originalRecord) {
      const { addedNodes, removedNodes, target, type } = originalRecord;
      const retargetedRecord = create(MutationRecord.prototype);
      defineProperties(retargetedRecord, {
          addedNodes: {
              get() {
                  return addedNodes;
              },
              enumerable: true,
              configurable: true,
          },
          removedNodes: {
              get() {
                  return removedNodes;
              },
              enumerable: true,
              configurable: true,
          },
          type: {
              get() {
                  return type;
              },
              enumerable: true,
              configurable: true,
          },
          target: {
              get() {
                  return target.shadowRoot;
              },
              enumerable: true,
              configurable: true,
          },
      });
      return retargetedRecord;
  }
  /**
   * Utility to identify if a target node is being observed by the given observer
   * Start at the current node, if the observer is registered to observe the current node, the mutation qualifies
   * @param observer
   * @param target
   */
  function isQualifiedObserver(observer, target) {
      let parentNode = target;
      while (!isNull(parentNode)) {
          const parentNodeObservers = getNodeObservers(parentNode);
          if (!isUndefined(parentNodeObservers) &&
              (parentNodeObservers[0] === observer || // perf optimization to check for the first item is a match
                  ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
              return true;
          }
          parentNode = parentNode.parentNode;
      }
      return false;
  }
  /**
   * This function provides a shadow dom compliant filtered view of mutation records for a given observer.
   *
   * The key logic here is to determine if a given observer has been registered to observe any nodes
   * between the target node of a mutation record to the target's root node.
   * This function also retargets records when mutations occur directly under the shadow root
   * @param mutations
   * @param observer
   */
  function filterMutationRecords(mutations, observer) {
      const result = [];
      for (const record of mutations) {
          const { target, type } = record;
          // If target is an lwc host,
          // Determine if the mutations affected the host or the shadowRoot
          // Mutations affecting host: changes to slot content
          // Mutations affecting shadowRoot: changes to template content
          if (type === 'childList' && !isUndefined(getNodeKey(target))) {
              const { addedNodes } = record;
              // In case of added nodes, we can climb up the tree and determine eligibility
              if (addedNodes.length > 0) {
                  // Optimization: Peek in and test one node to decide if the MutationRecord qualifies
                  // The remaining nodes in this MutationRecord will have the same ownerKey
                  const sampleNode = addedNodes[0];
                  if (isQualifiedObserver(observer, sampleNode)) {
                      // If the target was being observed, then return record as-is
                      // this will be the case for slot content
                      const nodeObservers = getNodeObservers(target);
                      if (nodeObservers &&
                          (nodeObservers[0] === observer ||
                              ArrayIndexOf.call(nodeObservers, observer) !== -1)) {
                          ArrayPush.call(result, record);
                      }
                      else {
                          // else, must be observing the shadowRoot
                          ArrayPush.call(result, retargetMutationRecord(record));
                      }
                  }
              }
              else {
                  const { removedNodes } = record;
                  // In the case of removed nodes, climbing the tree is not an option as the nodes are disconnected
                  // We can only check if either the host or shadow root was observed and qualify the record
                  const shadowRoot = target.shadowRoot;
                  const sampleNode = removedNodes[0];
                  if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && // trickery: sampleNode is slot content
                      isQualifiedObserver(observer, target) // use target as a close enough reference to climb up
                  ) {
                      ArrayPush.call(result, record);
                  }
                  else if (shadowRoot) {
                      const shadowRootObservers = getNodeObservers(shadowRoot);
                      if (shadowRootObservers &&
                          (shadowRootObservers[0] === observer ||
                              ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {
                          ArrayPush.call(result, retargetMutationRecord(record));
                      }
                  }
              }
          }
          else {
              // Mutation happened under a root node(shadow root or document) and the decision is straighforward
              // Ascend the tree starting from target and check if observer is qualified
              if (isQualifiedObserver(observer, target)) {
                  ArrayPush.call(result, record);
              }
          }
      }
      return result;
  }
  function getWrappedCallback(callback) {
      let wrappedCallback = callback[wrapperLookupField];
      if (isUndefined(wrappedCallback)) {
          wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
              // Filter mutation records
              const filteredRecords = filterMutationRecords(mutations, observer);
              // If not records are eligible for the observer, do not invoke callback
              if (filteredRecords.length === 0) {
                  return;
              }
              callback.call(observer, filteredRecords, observer);
          };
      }
      return wrappedCallback;
  }
  /**
   * Patched MutationObserver constructor.
   * 1. Wrap the callback to filter out MutationRecords based on dom ownership
   * 2. Add a property field to track all observed targets of the observer instance
   * @param callback
   */
  function PatchedMutationObserver(callback) {
      const wrappedCallback = getWrappedCallback(callback);
      const observer = new OriginalMutationObserver(wrappedCallback);
      return observer;
  }
  function patchedDisconnect() {
      originalDisconnect.call(this);
      // Clear the node to observer reference which is a strong references
      const observedNodes = observerToNodesMap.get(this);
      if (!isUndefined(observedNodes)) {
          forEach.call(observedNodes, (observedNode) => {
              const observers = observedNode[observerLookupField];
              if (!isUndefined(observers)) {
                  const index = ArrayIndexOf.call(observers, this);
                  if (index !== -1) {
                      ArraySplice.call(observers, index, 1);
                  }
              }
          });
          observedNodes.length = 0;
      }
  }
  /**
   * A single mutation observer can observe multiple nodes(target).
   * Maintain a list of all targets that the observer chooses to observe
   * @param target
   * @param options
   */
  function patchedObserve(target, options) {
      let targetObservers = getNodeObservers(target);
      // Maintain a list of all observers that want to observe a node
      if (isUndefined(targetObservers)) {
          targetObservers = [];
          setNodeObservers(target, targetObservers);
      }
      // Same observer trying to observe the same node
      if (ArrayIndexOf.call(targetObservers, this) === -1) {
          ArrayPush.call(targetObservers, this);
      } // else There is more bookkeeping to do here https://dom.spec.whatwg.org/#dom-mutationobserver-observe Step #7
      // SyntheticShadowRoot instances are not actually a part of the DOM so observe the host instead.
      if (isSyntheticShadowRoot(target)) {
          target = target.host;
      }
      // maintain a list of all nodes observed by this observer
      if (observerToNodesMap.has(this)) {
          const observedNodes = observerToNodesMap.get(this);
          if (ArrayIndexOf.call(observedNodes, target) === -1) {
              ArrayPush.call(observedNodes, target);
          }
      }
      else {
          observerToNodesMap.set(this, [target]);
      }
      return originalObserve.call(this, target, options);
  }
  /**
   * Patch the takeRecords() api to filter MutationRecords based on the observed targets
   */
  function patchedTakeRecords() {
      return filterMutationRecords(originalTakeRecords.call(this), this);
  }
  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, 'MutationObserver', {
      value: PatchedMutationObserver,
      configurable: true,
      writable: true,
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function patchedAddEventListener(type, listener, optionsOrCapture) {
      if (isSyntheticShadowHost(this)) {
          // Typescript does not like it when you treat the `arguments` object as an array
          // @ts-expect-error type-mismatch
          return addCustomElementEventListener.apply(this, arguments);
      }
      if (this instanceof _Node && isInstanceOfNativeShadowRoot(this.getRootNode())) {
          // Typescript does not like it when you treat the `arguments` object as an array
          // @ts-expect-error type-mismatch
          return addEventListener.apply(this, arguments);
      }
      if (arguments.length < 2) {
          // Slow path, unlikely to be called frequently. We expect modern browsers to throw:
          // https://googlechrome.github.io/samples/event-listeners-mandatory-arguments/
          const args = ArraySlice.call(arguments);
          if (args.length > 1) {
              args[1] = getEventListenerWrapper(args[1]);
          }
          // Ignore types because we're passing through to native method
          // @ts-expect-error type-mismatch
          return addEventListener.apply(this, args);
      }
      // Fast path. This function is optimized to avoid ArraySlice because addEventListener is called
      // very frequently, and it provides a measurable perf boost to avoid so much array cloning.
      const wrappedListener = getEventListenerWrapper(listener);
      // The third argument is optional, so passing in `undefined` for `optionsOrCapture` gives capture=false
      return addEventListener.call(this, type, wrappedListener, optionsOrCapture);
  }
  function patchedRemoveEventListener(_type, _listener, _optionsOrCapture) {
      if (isSyntheticShadowHost(this)) {
          // Typescript does not like it when you treat the `arguments` object as an array
          // @ts-expect-error type-mismatch
          return removeCustomElementEventListener.apply(this, arguments);
      }
      const args = ArraySlice.call(arguments);
      if (arguments.length > 1) {
          args[1] = getEventListenerWrapper(args[1]);
      }
      // Ignore types because we're passing through to native method
      // @ts-expect-error type-mismatch
      removeEventListener.apply(this, args);
      // Account for listeners that were added before this polyfill was applied
      // Typescript does not like it when you treat the `arguments` object as an array
      // @ts-expect-error type-mismatch
      removeEventListener.apply(this, arguments);
  }
  defineProperties(eventTargetPrototype, {
      addEventListener: {
          value: patchedAddEventListener,
          enumerable: true,
          writable: true,
          configurable: true,
      },
      removeEventListener: {
          value: patchedRemoveEventListener,
          enumerable: true,
          writable: true,
          configurable: true,
      },
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function patchedCurrentTargetGetter() {
      const currentTarget = eventCurrentTargetGetter.call(this);
      if (isNull(currentTarget)) {
          return null;
      }
      if (eventToContextMap.get(this) === 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */) {
          return getShadowRoot(currentTarget);
      }
      return currentTarget;
  }
  function patchedTargetGetter() {
      const originalTarget = eventTargetGetter.call(this);
      if (!(originalTarget instanceof _Node)) {
          return originalTarget;
      }
      const doc = getOwnerDocument(originalTarget);
      const composedPath = pathComposer(originalTarget, this.composed);
      const originalCurrentTarget = eventCurrentTargetGetter.call(this);
      // Handle cases where the currentTarget is null (for async events), and when an event has been
      // added to Window
      if (!(originalCurrentTarget instanceof _Node)) {
          // TODO [#1511]: Special escape hatch to support legacy behavior. Should be fixed.
          // If the event's target is being accessed async and originalTarget is not a keyed element, do not retarget
          if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
              return originalTarget;
          }
          return retarget(doc, composedPath);
      }
      else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
          // TODO [#1530]: If currentTarget is document or document.body (Third party libraries that have global event listeners)
          // and the originalTarget is not a keyed element, do not retarget
          if (isUndefined(getNodeOwnerKey(originalTarget))) {
              return originalTarget;
          }
          return retarget(doc, composedPath);
      }
      let actualCurrentTarget = originalCurrentTarget;
      let actualPath = composedPath;
      // Address the possibility that `currentTarget` is a shadow root
      if (isSyntheticShadowHost(originalCurrentTarget)) {
          const context = eventToContextMap.get(this);
          if (context === 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */) {
              actualCurrentTarget = getShadowRoot(originalCurrentTarget);
          }
      }
      // Address the possibility that `target` is a shadow root
      if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {
          actualPath = pathComposer(getShadowRoot(originalTarget), this.composed);
      }
      return retarget(actualCurrentTarget, actualPath);
  }
  function patchedComposedPathValue() {
      const originalTarget = eventTargetGetter.call(this);
      // Account for events with targets that are not instances of Node (e.g., when a readystatechange
      // handler is listening on an instance of XMLHttpRequest).
      if (!(originalTarget instanceof _Node)) {
          return [];
      }
      // If the original target is inside a native shadow root, then just call the native
      // composePath() method. The event is already retargeted and this causes our composedPath()
      // polyfill to compute the wrong value. This is only an issue when you have a native web
      // component inside an LWC component (see test in same commit) but this scenario is unlikely
      // because we don't yet support that. Workaround specifically for W-9846457. Mixed mode solution
      // will likely be more involved.
      const hasShadowRoot = Boolean(originalTarget.shadowRoot);
      const hasSyntheticShadowRootAttached = hasInternalSlot(originalTarget);
      if (hasShadowRoot && !hasSyntheticShadowRootAttached) {
          return composedPath.call(this);
      }
      const originalCurrentTarget = eventCurrentTargetGetter.call(this);
      // If the event has completed propagation, the composedPath should be an empty array.
      if (isNull(originalCurrentTarget)) {
          return [];
      }
      // Address the possibility that `target` is a shadow root
      let actualTarget = originalTarget;
      if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {
          actualTarget = getShadowRoot(originalTarget);
      }
      return pathComposer(actualTarget, this.composed);
  }
  defineProperties(Event.prototype, {
      target: {
          get: patchedTargetGetter,
          enumerable: true,
          configurable: true,
      },
      currentTarget: {
          get: patchedCurrentTargetGetter,
          enumerable: true,
          configurable: true,
      },
      composedPath: {
          value: patchedComposedPathValue,
          writable: true,
          enumerable: true,
          configurable: true,
      },
      // Non-standard but widely supported for backwards-compatibility
      srcElement: {
          get: patchedTargetGetter,
          enumerable: true,
          configurable: true,
      },
      // Non-standard but implemented in Chrome and continues to exist for backwards-compatibility
      // https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/dom/events/event.idl;l=58?q=event.idl&ss=chromium
      path: {
          get: patchedComposedPathValue,
          enumerable: true,
          configurable: true,
      },
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function retargetRelatedTarget(Ctor) {
      const relatedTargetGetter = getOwnPropertyDescriptor(Ctor.prototype, 'relatedTarget')
          .get;
      defineProperty(Ctor.prototype, 'relatedTarget', {
          get() {
              const relatedTarget = relatedTargetGetter.call(this);
              if (isNull(relatedTarget)) {
                  return null;
              }
              if (!(relatedTarget instanceof _Node) || !isNodeShadowed(relatedTarget)) {
                  return relatedTarget;
              }
              let pointOfReference = eventCurrentTargetGetter.call(this);
              if (isNull(pointOfReference)) {
                  pointOfReference = getOwnerDocument(relatedTarget);
              }
              return retarget(pointOfReference, pathComposer(relatedTarget, true));
          },
          enumerable: true,
          configurable: true,
      });
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  retargetRelatedTarget(FocusEvent);

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  retargetRelatedTarget(MouseEvent);

  /*
   * Copyright (c) 2021, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const assignedSlotGetter = hasOwnProperty.call(Text.prototype, 'assignedSlot')
      ? getOwnPropertyDescriptor(Text.prototype, 'assignedSlot').get
      : () => null;

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // We can use a single observer without having to worry about leaking because
  // "Registered observers in a nodes registered observer list have a weak
  // reference to the node."
  // https://dom.spec.whatwg.org/#garbage-collection
  let observer;
  const observerConfig = { childList: true };
  const SlotChangeKey = new WeakMap();
  function initSlotObserver() {
      return new MO((mutations) => {
          const slots = [];
          forEach.call(mutations, (mutation) => {
              {
                  assert.invariant(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
              }
              const { target: slot } = mutation;
              if (ArrayIndexOf.call(slots, slot) === -1) {
                  ArrayPush.call(slots, slot);
                  dispatchEvent.call(slot, new CustomEvent('slotchange'));
              }
          });
      });
  }
  function getFilteredSlotFlattenNodes(slot) {
      const childNodes = arrayFromCollection(childNodesGetter.call(slot));
      // Typescript is inferring the wrong function type for this particular
      // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
      // @ts-expect-error type-mismatch
      return ArrayReduce.call(childNodes, (seed, child) => {
          if (child instanceof Element && isSlotElement(child)) {
              ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
          }
          else {
              ArrayPush.call(seed, child);
          }
          return seed;
      }, []);
  }
  function assignedSlotGetterPatched() {
      const parentNode = parentNodeGetter.call(this);
      // use original assignedSlot if parent has a native shdow root
      if (parentNode instanceof Element) {
          const sr = shadowRootGetter.call(parentNode);
          if (isInstanceOfNativeShadowRoot(sr)) {
              if (this instanceof Text) {
                  return assignedSlotGetter.call(this);
              }
              return assignedSlotGetter$1.call(this);
          }
      }
      /**
       * The node is assigned to a slot if:
       * - it has a parent and its parent is a slot element
       * - and if the slot owner key is different than the node owner key.
       * When the slot and the slotted node are 2 different shadow trees, the owner keys will be
       * different. When the slot is in a shadow tree and the slotted content is a light DOM node,
       * the light DOM node doesn't have an owner key and therefor the slot owner key will be
       * different than the node owner key (always `undefined`).
       */
      if (!isNull(parentNode) &&
          isSlotElement(parentNode) &&
          getNodeOwnerKey(parentNode) !== getNodeOwnerKey(this)) {
          return parentNode;
      }
      return null;
  }
  defineProperties(HTMLSlotElement.prototype, {
      addEventListener: {
          value(type, listener, options) {
              // super.addEventListener - but that doesn't work with typescript
              HTMLElement.prototype.addEventListener.call(this, type, listener, options);
              if (type === 'slotchange' && !SlotChangeKey.get(this)) {
                  SlotChangeKey.set(this, true);
                  if (!observer) {
                      observer = initSlotObserver();
                  }
                  MutationObserverObserve.call(observer, this, observerConfig);
              }
          },
          writable: true,
          enumerable: true,
          configurable: true,
      },
      assignedElements: {
          value(options) {
              if (isNodeShadowed(this)) {
                  const flatten = !isUndefined(options) && isTrue(options.flatten);
                  const nodes = flatten
                      ? getFilteredSlotFlattenNodes(this)
                      : getFilteredSlotAssignedNodes(this);
                  return ArrayFilter.call(nodes, (node) => node instanceof Element);
              }
              else {
                  return assignedElements.apply(this, ArraySlice.call(arguments));
              }
          },
          writable: true,
          enumerable: true,
          configurable: true,
      },
      assignedNodes: {
          value(options) {
              if (isNodeShadowed(this)) {
                  const flatten = !isUndefined(options) && isTrue(options.flatten);
                  return flatten
                      ? getFilteredSlotFlattenNodes(this)
                      : getFilteredSlotAssignedNodes(this);
              }
              else {
                  return assignedNodes.apply(this, ArraySlice.call(arguments));
              }
          },
          writable: true,
          enumerable: true,
          configurable: true,
      },
      name: {
          get() {
              const name = getAttribute.call(this, 'name');
              return isNull(name) ? '' : name;
          },
          set(value) {
              setAttribute.call(this, 'name', value);
          },
          enumerable: true,
          configurable: true,
      },
      childNodes: {
          get() {
              if (isNodeShadowed(this)) {
                  const owner = getNodeOwner(this);
                  const childNodes = isNull(owner)
                      ? []
                      : getAllMatches(owner, getFilteredChildNodes(this));
                  return createStaticNodeList(childNodes);
              }
              return childNodesGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // Non-deep-traversing patches: this descriptor map includes all descriptors that
  // do not five access to nodes beyond the immediate children.
  defineProperties(Text.prototype, {
      assignedSlot: {
          get: assignedSlotGetterPatched,
          enumerable: true,
          configurable: true,
      },
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
   * This methods filters out elements that are not in the same shadow root of context.
   * It does not enforce shadow dom semantics if $context is not managed by LWC
   * @param context
   * @param unfilteredNodes
   */
  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
      let filtered;
      const ownerKey = getNodeOwnerKey(context);
      // a node inside a shadow.
      if (!isUndefined(ownerKey)) {
          if (isSyntheticShadowHost(context)) {
              // element with shadowRoot attached
              const owner = getNodeOwner(context);
              if (isNull(owner)) {
                  filtered = [];
              }
              else if (getNodeKey(context)) {
                  // it is a custom element, and we should then filter by slotted elements
                  filtered = getAllSlottedMatches(context, unfilteredNodes);
              }
              else {
                  // regular element, we should then filter by ownership
                  filtered = getAllMatches(owner, unfilteredNodes);
              }
          }
          else {
              // context is handled by lwc, using getNodeNearestOwnerKey to include manually inserted elements in the same shadow.
              filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
          }
      }
      else if (context instanceof HTMLBodyElement) {
          // `context` is document.body which is already patched.
          filtered = ArrayFilter.call(unfilteredNodes, 
          // Note: we deviate from native shadow here, but are not fixing
          // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
          (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
      }
      else {
          // `context` is outside the lwc boundary, return unfiltered list.
          filtered = ArraySlice.call(unfilteredNodes);
      }
      return filtered;
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function innerHTMLGetterPatched() {
      const childNodes = getInternalChildNodes(this);
      let innerHTML = '';
      for (let i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
      }
      return innerHTML;
  }
  function outerHTMLGetterPatched() {
      return getOuterHTML(this);
  }
  function attachShadowPatched(options) {
      // To retain native behavior of the API, provide synthetic shadowRoot only when specified
      if (options[KEY__SYNTHETIC_MODE]) {
          return attachShadow(this, options);
      }
      return attachShadow$1.call(this, options);
  }
  function shadowRootGetterPatched() {
      if (isSyntheticShadowHost(this)) {
          const shadow = getShadowRoot(this);
          if (shadow.mode === 'open') {
              return shadow;
          }
      }
      return shadowRootGetter.call(this);
  }
  function childrenGetterPatched() {
      const owner = getNodeOwner(this);
      const filteredChildNodes = getFilteredChildNodes(this);
      // No need to filter by owner for non-shadowed nodes
      const childNodes = isNull(owner)
          ? filteredChildNodes
          : getAllMatches(owner, filteredChildNodes);
      return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
  }
  function childElementCountGetterPatched() {
      return this.children.length;
  }
  function firstElementChildGetterPatched() {
      return this.children[0] || null;
  }
  function lastElementChildGetterPatched() {
      const { children } = this;
      return children.item(children.length - 1) || null;
  }
  // Non-deep-traversing patches: this descriptor map includes all descriptors that
  // do not five access to nodes beyond the immediate children.
  defineProperties(Element.prototype, {
      innerHTML: {
          get() {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
                  return innerHTMLGetterPatched.call(this);
              }
              return innerHTMLGetter.call(this);
          },
          set(v) {
              innerHTMLSetter.call(this, v);
          },
          enumerable: true,
          configurable: true,
      },
      outerHTML: {
          get() {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
                  return outerHTMLGetterPatched.call(this);
              }
              return outerHTMLGetter.call(this);
          },
          set(v) {
              outerHTMLSetter.call(this, v);
          },
          enumerable: true,
          configurable: true,
      },
      attachShadow: {
          value: attachShadowPatched,
          enumerable: true,
          writable: true,
          configurable: true,
      },
      shadowRoot: {
          get: shadowRootGetterPatched,
          enumerable: true,
          configurable: true,
      },
      // patched in HTMLElement if exists (IE11 is the one off here)
      children: {
          get() {
              if (hasMountedChildren(this)) {
                  return childrenGetterPatched.call(this);
              }
              return childrenGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      childElementCount: {
          get() {
              if (hasMountedChildren(this)) {
                  return childElementCountGetterPatched.call(this);
              }
              return childElementCountGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      firstElementChild: {
          get() {
              if (hasMountedChildren(this)) {
                  return firstElementChildGetterPatched.call(this);
              }
              return firstElementChildGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      lastElementChild: {
          get() {
              if (hasMountedChildren(this)) {
                  return lastElementChildGetterPatched.call(this);
              }
              return lastElementChildGetter.call(this);
          },
          enumerable: true,
          configurable: true,
      },
      assignedSlot: {
          get: assignedSlotGetterPatched,
          enumerable: true,
          configurable: true,
      },
  });
  // IE11 extra patches for wrong prototypes
  if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
      defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
      defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
      defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
  }
  // Deep-traversing patches from this point on:
  function querySelectorPatched() {
      const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      if (isSyntheticShadowHost(this)) {
          // element with shadowRoot attached
          const owner = getNodeOwner(this);
          if (!isUndefined(getNodeKey(this))) {
              // it is a custom element, and we should then filter by slotted elements
              return getFirstSlottedMatch(this, nodeList);
          }
          else if (isNull(owner)) {
              return null;
          }
          else {
              // regular element, we should then filter by ownership
              return getFirstMatch(owner, nodeList);
          }
      }
      else if (isNodeShadowed(this)) {
          // element inside a shadowRoot
          const ownerKey = getNodeOwnerKey(this);
          if (!isUndefined(ownerKey)) {
              // `this` is handled by lwc, using getNodeNearestOwnerKey to include manually inserted elements in the same shadow.
              const elm = ArrayFind.call(nodeList, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
              return isUndefined(elm) ? null : elm;
          }
          else {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              // `this` is a manually inserted element inside a shadowRoot, return the first element.
              return nodeList.length === 0 ? null : nodeList[0];
          }
      }
      else {
          if (!(this instanceof HTMLBodyElement)) {
              const elm = nodeList[0];
              return isUndefined(elm) ? null : elm;
          }
          // element belonging to the document
          const elm = ArrayFind.call(nodeList, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(this));
          return isUndefined(elm) ? null : elm;
      }
  }
  function getFilteredArrayOfNodes(context, unfilteredNodes) {
      let filtered;
      if (isSyntheticShadowHost(context)) {
          // element with shadowRoot attached
          const owner = getNodeOwner(context);
          if (!isUndefined(getNodeKey(context))) {
              // it is a custom element, and we should then filter by slotted elements
              filtered = getAllSlottedMatches(context, unfilteredNodes);
          }
          else if (isNull(owner)) {
              filtered = [];
          }
          else {
              // regular element, we should then filter by ownership
              filtered = getAllMatches(owner, unfilteredNodes);
          }
      }
      else if (isNodeShadowed(context)) {
          // element inside a shadowRoot
          const ownerKey = getNodeOwnerKey(context);
          if (!isUndefined(ownerKey)) {
              // context is handled by lwc, using getNodeNearestOwnerKey to include manually inserted elements in the same shadow.
              filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
          }
          else {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              // context is manually inserted without lwc:dom-manual, return everything
              filtered = ArraySlice.call(unfilteredNodes);
          }
      }
      else {
          if (context instanceof HTMLBodyElement) {
              // `context` is document.body or element belonging to the document with the patch enabled
              filtered = ArrayFilter.call(unfilteredNodes, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
          }
          else {
              // `context` is outside the lwc boundary and patch is not enabled.
              filtered = ArraySlice.call(unfilteredNodes);
          }
      }
      return filtered;
  }
  // The following patched methods hide shadowed elements from global
  // traversing mechanisms. They are simplified for performance reasons to
  // filter by ownership and do not account for slotted elements. This
  // compromise is fine for our synthetic shadow dom because root elements
  // cannot have slotted elements.
  // Another compromise here is that all these traversing methods will return
  // static HTMLCollection or static NodeList. We decided that this compromise
  // is not a big problem considering the amount of code that is relying on
  // the liveliness of these results are rare.
  defineProperties(Element.prototype, {
      querySelector: {
          value: querySelectorPatched,
          writable: true,
          enumerable: true,
          configurable: true,
      },
      querySelectorAll: {
          value() {
              const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              const filteredResults = getFilteredArrayOfNodes(this, nodeList);
              return createStaticNodeList(filteredResults);
          },
          writable: true,
          enumerable: true,
          configurable: true,
      },
  });
  // The following APIs are used directly by Jest internally so we avoid patching them during testing.
  {
      defineProperties(Element.prototype, {
          getElementsByClassName: {
              value() {
                  const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
                  // Note: we deviate from native shadow here, but are not fixing
                  // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
                  return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
              },
              writable: true,
              enumerable: true,
              configurable: true,
          },
          getElementsByTagName: {
              value() {
                  const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
                  // Note: we deviate from native shadow here, but are not fixing
                  // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
                  return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
              },
              writable: true,
              enumerable: true,
              configurable: true,
          },
          getElementsByTagNameNS: {
              value() {
                  const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
                  // Note: we deviate from native shadow here, but are not fixing
                  // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
                  return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
              },
              writable: true,
              enumerable: true,
              configurable: true,
          },
      });
  }
  // IE11 extra patches for wrong prototypes
  if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
      defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const FocusableSelector = `
    [contenteditable],
    [tabindex],
    a[href],
    area[href],
    audio[controls],
    button,
    iframe,
    input,
    select,
    textarea,
    video[controls]
`;
  const formElementTagNames = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA']);
  function filterSequentiallyFocusableElements(elements) {
      return elements.filter((element) => {
          if (hasAttribute.call(element, 'tabindex')) {
              // Even though LWC only supports tabindex values of 0 or -1,
              // passing through elements with tabindex="0" is a tighter criteria
              // than filtering out elements based on tabindex="-1".
              return getAttribute.call(element, 'tabindex') === '0';
          }
          if (formElementTagNames.has(tagNameGetter.call(element))) {
              return !hasAttribute.call(element, 'disabled');
          }
          return true;
      });
  }
  const DidAddMouseEventListeners = new WeakMap();
  // Due to browser differences, it is impossible to know what is focusable until
  // we actually try to focus it. We need to refactor our focus delegation logic
  // to verify whether or not the target was actually focused instead of trying
  // to predict focusability like we do here.
  function isVisible(element) {
      const { width, height } = getBoundingClientRect.call(element);
      const noZeroSize = width > 0 || height > 0;
      // The area element can be 0x0 and focusable. Hardcoding this is not ideal
      // but it will minimize changes in the current behavior.
      const isAreaElement = element.tagName === 'AREA';
      return (noZeroSize || isAreaElement) && getComputedStyle(element).visibility !== 'hidden';
  }
  // This function based on https://allyjs.io/data-tables/focusable.html
  // It won't catch everything, but should be good enough
  // There are a lot of edge cases here that we can't realistically handle
  // Determines if a particular element is tabbable, as opposed to simply focusable
  function isTabbable(element) {
      if (isSyntheticShadowHost(element) && isDelegatingFocus(element)) {
          return false;
      }
      return matches.call(element, FocusableSelector) && isVisible(element);
  }
  function hostElementFocus() {
      const _rootNode = this.getRootNode();
      if (_rootNode === this) {
          // We invoke the focus() method even if the host is disconnected in order to eliminate
          // observable differences for component authors between synthetic and native.
          const focusable = querySelector.call(this, FocusableSelector);
          if (!isNull(focusable)) {
              // @ts-expect-error type-mismatch
              focusable.focus.apply(focusable, arguments);
          }
          return;
      }
      // If the root node is not the host element then it's either the document or a shadow root.
      const rootNode = _rootNode;
      if (rootNode.activeElement === this) {
          // The focused element should not change if the focus method is invoked
          // on the shadow-including ancestor of the currently focused element.
          return;
      }
      const focusables = arrayFromCollection(querySelectorAll$1.call(this, FocusableSelector));
      let didFocus = false;
      while (!didFocus && focusables.length !== 0) {
          const focusable = focusables.shift();
          // @ts-expect-error type-mismatch
          focusable.focus.apply(focusable, arguments);
          // Get the root node of the current focusable in case it was slotted.
          const currentRootNode = focusable.getRootNode();
          didFocus = currentRootNode.activeElement === focusable;
      }
  }
  function getTabbableSegments(host) {
      const doc = getOwnerDocument(host);
      const all = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll.call(doc, FocusableSelector)));
      const inner = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll$1.call(host, FocusableSelector)));
      {
          assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
      }
      const firstChild = inner[0];
      const lastChild = inner[inner.length - 1];
      const hostIndex = ArrayIndexOf.call(all, host);
      // Host element can show up in our "previous" section if its tabindex is 0
      // We want to filter that out here
      const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
      // Account for an empty inner list
      const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
      const prev = ArraySlice.call(all, 0, firstChildIndex);
      const next = ArraySlice.call(all, lastChildIndex);
      return {
          prev,
          inner,
          next,
      };
  }
  function getActiveElement(host) {
      const doc = getOwnerDocument(host);
      const activeElement = DocumentPrototypeActiveElement.call(doc);
      if (isNull(activeElement)) {
          return activeElement;
      }
      // activeElement must be child of the host and owned by it
      return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !==
          0
          ? activeElement
          : null;
  }
  function relatedTargetPosition(host, relatedTarget) {
      // assert: target must be child of host
      const pos = compareDocumentPosition.call(host, relatedTarget);
      if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
          // focus remains inside the host
          return 0;
      }
      else if (pos & DOCUMENT_POSITION_PRECEDING) {
          // focus is coming from above
          return 1;
      }
      else if (pos & DOCUMENT_POSITION_FOLLOWING) {
          // focus is coming from below
          return 2;
      }
      // we don't know what's going on.
      return -1;
  }
  function muteEvent(event) {
      event.preventDefault();
      event.stopPropagation();
  }
  function muteFocusEventsDuringExecution(win, func) {
      windowAddEventListener.call(win, 'focusin', muteEvent, true);
      windowAddEventListener.call(win, 'focusout', muteEvent, true);
      func();
      windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
      windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
  }
  function focusOnNextOrBlur(segment, target, relatedTarget) {
      const win = getOwnerWindow(relatedTarget);
      const next = getNextTabbable(segment, relatedTarget);
      if (isNull(next)) {
          // nothing to focus on, blur to invalidate the operation
          muteFocusEventsDuringExecution(win, () => {
              target.blur();
          });
      }
      else {
          muteFocusEventsDuringExecution(win, () => {
              next.focus();
          });
      }
  }
  let letBrowserHandleFocus = false;
  function disableKeyboardFocusNavigationRoutines() {
      letBrowserHandleFocus = true;
  }
  function enableKeyboardFocusNavigationRoutines() {
      letBrowserHandleFocus = false;
  }
  function isKeyboardFocusNavigationRoutineEnabled() {
      return !letBrowserHandleFocus;
  }
  function skipHostHandler(event) {
      if (letBrowserHandleFocus) {
          return;
      }
      const host = eventCurrentTargetGetter.call(event);
      const target = eventTargetGetter.call(event);
      // If the host delegating focus with tabindex=0 is not the target, we know
      // that the event was dispatched on a descendant node of the host. This
      // means the focus is coming from below and we don't need to do anything.
      if (host !== target) {
          // Focus is coming from above
          return;
      }
      const relatedTarget = focusEventRelatedTargetGetter.call(event);
      if (isNull(relatedTarget)) {
          // If relatedTarget is null, the user is most likely tabbing into the document from the
          // browser chrome. We could probably deduce whether focus is coming in from the top or the
          // bottom by comparing the position of the target to all tabbable elements. This is an edge
          // case and only comes up if the custom element is the first or last tabbable element in the
          // document.
          return;
      }
      const segments = getTabbableSegments(host);
      const position = relatedTargetPosition(host, relatedTarget);
      if (position === 1) {
          // Focus is coming from above
          const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
          const first = ArrayFind.call(segments.inner, findTabbableElms);
          if (!isUndefined(first)) {
              const win = getOwnerWindow(first);
              muteFocusEventsDuringExecution(win, () => {
                  first.focus();
              });
          }
          else {
              focusOnNextOrBlur(segments.next, target, relatedTarget);
          }
      }
      else if (host === target) {
          // Host is receiving focus from below, either from its shadow or from a sibling
          focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
      }
  }
  function skipShadowHandler(event) {
      if (letBrowserHandleFocus) {
          return;
      }
      const relatedTarget = focusEventRelatedTargetGetter.call(event);
      if (isNull(relatedTarget)) {
          // If relatedTarget is null, the user is most likely tabbing into the document from the
          // browser chrome. We could probably deduce whether focus is coming in from the top or the
          // bottom by comparing the position of the target to all tabbable elements. This is an edge
          // case and only comes up if the custom element is the first or last tabbable element in the
          // document.
          return;
      }
      const host = eventCurrentTargetGetter.call(event);
      const segments = getTabbableSegments(host);
      if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
          // If relatedTarget is contained by the host's subtree we can assume that the user is
          // tabbing between elements inside of the shadow. Do nothing.
          return;
      }
      const target = eventTargetGetter.call(event);
      // Determine where the focus is coming from (Tab or Shift+Tab)
      const position = relatedTargetPosition(host, relatedTarget);
      if (position === 1) {
          // Focus is coming from above
          focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
      if (position === 2) {
          // Focus is coming from below
          focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
      }
  }
  // Use this function to determine whether you can start from one root and end up
  // at another element via tabbing.
  function isTabbableFrom(fromRoot, toElm) {
      if (!isTabbable(toElm)) {
          return false;
      }
      const ownerDocument = getOwnerDocument(toElm);
      let root = toElm.getRootNode();
      while (root !== ownerDocument && root !== fromRoot) {
          const sr = root;
          const host = sr.host;
          if (getAttribute.call(host, 'tabindex') === '-1') {
              return false;
          }
          root = host && host.getRootNode();
      }
      return true;
  }
  function getNextTabbable(tabbables, relatedTarget) {
      const len = tabbables.length;
      if (len > 0) {
          for (let i = 0; i < len; i += 1) {
              const next = tabbables[i];
              if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
                  return next;
              }
          }
      }
      return null;
  }
  // Skips the host element
  function handleFocus(elm) {
      {
          assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
      }
      bindDocumentMousedownMouseupHandlers(elm);
      // Unbind any focusin listeners we may have going on
      ignoreFocusIn(elm);
      addEventListener.call(elm, 'focusin', skipHostHandler, true);
  }
  function ignoreFocus(elm) {
      removeEventListener.call(elm, 'focusin', skipHostHandler, true);
  }
  function bindDocumentMousedownMouseupHandlers(elm) {
      const ownerDocument = getOwnerDocument(elm);
      if (!DidAddMouseEventListeners.get(ownerDocument)) {
          DidAddMouseEventListeners.set(ownerDocument, true);
          addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
          addEventListener.call(ownerDocument, 'mouseup', () => {
              // We schedule this as an async task in the mouseup handler (as
              // opposed to the mousedown handler) because we want to guarantee
              // that it will never run before the focusin handler:
              //
              // Click form element   | Click form element label
              // ==================================================
              // mousedown            | mousedown
              // FOCUSIN              | mousedown-setTimeout
              // mousedown-setTimeout | mouseup
              // mouseup              | FOCUSIN
              // mouseup-setTimeout   | mouseup-setTimeout
              setTimeout(enableKeyboardFocusNavigationRoutines);
          }, true);
          // [W-7824445] If the element is draggable, the mousedown event is dispatched before the
          // element is starting to be dragged, which disable the keyboard focus navigation routine.
          // But by specification, the mouseup event is never dispatched once the element is dropped.
          //
          // For all draggable element, we need to add an event listener to re-enable the keyboard
          // navigation routine after dragging starts.
          addEventListener.call(ownerDocument, 'dragstart', enableKeyboardFocusNavigationRoutines, true);
      }
  }
  // Skips the shadow tree
  function handleFocusIn(elm) {
      {
          assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
      }
      bindDocumentMousedownMouseupHandlers(elm);
      // Unbind any focus listeners we may have going on
      ignoreFocus(elm);
      // This focusin listener is to catch focusin events from keyboard interactions
      // A better solution would perhaps be to listen for keydown events, but
      // the keydown event happens on whatever element already has focus (or no element
      // at all in the case of the location bar. So, instead we have to assume that focusin
      // without a mousedown means keyboard navigation
      addEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }
  function ignoreFocusIn(elm) {
      removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const { blur, focus } = HTMLElement.prototype;
  /**
   * This method only applies to elements with a shadow attached to them
   */
  function tabIndexGetterPatched() {
      if (isDelegatingFocus(this) && isFalse(hasAttribute.call(this, 'tabindex'))) {
          // this covers the case where the default tabindex should be 0 because the
          // custom element is delegating its focus
          return 0;
      }
      return tabIndexGetter.call(this);
  }
  /**
   * This method only applies to elements with a shadow attached to them
   * @param value
   */
  function tabIndexSetterPatched(value) {
      // This tabIndex setter might be confusing unless it is understood that HTML
      // elements have default tabIndex property values. Natively focusable elements have
      // a default tabIndex value of 0 and all other elements have a default tabIndex
      // value of -1. For example, the tabIndex property value is -1 for both <x-foo> and
      // <x-foo tabindex="-1">, but our delegatesFocus polyfill should only kick in for
      // the latter case when the value of the tabindex attribute is -1.
      const delegatesFocus = isDelegatingFocus(this);
      // Record the state of things before invoking component setter.
      const prevValue = tabIndexGetter.call(this);
      const prevHasAttr = hasAttribute.call(this, 'tabindex');
      tabIndexSetter.call(this, value);
      // Record the state of things after invoking component setter.
      const currValue = tabIndexGetter.call(this);
      const currHasAttr = hasAttribute.call(this, 'tabindex');
      const didValueChange = prevValue !== currValue;
      // If the tabindex attribute is initially rendered, we can assume that this setter has
      // previously executed and a listener has been added. We must remove that listener if
      // the tabIndex property value has changed or if the component no longer renders a
      // tabindex attribute.
      if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
          if (prevValue === -1) {
              ignoreFocusIn(this);
          }
          if (prevValue === 0 && delegatesFocus) {
              ignoreFocus(this);
          }
      }
      // If a tabindex attribute was not rendered after invoking its setter, it means the
      // component is taking control. Do nothing.
      if (isFalse(currHasAttr)) {
          return;
      }
      // If the tabindex attribute is initially rendered, we can assume that this setter has
      // previously executed and a listener has been added. If the tabindex attribute is still
      // rendered after invoking the setter AND the tabIndex property value has not changed,
      // we don't need to do any work.
      if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
          return;
      }
      // At this point we know that a tabindex attribute was rendered after invoking the
      // setter and that either:
      // 1) This is the first time this setter is being invoked.
      // 2) This is not the first time this setter is being invoked and the value is changing.
      // We need to add the appropriate listeners in either case.
      if (currValue === -1) {
          // Add the magic to skip the shadow tree
          handleFocusIn(this);
      }
      if (currValue === 0 && delegatesFocus) {
          // Add the magic to skip the host element
          handleFocus(this);
      }
  }
  /**
   * This method only applies to elements with a shadow attached to them
   */
  function blurPatched() {
      if (isDelegatingFocus(this)) {
          const currentActiveElement = getActiveElement(this);
          if (!isNull(currentActiveElement)) {
              // if there is an active element, blur it (intentionally using the dot notation in case the user defines the blur routine)
              currentActiveElement.blur();
              return;
          }
      }
      return blur.call(this);
  }
  function focusPatched() {
      // Save enabled state
      const originallyEnabled = isKeyboardFocusNavigationRoutineEnabled();
      // Change state by disabling if originally enabled
      if (originallyEnabled) {
          disableKeyboardFocusNavigationRoutines();
      }
      if (isSyntheticShadowHost(this) && isDelegatingFocus(this)) {
          hostElementFocus.call(this);
          return;
      }
      // Typescript does not like it when you treat the `arguments` object as an array
      // @ts-expect-error type-mismatch
      focus.apply(this, arguments);
      // Restore state by enabling if originally enabled
      if (originallyEnabled) {
          enableKeyboardFocusNavigationRoutines();
      }
  }
  // Non-deep-traversing patches: this descriptor map includes all descriptors that
  // do not five access to nodes beyond the immediate children.
  defineProperties(HTMLElement.prototype, {
      tabIndex: {
          get() {
              if (isSyntheticShadowHost(this)) {
                  return tabIndexGetterPatched.call(this);
              }
              return tabIndexGetter.call(this);
          },
          set(v) {
              if (isSyntheticShadowHost(this)) {
                  return tabIndexSetterPatched.call(this, v);
              }
              return tabIndexSetter.call(this, v);
          },
          enumerable: true,
          configurable: true,
      },
      blur: {
          value() {
              if (isSyntheticShadowHost(this)) {
                  return blurPatched.call(this);
              }
              blur.call(this);
          },
          enumerable: true,
          writable: true,
          configurable: true,
      },
      focus: {
          value() {
              // Typescript does not like it when you treat the `arguments` object as an array
              // @ts-expect-error type-mismatch
              focusPatched.apply(this, arguments);
          },
          enumerable: true,
          writable: true,
          configurable: true,
      },
  });
  // Note: In JSDOM innerText is not implemented: https://github.com/jsdom/jsdom/issues/1245
  if (innerTextGetter !== null && innerTextSetter !== null) {
      defineProperty(HTMLElement.prototype, 'innerText', {
          get() {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              return innerTextGetter.call(this);
          },
          set(v) {
              innerTextSetter.call(this, v);
          },
          enumerable: true,
          configurable: true,
      });
  }
  // Note: Firefox does not have outerText, https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText
  if (outerTextGetter !== null && outerTextSetter !== null) {
      // From https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText :
      // HTMLElement.outerText is a non-standard property. As a getter, it returns the same value as Node.innerText.
      // As a setter, it removes the current node and replaces it with the given text.
      defineProperty(HTMLElement.prototype, 'outerText', {
          get() {
              // Note: we deviate from native shadow here, but are not fixing
              // due to backwards compat: https://github.com/salesforce/lwc/pull/3103
              return outerTextGetter.call(this);
          },
          set(v) {
              // Invoking the `outerText` setter on a host element should trigger its disconnection, but until we merge node reactions, it will not work.
              // We could reimplement the outerText setter in JavaScript ([blink implementation](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/html_element.cc;l=841-879;drc=6e8b402a6231405b753919029c9027404325ea00;bpv=0;bpt=1))
              // but the benefits don't worth the efforts.
              outerTextSetter.call(this, v);
          },
          enumerable: true,
          configurable: true,
      });
  }

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function getShadowToken(node) {
      return node[KEY__SHADOW_TOKEN];
  }
  function setShadowToken(node, shadowToken) {
      node[KEY__SHADOW_TOKEN] = shadowToken;
  }
  /**
   * Patching Element.prototype.$shadowToken$ to mark elements a portal:
   * - we use a property to allow engines to set a custom attribute that should be
   * placed into the element to sandbox the css rules defined for the template.
   * - this custom attribute must be unique.
   */
  defineProperty(Element.prototype, KEY__SHADOW_TOKEN, {
      set(shadowToken) {
          const oldShadowToken = this[KEY__SHADOW_TOKEN_PRIVATE];
          if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
              removeAttribute.call(this, oldShadowToken);
          }
          if (!isUndefined(shadowToken)) {
              setAttribute.call(this, shadowToken, '');
          }
          this[KEY__SHADOW_TOKEN_PRIVATE] = shadowToken;
      },
      get() {
          return this[KEY__SHADOW_TOKEN_PRIVATE];
      },
      configurable: true,
  });
  function recursivelySetShadowResolver(node, fn) {
      node[KEY__SHADOW_RESOLVER] = fn;
      // Recurse using firstChild/nextSibling because browsers use a linked list under the hood to
      // represent the DOM, so childNodes/children would cause an unnecessary array allocation.
      // https://viethung.space/blog/2020/09/01/Browser-from-Scratch-DOM-API/#Choosing-DOM-tree-data-structure
      let child = firstChildGetter.call(node);
      while (!isNull(child)) {
          recursivelySetShadowResolver(child, fn);
          child = nextSiblingGetter.call(child);
      }
  }
  defineProperty(Element.prototype, KEY__SHADOW_STATIC, {
      set(v) {
          // Marking an element as static will propagate the shadow resolver to the children.
          if (v) {
              const fn = this[KEY__SHADOW_RESOLVER];
              recursivelySetShadowResolver(this, fn);
          }
          this[KEY__SHADOW_STATIC_PRIVATE] = v;
      },
      get() {
          return this[KEY__SHADOW_STATIC_PRIVATE];
      },
      configurable: true,
  });

  /*
   * Copyright (c) 2023, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  // TODO [#3733]: remove this entire file when we can remove legacy scope tokens
  function getLegacyShadowToken(node) {
      return node[KEY__LEGACY_SHADOW_TOKEN];
  }
  function setLegacyShadowToken(node, shadowToken) {
      node[KEY__LEGACY_SHADOW_TOKEN] = shadowToken;
  }
  /**
   * Patching Element.prototype.$legacyShadowToken$ to mark elements a portal:
   * Same as $shadowToken$ but for legacy CSS scope tokens.
   */
  defineProperty(Element.prototype, KEY__LEGACY_SHADOW_TOKEN, {
      set(shadowToken) {
          const oldShadowToken = this[KEY__LEGACY_SHADOW_TOKEN_PRIVATE];
          if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
              removeAttribute.call(this, oldShadowToken);
          }
          if (!isUndefined(shadowToken)) {
              setAttribute.call(this, shadowToken, '');
          }
          this[KEY__LEGACY_SHADOW_TOKEN_PRIVATE] = shadowToken;
      },
      get() {
          return this[KEY__LEGACY_SHADOW_TOKEN_PRIVATE];
      },
      configurable: true,
  });

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const DomManualPrivateKey = '$$DomManualKey$$';
  // Resolver function used when a node is removed from within a portal
  const DocumentResolverFn = function () { };
  // We can use a single observer without having to worry about leaking because
  // "Registered observers in a nodes registered observer list have a weak
  // reference to the node."
  // https://dom.spec.whatwg.org/#garbage-collection
  let portalObserver;
  const portalObserverConfig = {
      childList: true,
  };
  // TODO [#3733]: remove support for legacy scope tokens
  function adoptChildNode(node, fn, shadowToken, legacyShadowToken) {
      const previousNodeShadowResolver = getShadowRootResolver(node);
      if (previousNodeShadowResolver === fn) {
          return; // nothing to do here, it is already correctly patched
      }
      setShadowRootResolver(node, fn);
      if (node instanceof Element) {
          setShadowToken(node, shadowToken);
          if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {
              setLegacyShadowToken(node, legacyShadowToken);
          }
          if (isSyntheticShadowHost(node)) {
              // Root LWC elements can't get content slotted into them, therefore we don't observe their children.
              return;
          }
          if (isUndefined(previousNodeShadowResolver)) {
              // we only care about Element without shadowResolver (no MO.observe has been called)
              MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
          }
          // recursively patching all children as well
          const childNodes = childNodesGetter.call(node);
          for (let i = 0, len = childNodes.length; i < len; i += 1) {
              adoptChildNode(childNodes[i], fn, shadowToken, legacyShadowToken);
          }
      }
  }
  function initPortalObserver() {
      return new MO((mutations) => {
          forEach.call(mutations, (mutation) => {
              /**
               * This routine will process all nodes added or removed from elm (which is marked as a portal)
               * When adding a node to the portal element, we should add the ownership.
               * When removing a node from the portal element, this ownership should be removed.
               *
               * There is some special cases in which MutationObserver may call with stacked mutations (the same node
               * will be in addedNodes and removedNodes) or with false positives (a node that is removed and re-appended
               * in the same tick) for those cases, we cover by checking that the node is contained
               * (or not in the case of removal) by the element.
               */
              const { target: elm, addedNodes, removedNodes } = mutation;
              // the target of the mutation should always have a ShadowRootResolver attached to it
              const fn = getShadowRootResolver(elm);
              const shadowToken = getShadowToken(elm);
              const legacyShadowToken = lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS
                  ? getLegacyShadowToken(elm)
                  : undefined;
              // Process removals first to handle the case where an element is removed and reinserted
              for (let i = 0, len = removedNodes.length; i < len; i += 1) {
                  const node = removedNodes[i];
                  if (!(compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                      adoptChildNode(node, DocumentResolverFn, undefined, undefined);
                  }
              }
              for (let i = 0, len = addedNodes.length; i < len; i += 1) {
                  const node = addedNodes[i];
                  if (compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY) {
                      adoptChildNode(node, fn, shadowToken, legacyShadowToken);
                  }
              }
          });
      });
  }
  function markElementAsPortal(elm) {
      if (isUndefined(portalObserver)) {
          portalObserver = initPortalObserver();
      }
      if (isUndefined(getShadowRootResolver(elm))) {
          // only an element from a within a shadowRoot should be used here
          throw new Error(`Invalid Element`);
      }
      // install mutation observer for portals
      MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
      // TODO [#1253]: optimization to synchronously adopt new child nodes added
      // to this elm, we can do that by patching the most common operations
      // on the node itself
  }
  /**
   * Patching Element.prototype.$domManual$ to mark elements as portal:
   * - we use a property to allow engines to signal that a particular element in
   * a shadow supports manual insertion of child nodes.
   * - this signal comes as a boolean value, and we use it to install the MO instance
   * onto the element, to propagate the $ownerKey$ and $shadowToken$ to all new
   * child nodes.
   * - at the moment, there is no way to undo this operation, once the element is
   * marked as $domManual$, setting it to false does nothing.
   */
  // TODO [#1306]: rename this to $observerConnection$
  defineProperty(Element.prototype, '$domManual$', {
      set(v) {
          this[DomManualPrivateKey] = v;
          if (isTrue(v)) {
              markElementAsPortal(this);
          }
      },
      get() {
          return this[DomManualPrivateKey];
      },
      configurable: true,
  });
  /** version: 6.4.5 */
  }

})();
/** LWC OSS version: 6.4.5
    lwc-platform version: 250.8.3-6.4.5 */

"undefined"===typeof Aura&&(Aura={});
this.Aura = this.Aura || {};
this.Aura.Engine = (function (exports) {
    'use strict';

    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */
    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Minimal polyfill of ARIA string reflection, plus some non-standard ARIA props
    // Taken from https://github.com/salesforce/lwc/blob/44a01ef/packages/%40lwc/shared/src/aria.ts#L22-L70
    // This is designed for maximum backwards compatibility on LEX - it should never change.
    // We deliberately don't import from @lwc/shared because that would make this code less portable.
    const ARIA_PROPERTIES = [
        'ariaActiveDescendant',
        'ariaAtomic',
        'ariaAutoComplete',
        'ariaBusy',
        'ariaChecked',
        'ariaColCount',
        'ariaColIndex',
        'ariaColSpan',
        'ariaControls',
        'ariaCurrent',
        'ariaDescribedBy',
        'ariaDetails',
        'ariaDisabled',
        'ariaErrorMessage',
        'ariaExpanded',
        'ariaFlowTo',
        'ariaHasPopup',
        'ariaHidden',
        'ariaInvalid',
        'ariaKeyShortcuts',
        'ariaLabel',
        'ariaLabelledBy',
        'ariaLevel',
        'ariaLive',
        'ariaModal',
        'ariaMultiLine',
        'ariaMultiSelectable',
        'ariaOrientation',
        'ariaOwns',
        'ariaPlaceholder',
        'ariaPosInSet',
        'ariaPressed',
        'ariaReadOnly',
        'ariaRelevant',
        'ariaRequired',
        'ariaRoleDescription',
        'ariaRowCount',
        'ariaRowIndex',
        'ariaRowSpan',
        'ariaSelected',
        'ariaSetSize',
        'ariaSort',
        'ariaValueMax',
        'ariaValueMin',
        'ariaValueNow',
        'ariaValueText',
        'role',
    ];
    for (const prop of ARIA_PROPERTIES) {
        const attribute = prop.replace(/^aria/, 'aria-').toLowerCase(); // e.g. ariaPosInSet => aria-posinset
        if (!Object.getOwnPropertyDescriptor(Element.prototype, prop)) {
            Object.defineProperty(Element.prototype, prop, {
                get() {
                    return this.getAttribute(attribute);
                },
                set(value) {
                    // Per the spec, only null is treated as removing the attribute. However, Chromium/WebKit currently
                    // differ from the spec and allow undefined as well. Here, we follow the spec, as well as
                    // our historical behavior. See: https://github.com/w3c/aria/issues/1858
                    if (value === null) {
                        this.removeAttribute(attribute);
                    }
                    else {
                        this.setAttribute(attribute, value);
                    }
                },
                // configurable and enumerable to allow it to be overridden  this mimics Safari's/Chrome's behavior
                configurable: true,
                enumerable: true,
            });
        }
    }
    /** version: 6.4.5 */

    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */
    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     *
     * @param value
     * @param msg
     */
    function invariant(value, msg) {
        if (!value) {
            throw new Error(`Invariant Violation: ${msg}`);
        }
    }
    /**
     *
     * @param value
     * @param msg
     */
    function isTrue$1(value, msg) {
        if (!value) {
            throw new Error(`Assert Violation: ${msg}`);
        }
    }
    /**
     *
     * @param value
     * @param msg
     */
    function isFalse$1(value, msg) {
        if (value) {
            throw new Error(`Assert Violation: ${msg}`);
        }
    }
    /**
     *
     * @param msg
     */
    function fail(msg) {
        throw new Error(msg);
    }

    var assert = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fail: fail,
        invariant: invariant,
        isFalse: isFalse$1,
        isTrue: isTrue$1
    });

    /*
     * Copyright (c) 2024, Salesforce, Inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { 
    /** Detached {@linkcode Object.assign}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign MDN Reference}. */
    assign, 
    /** Detached {@linkcode Object.create}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create MDN Reference}. */
    create, 
    /** Detached {@linkcode Object.defineProperties}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties MDN Reference}. */
    defineProperties, 
    /** Detached {@linkcode Object.defineProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty MDN Reference}. */
    defineProperty, 
    /** Detached {@linkcode Object.entries}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries MDN Reference}. */
    entries, 
    /** Detached {@linkcode Object.freeze}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze MDN Reference}. */
    freeze, 
    /** Detached {@linkcode Object.getOwnPropertyDescriptor}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor MDN Reference}. */
    getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, 
    /** Detached {@linkcode Object.getOwnPropertyDescriptors}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors MDN Reference}. */
    getOwnPropertyDescriptors, 
    /** Detached {@linkcode Object.getOwnPropertyNames}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames MDN Reference}. */
    getOwnPropertyNames: getOwnPropertyNames$1, 
    /** Detached {@linkcode Object.getPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf MDN Reference}. */
    getPrototypeOf: getPrototypeOf$1, 
    /** Detached {@linkcode Object.hasOwnProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty MDN Reference}. */
    hasOwnProperty: hasOwnProperty$1, 
    /** Detached {@linkcode Object.isFrozen}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen MDN Reference}. */
    isFrozen, 
    /** Detached {@linkcode Object.keys}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys MDN Reference}. */
    keys, 
    /** Detached {@linkcode Object.seal}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal MDN Reference}. */
    seal, 
    /** Detached {@linkcode Object.setPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf MDN Reference}. */
    setPrototypeOf, } = Object;
    /** Detached {@linkcode Array.isArray}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray MDN Reference}. */
    const { isArray: isArray$1 } = Array;
    // For some reason, JSDoc don't get picked up for multiple renamed destructured constants (even
    // though it works fine for one, e.g. isArray), so comments for these are added to the export
    // statement, rather than this declaration.
    const { concat: ArrayConcat$1, copyWithin: ArrayCopyWithin, every: ArrayEvery, fill: ArrayFill, filter: ArrayFilter, find: ArrayFind, findIndex: ArrayFindIndex, includes: ArrayIncludes, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush$1, reduce: ArrayReduce, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, // Weird anomaly!
     } = Array.prototype;
    /** Detached {@linkcode String.fromCharCode}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode MDN Reference}. */
    const { fromCharCode: StringFromCharCode } = String;
    // No JSDocs here - see comment for Array.prototype
    const { charAt: StringCharAt, charCodeAt: StringCharCodeAt, replace: StringReplace, split: StringSplit, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;
    /**
     * Determines whether the argument is `undefined`.
     * @param obj Value to test
     * @returns `true` if the value is `undefined`.
     */
    function isUndefined$1(obj) {
        return obj === undefined;
    }
    /**
     * Determines whether the argument is `null`.
     * @param obj Value to test
     * @returns `true` if the value is `null`.
     */
    function isNull(obj) {
        return obj === null;
    }
    /**
     * Determines whether the argument is `true`.
     * @param obj Value to test
     * @returns `true` if the value is `true`.
     */
    function isTrue(obj) {
        return obj === true;
    }
    /**
     * Determines whether the argument is `false`.
     * @param obj Value to test
     * @returns `true` if the value is `false`.
     */
    function isFalse(obj) {
        return obj === false;
    }
    /**
     * Determines whether the argument is a boolean.
     * @param obj Value to test
     * @returns `true` if the value is a boolean.
     */
    function isBoolean(obj) {
        return typeof obj === 'boolean';
    }
    /**
     * Determines whether the argument is a function.
     * @param obj Value to test
     * @returns `true` if the value is a function.
     */
    // Replacing `Function` with a narrower type that works for all our use cases is tricky...
    // eslint-disable-next-line @typescript-eslint/ban-types
    function isFunction$1(obj) {
        return typeof obj === 'function';
    }
    /**
     * Determines whether the argument is an object or null.
     * @param obj Value to test
     * @returns `true` if the value is an object or null.
     */
    function isObject(obj) {
        return typeof obj === 'object';
    }
    /**
     * Determines whether the argument is a string.
     * @param obj Value to test
     * @returns `true` if the value is a string.
     */
    function isString(obj) {
        return typeof obj === 'string';
    }
    /**
     * Determines whether the argument is a number.
     * @param obj Value to test
     * @returns `true` if the value is a number.
     */
    function isNumber(obj) {
        return typeof obj === 'number';
    }
    /** Does nothing!  */
    function noop() {
        /* Do nothing */
    }
    const OtS$1 = {}.toString;
    /**
     * Converts the argument to a string, safely accounting for objects with "null" prototype.
     * Note that `toString(null)` returns `"[object Null]"` rather than `"null"`.
     * @param obj Value to convert to a string.
     * @returns String representation of the value.
     */
    function toString$1(obj) {
        if (obj?.toString) {
            // Arrays might hold objects with "null" prototype So using
            // Array.prototype.toString directly will cause an error Iterate through
            // all the items and handle individually.
            if (isArray$1(obj)) {
                // This behavior is slightly different from Array#toString:
                // 1. Array#toString calls `this.join`, rather than Array#join
                // Ex: arr = []; arr.join = () => 1; arr.toString() === 1; toString(arr) === ''
                // 2. Array#toString delegates to Object#toString if `this.join` is not a function
                // Ex: arr = []; arr.join = 'no'; arr.toString() === '[object Array]; toString(arr) = ''
                // 3. Array#toString converts null/undefined to ''
                // Ex: arr = [null, undefined]; arr.toString() === ','; toString(arr) === '[object Null],undefined'
                // 4. Array#toString converts recursive references to arrays to ''
                // Ex: arr = [1]; arr.push(arr, 2); arr.toString() === '1,,2'; toString(arr) throws
                // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString
                return ArrayJoin.call(ArrayMap.call(obj, toString$1), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            // This catches null and returns "[object Null]". Weird, but kept for backwards compatibility.
            return OtS$1.call(obj);
        }
        else {
            return String(obj);
        }
    }
    /**
     * Gets the property descriptor for the given object and property key. Similar to
     * {@linkcode Object.getOwnPropertyDescriptor}, but looks up the prototype chain.
     * @param o Value to get the property descriptor for
     * @param p Property key to get the descriptor for
     * @returns The property descriptor for the given object and property key.
     */
    function getPropertyDescriptor(o, p) {
        do {
            const d = getOwnPropertyDescriptor$1(o, p);
            if (!isUndefined$1(d)) {
                return d;
            }
            o = getPrototypeOf$1(o);
        } while (o !== null);
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // These must be updated when the enum is updated.
    // It's a bit annoying to do have to do this manually, but this makes the file tree-shakeable,
    // passing the `verify-treeshakeable.js` test.
    const LOWEST_API_VERSION = 58 /* APIVersion.V58_244_SUMMER_23 */;
    /**
     *
     * @param apiVersionFeature
     * @param apiVersion
     */
    function isAPIFeatureEnabled(apiVersionFeature, apiVersion) {
        switch (apiVersionFeature) {
            case 0 /* APIFeature.LOWERCASE_SCOPE_TOKENS */:
            case 1 /* APIFeature.TREAT_ALL_PARSE5_ERRORS_AS_ERRORS */:
                return apiVersion >= 59 /* APIVersion.V59_246_WINTER_24 */;
            case 3 /* APIFeature.DISABLE_OBJECT_REST_SPREAD_TRANSFORMATION */:
            case 4 /* APIFeature.SKIP_UNNECESSARY_REGISTER_DECORATORS */:
            case 5 /* APIFeature.USE_COMMENTS_FOR_FRAGMENT_BOOKENDS */:
            case 2 /* APIFeature.USE_FRAGMENTS_FOR_LIGHT_DOM_SLOTS */:
                return apiVersion >= 60 /* APIVersion.V60_248_SPRING_24 */;
            case 8 /* APIFeature.ENABLE_ELEMENT_INTERNALS_AND_FACE */:
            case 7 /* APIFeature.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE */:
            case 6 /* APIFeature.USE_LIGHT_DOM_SLOT_FORWARDING */:
                return apiVersion >= 61 /* APIVersion.V61_250_SUMMER_24 */;
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     *
     * NOTE: If you update this list, please update test files that implicitly reference this list!
     * Searching the codebase for `aria-flowto` and `ariaFlowTo` should be good enough to find all usages.
     */
    const AriaPropertyNames = [
        'ariaActiveDescendant',
        'ariaAtomic',
        'ariaAutoComplete',
        'ariaBusy',
        'ariaChecked',
        'ariaColCount',
        'ariaColIndex',
        'ariaColIndexText',
        'ariaColSpan',
        'ariaControls',
        'ariaCurrent',
        'ariaDescribedBy',
        'ariaDescription',
        'ariaDetails',
        'ariaDisabled',
        'ariaErrorMessage',
        'ariaExpanded',
        'ariaFlowTo',
        'ariaHasPopup',
        'ariaHidden',
        'ariaInvalid',
        'ariaKeyShortcuts',
        'ariaLabel',
        'ariaLabelledBy',
        'ariaLevel',
        'ariaLive',
        'ariaModal',
        'ariaMultiLine',
        'ariaMultiSelectable',
        'ariaOrientation',
        'ariaOwns',
        'ariaPlaceholder',
        'ariaPosInSet',
        'ariaPressed',
        'ariaReadOnly',
        'ariaRelevant',
        'ariaRequired',
        'ariaRoleDescription',
        'ariaRowCount',
        'ariaRowIndex',
        'ariaRowIndexText',
        'ariaRowSpan',
        'ariaSelected',
        'ariaSetSize',
        'ariaSort',
        'ariaValueMax',
        'ariaValueMin',
        'ariaValueNow',
        'ariaValueText',
        'ariaBrailleLabel',
        'ariaBrailleRoleDescription',
        'role',
    ];
    const { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap } = /*@__PURE__*/ (() => {
        const AriaAttrNameToPropNameMap = create(null);
        const AriaPropNameToAttrNameMap = create(null);
        // Synthetic creation of all AOM property descriptors for Custom Elements
        forEach.call(AriaPropertyNames, (propName) => {
            const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, () => 'aria-'));
            AriaAttrNameToPropNameMap[attrName] = propName;
            AriaPropNameToAttrNameMap[propName] = attrName;
        });
        return { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap };
    })();
    // These attributes take either an ID or a list of IDs as values.
    // This includes aria-* attributes as well as the special non-ARIA "for" attribute
    const ID_REFERENCING_ATTRIBUTES_SET = /*@__PURE__*/ new Set([
        'aria-activedescendant',
        'aria-controls',
        'aria-describedby',
        'aria-details',
        'aria-errormessage',
        'aria-flowto',
        'aria-labelledby',
        'aria-owns',
        'for',
    ]);

    /*
     * Copyright (c) 2023, Salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const KEY__SHADOW_RESOLVER = '$shadowResolver$';
    const KEY__SHADOW_STATIC = '$shadowStaticNode$';
    const KEY__SHADOW_TOKEN = '$shadowToken$';
    const KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';
    const KEY__SCOPED_CSS = '$scoped$';
    const KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';
    const KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';
    const XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    const XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const CAMEL_REGEX = /-([a-z])/g;
    // These are HTML standard prop/attribute IDL mappings, but are not predictable based on camel/kebab-case conversion
    const SPECIAL_PROPERTY_ATTRIBUTE_MAPPING = /*@__PURE__@*/ new Map([
        ['accessKey', 'accesskey'],
        ['readOnly', 'readonly'],
        ['tabIndex', 'tabindex'],
        ['bgColor', 'bgcolor'],
        ['colSpan', 'colspan'],
        ['rowSpan', 'rowspan'],
        ['contentEditable', 'contenteditable'],
        ['crossOrigin', 'crossorigin'],
        ['dateTime', 'datetime'],
        ['formAction', 'formaction'],
        ['isMap', 'ismap'],
        ['maxLength', 'maxlength'],
        ['minLength', 'minlength'],
        ['noValidate', 'novalidate'],
        ['useMap', 'usemap'],
        ['htmlFor', 'for'],
    ]);
    /**
     * Map associating previously transformed HTML property into HTML attribute.
     */
    const CACHED_PROPERTY_ATTRIBUTE_MAPPING = /*@__PURE__@*/ new Map();
    /**
     *
     * @param propName
     */
    function htmlPropertyToAttribute(propName) {
        const ariaAttributeName = AriaPropNameToAttrNameMap[propName];
        if (!isUndefined$1(ariaAttributeName)) {
            return ariaAttributeName;
        }
        const specialAttributeName = SPECIAL_PROPERTY_ATTRIBUTE_MAPPING.get(propName);
        if (!isUndefined$1(specialAttributeName)) {
            return specialAttributeName;
        }
        const cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);
        if (!isUndefined$1(cachedAttributeName)) {
            return cachedAttributeName;
        }
        let attributeName = '';
        for (let i = 0, len = propName.length; i < len; i++) {
            const code = StringCharCodeAt.call(propName, i);
            if (code >= 65 && // "A"
                code <= 90 // "Z"
            ) {
                attributeName += '-' + StringFromCharCode(code + 32);
            }
            else {
                attributeName += StringFromCharCode(code);
            }
        }
        CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);
        return attributeName;
    }
    /**
     * Map associating previously transformed kabab-case attributes into camel-case props.
     */
    const CACHED_KEBAB_CAMEL_MAPPING = /*@__PURE__@*/ new Map();
    /**
     *
     * @param attrName
     */
    function kebabCaseToCamelCase(attrName) {
        let result = CACHED_KEBAB_CAMEL_MAPPING.get(attrName);
        if (isUndefined$1(result)) {
            result = StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());
            CACHED_KEBAB_CAMEL_MAPPING.set(attrName, result);
        }
        return result;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Increment whenever the LWC template compiler changes
    const LWC_VERSION = "6.4.5";
    const LWC_VERSION_COMMENT_REGEX = /\/\*LWC compiler v([\d.]+)\*\/\s*}/;
    /** version: 6.4.5 */

    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */

    /*
     * Copyright (c) 2024, Salesforce, Inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // When deprecating a feature flag, ensure that it is also no longer set in the application. For
    // example, in core, the flag should be removed from LwcPermAndPrefUtilImpl.java
    /** List of all feature flags available, with the default value `null`. */
    const features = {
        PLACEHOLDER_TEST_FLAG: null,
        DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE: null,
        ENABLE_WIRE_SYNC_EMIT: null,
        DISABLE_LIGHT_DOM_UNSCOPED_CSS: null,
        ENABLE_FROZEN_TEMPLATE: null,
        ENABLE_LEGACY_SCOPE_TOKENS: null,
        ENABLE_FORCE_SHADOW_MIGRATE_MODE: null,
        ENABLE_EXPERIMENTAL_SIGNALS: null,
    };
    if (!globalThis.lwcRuntimeFlags) {
        Object.defineProperty(globalThis, 'lwcRuntimeFlags', { value: create(null) });
    }
    /** Feature flags that have been set. */
    const flags = globalThis.lwcRuntimeFlags;
    /**
     * Set the value at runtime of a given feature flag. This method only be invoked once per feature
     * flag. It is meant to be used during the app initialization.
     * @param name Name of the feature flag to set
     * @param value Whether the feature flag should be enabled
     * @throws Will throw if a non-boolean value is provided when running in production.
     * @example setFeatureFlag("DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE", true)
     */
    function setFeatureFlag(name, value) {
        if (!isBoolean(value)) {
            const message = `Failed to set the value "${value}" for the runtime feature flag "${name}". Runtime feature flags can only be set to a boolean value.`;
            {
                throw new TypeError(message);
            }
        }
        if (isUndefined$1(features[name])) {
            // eslint-disable-next-line no-console
            console.info(`Attempt to set a value on an unknown feature flag "${name}" resulted in a NOOP.`);
            return;
        }
        // This may seem redundant, but `"development" === 'test-karma-lwc'` is replaced by Karma tests
        {
            // Allow the same flag to be set more than once outside of production to enable testing
            flags[name] = value;
        }
    }
    /** version: 6.4.5 */

    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const onReportingEnabledCallbacks = [];
    /** The currently assigned reporting dispatcher. */
    let currentDispatcher$1 = noop;
    /**
     * Whether reporting is enabled.
     *
     * Note that this may seem redundant, given you can just check if the currentDispatcher is undefined,
     * but it turns out that Terser only strips out unused code if we use this explicit boolean.
     */
    let enabled$1 = false;
    const reportingControl = {
        /**
         * Attach a new reporting control (aka dispatcher).
         * @param dispatcher reporting control
         */
        attachDispatcher(dispatcher) {
            enabled$1 = true;
            currentDispatcher$1 = dispatcher;
            for (const callback of onReportingEnabledCallbacks) {
                try {
                    callback();
                }
                catch (err) {
                    // This should never happen. But if it does, we don't want one callback to cause another to fail
                    // eslint-disable-next-line no-console
                    console.error('Could not invoke callback', err);
                }
            }
            onReportingEnabledCallbacks.length = 0; // clear the array
        },
        /**
         * Detach the current reporting control (aka dispatcher).
         */
        detachDispatcher() {
            enabled$1 = false;
            currentDispatcher$1 = noop;
        },
    };
    /**
     * Report to the current dispatcher, if there is one.
     * @param reportingEventId
     * @param payload data to report
     */
    function report(reportingEventId, payload) {
        if (enabled$1) {
            currentDispatcher$1(reportingEventId, payload);
        }
    }
    /**
     * Return true if reporting is enabled
     */
    function isReportingEnabled() {
        return enabled$1;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getComponentTag(vm) {
        return `<${StringToLowerCase.call(vm.tagName)}>`;
    }
    // TODO [#1695]: Unify getComponentStack and getErrorComponentStack
    function getComponentStack(vm) {
        const stack = [];
        let prefix = '';
        while (!isNull(vm.owner)) {
            ArrayPush$1.call(stack, prefix + getComponentTag(vm));
            vm = vm.owner;
            prefix += '\t';
        }
        return ArrayJoin.call(stack, '\n');
    }
    function getErrorComponentStack(vm) {
        const wcStack = [];
        let currentVm = vm;
        while (!isNull(currentVm)) {
            ArrayPush$1.call(wcStack, getComponentTag(currentVm));
            currentVm = currentVm.owner;
        }
        return wcStack.reverse().join('\n\t');
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function addErrorComponentStack(vm, error) {
        if (!isFrozen(error) && isUndefined$1(error.wcStack)) {
            const wcStack = getErrorComponentStack(vm);
            defineProperty(error, 'wcStack', {
                get() {
                    return wcStack;
                },
            });
        }
    }

    /*
     * Copyright (c) 2024, Salesforce, Inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const alreadyLoggedMessages = new Set();
    function log(method, message, vm, once) {
        let msg = `[LWC ${method}]: ${message}`;
        if (!isUndefined$1(vm)) {
            msg = `${msg}\n${getComponentStack(vm)}`;
        }
        if (once) {
            if (alreadyLoggedMessages.has(msg)) {
                return;
            }
            alreadyLoggedMessages.add(msg);
        }
        try {
            throw new Error(msg);
        }
        catch (e) {
            /* eslint-disable-next-line no-console */
            console[method](e);
        }
    }
    function logError(message, vm) {
        log('error', message, vm, false);
    }
    function logWarn(message, vm) {
        log('warn', message, vm, false);
    }
    function logWarnOnce(message, vm) {
        log('warn', message, vm, true);
    }

    /*
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const TargetToReactiveRecordMap = new WeakMap();
    function getReactiveRecord(target) {
        let reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (isUndefined$1(reactiveRecord)) {
            const newRecord = create(null);
            reactiveRecord = newRecord;
            TargetToReactiveRecordMap.set(target, newRecord);
        }
        return reactiveRecord;
    }
    let currentReactiveObserver = null;
    function valueMutated(target, key) {
        const reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (!isUndefined$1(reactiveRecord)) {
            const reactiveObservers = reactiveRecord[key];
            if (!isUndefined$1(reactiveObservers)) {
                for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {
                    const ro = reactiveObservers[i];
                    ro.notify();
                }
            }
        }
    }
    function valueObserved(target, key) {
        // We should determine if an active Observing Record is present to track mutations.
        if (currentReactiveObserver === null) {
            return;
        }
        const ro = currentReactiveObserver;
        const reactiveRecord = getReactiveRecord(target);
        let reactiveObservers = reactiveRecord[key];
        if (isUndefined$1(reactiveObservers)) {
            reactiveObservers = [];
            reactiveRecord[key] = reactiveObservers;
        }
        else if (reactiveObservers[0] === ro) {
            return; // perf optimization considering that most subscriptions will come from the same record
        }
        if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {
            ro.link(reactiveObservers);
        }
    }
    class ReactiveObserver {
        constructor(callback) {
            this.listeners = [];
            this.callback = callback;
        }
        observe(job) {
            const inceptionReactiveRecord = currentReactiveObserver;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            currentReactiveObserver = this;
            let error;
            try {
                job();
            }
            catch (e) {
                error = Object(e);
            }
            finally {
                currentReactiveObserver = inceptionReactiveRecord;
                if (error !== undefined) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
            }
        }
        /**
         * This method is responsible for disconnecting the Reactive Observer
         * from any Reactive Record that has a reference to it, to prevent future
         * notifications about previously recorded access.
         */
        reset() {
            const { listeners } = this;
            const len = listeners.length;
            if (len > 0) {
                for (let i = 0; i < len; i++) {
                    const set = listeners[i];
                    if (set.length === 1) {
                        // Perf optimization for the common case - the length is usually 1, so avoid the indexOf+splice.
                        // If the length is 1, we can also be sure that `this` is the first item in the array.
                        set.length = 0;
                    }
                    else {
                        // Slow case
                        const pos = ArrayIndexOf.call(set, this);
                        ArraySplice.call(set, pos, 1);
                    }
                }
                listeners.length = 0;
            }
        }
        // friend methods
        notify() {
            this.callback.call(undefined, this);
        }
        link(reactiveObservers) {
            ArrayPush$1.call(reactiveObservers, this);
            // we keep track of observing records where the observing record was added to so we can do some clean up later on
            ArrayPush$1.call(this.listeners, reactiveObservers);
        }
        isObserving() {
            return currentReactiveObserver === this;
        }
    }
    function componentValueMutated(vm, key) {
        // On the server side, we don't need mutation tracking. Skipping it improves performance.
        {
            valueMutated(vm.component, key);
        }
    }
    function componentValueObserved(vm, key, target = {}) {
        const { component, tro } = vm;
        // On the server side, we don't need mutation tracking. Skipping it improves performance.
        {
            valueObserved(component, key);
        }
    }
    function createReactiveObserver(callback) {
        // On the server side, we don't need mutation tracking. Skipping it improves performance.
        return new ReactiveObserver(callback) ;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let nextTickCallbackQueue = [];
    const SPACE_CHAR = 32;
    const EmptyObject = seal(create(null));
    const EmptyArray = seal([]);
    function flushCallbackQueue() {
        {
            if (nextTickCallbackQueue.length === 0) {
                throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);
            }
        }
        const callbacks = nextTickCallbackQueue;
        nextTickCallbackQueue = []; // reset to a new queue
        for (let i = 0, len = callbacks.length; i < len; i += 1) {
            callbacks[i]();
        }
    }
    function addCallbackToNextTick(callback) {
        {
            if (!isFunction$1(callback)) {
                throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);
            }
        }
        if (nextTickCallbackQueue.length === 0) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            Promise.resolve().then(flushCallbackQueue);
        }
        ArrayPush$1.call(nextTickCallbackQueue, callback);
    }
    function guid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    function shouldUseNativeCustomElementLifecycle(ctor) {
        if (lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {
            // temporary "kill switch"
            return false;
        }
        const apiVersion = getComponentAPIVersion(ctor);
        return isAPIFeatureEnabled(7 /* APIFeature.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE */, apiVersion);
    }
    function flattenStylesheets(stylesheets) {
        const list = [];
        for (const stylesheet of stylesheets) {
            if (!isArray$1(stylesheet)) {
                list.push(stylesheet);
            }
            else {
                list.push(...flattenStylesheets(stylesheet));
            }
        }
        return list;
    }
    function shouldBeFormAssociated(Ctor) {
        const ctorFormAssociated = Boolean(Ctor.formAssociated);
        const apiVersion = getComponentAPIVersion(Ctor);
        const apiFeatureEnabled = isAPIFeatureEnabled(8 /* APIFeature.ENABLE_ELEMENT_INTERNALS_AND_FACE */, apiVersion);
        if (ctorFormAssociated && !apiFeatureEnabled) {
            const tagName = getComponentRegisteredName(Ctor);
            logWarnOnce(`Component <${tagName}> set static formAssociated to true, but form ` +
                `association is not enabled because the API version is ${apiVersion}. To enable form association, ` +
                `update the LWC component API version to 61 or above. https://lwc.dev/guide/versioning`);
        }
        return ctorFormAssociated && apiFeatureEnabled;
    }

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function resolveCircularModuleDependency(fn) {
        const module = fn();
        return module?.__esModule ? module.default : module;
    }
    function isCircularModuleDependency(obj) {
        return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const instrumentDef = globalThis.__lwc_instrument_cmp_def ?? noop;
    const instrumentInstance = globalThis.__lwc_instrument_cmp_instance ?? noop;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having
    // to inject at runtime.
    const HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () { };
    const HTMLElementPrototype = HTMLElementConstructor.prototype;

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Apply ARIA string reflection behavior to a prototype.
    // This is deliberately kept separate from @lwc/aria-reflection. @lwc/aria-reflection is a global polyfill that is
    // needed for backwards compatibility in LEX, whereas this is designed to only apply to our own
    // LightningElement/BaseBridgeElement prototypes.
    // Note we only need to handle ARIA reflections that aren't already in Element.prototype
    const ariaReflectionPolyfillDescriptors = create(null);
    for (const [propName, attrName] of entries(AriaPropNameToAttrNameMap)) {
        if (isUndefined$1(getPropertyDescriptor(HTMLElementPrototype, propName))) {
            // Note that we need to call this.{get,set,has,remove}Attribute rather than dereferencing
            // from Element.prototype, because these methods are overridden in LightningElement.
            ariaReflectionPolyfillDescriptors[propName] = {
                get() {
                    return this.getAttribute(attrName);
                },
                set(newValue) {
                    // TODO [#3284]: there is disagreement between browsers and the spec on how to treat undefined
                    // Our historical behavior is to only treat null as removing the attribute
                    // See also https://github.com/w3c/aria/issues/1858
                    if (isNull(newValue)) {
                        this.removeAttribute(attrName);
                    }
                    else {
                        this.setAttribute(attrName, newValue);
                    }
                },
                // configurable and enumerable to allow it to be overridden  this mimics Safari's/Chrome's behavior
                configurable: true,
                enumerable: true,
            };
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // These properties get added to LWCElement.prototype publicProps automatically
    const defaultDefHTMLPropertyNames = [
        'accessKey',
        'dir',
        'draggable',
        'hidden',
        'id',
        'lang',
        'spellcheck',
        'tabIndex',
        'title',
    ];

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */
    const HTMLElementOriginalDescriptors = create(null);
    forEach.call(keys(AriaPropNameToAttrNameMap), (propName) => {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
        const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
        if (!isUndefined$1(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    forEach.call(defaultDefHTMLPropertyNames, (propName) => {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
        // this category, so, better to be sure.
        const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
        if (!isUndefined$1(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function generateDataDescriptor(options) {
        return assign({
            configurable: true,
            enumerable: true,
            writable: true,
        }, options);
    }
    function generateAccessorDescriptor(options) {
        return assign({
            configurable: true,
            enumerable: true,
        }, options);
    }
    let isDomMutationAllowed = false;
    function unlockDomMutation() {
        isDomMutationAllowed = true;
    }
    function lockDomMutation() {
        isDomMutationAllowed = false;
    }
    function logMissingPortalWarn(name, type) {
        return logWarn(`The \`${name}\` ${type} is available only on elements that use the \`lwc:dom="manual"\` directive.`);
    }
    function patchElementWithRestrictions(elm, options) {
        const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
        const descriptors = {
            outerHTML: generateAccessorDescriptor({
                get() {
                    return originalOuterHTMLDescriptor.get.call(this);
                },
                set(value) {
                    logError(`Invalid attempt to set outerHTML on Element.`);
                    return originalOuterHTMLDescriptor.set.call(this, value);
                },
            }),
        };
        // Apply extra restriction related to DOM manipulation if the element is not a portal.
        if (!options.isLight && options.isSynthetic && !options.isPortal) {
            const { appendChild, insertBefore, removeChild, replaceChild } = elm;
            const originalNodeValueDescriptor = getPropertyDescriptor(elm, 'nodeValue');
            const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
            const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');
            assign(descriptors, {
                appendChild: generateDataDescriptor({
                    value(aChild) {
                        logMissingPortalWarn('appendChild', 'method');
                        return appendChild.call(this, aChild);
                    },
                }),
                insertBefore: generateDataDescriptor({
                    value(newNode, referenceNode) {
                        if (!isDomMutationAllowed) {
                            logMissingPortalWarn('insertBefore', 'method');
                        }
                        return insertBefore.call(this, newNode, referenceNode);
                    },
                }),
                removeChild: generateDataDescriptor({
                    value(aChild) {
                        if (!isDomMutationAllowed) {
                            logMissingPortalWarn('removeChild', 'method');
                        }
                        return removeChild.call(this, aChild);
                    },
                }),
                replaceChild: generateDataDescriptor({
                    value(newChild, oldChild) {
                        logMissingPortalWarn('replaceChild', 'method');
                        return replaceChild.call(this, newChild, oldChild);
                    },
                }),
                nodeValue: generateAccessorDescriptor({
                    get() {
                        return originalNodeValueDescriptor.get.call(this);
                    },
                    set(value) {
                        if (!isDomMutationAllowed) {
                            logMissingPortalWarn('nodeValue', 'property');
                        }
                        originalNodeValueDescriptor.set.call(this, value);
                    },
                }),
                textContent: generateAccessorDescriptor({
                    get() {
                        return originalTextContentDescriptor.get.call(this);
                    },
                    set(value) {
                        logMissingPortalWarn('textContent', 'property');
                        originalTextContentDescriptor.set.call(this, value);
                    },
                }),
                innerHTML: generateAccessorDescriptor({
                    get() {
                        return originalInnerHTMLDescriptor.get.call(this);
                    },
                    set(value) {
                        logMissingPortalWarn('innerHTML', 'property');
                        return originalInnerHTMLDescriptor.set.call(this, value);
                    },
                }),
            });
        }
        defineProperties(elm, descriptors);
    }
    function getShadowRootRestrictionsDescriptors(sr) {
        // Disallowing properties in dev mode only to avoid people doing the wrong
        // thing when using the real shadow root, because if that's the case,
        // the component will not work when running with synthetic shadow.
        const originalAddEventListener = sr.addEventListener;
        const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');
        const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');
        return {
            innerHTML: generateAccessorDescriptor({
                get() {
                    return originalInnerHTMLDescriptor.get.call(this);
                },
                set(value) {
                    logError(`Invalid attempt to set innerHTML on ShadowRoot.`);
                    return originalInnerHTMLDescriptor.set.call(this, value);
                },
            }),
            textContent: generateAccessorDescriptor({
                get() {
                    return originalTextContentDescriptor.get.call(this);
                },
                set(value) {
                    logError(`Invalid attempt to set textContent on ShadowRoot.`);
                    return originalTextContentDescriptor.set.call(this, value);
                },
            }),
            addEventListener: generateDataDescriptor({
                value(type, listener, options) {
                    // TODO [#1824]: Potentially relax this restriction
                    if (!isUndefined$1(options)) {
                        logError('The `addEventListener` method on ShadowRoot does not support any options.', getAssociatedVMIfPresent(this));
                    }
                    // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-expect-error type-mismatch
                    return originalAddEventListener.apply(this, arguments);
                },
            }),
        };
    }
    // Custom Elements Restrictions:
    // -----------------------------
    function getCustomElementRestrictionsDescriptors(elm) {
        const originalAddEventListener = elm.addEventListener;
        const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
        const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
        const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');
        return {
            innerHTML: generateAccessorDescriptor({
                get() {
                    return originalInnerHTMLDescriptor.get.call(this);
                },
                set(value) {
                    logError(`Invalid attempt to set innerHTML on HTMLElement.`);
                    return originalInnerHTMLDescriptor.set.call(this, value);
                },
            }),
            outerHTML: generateAccessorDescriptor({
                get() {
                    return originalOuterHTMLDescriptor.get.call(this);
                },
                set(value) {
                    logError(`Invalid attempt to set outerHTML on HTMLElement.`);
                    return originalOuterHTMLDescriptor.set.call(this, value);
                },
            }),
            textContent: generateAccessorDescriptor({
                get() {
                    return originalTextContentDescriptor.get.call(this);
                },
                set(value) {
                    logError(`Invalid attempt to set textContent on HTMLElement.`);
                    return originalTextContentDescriptor.set.call(this, value);
                },
            }),
            addEventListener: generateDataDescriptor({
                value(type, listener, options) {
                    // TODO [#1824]: Potentially relax this restriction
                    if (!isUndefined$1(options)) {
                        logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));
                    }
                    // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-expect-error type-mismatch
                    return originalAddEventListener.apply(this, arguments);
                },
            }),
        };
    }
    // This routine will prevent access to certain properties on a shadow root instance to guarantee
    // that all components will work fine in IE11 and other browsers without shadow dom support.
    function patchShadowRootWithRestrictions(sr) {
        defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));
    }
    function patchCustomElementWithRestrictions(elm) {
        const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);
        const elmProto = getPrototypeOf$1(elm);
        setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));
    }

    function updateComponentValue(vm, key, newValue) {
        const { cmpFields } = vm;
        if (newValue !== cmpFields[key]) {
            cmpFields[key] = newValue;
            componentValueMutated(vm, key);
        }
    }

    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */
    const { isArray } = Array;
    const { prototype: ObjectDotPrototype, getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;
    const { push: ArrayPush, concat: ArrayConcat } = Array.prototype;
    const OtS = {}.toString;
    function toString(obj) {
        if (obj && obj.toString) {
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS.call(obj);
        }
        else {
            return obj + '';
        }
    }
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    const proxyToValueMap = new WeakMap();
    function registerProxy(proxy, value) {
        proxyToValueMap.set(proxy, value);
    }
    const unwrap$1 = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;

    class BaseProxyHandler {
        constructor(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        // Shared utility methods
        wrapDescriptor(descriptor) {
            if (hasOwnProperty.call(descriptor, 'value')) {
                descriptor.value = this.wrapValue(descriptor.value);
            }
            else {
                const { set: originalSet, get: originalGet } = descriptor;
                if (!isUndefined(originalGet)) {
                    descriptor.get = this.wrapGetter(originalGet);
                }
                if (!isUndefined(originalSet)) {
                    descriptor.set = this.wrapSetter(originalSet);
                }
            }
            return descriptor;
        }
        copyDescriptorIntoShadowTarget(shadowTarget, key) {
            const { originalTarget } = this;
            // Note: a property might get defined multiple times in the shadowTarget
            //       but it will always be compatible with the previous descriptor
            //       to preserve the object invariants, which makes these lines safe.
            const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
            // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed
            /* istanbul ignore else */
            if (!isUndefined(originalDescriptor)) {
                const wrappedDesc = this.wrapDescriptor(originalDescriptor);
                ObjectDefineProperty(shadowTarget, key, wrappedDesc);
            }
        }
        lockShadowTarget(shadowTarget) {
            const { originalTarget } = this;
            const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
            targetKeys.forEach((key) => {
                this.copyDescriptorIntoShadowTarget(shadowTarget, key);
            });
            const { membrane: { tagPropertyKey }, } = this;
            if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {
                ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));
            }
            preventExtensions(shadowTarget);
        }
        // Shared Traps
        // TODO: apply() is never called
        /* istanbul ignore next */
        apply(shadowTarget, thisArg, argArray) {
            /* No op */
        }
        // TODO: construct() is never called
        /* istanbul ignore next */
        construct(shadowTarget, argArray, newTarget) {
            /* No op */
        }
        get(shadowTarget, key) {
            const { originalTarget, membrane: { valueObserved }, } = this;
            const value = originalTarget[key];
            valueObserved(originalTarget, key);
            return this.wrapValue(value);
        }
        has(shadowTarget, key) {
            const { originalTarget, membrane: { tagPropertyKey, valueObserved }, } = this;
            valueObserved(originalTarget, key);
            // since key is never going to be undefined, and tagPropertyKey might be undefined
            // we can simply compare them as the second part of the condition.
            return key in originalTarget || key === tagPropertyKey;
        }
        ownKeys(shadowTarget) {
            const { originalTarget, membrane: { tagPropertyKey }, } = this;
            // if the membrane tag key exists and it is not in the original target, we add it to the keys.
            const keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey)
                ? []
                : [tagPropertyKey];
            // small perf optimization using push instead of concat to avoid creating an extra array
            ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));
            ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));
            return keys;
        }
        isExtensible(shadowTarget) {
            const { originalTarget } = this;
            // optimization to avoid attempting to lock down the shadowTarget multiple times
            if (!isExtensible(shadowTarget)) {
                return false; // was already locked down
            }
            if (!isExtensible(originalTarget)) {
                this.lockShadowTarget(shadowTarget);
                return false;
            }
            return true;
        }
        getPrototypeOf(shadowTarget) {
            const { originalTarget } = this;
            return getPrototypeOf(originalTarget);
        }
        getOwnPropertyDescriptor(shadowTarget, key) {
            const { originalTarget, membrane: { valueObserved, tagPropertyKey }, } = this;
            // keys looked up via getOwnPropertyDescriptor need to be reactive
            valueObserved(originalTarget, key);
            let desc = getOwnPropertyDescriptor(originalTarget, key);
            if (isUndefined(desc)) {
                if (key !== tagPropertyKey) {
                    return undefined;
                }
                // if the key is the membrane tag key, and is not in the original target,
                // we produce a synthetic descriptor and install it on the shadow target
                desc = { value: undefined, writable: false, configurable: false, enumerable: false };
                ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);
                return desc;
            }
            if (desc.configurable === false) {
                // updating the descriptor to non-configurable on the shadow
                this.copyDescriptorIntoShadowTarget(shadowTarget, key);
            }
            // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value, setter or getter (if available) cannot observe
            // mutations, just like regular methods, in which case we just do nothing.
            return this.wrapDescriptor(desc);
        }
    }

    const getterMap$1 = new WeakMap();
    const setterMap$1 = new WeakMap();
    const reverseGetterMap = new WeakMap();
    const reverseSetterMap = new WeakMap();
    class ReactiveProxyHandler extends BaseProxyHandler {
        wrapValue(value) {
            return this.membrane.getProxy(value);
        }
        wrapGetter(originalGet) {
            const wrappedGetter = getterMap$1.get(originalGet);
            if (!isUndefined(wrappedGetter)) {
                return wrappedGetter;
            }
            const handler = this;
            const get = function () {
                // invoking the original getter with the original target
                return handler.wrapValue(originalGet.call(unwrap$1(this)));
            };
            getterMap$1.set(originalGet, get);
            reverseGetterMap.set(get, originalGet);
            return get;
        }
        wrapSetter(originalSet) {
            const wrappedSetter = setterMap$1.get(originalSet);
            if (!isUndefined(wrappedSetter)) {
                return wrappedSetter;
            }
            const set = function (v) {
                // invoking the original setter with the original target
                originalSet.call(unwrap$1(this), unwrap$1(v));
            };
            setterMap$1.set(originalSet, set);
            reverseSetterMap.set(set, originalSet);
            return set;
        }
        unwrapDescriptor(descriptor) {
            if (hasOwnProperty.call(descriptor, 'value')) {
                // dealing with a data descriptor
                descriptor.value = unwrap$1(descriptor.value);
            }
            else {
                const { set, get } = descriptor;
                if (!isUndefined(get)) {
                    descriptor.get = this.unwrapGetter(get);
                }
                if (!isUndefined(set)) {
                    descriptor.set = this.unwrapSetter(set);
                }
            }
            return descriptor;
        }
        unwrapGetter(redGet) {
            const reverseGetter = reverseGetterMap.get(redGet);
            if (!isUndefined(reverseGetter)) {
                return reverseGetter;
            }
            const handler = this;
            const get = function () {
                // invoking the red getter with the proxy of this
                return unwrap$1(redGet.call(handler.wrapValue(this)));
            };
            getterMap$1.set(get, redGet);
            reverseGetterMap.set(redGet, get);
            return get;
        }
        unwrapSetter(redSet) {
            const reverseSetter = reverseSetterMap.get(redSet);
            if (!isUndefined(reverseSetter)) {
                return reverseSetter;
            }
            const handler = this;
            const set = function (v) {
                // invoking the red setter with the proxy of this
                redSet.call(handler.wrapValue(this), handler.wrapValue(v));
            };
            setterMap$1.set(set, redSet);
            reverseSetterMap.set(redSet, set);
            return set;
        }
        set(shadowTarget, key, value) {
            const { originalTarget, membrane: { valueMutated }, } = this;
            const oldValue = originalTarget[key];
            if (oldValue !== value) {
                originalTarget[key] = value;
                valueMutated(originalTarget, key);
            }
            else if (key === 'length' && isArray(originalTarget)) {
                // fix for issue #236: push will add the new index, and by the time length
                // is updated, the internal length is already equal to the new length value
                // therefore, the oldValue is equal to the value. This is the forking logic
                // to support this use case.
                valueMutated(originalTarget, key);
            }
            return true;
        }
        deleteProperty(shadowTarget, key) {
            const { originalTarget, membrane: { valueMutated }, } = this;
            delete originalTarget[key];
            valueMutated(originalTarget, key);
            return true;
        }
        setPrototypeOf(shadowTarget, prototype) {
            /* istanbul ignore else */
            {
                throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);
            }
        }
        preventExtensions(shadowTarget) {
            if (isExtensible(shadowTarget)) {
                const { originalTarget } = this;
                preventExtensions(originalTarget);
                // if the originalTarget is a proxy itself, it might reject
                // the preventExtension call, in which case we should not attempt to lock down
                // the shadow target.
                // TODO: It should not actually be possible to reach this `if` statement.
                // If a proxy rejects extensions, then calling preventExtensions will throw an error:
                // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY
                /* istanbul ignore if */
                if (isExtensible(originalTarget)) {
                    return false;
                }
                this.lockShadowTarget(shadowTarget);
            }
            return true;
        }
        defineProperty(shadowTarget, key, descriptor) {
            const { originalTarget, membrane: { valueMutated, tagPropertyKey }, } = this;
            if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {
                // To avoid leaking the membrane tag property into the original target, we must
                // be sure that the original target doesn't have yet.
                // NOTE: we do not return false here because Object.freeze and equivalent operations
                // will attempt to set the descriptor to the same value, and expect no to throw. This
                // is an small compromise for the sake of not having to diff the descriptors.
                return true;
            }
            ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));
            // intentionally testing if false since it could be undefined as well
            if (descriptor.configurable === false) {
                this.copyDescriptorIntoShadowTarget(shadowTarget, key);
            }
            valueMutated(originalTarget, key);
            return true;
        }
    }

    const getterMap = new WeakMap();
    const setterMap = new WeakMap();
    class ReadOnlyHandler extends BaseProxyHandler {
        wrapValue(value) {
            return this.membrane.getReadOnlyProxy(value);
        }
        wrapGetter(originalGet) {
            const wrappedGetter = getterMap.get(originalGet);
            if (!isUndefined(wrappedGetter)) {
                return wrappedGetter;
            }
            const handler = this;
            const get = function () {
                // invoking the original getter with the original target
                return handler.wrapValue(originalGet.call(unwrap$1(this)));
            };
            getterMap.set(originalGet, get);
            return get;
        }
        wrapSetter(originalSet) {
            const wrappedSetter = setterMap.get(originalSet);
            if (!isUndefined(wrappedSetter)) {
                return wrappedSetter;
            }
            const handler = this;
            const set = function (v) {
                /* istanbul ignore else */
                {
                    const { originalTarget } = handler;
                    throw new Error(`Invalid mutation: Cannot invoke a setter on "${originalTarget}". "${originalTarget}" is read-only.`);
                }
            };
            setterMap.set(originalSet, set);
            return set;
        }
        set(shadowTarget, key, value) {
            /* istanbul ignore else */
            {
                const { originalTarget } = this;
                const msg = isArray(originalTarget)
                    ? `Invalid mutation: Cannot mutate array at index ${key.toString()}. Array is read-only.`
                    : `Invalid mutation: Cannot set "${key.toString()}" on "${originalTarget}". "${originalTarget}" is read-only.`;
                throw new Error(msg);
            }
        }
        deleteProperty(shadowTarget, key) {
            /* istanbul ignore else */
            {
                const { originalTarget } = this;
                throw new Error(`Invalid mutation: Cannot delete "${key.toString()}" on "${originalTarget}". "${originalTarget}" is read-only.`);
            }
        }
        setPrototypeOf(shadowTarget, prototype) {
            /* istanbul ignore else */
            {
                const { originalTarget } = this;
                throw new Error(`Invalid prototype mutation: Cannot set prototype on "${originalTarget}". "${originalTarget}" prototype is read-only.`);
            }
        }
        preventExtensions(shadowTarget) {
            /* istanbul ignore else */
            {
                const { originalTarget } = this;
                throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}". "${originalTarget} is read-only.`);
            }
        }
        defineProperty(shadowTarget, key, descriptor) {
            /* istanbul ignore else */
            {
                const { originalTarget } = this;
                throw new Error(`Invalid mutation: Cannot defineProperty "${key.toString()}" on "${originalTarget}". "${originalTarget}" is read-only.`);
            }
        }
    }

    function extract(objectOrArray) {
        if (isArray(objectOrArray)) {
            return objectOrArray.map((item) => {
                const original = unwrap$1(item);
                if (original !== item) {
                    return extract(original);
                }
                return item;
            });
        }
        const obj = ObjectCreate(getPrototypeOf(objectOrArray));
        const names = getOwnPropertyNames(objectOrArray);
        return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce((seed, key) => {
            const item = objectOrArray[key];
            const original = unwrap$1(item);
            if (original !== item) {
                seed[key] = extract(original);
            }
            else {
                seed[key] = item;
            }
            return seed;
        }, obj);
    }
    const formatter = {
        header: (plainOrProxy) => {
            const originalTarget = unwrap$1(plainOrProxy);
            // if originalTarget is falsy or not unwrappable, exit
            if (!originalTarget || originalTarget === plainOrProxy) {
                return null;
            }
            const obj = extract(plainOrProxy);
            return ['object', { object: obj }];
        },
        hasBody: () => {
            return false;
        },
        body: () => {
            return null;
        },
    };
    // Inspired from paulmillr/es6-shim
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185
    /* istanbul ignore next */
    function getGlobal() {
        // the only reliable means to get the global object is `Function('return this')()`
        // However, this causes CSP violations in Chrome apps.
        if (typeof globalThis !== 'undefined') {
            return globalThis;
        }
        if (typeof self !== 'undefined') {
            return self;
        }
        if (typeof window !== 'undefined') {
            return window;
        }
        if (typeof global !== 'undefined') {
            return global;
        }
        // Gracefully degrade if not able to locate the global object
        return {};
    }
    function init$1() {
        const global = getGlobal();
        // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools
        //  - Go to Settings,
        //  - Under console, select "Enable custom formatters"
        // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
        const devtoolsFormatters = global.devtoolsFormatters || [];
        ArrayPush.call(devtoolsFormatters, formatter);
        global.devtoolsFormatters = devtoolsFormatters;
    }

    /* istanbul ignore else */
    {
        init$1();
    }
    function defaultValueIsObservable(value) {
        // intentionally checking for null
        if (value === null) {
            return false;
        }
        // treat all non-object types, including undefined, as non-observable values
        if (typeof value !== 'object') {
            return false;
        }
        if (isArray(value)) {
            return true;
        }
        const proto = getPrototypeOf(value);
        return proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null;
    }
    const defaultValueObserved = (obj, key) => {
        /* do nothing */
    };
    const defaultValueMutated = (obj, key) => {
        /* do nothing */
    };
    function createShadowTarget(value) {
        return isArray(value) ? [] : {};
    }
    class ObservableMembrane {
        constructor(options = {}) {
            this.readOnlyObjectGraph = new WeakMap();
            this.reactiveObjectGraph = new WeakMap();
            const { valueMutated, valueObserved, valueIsObservable, tagPropertyKey } = options;
            this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;
            this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;
            this.valueIsObservable = isFunction(valueIsObservable)
                ? valueIsObservable
                : defaultValueIsObservable;
            this.tagPropertyKey = tagPropertyKey;
        }
        getProxy(value) {
            const unwrappedValue = unwrap$1(value);
            if (this.valueIsObservable(unwrappedValue)) {
                // When trying to extract the writable version of a readonly we return the readonly.
                if (this.readOnlyObjectGraph.get(unwrappedValue) === value) {
                    return value;
                }
                return this.getReactiveHandler(unwrappedValue);
            }
            return unwrappedValue;
        }
        getReadOnlyProxy(value) {
            value = unwrap$1(value);
            if (this.valueIsObservable(value)) {
                return this.getReadOnlyHandler(value);
            }
            return value;
        }
        unwrapProxy(p) {
            return unwrap$1(p);
        }
        getReactiveHandler(value) {
            let proxy = this.reactiveObjectGraph.get(value);
            if (isUndefined(proxy)) {
                // caching the proxy after the first time it is accessed
                const handler = new ReactiveProxyHandler(this, value);
                proxy = new Proxy(createShadowTarget(value), handler);
                registerProxy(proxy, value);
                this.reactiveObjectGraph.set(value, proxy);
            }
            return proxy;
        }
        getReadOnlyHandler(value) {
            let proxy = this.readOnlyObjectGraph.get(value);
            if (isUndefined(proxy)) {
                // caching the proxy after the first time it is accessed
                const handler = new ReadOnlyHandler(this, value);
                proxy = new Proxy(createShadowTarget(value), handler);
                registerProxy(proxy, value);
                this.readOnlyObjectGraph.set(value, proxy);
            }
            return proxy;
        }
    }
    /** version: 2.0.0 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');
    const reactiveMembrane = new ObservableMembrane({
        valueObserved,
        valueMutated,
        tagPropertyKey: lockerLivePropertyKey,
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     * @param value
     */
    function unwrap(value) {
        // On the server side, we don't need mutation tracking. Skipping it improves performance.
        return reactiveMembrane.unwrapProxy(value) ;
    }
    function getReadOnlyProxy(value) {
        // We must return a frozen wrapper around the value, so that child components cannot mutate properties passed to
        // them from their parents. This applies to both the client and server.
        return reactiveMembrane.getReadOnlyProxy(value);
    }
    function getReactiveProxy(value) {
        // On the server side, we don't need mutation tracking. Skipping it improves performance.
        return reactiveMembrane.getProxy(value) ;
    }
    // Making the component instance a live value when using Locker to support expandos.
    function markLockerLiveObject(obj) {
        // On the server side, we don't need mutation tracking. Skipping it improves performance.
        {
            obj[lockerLivePropertyKey] = undefined;
        }
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let globalStylesheet;
    function isStyleElement(elm) {
        return elm.tagName === 'STYLE';
    }
    async function fetchStylesheet(elm) {
        if (isStyleElement(elm)) {
            return elm.textContent;
        }
        else {
            // <link>
            const { href } = elm;
            try {
                return await (await fetch(href)).text();
            }
            catch (err) {
                logWarnOnce(`Ignoring cross-origin stylesheet in migrate mode: ${href}`);
                // ignore errors with cross-origin stylesheets - nothing we can do for those
                return '';
            }
        }
    }
    function initGlobalStylesheet() {
        const stylesheet = new CSSStyleSheet();
        const elmsToPromises = new Map();
        let lastSeenLength = 0;
        const copyToGlobalStylesheet = () => {
            const elms = document.head.querySelectorAll('style:not([data-rendered-by-lwc]),link[rel="stylesheet"]');
            if (elms.length === lastSeenLength) {
                return; // nothing to update
            }
            lastSeenLength = elms.length;
            const promises = [...elms].map((elm) => {
                let promise = elmsToPromises.get(elm);
                if (!promise) {
                    // Cache the promise
                    promise = fetchStylesheet(elm);
                    elmsToPromises.set(elm, promise);
                }
                return promise;
            });
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            Promise.all(promises).then((stylesheetTexts) => {
                // When replaceSync() is called, the entire contents of the constructable stylesheet are replaced
                // with the copied+concatenated styles. This means that any shadow root's adoptedStyleSheets that
                // contains this constructable stylesheet will immediately get the new styles.
                stylesheet.replaceSync(stylesheetTexts.join('\n'));
            });
        };
        const headObserver = new MutationObserver(copyToGlobalStylesheet);
        // By observing only the childList, note that we are not covering the case where someone changes an `href`
        // on an existing <link>`, or the textContent on an existing `<style>`. This is assumed to be an uncommon
        // case and not worth covering.
        headObserver.observe(document.head, {
            childList: true,
        });
        copyToGlobalStylesheet();
        return stylesheet;
    }
    function applyShadowMigrateMode(shadowRoot) {
        if (!globalStylesheet) {
            globalStylesheet = initGlobalStylesheet();
        }
        shadowRoot.synthetic = true; // pretend to be synthetic mode
        shadowRoot.adoptedStyleSheets.push(globalStylesheet);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This module is responsible for producing the ComponentDef object that is always
     * accessible via `vm.def`. This is lazily created during the creation of the first
     * instance of a component class, and shared across all instances.
     *
     * This structure can be used to synthetically create proxies, and understand the
     * shape of a component. It is also used internally to apply extra optimizations.
     */
    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     * @param propName
     * @param descriptor
     */
    function createBridgeToElementDescriptor(propName, descriptor) {
        const { get, set, enumerable, configurable } = descriptor;
        if (!isFunction$1(get)) {
            throw new TypeError(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);
        }
        if (!isFunction$1(set)) {
            throw new TypeError(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);
        }
        return {
            enumerable,
            configurable,
            get() {
                const vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    {
                        logError(`The value of property \`${propName}\` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.`, vm);
                    }
                    return;
                }
                componentValueObserved(vm, propName);
                return get.call(vm.elm);
            },
            set(newValue) {
                const vm = getAssociatedVM(this);
                {
                    const vmBeingRendered = getVMBeingRendered();
                    if (isInvokingRender) {
                        logError(`${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);
                    }
                    if (isUpdatingTemplate) {
                        logError(`When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);
                    }
                    if (isBeingConstructed(vm)) {
                        logError(`Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);
                    }
                    if (isObject(newValue) && !isNull(newValue)) {
                        logError(`Invalid value "${newValue}" for "${propName}" of ${vm}. Value cannot be an object, must be a primitive value.`);
                    }
                }
                updateComponentValue(vm, propName, newValue);
                return set.call(vm.elm, newValue);
            },
        };
    }
    const refsCache = new WeakMap();
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     */
    // @ts-expect-error When exported, it will conform, but we need to build it first!
    const LightningElement = function () {
        // This should be as performant as possible, while any initialization should be done lazily
        if (isNull(vmBeingConstructed)) {
            // Thrown when doing something like `new LightningElement()` or
            // `class Foo extends LightningElement {}; new Foo()`
            throw new TypeError('Illegal constructor');
        }
        // This is a no-op unless Lightning DevTools are enabled.
        instrumentInstance(this, vmBeingConstructed);
        const vm = vmBeingConstructed;
        const { def, elm } = vm;
        const { bridge } = def;
        {
            const { assertInstanceOfHTMLElement } = vm.renderer;
            assertInstanceOfHTMLElement(vm.elm, `Component creation requires a DOM element to be associated to ${vm}.`);
        }
        setPrototypeOf(elm, bridge.prototype);
        vm.component = this;
        // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new
        // component creation and passes hooks to instrument all the component interactions with the
        // engine. We are intentionally hiding this argument from the formal API of LightningElement
        // because we don't want folks to know about it just yet.
        if (arguments.length === 1) {
            const { callHook, setHook, getHook } = arguments[0];
            vm.callHook = callHook;
            vm.setHook = setHook;
            vm.getHook = getHook;
        }
        markLockerLiveObject(this);
        // Linking elm, shadow root and component with the VM.
        associateVM(this, vm);
        associateVM(elm, vm);
        if (vm.renderMode === 1 /* RenderMode.Shadow */) {
            vm.renderRoot = doAttachShadow(vm);
        }
        else {
            vm.renderRoot = elm;
        }
        // Adding extra guard rails in DEV mode.
        {
            patchCustomElementWithRestrictions(elm);
        }
        return this;
    };
    function doAttachShadow(vm) {
        const { elm, mode, shadowMode, def: { ctor }, renderer: { attachShadow }, } = vm;
        const shadowRoot = attachShadow(elm, {
            [KEY__SYNTHETIC_MODE]: shadowMode === 1 /* ShadowMode.Synthetic */,
            delegatesFocus: Boolean(ctor.delegatesFocus),
            mode,
        });
        vm.shadowRoot = shadowRoot;
        associateVM(shadowRoot, vm);
        {
            patchShadowRootWithRestrictions(shadowRoot);
        }
        if (lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE &&
            vm.shadowMigrateMode) {
            applyShadowMigrateMode(shadowRoot);
        }
        return shadowRoot;
    }
    function warnIfInvokedDuringConstruction(vm, methodOrPropName) {
        if (isBeingConstructed(vm)) {
            logError(`this.${methodOrPropName} should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM or has no children yet.`);
        }
    }
    // Type assertion because we need to build the prototype before it satisfies the interface.
    LightningElement.prototype = {
        constructor: LightningElement,
        dispatchEvent(event) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { dispatchEvent }, } = vm;
            return dispatchEvent(elm, event);
        },
        addEventListener(type, listener, options) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { addEventListener }, } = vm;
            {
                const vmBeingRendered = getVMBeingRendered();
                if (isInvokingRender) {
                    logError(`${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for "${type}".`);
                }
                if (isUpdatingTemplate) {
                    logError(`Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for "${type}".`);
                }
                if (!isFunction$1(listener)) {
                    logError(`Invalid second argument for this.addEventListener() in ${vm} for event "${type}". Expected an EventListener but received ${listener}.`);
                }
            }
            const wrappedListener = getWrappedComponentsListener(vm, listener);
            addEventListener(elm, type, wrappedListener, options);
        },
        removeEventListener(type, listener, options) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { removeEventListener }, } = vm;
            const wrappedListener = getWrappedComponentsListener(vm, listener);
            removeEventListener(elm, type, wrappedListener, options);
        },
        hasAttribute(name) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { getAttribute }, } = vm;
            return !isNull(getAttribute(elm, name));
        },
        hasAttributeNS(namespace, name) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { getAttribute }, } = vm;
            return !isNull(getAttribute(elm, name, namespace));
        },
        removeAttribute(name) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { removeAttribute }, } = vm;
            removeAttribute(elm, name);
        },
        removeAttributeNS(namespace, name) {
            const { elm, renderer: { removeAttribute }, } = getAssociatedVM(this);
            removeAttribute(elm, name, namespace);
        },
        getAttribute(name) {
            const vm = getAssociatedVM(this);
            const { elm } = vm;
            const { getAttribute } = vm.renderer;
            return getAttribute(elm, name);
        },
        getAttributeNS(namespace, name) {
            const vm = getAssociatedVM(this);
            const { elm } = vm;
            const { getAttribute } = vm.renderer;
            return getAttribute(elm, name, namespace);
        },
        setAttribute(name, value) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { setAttribute }, } = vm;
            {
                if (isBeingConstructed(vm)) {
                    logError(`Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);
                }
            }
            setAttribute(elm, name, value);
        },
        setAttributeNS(namespace, name, value) {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { setAttribute }, } = vm;
            {
                if (isBeingConstructed(vm)) {
                    logError(`Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);
                }
            }
            setAttribute(elm, name, value, namespace);
        },
        getBoundingClientRect() {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { getBoundingClientRect }, } = vm;
            {
                warnIfInvokedDuringConstruction(vm, 'getBoundingClientRect()');
            }
            return getBoundingClientRect(elm);
        },
        attachInternals() {
            const vm = getAssociatedVM(this);
            const { elm, apiVersion, renderer: { attachInternals }, } = vm;
            if (!isAPIFeatureEnabled(8 /* APIFeature.ENABLE_ELEMENT_INTERNALS_AND_FACE */, apiVersion)) {
                throw new Error(`The attachInternals API is only supported in API version 61 and above. ` +
                    `The current version is ${apiVersion}. ` +
                    `To use this API, update the LWC component API version. https://lwc.dev/guide/versioning`);
            }
            if (vm.shadowMode === 1 /* ShadowMode.Synthetic */) {
                throw new Error('attachInternals API is not supported in synthetic shadow.');
            }
            return attachInternals(elm);
        },
        get isConnected() {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { isConnected }, } = vm;
            return isConnected(elm);
        },
        get classList() {
            const vm = getAssociatedVM(this);
            const { elm, renderer: { getClassList }, } = vm;
            {
                if (isBeingConstructed(vm)) {
                    logError(`Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);
                }
            }
            return getClassList(elm);
        },
        get template() {
            const vm = getAssociatedVM(this);
            {
                if (vm.renderMode === 0 /* RenderMode.Light */) {
                    logError('`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`.');
                }
            }
            return vm.shadowRoot;
        },
        get refs() {
            const vm = getAssociatedVM(this);
            if (isUpdatingTemplate) {
                {
                    logError(`this.refs should not be called while ${getComponentTag(vm)} is rendering. Use this.refs only when the DOM is stable, e.g. in renderedCallback().`);
                }
                // If the template is in the process of being updated, then we don't want to go through the normal
                // process of returning the refs and caching them, because the state of the refs is unstable.
                // This can happen if e.g. a template contains `<div class={foo}></div>` and `foo` is computed
                // based on `this.refs.bar`.
                return;
            }
            {
                warnIfInvokedDuringConstruction(vm, 'refs');
            }
            const { refVNodes, cmpTemplate } = vm;
            // If the `cmpTemplate` is null, that means that the template has not been rendered yet. Most likely this occurs
            // if `this.refs` is called during the `connectedCallback` phase. The DOM elements have not been rendered yet,
            // so log a warning. Note we also check `isBeingConstructed()` to avoid a double warning (due to
            // `warnIfInvokedDuringConstruction` above).
            if (isNull(cmpTemplate) &&
                !isBeingConstructed(vm)) {
                logError(`this.refs is undefined for ${getComponentTag(vm)}. This is either because the attached template has no "lwc:ref" directive, or this.refs was ` +
                    `invoked before renderedCallback(). Use this.refs only when the referenced HTML elements have ` +
                    `been rendered to the DOM, such as within renderedCallback() or disconnectedCallback().`);
            }
            // For backwards compatibility with component written before template refs
            // were introduced, we return undefined if the template has no refs defined
            // anywhere. This fixes components that may want to add an expando called `refs`
            // and are checking if it exists with `if (this.refs)`  before adding it.
            // Note we use a null refVNodes to indicate that the template has no refs defined.
            if (isNull(refVNodes)) {
                return;
            }
            // The refNodes can be cached based on the refVNodes, since the refVNodes
            // are recreated from scratch every time the template is rendered.
            // This happens with `vm.refVNodes = null` in `template.ts` in `@lwc/engine-core`.
            let refs = refsCache.get(refVNodes);
            if (isUndefined$1(refs)) {
                refs = create(null);
                for (const key of keys(refVNodes)) {
                    refs[key] = refVNodes[key].elm;
                }
                freeze(refs);
                refsCache.set(refVNodes, refs);
            }
            return refs;
        },
        // For backwards compat, we allow component authors to set `refs` as an expando
        set refs(value) {
            defineProperty(this, 'refs', {
                configurable: true,
                enumerable: true,
                writable: true,
                value,
            });
        },
        get shadowRoot() {
            // From within the component instance, the shadowRoot is always reported as "closed".
            // Authors should rely on this.template instead.
            return null;
        },
        get children() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'children');
            }
            return renderer.getChildren(vm.elm);
        },
        get childNodes() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'childNodes');
            }
            // getChildNodes returns a NodeList, which has `item(index: number): Node | null`.
            // NodeListOf<T> extends NodeList, but claims to not return null. That seems inaccurate,
            // but these are built-in types, so ultimately not our problem.
            return renderer.getChildNodes(vm.elm);
        },
        get firstChild() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'firstChild');
            }
            return renderer.getFirstChild(vm.elm);
        },
        get firstElementChild() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'firstElementChild');
            }
            return renderer.getFirstElementChild(vm.elm);
        },
        get lastChild() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'lastChild');
            }
            return renderer.getLastChild(vm.elm);
        },
        get lastElementChild() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'lastElementChild');
            }
            return renderer.getLastElementChild(vm.elm);
        },
        get ownerDocument() {
            const vm = getAssociatedVM(this);
            const renderer = vm.renderer;
            {
                warnIfInvokedDuringConstruction(vm, 'ownerDocument');
            }
            return renderer.ownerDocument(vm.elm);
        },
        get tagName() {
            const { elm, renderer } = getAssociatedVM(this);
            return renderer.getTagName(elm);
        },
        render() {
            const vm = getAssociatedVM(this);
            return vm.def.template;
        },
        toString() {
            const vm = getAssociatedVM(this);
            return `[object ${vm.def.name}]`;
        },
    };
    const queryAndChildGetterDescriptors = create(null);
    const queryMethods = [
        'getElementsByClassName',
        'getElementsByTagName',
        'querySelector',
        'querySelectorAll',
    ];
    // Generic passthrough for query APIs on HTMLElement to the relevant Renderer APIs
    for (const queryMethod of queryMethods) {
        queryAndChildGetterDescriptors[queryMethod] = {
            value(arg) {
                const vm = getAssociatedVM(this);
                const { elm, renderer } = vm;
                {
                    warnIfInvokedDuringConstruction(vm, `${queryMethod}()`);
                }
                return renderer[queryMethod](elm, arg);
            },
            configurable: true,
            enumerable: true,
            writable: true,
        };
    }
    defineProperties(LightningElement.prototype, queryAndChildGetterDescriptors);
    const lightningBasedDescriptors = create(null);
    for (const propName in HTMLElementOriginalDescriptors) {
        lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
    }
    // Apply ARIA reflection to LightningElement.prototype, on both the browser and server.
    // This allows `this.aria*` property accessors to work from inside a component, and to reflect `aria-*` attrs.
    // Note this works regardless of whether the global ARIA reflection polyfill is applied or not.
    {
        // In the browser, we use createBridgeToElementDescriptor, so we can get the normal reactivity lifecycle for
        // aria* properties
        for (const [propName, descriptor] of entries(ariaReflectionPolyfillDescriptors)) {
            lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, descriptor);
        }
    }
    defineProperties(LightningElement.prototype, lightningBasedDescriptors);
    defineProperty(LightningElement, 'CustomElementConstructor', {
        get() {
            // If required, a runtime-specific implementation must be defined.
            throw new ReferenceError('The current runtime does not support CustomElementConstructor.');
        },
        configurable: true,
    });

    function createObservedFieldPropertyDescriptor(key) {
        return {
            get() {
                const vm = getAssociatedVM(this);
                const val = vm.cmpFields[key];
                componentValueObserved(vm, key, val);
                return val;
            },
            set(newValue) {
                const vm = getAssociatedVM(this);
                updateComponentValue(vm, key, newValue);
            },
            enumerable: true,
            configurable: true,
        };
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const AdapterToTokenMap = new Map();
    function createContextProviderWithRegister(adapter, registerContextProvider) {
        if (AdapterToTokenMap.has(adapter)) {
            throw new Error(`Adapter already has a context provider.`);
        }
        const adapterContextToken = guid();
        AdapterToTokenMap.set(adapter, adapterContextToken);
        const providers = new WeakSet();
        return (elmOrComponent, options) => {
            if (providers.has(elmOrComponent)) {
                throw new Error(`Adapter was already installed on ${elmOrComponent}.`);
            }
            providers.add(elmOrComponent);
            const { consumerConnectedCallback, consumerDisconnectedCallback } = options;
            registerContextProvider(elmOrComponent, adapterContextToken, (subscriptionPayload) => {
                const { setNewContext, setDisconnectedCallback } = subscriptionPayload;
                const consumer = {
                    provide(newContext) {
                        setNewContext(newContext);
                    },
                };
                const disconnectCallback = () => {
                    if (!isUndefined$1(consumerDisconnectedCallback)) {
                        consumerDisconnectedCallback(consumer);
                    }
                };
                setDisconnectedCallback(disconnectCallback);
                consumerConnectedCallback(consumer);
            });
        };
    }
    function createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {
        const { adapter } = wireDef;
        const adapterContextToken = AdapterToTokenMap.get(adapter);
        if (isUndefined$1(adapterContextToken)) {
            return; // no provider found, nothing to be done
        }
        const { elm, context: { wiredConnecting, wiredDisconnecting }, renderer: { registerContextConsumer }, } = vm;
        // waiting for the component to be connected to formally request the context via the token
        ArrayPush$1.call(wiredConnecting, () => {
            // This will attempt to connect the current element with one of its anscestors
            // that can provide context for the given wire adapter. This relationship is
            // keyed on the secret & internal value of `adapterContextToken`, which is unique
            // to a given wire adapter.
            //
            // Depending on the runtime environment, this connection is made using either DOM
            // events (in the browser) or a custom traversal (on the server).
            registerContextConsumer(elm, adapterContextToken, {
                setNewContext(newContext) {
                    // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo
                    // TODO: dev-mode validation of config based on the adapter.contextSchema
                    callbackWhenContextIsReady(newContext);
                },
                setDisconnectedCallback(disconnectCallback) {
                    // adds this callback into the disconnect bucket so it gets disconnected from parent
                    // the the element hosting the wire is disconnected
                    ArrayPush$1.call(wiredDisconnecting, disconnectCallback);
                },
            });
        });
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    const DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
    const WIRE_DEBUG_ENTRY = '@wire';
    const WireMetaMap = new Map();
    function createFieldDataCallback(vm, name) {
        return (value) => {
            updateComponentValue(vm, name, value);
        };
    }
    function createMethodDataCallback(vm, method) {
        return (value) => {
            // dispatching new value into the wired method
            runWithBoundaryProtection(vm, vm.owner, noop, () => {
                // job
                method.call(vm.component, value);
            }, noop);
        };
    }
    function createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {
        let hasPendingConfig = false;
        // creating the reactive observer for reactive params when needed
        const ro = createReactiveObserver(() => {
            if (hasPendingConfig === false) {
                hasPendingConfig = true;
                // collect new config in the micro-task
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                Promise.resolve().then(() => {
                    hasPendingConfig = false;
                    // resetting current reactive params
                    ro.reset();
                    // dispatching a new config due to a change in the configuration
                    computeConfigAndUpdate();
                });
            }
        });
        const computeConfigAndUpdate = () => {
            let config;
            ro.observe(() => (config = configCallback(component)));
            // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo
            // TODO: dev-mode validation of config based on the adapter.configSchema
            // @ts-expect-error it is assigned in the observe() callback
            callbackWhenConfigIsReady(config);
        };
        return {
            computeConfigAndUpdate,
            ro,
        };
    }
    function createConnector(vm, name, wireDef) {
        const { method, adapter, configCallback, dynamic } = wireDef;
        let debugInfo;
        {
            const wiredPropOrMethod = isUndefined$1(method) ? name : method.name;
            debugInfo = create(null);
            debugInfo.wasDataProvisionedForConfig = false;
            vm.debugInfo[WIRE_DEBUG_ENTRY][wiredPropOrMethod] = debugInfo;
        }
        const fieldOrMethodCallback = isUndefined$1(method)
            ? createFieldDataCallback(vm, name)
            : createMethodDataCallback(vm, method);
        const dataCallback = (value) => {
            {
                debugInfo.data = value;
                // Note: most of the time, the data provided is for the current config, but there may be
                // some conditions in which it does not, ex:
                // race conditions in a poor network while the adapter does not cancel a previous request.
                debugInfo.wasDataProvisionedForConfig = true;
            }
            fieldOrMethodCallback(value);
        };
        let context;
        let connector;
        // Workaround to pass the component element associated to this wire adapter instance.
        defineProperty(dataCallback, DeprecatedWiredElementHost, {
            value: vm.elm,
        });
        defineProperty(dataCallback, DeprecatedWiredParamsMeta, {
            value: dynamic,
        });
        runWithBoundaryProtection(vm, vm, noop, () => {
            // job
            connector = new adapter(dataCallback, { tagName: vm.tagName });
        }, noop);
        const updateConnectorConfig = (config) => {
            // every time the config is recomputed due to tracking,
            // this callback will be invoked with the new computed config
            runWithBoundaryProtection(vm, vm, noop, () => {
                // job
                if ("development" !== 'production') {
                    debugInfo.config = config;
                    debugInfo.context = context;
                    debugInfo.wasDataProvisionedForConfig = false;
                }
                connector.update(config, context);
            }, noop);
        };
        // Computes the current wire config and calls the update method on the wire adapter.
        // If it has params, we will need to observe changes in the next tick.
        const { computeConfigAndUpdate, ro } = createConfigWatcher(vm.component, configCallback, updateConnectorConfig);
        // if the adapter needs contextualization, we need to watch for new context and push it alongside the config
        if (!isUndefined$1(adapter.contextSchema)) {
            createContextWatcher(vm, wireDef, (newContext) => {
                // every time the context is pushed into this component,
                // this callback will be invoked with the new computed context
                if (context !== newContext) {
                    context = newContext;
                    // Note: when new context arrives, the config will be recomputed and pushed along side the new
                    // context, this is to preserve the identity characteristics, config should not have identity
                    // (ever), while context can have identity
                    if (vm.state === 1 /* VMState.connected */) {
                        computeConfigAndUpdate();
                    }
                }
            });
        }
        return {
            // @ts-expect-error the boundary protection executes sync, connector is always defined
            connector,
            computeConfigAndUpdate,
            resetConfigWatcher: () => ro.reset(),
        };
    }
    function storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        const method = descriptor.value;
        const def = {
            adapter,
            method,
            configCallback,
            dynamic,
        };
        WireMetaMap.set(descriptor, def);
    }
    function storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        const def = {
            adapter,
            configCallback,
            dynamic,
        };
        WireMetaMap.set(descriptor, def);
    }
    function installWireAdapters(vm) {
        const { context, def: { wire }, } = vm;
        {
            vm.debugInfo[WIRE_DEBUG_ENTRY] = create(null);
        }
        const wiredConnecting = (context.wiredConnecting = []);
        const wiredDisconnecting = (context.wiredDisconnecting = []);
        for (const fieldNameOrMethod in wire) {
            const descriptor = wire[fieldNameOrMethod];
            const wireDef = WireMetaMap.get(descriptor);
            {
                assert.invariant(wireDef, `Internal Error: invalid wire definition found.`);
            }
            if (!isUndefined$1(wireDef)) {
                const { connector, computeConfigAndUpdate, resetConfigWatcher } = createConnector(vm, fieldNameOrMethod, wireDef);
                const hasDynamicParams = wireDef.dynamic.length > 0;
                ArrayPush$1.call(wiredConnecting, () => {
                    connector.connect();
                    {
                        if (hasDynamicParams) {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            Promise.resolve().then(computeConfigAndUpdate);
                            return;
                        }
                    }
                    computeConfigAndUpdate();
                });
                ArrayPush$1.call(wiredDisconnecting, () => {
                    connector.disconnect();
                    resetConfigWatcher();
                });
            }
        }
    }
    function connectWireAdapters(vm) {
        const { wiredConnecting } = vm.context;
        for (let i = 0, len = wiredConnecting.length; i < len; i += 1) {
            wiredConnecting[i]();
        }
    }
    function disconnectWireAdapters(vm) {
        const { wiredDisconnecting } = vm.context;
        runWithBoundaryProtection(vm, vm, noop, () => {
            // job
            for (let i = 0, len = wiredDisconnecting.length; i < len; i += 1) {
                wiredDisconnecting[i]();
            }
        }, noop);
    }
    function createPublicPropertyDescriptor(key) {
        return {
            get() {
                const vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    {
                        logError(`Cant read the value of property \`${toString$1(key)}\` from the constructor because the owner component hasnt set the value yet. Instead, use the constructor to set a default value for the property.`, vm);
                    }
                    return;
                }
                const val = vm.cmpProps[key];
                componentValueObserved(vm, key, val);
                return val;
            },
            set(newValue) {
                const vm = getAssociatedVM(this);
                {
                    const vmBeingRendered = getVMBeingRendered();
                    if (isInvokingRender) {
                        logError(`render() method has side effects on the state of property "${toString$1(key)}"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);
                    }
                    if (isUpdatingTemplate) {
                        logError(`Updating the template has side effects on the state of property "${toString$1(key)}"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);
                    }
                }
                vm.cmpProps[key] = newValue;
                componentValueMutated(vm, key);
            },
            enumerable: true,
            configurable: true,
        };
    }
    function createPublicAccessorDescriptor(key, descriptor) {
        const { get, set, enumerable, configurable } = descriptor;
        assert.invariant(isFunction$1(get), `Invalid public accessor ${toString$1(key)} decorated with @api. The property is missing a getter.`);
        return {
            get() {
                {
                    // Assert that the this value is an actual Component with an associated VM.
                    getAssociatedVM(this);
                }
                return get.call(this);
            },
            set(newValue) {
                const vm = getAssociatedVM(this);
                {
                    const vmBeingRendered = getVMBeingRendered();
                    if (isInvokingRender) {
                        logError(`render() method has side effects on the state of property "${toString$1(key)}"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);
                    }
                    if (isUpdatingTemplate) {
                        logError(`Updating the template has side effects on the state of property "${toString$1(key)}"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);
                    }
                }
                if (set) {
                    set.call(this, newValue);
                }
                else {
                    logError(`Invalid attempt to set a new value for property "${toString$1(key)}" that does not has a setter decorated with @api.`, vm);
                }
            },
            enumerable,
            configurable,
        };
    }
    function internalTrackDecorator(key) {
        return {
            get() {
                const vm = getAssociatedVM(this);
                const val = vm.cmpFields[key];
                componentValueObserved(vm, key, val);
                return val;
            },
            set(newValue) {
                const vm = getAssociatedVM(this);
                {
                    const vmBeingRendered = getVMBeingRendered();
                    if (isInvokingRender) {
                        logError(`${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);
                    }
                    if (isUpdatingTemplate) {
                        logError(`Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);
                    }
                }
                const reactiveOrAnyValue = getReactiveProxy(newValue);
                updateComponentValue(vm, key, reactiveOrAnyValue);
            },
            enumerable: true,
            configurable: true,
        };
    }
    function internalWireFieldDecorator(key) {
        return {
            get() {
                const vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set(value) {
                const vm = getAssociatedVM(this);
                /**
                 * Reactivity for wired fields is provided in wiring.
                 * We intentionally add reactivity here since this is just
                 * letting the author to do the wrong thing, but it will keep our
                 * system to be backward compatible.
                 */
                updateComponentValue(vm, key, value);
            },
            enumerable: true,
            configurable: true,
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getClassDescriptorType(descriptor) {
        if (isFunction$1(descriptor.value)) {
            return "method" /* DescriptorType.Method */;
        }
        else if (isFunction$1(descriptor.set) || isFunction$1(descriptor.get)) {
            return "accessor" /* DescriptorType.Accessor */;
        }
        else {
            return "field" /* DescriptorType.Field */;
        }
    }
    function validateObservedField(Ctor, fieldName, descriptor) {
        if (!isUndefined$1(descriptor)) {
            const type = getClassDescriptorType(descriptor);
            const message = `Invalid observed ${fieldName} field. Found a duplicate ${type} with the same name.`;
            // TODO [#3408]: this should throw, not log
            logError(message);
        }
    }
    function validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {
        if (!isUndefined$1(descriptor)) {
            const type = getClassDescriptorType(descriptor);
            // TODO [#3408]: this should throw, not log
            logError(`Invalid @track ${fieldName} field. Found a duplicate ${type} with the same name.`);
        }
    }
    function validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {
        if (!isUndefined$1(descriptor)) {
            const type = getClassDescriptorType(descriptor);
            // TODO [#3408]: this should throw, not log
            logError(`Invalid @wire ${fieldName} field. Found a duplicate ${type} with the same name.`);
        }
    }
    function validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {
        if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {
            // TODO [#3441]: This line of code does not seem possible to reach.
            logError(`Invalid @wire ${methodName} field. The field should have a valid writable descriptor.`);
        }
    }
    function validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {
        if (!isUndefined$1(descriptor)) {
            const type = getClassDescriptorType(descriptor);
            const message = `Invalid @api ${fieldName} field. Found a duplicate ${type} with the same name.`;
            // TODO [#3408]: this should throw, not log
            logError(message);
        }
    }
    function validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {
        if (isFunction$1(descriptor.set)) {
            if (!isFunction$1(descriptor.get)) {
                // TODO [#3441]: This line of code does not seem possible to reach.
                logError(`Missing getter for property ${fieldName} decorated with @api in ${Ctor}. You cannot have a setter without the corresponding getter.`);
            }
        }
        else if (!isFunction$1(descriptor.get)) {
            // TODO [#3441]: This line of code does not seem possible to reach.
            logError(`Missing @api get ${fieldName} accessor.`);
        }
    }
    function validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {
        if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {
            // TODO [#3441]: This line of code does not seem possible to reach.
            logError(`Invalid @api ${methodName} method.`);
        }
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by user-land code.
     * @param Ctor
     * @param meta
     */
    function registerDecorators(Ctor, meta) {
        const proto = Ctor.prototype;
        const { publicProps, publicMethods, wire, track, fields } = meta;
        const apiMethods = create(null);
        const apiFields = create(null);
        const wiredMethods = create(null);
        const wiredFields = create(null);
        const observedFields = create(null);
        const apiFieldsConfig = create(null);
        let descriptor;
        if (!isUndefined$1(publicProps)) {
            for (const fieldName in publicProps) {
                const propConfig = publicProps[fieldName];
                apiFieldsConfig[fieldName] = propConfig.config;
                descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
                if (propConfig.config > 0) {
                    if (isUndefined$1(descriptor)) {
                        // TODO [#3441]: This line of code does not seem possible to reach.
                        throw new Error();
                    }
                    // accessor declaration
                    {
                        validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);
                    }
                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
                }
                else {
                    // field declaration
                    {
                        validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);
                    }
                    // [W-9927596] If a component has both a public property and a private setter/getter
                    // with the same name, the property is defined as a public accessor. This branch is
                    // only here for backward compatibility reasons.
                    if (!isUndefined$1(descriptor) && !isUndefined$1(descriptor.get)) {
                        descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
                    }
                    else {
                        descriptor = createPublicPropertyDescriptor(fieldName);
                    }
                }
                apiFields[fieldName] = descriptor;
                defineProperty(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined$1(publicMethods)) {
            forEach.call(publicMethods, (methodName) => {
                descriptor = getOwnPropertyDescriptor$1(proto, methodName);
                {
                    validateMethodDecoratedWithApi(Ctor, methodName, descriptor);
                }
                if (isUndefined$1(descriptor)) {
                    throw new Error();
                }
                apiMethods[methodName] = descriptor;
            });
        }
        if (!isUndefined$1(wire)) {
            for (const fieldOrMethodName in wire) {
                const { adapter, method, config: configCallback, dynamic = [], } = wire[fieldOrMethodName];
                descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);
                if (method === 1) {
                    {
                        if (!adapter) {
                            // TODO [#3408]: this should throw, not log
                            logError(`@wire on method "${fieldOrMethodName}": adapter id must be truthy.`);
                        }
                        validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
                    }
                    if (isUndefined$1(descriptor)) {
                        throw new Error();
                    }
                    wiredMethods[fieldOrMethodName] = descriptor;
                    storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);
                }
                else {
                    {
                        if (!adapter) {
                            // TODO [#3408]: this should throw, not log
                            logError(`@wire on field "${fieldOrMethodName}": adapter id must be truthy.`);
                        }
                        validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
                    }
                    descriptor = internalWireFieldDecorator(fieldOrMethodName);
                    wiredFields[fieldOrMethodName] = descriptor;
                    storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);
                    defineProperty(proto, fieldOrMethodName, descriptor);
                }
            }
        }
        if (!isUndefined$1(track)) {
            for (const fieldName in track) {
                descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
                {
                    validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);
                }
                descriptor = internalTrackDecorator(fieldName);
                defineProperty(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined$1(fields)) {
            for (let i = 0, n = fields.length; i < n; i++) {
                const fieldName = fields[i];
                descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
                {
                    validateObservedField(Ctor, fieldName, descriptor);
                }
                // [W-9927596] Only mark a field as observed whenever it isn't a duplicated public nor
                // tracked property. This is only here for backward compatibility purposes.
                const isDuplicatePublicProp = !isUndefined$1(publicProps) && fieldName in publicProps;
                const isDuplicateTrackedProp = !isUndefined$1(track) && fieldName in track;
                if (!isDuplicatePublicProp && !isDuplicateTrackedProp) {
                    observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);
                }
            }
        }
        setDecoratorsMeta(Ctor, {
            apiMethods,
            apiFields,
            apiFieldsConfig,
            wiredMethods,
            wiredFields,
            observedFields,
        });
        return Ctor;
    }
    const signedDecoratorToMetaMap = new Map();
    function setDecoratorsMeta(Ctor, meta) {
        signedDecoratorToMetaMap.set(Ctor, meta);
    }
    const defaultMeta = {
        apiMethods: EmptyObject,
        apiFields: EmptyObject,
        apiFieldsConfig: EmptyObject,
        wiredMethods: EmptyObject,
        wiredFields: EmptyObject,
        observedFields: EmptyObject,
    };
    function getDecoratorsMeta(Ctor) {
        const meta = signedDecoratorToMetaMap.get(Ctor);
        return isUndefined$1(meta) ? defaultMeta : meta;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let warned = false;
    function checkVersionMismatch(func, type) {
        const versionMatcher = func.toString().match(LWC_VERSION_COMMENT_REGEX);
        if (!isNull(versionMatcher) && !warned) {
            const version = versionMatcher[1];
            const [major, minor] = version.split('.');
            const [expectedMajor, expectedMinor] = LWC_VERSION.split('.');
            if (major !== expectedMajor || minor !== expectedMinor) {
                warned = true; // only warn once to avoid flooding the console
                // stylesheets and templates do not have user-meaningful names, but components do
                const friendlyName = type === 'component' ? `${type} ${func.name}` : type;
                logError(`LWC WARNING: current engine is v${LWC_VERSION}, but ${friendlyName} was compiled with v${version}.\nPlease update your compiled code or LWC engine so that the versions match.\nNo further warnings will appear.`);
                report("CompilerRuntimeVersionMismatch" /* ReportingEventId.CompilerRuntimeVersionMismatch */, {
                    compilerVersion: version,
                    runtimeVersion: LWC_VERSION,
                });
            }
        }
    }

    const signedTemplateSet = new Set();
    function defaultEmptyTemplate() {
        return [];
    }
    signedTemplateSet.add(defaultEmptyTemplate);
    function isTemplateRegistered(tpl) {
        return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     * @param tpl
     */
    function registerTemplate(tpl) {
        {
            checkVersionMismatch(tpl, 'template');
        }
        signedTemplateSet.add(tpl);
        // chaining this method as a way to wrap existing
        // assignment of templates easily, without too much transformation
        return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar
     * libraries to sanitize vulnerable attributes.
     * @param tagName
     * @param namespaceUri
     * @param attrName
     * @param attrValue
     */
    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
        // locker-service patches this function during runtime to sanitize vulnerable attributes. When
        // ran off-core this function becomes a noop and returns the user authored value.
        return attrValue;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This module is responsible for creating the base bridge class BaseBridgeElement
     * that represents the HTMLElement extension used for any LWC inserted in the DOM.
     */
    // A bridge descriptor is a descriptor whose job is just to get the component instance
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:
    const cachedGetterByKey = create(null);
    const cachedSetterByKey = create(null);
    function createGetter(key) {
        let fn = cachedGetterByKey[key];
        if (isUndefined$1(fn)) {
            fn = cachedGetterByKey[key] = function () {
                const vm = getAssociatedVM(this);
                const { getHook } = vm;
                return getHook(vm.component, key);
            };
        }
        return fn;
    }
    function createSetter(key) {
        let fn = cachedSetterByKey[key];
        if (isUndefined$1(fn)) {
            fn = cachedSetterByKey[key] = function (newValue) {
                const vm = getAssociatedVM(this);
                const { setHook } = vm;
                newValue = getReadOnlyProxy(newValue);
                setHook(vm.component, key, newValue);
            };
        }
        return fn;
    }
    function createMethodCaller(methodName) {
        return function () {
            const vm = getAssociatedVM(this);
            const { callHook, component } = vm;
            const fn = component[methodName];
            return callHook(vm.component, fn, ArraySlice.call(arguments));
        };
    }
    function createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {
        return function attributeChangedCallback(attrName, oldValue, newValue) {
            if (oldValue === newValue) {
                // Ignore same values.
                return;
            }
            const propName = attributeToPropMap[attrName];
            if (isUndefined$1(propName)) {
                if (!isUndefined$1(superAttributeChangedCallback)) {
                    // delegate unknown attributes to the super.
                    // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-expect-error type-mismatch
                    superAttributeChangedCallback.apply(this, arguments);
                }
                return;
            }
            // Reflect attribute change to the corresponding property when changed from outside.
            this[propName] = newValue;
        };
    }
    function createAccessorThatWarns(propName) {
        let prop;
        return {
            get() {
                logWarn(`The property "${propName}" is not publicly accessible. Add the @api annotation to the property declaration or getter/setter in the component to make it accessible.`);
                return prop;
            },
            set(value) {
                logWarn(`The property "${propName}" is not publicly accessible. Add the @api annotation to the property declaration or getter/setter in the component to make it accessible.`);
                prop = value;
            },
            enumerable: true,
            configurable: true,
        };
    }
    function HTMLBridgeElementFactory(SuperClass, publicProperties, methods, observedFields, proto, hasCustomSuperClass) {
        const HTMLBridgeElement = class extends SuperClass {
        };
        // generating the hash table for attributes to avoid duplicate fields and facilitate validation
        // and false positives in case of inheritance.
        const attributeToPropMap = create(null);
        const { attributeChangedCallback: superAttributeChangedCallback } = SuperClass.prototype;
        const { observedAttributes: superObservedAttributes = [] } = SuperClass;
        const descriptors = create(null);
        // present a hint message so that developers are aware that they have not decorated property with @api
        {
            // TODO [#3761]: enable for components that don't extend from LightningElement
            if (!isUndefined$1(proto) && !isNull(proto) && !hasCustomSuperClass) {
                const nonPublicPropertiesToWarnOn = new Set([
                    // getters, setters, and methods
                    ...keys(getOwnPropertyDescriptors(proto)),
                    // class properties
                    ...observedFields,
                ]
                    // we don't want to override HTMLElement props because these are meaningful in other ways,
                    // and can break tooling that expects it to be iterable or defined, e.g. Jest:
                    // https://github.com/jestjs/jest/blob/b4c9587/packages/pretty-format/src/plugins/DOMElement.ts#L95
                    // It also doesn't make sense to override e.g. "constructor".
                    .filter((propName) => !(propName in HTMLElementPrototype) &&
                    !(propName in ariaReflectionPolyfillDescriptors)));
                for (const propName of nonPublicPropertiesToWarnOn) {
                    if (ArrayIndexOf.call(publicProperties, propName) === -1) {
                        descriptors[propName] = createAccessorThatWarns(propName);
                    }
                }
            }
        }
        // expose getters and setters for each public props on the new Element Bridge
        for (let i = 0, len = publicProperties.length; i < len; i += 1) {
            const propName = publicProperties[i];
            attributeToPropMap[htmlPropertyToAttribute(propName)] = propName;
            descriptors[propName] = {
                get: createGetter(propName),
                set: createSetter(propName),
                enumerable: true,
                configurable: true,
            };
        }
        // expose public methods as props on the new Element Bridge
        for (let i = 0, len = methods.length; i < len; i += 1) {
            const methodName = methods[i];
            descriptors[methodName] = {
                value: createMethodCaller(methodName),
                writable: true,
                configurable: true,
            };
        }
        // creating a new attributeChangedCallback per bridge because they are bound to the corresponding
        // map of attributes to props. We do this after all other props and methods to avoid the possibility
        // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable
        // to preserve this definition.
        descriptors.attributeChangedCallback = {
            value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback),
        };
        // To avoid leaking private component details, accessing internals from outside a component is not allowed.
        descriptors.attachInternals = {
            set() {
                {
                    logWarn('attachInternals cannot be accessed outside of a component. Use this.attachInternals instead.');
                }
            },
            get() {
                {
                    logWarn('attachInternals cannot be accessed outside of a component. Use this.attachInternals instead.');
                }
            },
        };
        descriptors.formAssociated = {
            set() {
                {
                    logWarn('formAssociated cannot be accessed outside of a component. Set the value within the component class.');
                }
            },
            get() {
                {
                    logWarn('formAssociated cannot be accessed outside of a component. Set the value within the component class.');
                }
            },
        };
        // Specify attributes for which we want to reflect changes back to their corresponding
        // properties via attributeChangedCallback.
        defineProperty(HTMLBridgeElement, 'observedAttributes', {
            get() {
                return [...superObservedAttributes, ...keys(attributeToPropMap)];
            },
        });
        defineProperties(HTMLBridgeElement.prototype, descriptors);
        return HTMLBridgeElement;
    }
    // We do some special handling of non-standard ARIA props like ariaLabelledBy as well as props without (as of this
    // writing) broad cross-browser support like ariaBrailleLabel. This is so the reflection works correctly and preserves
    // backwards compatibility with the previous global polyfill approach.
    //
    // The goal here is to expose `elm.aria*` property accessors to work from outside a component, and to reflect `aria-*`
    // attrs. This is especially important because the template compiler compiles aria-* attrs on components to aria* props.
    // Note this works regardless of whether the global ARIA reflection polyfill is applied or not.
    //
    // Also note this ARIA reflection only really makes sense in the browser. On the server, there is no
    // `renderedCallback()`, so you cannot do e.g. `this.template.querySelector('x-child').ariaBusy = 'true'`. So we don't
    // need to expose ARIA props outside the LightningElement
    const basePublicProperties = [
        ...getOwnPropertyNames$1(HTMLElementOriginalDescriptors),
        ...(getOwnPropertyNames$1(ariaReflectionPolyfillDescriptors) ),
    ];
    const BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, basePublicProperties, [], [], null, false);
    freeze(BaseBridgeElement);
    seal(BaseBridgeElement.prototype);

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const supportsWeakRefs = typeof WeakRef === 'function' && typeof FinalizationRegistry === 'function';
    // In browsers that doesn't support WeakRefs, the values will still leak, but at least the keys won't
    class LegacyWeakMultiMap {
        constructor() {
            this._map = new WeakMap();
        }
        _getValues(key) {
            let values = this._map.get(key);
            if (isUndefined$1(values)) {
                values = new Set();
                this._map.set(key, values);
            }
            return values;
        }
        get(key) {
            return this._getValues(key);
        }
        add(key, vm) {
            const set = this._getValues(key);
            set.add(vm);
        }
        delete(key) {
            this._map.delete(key);
        }
    }
    // This implementation relies on the WeakRef/FinalizationRegistry proposal.
    // For some background, see: https://github.com/tc39/proposal-weakrefs
    class ModernWeakMultiMap {
        constructor() {
            this._map = new WeakMap();
            this._registry = new FinalizationRegistry((weakRefs) => {
                // This should be considered an optional cleanup method to remove GC'ed values from their respective arrays.
                // JS VMs are not obligated to call FinalizationRegistry callbacks.
                // Work backwards, removing stale VMs
                for (let i = weakRefs.length - 1; i >= 0; i--) {
                    const vm = weakRefs[i].deref();
                    if (isUndefined$1(vm)) {
                        ArraySplice.call(weakRefs, i, 1); // remove
                    }
                }
            });
        }
        _getWeakRefs(key) {
            let weakRefs = this._map.get(key);
            if (isUndefined$1(weakRefs)) {
                weakRefs = [];
                this._map.set(key, weakRefs);
            }
            return weakRefs;
        }
        get(key) {
            const weakRefs = this._getWeakRefs(key);
            const result = new Set();
            for (const weakRef of weakRefs) {
                const vm = weakRef.deref();
                if (!isUndefined$1(vm)) {
                    result.add(vm);
                }
            }
            return result;
        }
        add(key, value) {
            const weakRefs = this._getWeakRefs(key);
            // We could check for duplicate values here, but it doesn't seem worth it.
            // We transform the output into a Set anyway
            ArrayPush$1.call(weakRefs, new WeakRef(value));
            // It's important here not to leak the second argument, which is the "held value." The FinalizationRegistry
            // effectively creates a strong reference between the first argument (the "target") and the held value. When
            // the target is GC'ed, the callback is called, and then the held value is GC'ed.
            // Putting the key here would mean the key is not GC'ed until the value is GC'ed, which defeats the purpose
            // of the WeakMap. Whereas putting the weakRefs array here is fine, because it doesn't have a strong reference
            // to anything. See also this example:
            // https://gist.github.com/nolanlawson/79a3d36e8e6cc25c5048bb17c1795aea
            this._registry.register(value, weakRefs);
        }
        delete(key) {
            this._map.delete(key);
        }
    }
    const WeakMultiMap = supportsWeakRefs ? ModernWeakMultiMap : LegacyWeakMultiMap;

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const swappedTemplateMap = new WeakMap();
    const swappedComponentMap = new WeakMap();
    const swappedStyleMap = new WeakMap();
    // The important thing here is the weak values  VMs are transient (one per component instance) and should be GC'ed,
    // so we don't want to create strong references to them.
    // The weak keys are kind of useless, because Templates, LightningElementConstructors, and StylesheetFactories are
    // never GC'ed. But maybe they will be someday, so we may as well use weak keys too.
    const activeTemplates = new WeakMultiMap();
    const activeComponents = new WeakMultiMap();
    const activeStyles = new WeakMultiMap();
    function rehydrateHotTemplate(tpl) {
        const list = activeTemplates.get(tpl);
        for (const vm of list) {
            if (isFalse(vm.isDirty)) {
                // forcing the vm to rehydrate in the micro-task:
                markComponentAsDirty(vm);
                scheduleRehydration(vm);
            }
        }
        // Resetting the Set since these VMs are no longer related to this template, instead
        // they will get re-associated once these instances are rehydrated.
        activeTemplates.delete(tpl);
        return true;
    }
    function rehydrateHotStyle(style) {
        const list = activeStyles.get(style);
        for (const vm of list) {
            // if a style definition is swapped, we must reset
            // vm's template content in the next micro-task:
            forceRehydration(vm);
        }
        // Resetting the Set since these VMs are no longer related to this style, instead
        // they will get re-associated once these instances are rehydrated.
        activeStyles.delete(style);
        return true;
    }
    function rehydrateHotComponent(Ctor) {
        const list = activeComponents.get(Ctor);
        let canRefreshAllInstances = true;
        for (const vm of list) {
            const { owner } = vm;
            if (!isNull(owner)) {
                // if a component class definition is swapped, we must reset
                // owner's template content in the next micro-task:
                forceRehydration(owner);
            }
            else {
                // the hot swapping for components only work for instances of components
                // created from a template, root elements can't be swapped because we
                // don't have a way to force the creation of the element with the same state
                // of the current element.
                // Instead, we can report the problem to the caller so it can take action,
                // for example: reload the entire page.
                canRefreshAllInstances = false;
            }
        }
        // resetting the Set since these VMs are no longer related to this constructor, instead
        // they will get re-associated once these instances are rehydrated.
        activeComponents.delete(Ctor);
        return canRefreshAllInstances;
    }
    function getTemplateOrSwappedTemplate(tpl) {
        const visited = new Set();
        while (swappedTemplateMap.has(tpl) && !visited.has(tpl)) {
            visited.add(tpl);
            tpl = swappedTemplateMap.get(tpl);
        }
        return tpl;
    }
    function getComponentOrSwappedComponent(Ctor) {
        const visited = new Set();
        while (swappedComponentMap.has(Ctor) && !visited.has(Ctor)) {
            visited.add(Ctor);
            Ctor = swappedComponentMap.get(Ctor);
        }
        return Ctor;
    }
    function getStyleOrSwappedStyle(style) {
        const visited = new Set();
        while (swappedStyleMap.has(style) && !visited.has(style)) {
            visited.add(style);
            style = swappedStyleMap.get(style);
        }
        return style;
    }
    function setActiveVM(vm) {
        // tracking active component
        const Ctor = vm.def.ctor;
        // this will allow us to keep track of the hot components
        activeComponents.add(Ctor, vm);
        // tracking active template
        const tpl = vm.cmpTemplate;
        if (tpl) {
            // this will allow us to keep track of the templates that are
            // being used by a hot component
            activeTemplates.add(tpl, vm);
            // tracking active styles associated to template
            const stylesheets = tpl.stylesheets;
            if (!isUndefined$1(stylesheets)) {
                for (const stylesheet of flattenStylesheets(stylesheets)) {
                    // this is necessary because we don't hold the list of styles
                    // in the vm, we only hold the selected (already swapped template)
                    // but the styles attached to the template might not be the actual
                    // active ones, but the swapped versions of those.
                    const swappedStylesheet = getStyleOrSwappedStyle(stylesheet);
                    // this will allow us to keep track of the stylesheet that are
                    // being used by a hot component
                    activeStyles.add(swappedStylesheet, vm);
                }
            }
        }
    }
    function swapTemplate(oldTpl, newTpl) {
        {
            if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {
                swappedTemplateMap.set(oldTpl, newTpl);
                return rehydrateHotTemplate(oldTpl);
            }
            else {
                throw new TypeError(`Invalid Template`);
            }
        }
    }
    function swapComponent(oldComponent, newComponent) {
        {
            if (isComponentConstructor(oldComponent) && isComponentConstructor(newComponent)) {
                swappedComponentMap.set(oldComponent, newComponent);
                return rehydrateHotComponent(oldComponent);
            }
            else {
                throw new TypeError(`Invalid Component`);
            }
        }
    }
    function swapStyle(oldStyle, newStyle) {
        {
            // TODO [#1887]: once the support for registering styles is implemented
            // we can add the validation of both styles around this block.
            swappedStyleMap.set(oldStyle, newStyle);
            return rehydrateHotStyle(oldStyle);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This module is responsible for producing the ComponentDef object that is always
     * accessible via `vm.def`. This is lazily created during the creation of the first
     * instance of a component class, and shared across all instances.
     *
     * This structure can be used to synthetically create proxies, and understand the
     * shape of a component. It is also used internally to apply extra optimizations.
     */
    const CtorToDefMap = new WeakMap();
    function getCtorProto(Ctor) {
        let proto = getPrototypeOf$1(Ctor);
        if (isNull(proto)) {
            throw new ReferenceError(`Invalid prototype chain for ${Ctor.name}, you must extend LightningElement.`);
        }
        // covering the cases where the ref is circular in AMD
        if (isCircularModuleDependency(proto)) {
            const p = resolveCircularModuleDependency(proto);
            {
                if (isNull(p)) {
                    throw new ReferenceError(`Circular module dependency for ${Ctor.name}, must resolve to a constructor that extends LightningElement.`);
                }
            }
            // escape hatch for Locker and other abstractions to provide their own base class instead
            // of our Base class without having to leak it to user-land. If the circular function returns
            // itself, that's the signal that we have hit the end of the proto chain, which must always
            // be base.
            proto = p === proto ? LightningElement : p;
        }
        return proto;
    }
    function createComponentDef(Ctor) {
        const { shadowSupportMode: ctorShadowSupportMode, renderMode: ctorRenderMode, formAssociated: ctorFormAssociated, } = Ctor;
        {
            const ctorName = Ctor.name;
            // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
            // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
            if (!Ctor.constructor) {
                // This error seems impossible to hit, due to an earlier check in `isComponentConstructor()`.
                // But we keep it here just in case.
                logError(`Missing ${ctorName}.constructor, ${ctorName} should have a "constructor" property.`);
            }
            if (!isUndefined$1(ctorShadowSupportMode) &&
                ctorShadowSupportMode !== "any" /* ShadowSupportMode.Any */ &&
                ctorShadowSupportMode !== "reset" /* ShadowSupportMode.Default */ &&
                ctorShadowSupportMode !== "native" /* ShadowSupportMode.Native */) {
                logError(`Invalid value for static property shadowSupportMode: '${ctorShadowSupportMode}'`);
            }
            // TODO [#3971]: Completely remove shadowSupportMode "any"
            if (ctorShadowSupportMode === "any" /* ShadowSupportMode.Any */) {
                logWarn(`Invalid value 'any' for static property shadowSupportMode. 'any' is deprecated and will be removed in a future release--use 'native' instead.`);
            }
            if (!isUndefined$1(ctorRenderMode) &&
                ctorRenderMode !== 'light' &&
                ctorRenderMode !== 'shadow') {
                logError(`Invalid value for static property renderMode: '${ctorRenderMode}'. renderMode must be either 'light' or 'shadow'.`);
            }
        }
        const decoratorsMeta = getDecoratorsMeta(Ctor);
        const { apiFields, apiFieldsConfig, apiMethods, wiredFields, wiredMethods, observedFields } = decoratorsMeta;
        const proto = Ctor.prototype;
        let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, formAssociatedCallback, formResetCallback, formDisabledCallback, formStateRestoreCallback, render, } = proto;
        const superProto = getCtorProto(Ctor);
        const hasCustomSuperClass = superProto !== LightningElement;
        const superDef = hasCustomSuperClass ? getComponentInternalDef(superProto) : lightingElementDef;
        const bridge = HTMLBridgeElementFactory(superDef.bridge, keys(apiFields), keys(apiMethods), keys(observedFields), proto, hasCustomSuperClass);
        const props = assign(create(null), superDef.props, apiFields);
        const propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);
        const methods = assign(create(null), superDef.methods, apiMethods);
        const wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        formAssociatedCallback = formAssociatedCallback || superDef.formAssociatedCallback;
        formResetCallback = formResetCallback || superDef.formResetCallback;
        formDisabledCallback = formDisabledCallback || superDef.formDisabledCallback;
        formStateRestoreCallback = formStateRestoreCallback || superDef.formStateRestoreCallback;
        render = render || superDef.render;
        let shadowSupportMode = superDef.shadowSupportMode;
        if (!isUndefined$1(ctorShadowSupportMode)) {
            shadowSupportMode = ctorShadowSupportMode;
            if (isReportingEnabled() &&
                (shadowSupportMode === "any" /* ShadowSupportMode.Any */ ||
                    shadowSupportMode === "native" /* ShadowSupportMode.Native */)) {
                report("ShadowSupportModeUsage" /* ReportingEventId.ShadowSupportModeUsage */, {
                    tagName: Ctor.name,
                    mode: shadowSupportMode,
                });
            }
        }
        let renderMode = superDef.renderMode;
        if (!isUndefined$1(ctorRenderMode)) {
            renderMode = ctorRenderMode === 'light' ? 0 /* RenderMode.Light */ : 1 /* RenderMode.Shadow */;
        }
        let formAssociated = superDef.formAssociated;
        if (!isUndefined$1(ctorFormAssociated)) {
            formAssociated = ctorFormAssociated;
        }
        const template = getComponentRegisteredTemplate(Ctor) || superDef.template;
        const name = Ctor.name || superDef.name;
        // installing observed fields into the prototype.
        defineProperties(proto, observedFields);
        const def = {
            ctor: Ctor,
            name,
            wire,
            props,
            propsConfig,
            methods,
            bridge,
            template,
            renderMode,
            shadowSupportMode,
            formAssociated,
            connectedCallback,
            disconnectedCallback,
            errorCallback,
            formAssociatedCallback,
            formDisabledCallback,
            formResetCallback,
            formStateRestoreCallback,
            renderedCallback,
            render,
        };
        // This is a no-op unless Lightning DevTools are enabled.
        instrumentDef(def);
        {
            freeze(Ctor.prototype);
        }
        return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is
     * subject to change or being removed.
     * @param ctor
     */
    function isComponentConstructor(ctor) {
        if (!isFunction$1(ctor)) {
            return false;
        }
        // Fast path: LightningElement is part of the prototype chain of the constructor.
        if (ctor.prototype instanceof LightningElement) {
            return true;
        }
        // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
        // climb up the constructor prototype chain to check in case there are circular dependencies
        // to resolve.
        let current = ctor;
        do {
            if (isCircularModuleDependency(current)) {
                const circularResolved = resolveCircularModuleDependency(current);
                // If the circular function returns itself, that's the signal that we have hit the end
                // of the proto chain, which must always be a valid base constructor.
                if (circularResolved === current) {
                    return true;
                }
                current = circularResolved;
            }
            if (current === LightningElement) {
                return true;
            }
        } while (!isNull(current) && (current = getPrototypeOf$1(current)));
        // Finally return false if the LightningElement is not part of the prototype chain.
        return false;
    }
    function getComponentInternalDef(Ctor) {
        {
            Ctor = getComponentOrSwappedComponent(Ctor);
        }
        let def = CtorToDefMap.get(Ctor);
        if (isUndefined$1(def)) {
            if (isCircularModuleDependency(Ctor)) {
                const resolvedCtor = resolveCircularModuleDependency(Ctor);
                def = getComponentInternalDef(resolvedCtor);
                // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,
                // look up the definition in cache instead of re-resolving and recreating the def.
                CtorToDefMap.set(Ctor, def);
                return def;
            }
            if (!isComponentConstructor(Ctor)) {
                throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);
            }
            def = createComponentDef(Ctor);
            CtorToDefMap.set(Ctor, def);
        }
        return def;
    }
    function getComponentHtmlPrototype(Ctor) {
        const def = getComponentInternalDef(Ctor);
        return def.bridge;
    }
    const lightingElementDef = {
        ctor: LightningElement,
        name: LightningElement.name,
        props: lightningBasedDescriptors,
        propsConfig: EmptyObject,
        methods: EmptyObject,
        renderMode: 1 /* RenderMode.Shadow */,
        shadowSupportMode: "reset" /* ShadowSupportMode.Default */,
        formAssociated: undefined,
        wire: EmptyObject,
        bridge: BaseBridgeElement,
        template: defaultEmptyTemplate,
        render: LightningElement.prototype.render,
    };
    /**
     * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is
     * subject to change or being removed.
     * @param Ctor
     */
    function getComponentDef(Ctor) {
        const def = getComponentInternalDef(Ctor);
        // From the internal def object, we need to extract the info that is useful
        // for some external services, e.g.: Locker Service, usually, all they care
        // is about the shape of the constructor, the internals of it are not relevant
        // because they don't have a way to mess with that.
        const { ctor, name, props, propsConfig, methods } = def;
        const publicProps = {};
        for (const key in props) {
            // avoid leaking the reference to the public props descriptors
            publicProps[key] = {
                config: propsConfig[key] || 0, // a property by default
                type: "any" /* PropDefType.any */, // no type inference for public services
                attr: htmlPropertyToAttribute(key),
            };
        }
        const publicMethods = {};
        for (const key in methods) {
            // avoid leaking the reference to the public method descriptors
            publicMethods[key] = methods[key].value;
        }
        return {
            ctor,
            name,
            props: publicProps,
            methods: publicMethods,
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function makeHostToken(token) {
        // Note: if this ever changes, update the `cssScopeTokens` returned by `@lwc/compiler`
        return `${token}-host`;
    }
    function createInlineStyleVNode(content) {
        return api.h('style', {
            key: 'style', // special key
            attrs: {
                type: 'text/css',
            },
        }, [api.t(content)]);
    }
    // TODO [#3733]: remove support for legacy scope tokens
    function updateStylesheetToken(vm, template, legacy) {
        const { elm, context, renderMode, shadowMode, renderer: { getClassList, removeAttribute, setAttribute }, } = vm;
        const { stylesheets: newStylesheets } = template;
        const newStylesheetToken = legacy ? template.legacyStylesheetToken : template.stylesheetToken;
        const { stylesheets: newVmStylesheets } = vm;
        const isSyntheticShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */;
        const { hasScopedStyles } = context;
        let newToken;
        let newHasTokenInClass;
        let newHasTokenInAttribute;
        // Reset the styling token applied to the host element.
        let oldToken;
        let oldHasTokenInClass;
        let oldHasTokenInAttribute;
        if (legacy) {
            oldToken = context.legacyStylesheetToken;
            oldHasTokenInClass = context.hasLegacyTokenInClass;
            oldHasTokenInAttribute = context.hasLegacyTokenInAttribute;
        }
        else {
            oldToken = context.stylesheetToken;
            oldHasTokenInClass = context.hasTokenInClass;
            oldHasTokenInAttribute = context.hasTokenInAttribute;
        }
        if (!isUndefined$1(oldToken)) {
            if (oldHasTokenInClass) {
                getClassList(elm).remove(makeHostToken(oldToken));
            }
            if (oldHasTokenInAttribute) {
                removeAttribute(elm, makeHostToken(oldToken));
            }
        }
        // Apply the new template styling token to the host element, if the new template has any
        // associated stylesheets. In the case of light DOM, also ensure there is at least one scoped stylesheet.
        const hasNewStylesheets = hasStyles(newStylesheets);
        const hasNewVmStylesheets = hasStyles(newVmStylesheets);
        if (hasNewStylesheets || hasNewVmStylesheets) {
            newToken = newStylesheetToken;
        }
        // Set the new styling token on the host element
        if (!isUndefined$1(newToken)) {
            if (hasScopedStyles) {
                getClassList(elm).add(makeHostToken(newToken));
                newHasTokenInClass = true;
            }
            if (isSyntheticShadow) {
                setAttribute(elm, makeHostToken(newToken), '');
                newHasTokenInAttribute = true;
            }
        }
        // Update the styling tokens present on the context object.
        if (legacy) {
            context.legacyStylesheetToken = newToken;
            context.hasLegacyTokenInClass = newHasTokenInClass;
            context.hasLegacyTokenInAttribute = newHasTokenInAttribute;
        }
        else {
            context.stylesheetToken = newToken;
            context.hasTokenInClass = newHasTokenInClass;
            context.hasTokenInAttribute = newHasTokenInAttribute;
        }
    }
    function evaluateStylesheetsContent(stylesheets, stylesheetToken, vm) {
        const content = [];
        let root;
        for (let i = 0; i < stylesheets.length; i++) {
            let stylesheet = stylesheets[i];
            if (isArray$1(stylesheet)) {
                ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, stylesheetToken, vm));
            }
            else {
                {
                    // Check for compiler version mismatch in dev mode only
                    checkVersionMismatch(stylesheet, 'stylesheet');
                    // in dev-mode, we support hot swapping of stylesheet, which means that
                    // the component instance might be attempting to use an old version of
                    // the stylesheet, while internally, we have a replacement for it.
                    stylesheet = getStyleOrSwappedStyle(stylesheet);
                }
                const isScopedCss = stylesheet[KEY__SCOPED_CSS];
                if (lwcRuntimeFlags.DISABLE_LIGHT_DOM_UNSCOPED_CSS &&
                    !isScopedCss &&
                    vm.renderMode === 0 /* RenderMode.Light */) {
                    logError('Unscoped CSS is not supported in Light DOM in this environment. Please use scoped CSS ' +
                        '(*.scoped.css) instead of unscoped CSS (*.css). See also: https://sfdc.co/scoped-styles-light-dom');
                    continue;
                }
                // Apply the scope token only if the stylesheet itself is scoped, or if we're rendering synthetic shadow.
                const scopeToken = isScopedCss ||
                    (vm.shadowMode === 1 /* ShadowMode.Synthetic */ && vm.renderMode === 1 /* RenderMode.Shadow */)
                    ? stylesheetToken
                    : undefined;
                // Use the actual `:host` selector if we're rendering global CSS for light DOM, or if we're rendering
                // native shadow DOM. Synthetic shadow DOM never uses `:host`.
                const useActualHostSelector = vm.renderMode === 0 /* RenderMode.Light */
                    ? !isScopedCss
                    : vm.shadowMode === 0 /* ShadowMode.Native */;
                // Use the native :dir() pseudoclass only in native shadow DOM. Otherwise, in synthetic shadow,
                // we use an attribute selector on the host to simulate :dir().
                let useNativeDirPseudoclass;
                if (vm.renderMode === 1 /* RenderMode.Shadow */) {
                    useNativeDirPseudoclass = vm.shadowMode === 0 /* ShadowMode.Native */;
                }
                else {
                    // Light DOM components should only render `[dir]` if they're inside of a synthetic shadow root.
                    // At the top level (root is null) or inside of a native shadow root, they should use `:dir()`.
                    if (isUndefined$1(root)) {
                        // Only calculate the root once as necessary
                        root = getNearestShadowComponent(vm);
                    }
                    useNativeDirPseudoclass = isNull(root) || root.shadowMode === 0 /* ShadowMode.Native */;
                }
                ArrayPush$1.call(content, stylesheet(scopeToken, useActualHostSelector, useNativeDirPseudoclass));
            }
        }
        return content;
    }
    function getStylesheetsContent(vm, template) {
        const { stylesheets, stylesheetToken } = template;
        const { stylesheets: vmStylesheets } = vm;
        let content = [];
        if (hasStyles(stylesheets)) {
            content = evaluateStylesheetsContent(stylesheets, stylesheetToken, vm);
        }
        // VM (component) stylesheets apply after template stylesheets
        if (hasStyles(vmStylesheets)) {
            ArrayPush$1.apply(content, evaluateStylesheetsContent(vmStylesheets, stylesheetToken, vm));
        }
        return content;
    }
    // It might be worth caching this to avoid doing the lookup repeatedly, but
    // perf testing has not shown it to be a huge improvement yet:
    // https://github.com/salesforce/lwc/pull/2460#discussion_r691208892
    function getNearestShadowComponent(vm) {
        let owner = vm;
        while (!isNull(owner)) {
            if (owner.renderMode === 1 /* RenderMode.Shadow */) {
                return owner;
            }
            owner = owner.owner;
        }
        return owner;
    }
    /**
     * If the component that is currently being rendered uses scoped styles,
     * this returns the unique token for that scoped stylesheet. Otherwise
     * it returns null.
     * @param owner
     * @param legacy
     */
    // TODO [#3733]: remove support for legacy scope tokens
    function getScopeTokenClass(owner, legacy) {
        const { cmpTemplate, context } = owner;
        return ((context.hasScopedStyles &&
            (legacy ? cmpTemplate?.legacyStylesheetToken : cmpTemplate?.stylesheetToken)) ||
            null);
    }
    function getNearestNativeShadowComponent(vm) {
        const owner = getNearestShadowComponent(vm);
        if (!isNull(owner) && owner.shadowMode === 1 /* ShadowMode.Synthetic */) {
            // Synthetic-within-native is impossible. So if the nearest shadow component is
            // synthetic, we know we won't find a native component if we go any further.
            return null;
        }
        return owner;
    }
    function createStylesheet(vm, stylesheets) {
        const { renderMode, shadowMode, renderer: { insertStylesheet }, } = vm;
        if (renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */) {
            for (let i = 0; i < stylesheets.length; i++) {
                insertStylesheet(stylesheets[i]);
            }
        }
        else if (vm.hydrated) {
            // Note: We need to ensure that during hydration, the stylesheets method is the same as those in ssr.
            //       This works in the client, because the stylesheets are created, and cached in the VM
            //       the first time the VM renders.
            // native shadow or light DOM, SSR
            return ArrayMap.call(stylesheets, createInlineStyleVNode);
        }
        else {
            // native shadow or light DOM, DOM renderer
            const root = getNearestNativeShadowComponent(vm);
            // null root means a global style
            const target = isNull(root) ? undefined : root.shadowRoot;
            for (let i = 0; i < stylesheets.length; i++) {
                insertStylesheet(stylesheets[i], target);
            }
        }
        return null;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isVBaseElement(vnode) {
        const { type } = vnode;
        return type === 2 /* VNodeType.Element */ || type === 3 /* VNodeType.CustomElement */;
    }
    function isSameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVCustomElement(vnode) {
        return vnode.type === 3 /* VNodeType.CustomElement */;
    }
    function isVFragment(vnode) {
        return vnode.type === 5 /* VNodeType.Fragment */;
    }
    function isVScopedSlotFragment(vnode) {
        return vnode.type === 6 /* VNodeType.ScopedSlotFragment */;
    }
    function isVStatic(vnode) {
        return vnode.type === 4 /* VNodeType.Static */;
    }
    function isVStaticPartElement(vnode) {
        return vnode.type === 1 /* VStaticPartType.Element */;
    }
    function isVStaticPartText(vnode) {
        return vnode.type === 0 /* VStaticPartType.Text */;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ColonCharCode = 58;
    function patchAttributes(oldVnode, vnode, renderer) {
        const { data, elm } = vnode;
        const { attrs } = data;
        if (isUndefined$1(attrs)) {
            return;
        }
        const oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;
        // Attrs may be the same due to the static content optimization, so we can skip diffing
        if (oldAttrs === attrs) {
            return;
        }
        // Note VStaticPartData does not contain the external property so it will always default to false.
        const external = 'external' in data ? data.external : false;
        const { setAttribute, removeAttribute, setProperty } = renderer;
        for (const key in attrs) {
            const cur = attrs[key];
            const old = oldAttrs[key];
            if (old !== cur) {
                let propName;
                // For external custom elements, sniff to see if the attr should be considered a prop.
                // Use kebabCaseToCamelCase directly because we don't want to set props like `ariaLabel` or `tabIndex`
                // on a custom element versus just using the more reliable attribute format.
                if (external && (propName = kebabCaseToCamelCase(key)) in elm) {
                    setProperty(elm, propName, cur);
                }
                else if (StringCharCodeAt.call(key, 3) === ColonCharCode) {
                    // Assume xml namespace
                    setAttribute(elm, key, cur, XML_NAMESPACE);
                }
                else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {
                    // Assume xlink namespace
                    setAttribute(elm, key, cur, XLINK_NAMESPACE);
                }
                else if (isNull(cur) || isUndefined$1(cur)) {
                    removeAttribute(elm, key);
                }
                else {
                    setAttribute(elm, key, cur);
                }
            }
        }
    }
    function patchSlotAssignment(oldVnode, vnode, renderer) {
        const { slotAssignment } = vnode;
        if (oldVnode?.slotAssignment === slotAssignment) {
            return;
        }
        const { elm } = vnode;
        const { setAttribute, removeAttribute } = renderer;
        if (isUndefined$1(slotAssignment) || isNull(slotAssignment)) {
            removeAttribute(elm, 'slot');
        }
        else {
            setAttribute(elm, 'slot', slotAssignment);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLiveBindingProp(sel, key) {
        // For properties with live bindings, we read values from the DOM element
        // instead of relying on internally tracked values.
        return sel === 'input' && (key === 'value' || key === 'checked');
    }
    function patchProps(oldVnode, vnode, renderer) {
        const { props } = vnode.data;
        if (isUndefined$1(props)) {
            return;
        }
        let oldProps;
        if (!isNull(oldVnode)) {
            oldProps = oldVnode.data.props;
            // Props may be the same due to the static content optimization, so we can skip diffing
            if (oldProps === props) {
                return;
            }
            if (isUndefined$1(oldProps)) {
                oldProps = EmptyObject;
            }
        }
        const isFirstPatch = isNull(oldVnode);
        const { elm, sel } = vnode;
        const { getProperty, setProperty } = renderer;
        for (const key in props) {
            const cur = props[key];
            // Set the property if it's the first time is is patched or if the previous property is
            // different than the one previously set.
            if (isFirstPatch ||
                cur !== (isLiveBindingProp(sel, key) ? getProperty(elm, key) : oldProps[key]) ||
                !(key in oldProps) // this is required because the above case will pass when `cur` is `undefined` and key is missing in `oldProps`
            ) {
                // Additional verification if properties are supported by the element
                // Validation relies on html properties and public properties being defined on the element,
                // SSR has its own custom validation.
                {
                    if (!(key in elm)) {
                        logWarn(`Unknown public property "${key}" of element <${elm.tagName.toLowerCase()}>. This is either a typo on the corresponding attribute "${htmlPropertyToAttribute(key)}", or the attribute does not exist in this browser or DOM implementation.`);
                    }
                }
                setProperty(elm, key, cur);
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const classNameToClassMap = create(null);
    function getMapFromClassName(className) {
        if (isUndefined$1(className) || isNull(className) || className === '') {
            return EmptyObject;
        }
        // computed class names must be string
        // This will throw if className is a symbol or null-prototype object
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        className = isString(className) ? className : className + '';
        let map = classNameToClassMap[className];
        if (map) {
            return map;
        }
        map = create(null);
        let start = 0;
        let o;
        const len = className.length;
        for (o = 0; o < len; o++) {
            if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
                if (o > start) {
                    map[StringSlice.call(className, start, o)] = true;
                }
                start = o + 1;
            }
        }
        if (o > start) {
            map[StringSlice.call(className, start, o)] = true;
        }
        classNameToClassMap[className] = map;
        {
            // just to make sure that this object never changes as part of the diffing algo
            freeze(map);
        }
        return map;
    }
    function patchClassAttribute(oldVnode, vnode, renderer) {
        const { elm, data: { className: newClass }, } = vnode;
        const oldClass = isNull(oldVnode) ? undefined : oldVnode.data.className;
        if (oldClass === newClass) {
            return;
        }
        const newClassMap = getMapFromClassName(newClass);
        const oldClassMap = getMapFromClassName(oldClass);
        if (oldClassMap === newClassMap) {
            // These objects are cached by className string (`classNameToClassMap`), so we can only get here if there is
            // a key collision due to types, e.g. oldClass is `undefined` and newClass is `""` (empty string), or oldClass
            // is `1` (number) and newClass is `"1"` (string).
            return;
        }
        const { getClassList } = renderer;
        const classList = getClassList(elm);
        let name;
        for (name in oldClassMap) {
            // remove only if it is not in the new class collection and it is not set from within the instance
            if (isUndefined$1(newClassMap[name])) {
                classList.remove(name);
            }
        }
        for (name in newClassMap) {
            if (isUndefined$1(oldClassMap[name])) {
                classList.add(name);
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The style property is a string when defined via an expression in the template.
    function patchStyleAttribute(oldVnode, vnode, renderer, owner) {
        const { elm, data: { style: newStyle }, } = vnode;
        {
            if (!isNull(newStyle) && !isUndefined$1(newStyle) && !isString(newStyle)) {
                logError(`Invalid 'style' attribute passed to <${elm.tagName.toLowerCase()}> is ignored. This attribute must be a string value.`, owner);
            }
        }
        const oldStyle = isNull(oldVnode) ? undefined : oldVnode.data.style;
        if (oldStyle === newStyle) {
            return;
        }
        const { setAttribute, removeAttribute } = renderer;
        if (!isString(newStyle) || newStyle === '') {
            removeAttribute(elm, 'style');
        }
        else {
            setAttribute(elm, 'style', newStyle);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function applyEventListeners(vnode, renderer) {
        const { elm, data } = vnode;
        const { on } = data;
        if (isUndefined$1(on)) {
            return;
        }
        const { addEventListener } = renderer;
        for (const name in on) {
            const handler = on[name];
            addEventListener(elm, name, handler);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.
    function applyStaticClassAttribute(vnode, renderer) {
        const { elm, data: { classMap }, } = vnode;
        if (isUndefined$1(classMap)) {
            return;
        }
        const { getClassList } = renderer;
        const classList = getClassList(elm);
        for (const name in classMap) {
            classList.add(name);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The HTML style property becomes the vnode.data.styleDecls object when defined as a string in the template.
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.
    function applyStaticStyleAttribute(vnode, renderer) {
        const { elm, data: { styleDecls }, } = vnode;
        if (isUndefined$1(styleDecls)) {
            return;
        }
        const { setCSSStyleProperty } = renderer;
        for (let i = 0; i < styleDecls.length; i++) {
            const [prop, value, important] = styleDecls[i];
            setCSSStyleProperty(elm, prop, value, important);
        }
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Set a ref (lwc:ref) on a VM, from a template API
    function applyRefs(vnode, owner) {
        const { data } = vnode;
        const { ref } = data;
        if (isUndefined$1(ref)) {
            return;
        }
        if (isUndefined$1(owner.refVNodes)) {
            throw new Error('refVNodes must be defined when setting a ref');
        }
        // If this method is called, then vm.refVNodes is set as the template has refs.
        // If not, then something went wrong and we threw an error above.
        const refVNodes = owner.refVNodes;
        // In cases of conflict (two elements with the same ref), prefer the last one,
        // in depth-first traversal order. This happens automatically due to how we render
        refVNodes[ref] = vnode;
    }

    /*
     * Copyright (c) 2024, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function patchTextVNode(n1, n2, renderer) {
        n2.elm = n1.elm;
        if (n2.text !== n1.text) {
            updateTextContent$1(n2, renderer);
        }
    }
    function patchTextVStaticPart(n1, n2, renderer) {
        if (isNull(n1) || n2.text !== n1.text) {
            updateTextContent$1(n2, renderer);
        }
    }
    function updateTextContent$1(vnode, renderer) {
        const { elm, text } = vnode;
        const { setText } = renderer;
        {
            unlockDomMutation();
        }
        setText(elm, text);
        {
            lockDomMutation();
        }
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * Given an array of static parts, mounts the DOM element to the part based on the staticPartId
     * @param root the root element
     * @param parts an array of VStaticParts
     * @param renderer the renderer to use
     */
    function traverseAndSetElements(root, parts, renderer) {
        const numParts = parts.length;
        // Optimization given that, in most cases, there will be one part, and it's just the root
        if (numParts === 1) {
            const firstPart = parts[0];
            if (firstPart.partId === 0) {
                // 0 means the root node
                firstPart.elm = root;
                return;
            }
        }
        const partIdsToParts = new Map();
        for (const staticPart of parts) {
            partIdsToParts.set(staticPart.partId, staticPart);
        }
        let numFoundParts = 0;
        const { previousSibling, getLastChild } = renderer;
        const stack = [root];
        let partId = -1;
        // Depth-first traversal. We assign a partId to each element, which is an integer based on traversal order.
        while (stack.length > 0) {
            const elm = ArrayShift.call(stack);
            partId++;
            const part = partIdsToParts.get(partId);
            if (!isUndefined$1(part)) {
                part.elm = elm;
                if (++numFoundParts === numParts) {
                    return; // perf optimization - stop traversing once we've found everything we need
                }
            }
            // For depth-first traversal, prepend to the stack in reverse order
            // Note that we traverse using `*Child`/`*Sibling` rather than `children` because the browser uses a linked
            // list under the hood to represent the DOM tree, so it's faster to do this than to create an underlying array
            // by calling `children`.
            let child = getLastChild(elm);
            while (!isNull(child)) {
                ArrayUnshift.call(stack, child);
                child = previousSibling(child);
            }
        }
        {
            assert.isTrue(numFoundParts === numParts, `Should have found all parts by now. Found ${numFoundParts}, needed ${numParts}.`);
        }
    }
    /**
     * Given an array of static parts, do all the mounting required for these parts.
     * @param root the root element
     * @param vnode the parent VStatic
     * @param renderer the renderer to use
     */
    function mountStaticParts(root, vnode, renderer) {
        const { parts, owner } = vnode;
        if (isUndefined$1(parts)) {
            return;
        }
        // This adds `part.elm` to each `part`. We have to do this on every mount because the `parts`
        // array is recreated from scratch every time, so each `part.elm` is now undefined.
        traverseAndSetElements(root, parts, renderer);
        // Currently only event listeners and refs are supported for static vnodes
        for (const part of parts) {
            if (isVStaticPartElement(part)) {
                // Event listeners only need to be applied once when mounting
                applyEventListeners(part, renderer);
                // Refs must be updated after every render due to refVNodes getting reset before every render
                applyRefs(part, owner);
                patchAttributes(null, part, renderer);
                patchClassAttribute(null, part, renderer);
                patchStyleAttribute(null, part, renderer, owner);
            }
            else {
                if (!isVStaticPartText(part)) {
                    throw new Error(`LWC internal error, encountered unknown static part type: ${part.type}`);
                }
                patchTextVStaticPart(null, part, renderer);
            }
        }
    }
    /**
     * Updates the static elements based on the content of the VStaticParts
     * @param n1 the previous VStatic vnode
     * @param n2 the current VStatic vnode
     * @param renderer the renderer to use
     */
    function patchStaticParts(n1, n2, renderer) {
        const { parts: currParts, owner: currPartsOwner } = n2;
        if (isUndefined$1(currParts)) {
            return;
        }
        const { parts: prevParts } = n1;
        {
            assert.isTrue(currParts.length === prevParts?.length, 'Expected static parts to be the same for the same element. This is an error with the LWC framework itself.');
        }
        for (let i = 0; i < currParts.length; i++) {
            const prevPart = prevParts[i];
            const part = currParts[i];
            // Patch only occurs if the vnode is newly generated, which means the part.elm is always undefined
            // Since the vnode and elements are the same we can safely assume that prevParts[i].elm is defined.
            part.elm = prevPart.elm;
            if (prevPart.type !== part.type) {
                throw new Error(`LWC internal error, static part types do not match. Previous type was ${prevPart.type} and current type is ${part.type}`);
            }
            if (isVStaticPartElement(part)) {
                // Refs must be updated after every render due to refVNodes getting reset before every render
                applyRefs(part, currPartsOwner);
                patchAttributes(prevPart, part, renderer);
                patchClassAttribute(prevPart, part, renderer);
                patchStyleAttribute(prevPart, part, renderer, currPartsOwner);
            }
            else {
                patchTextVStaticPart(null, part, renderer);
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function patchChildren(c1, c2, parent, renderer) {
        if (hasDynamicChildren(c2)) {
            updateDynamicChildren(c1, c2, parent, renderer);
        }
        else {
            updateStaticChildren(c1, c2, parent, renderer);
        }
    }
    function patch(n1, n2, parent, renderer) {
        if (n1 === n2) {
            return;
        }
        {
            if (!isSameVnode(n1, n2) &&
                // Currently the only scenario when patch does not receive the same vnodes are for
                // dynamic components. When a dynamic component's constructor changes, the value of its
                // tag name (sel) will be different. The engine will unmount the previous element
                // and mount the new one using the new constructor in patchCustomElement.
                !(isVCustomElement(n1) && isVCustomElement(n2))) {
                throw new Error('Expected these VNodes to be the same: ' +
                    JSON.stringify({ sel: n1.sel, key: n1.key }) +
                    ', ' +
                    JSON.stringify({ sel: n2.sel, key: n2.key }));
            }
        }
        switch (n2.type) {
            case 0 /* VNodeType.Text */:
                // VText has no special capability, fallback to the owner's renderer
                patchTextVNode(n1, n2, renderer);
                break;
            case 1 /* VNodeType.Comment */:
                // VComment has no special capability, fallback to the owner's renderer
                patchComment(n1, n2, renderer);
                break;
            case 4 /* VNodeType.Static */:
                patchStatic(n1, n2, renderer);
                break;
            case 5 /* VNodeType.Fragment */:
                patchFragment(n1, n2, parent, renderer);
                break;
            case 2 /* VNodeType.Element */:
                patchElement(n1, n2, n2.data.renderer ?? renderer);
                break;
            case 3 /* VNodeType.CustomElement */:
                patchCustomElement(n1, n2, parent, n2.data.renderer ?? renderer);
                break;
        }
    }
    function mount(node, parent, renderer, anchor) {
        switch (node.type) {
            case 0 /* VNodeType.Text */:
                // VText has no special capability, fallback to the owner's renderer
                mountText(node, parent, anchor, renderer);
                break;
            case 1 /* VNodeType.Comment */:
                // VComment has no special capability, fallback to the owner's renderer
                mountComment(node, parent, anchor, renderer);
                break;
            case 4 /* VNodeType.Static */:
                // VStatic cannot have a custom renderer associated to them, using owner's renderer
                mountStatic(node, parent, anchor, renderer);
                break;
            case 5 /* VNodeType.Fragment */:
                mountFragment(node, parent, anchor, renderer);
                break;
            case 2 /* VNodeType.Element */:
                // If the vnode data has a renderer override use it, else fallback to owner's renderer
                mountElement(node, parent, anchor, node.data.renderer ?? renderer);
                break;
            case 3 /* VNodeType.CustomElement */:
                // If the vnode data has a renderer override use it, else fallback to owner's renderer
                mountCustomElement(node, parent, anchor, node.data.renderer ?? renderer);
                break;
        }
    }
    function mountText(vnode, parent, anchor, renderer) {
        const { owner } = vnode;
        const { createText } = renderer;
        const textNode = (vnode.elm = createText(vnode.text));
        linkNodeToShadow(textNode, owner, renderer);
        insertNode(textNode, parent, anchor, renderer);
    }
    function patchComment(n1, n2, renderer) {
        n2.elm = n1.elm;
        // FIXME: Comment nodes should be static, we shouldn't need to diff them together. However
        // it is the case today.
        if (n2.text !== n1.text) {
            updateTextContent$1(n2, renderer);
        }
    }
    function mountComment(vnode, parent, anchor, renderer) {
        const { owner } = vnode;
        const { createComment } = renderer;
        const commentNode = (vnode.elm = createComment(vnode.text));
        linkNodeToShadow(commentNode, owner, renderer);
        insertNode(commentNode, parent, anchor, renderer);
    }
    function mountFragment(vnode, parent, anchor, renderer) {
        const { children } = vnode;
        mountVNodes(children, parent, renderer, anchor);
        vnode.elm = vnode.leading.elm;
    }
    function patchFragment(n1, n2, parent, renderer) {
        const { children, stable } = n2;
        if (stable) {
            updateStaticChildren(n1.children, children, parent, renderer);
        }
        else {
            updateDynamicChildren(n1.children, children, parent, renderer);
        }
        // Note: not reusing n1.elm, because during patching, it may be patched with another text node.
        n2.elm = n2.leading.elm;
    }
    function mountElement(vnode, parent, anchor, renderer) {
        const { sel, owner, data: { svg }, } = vnode;
        const { createElement } = renderer;
        const namespace = isTrue(svg) ? SVG_NAMESPACE : undefined;
        const elm = (vnode.elm = createElement(sel, namespace));
        linkNodeToShadow(elm, owner, renderer);
        applyStyleScoping(elm, owner, renderer);
        applyDomManual(elm, vnode);
        applyElementRestrictions(elm, vnode);
        patchElementPropsAndAttrsAndRefs$1(null, vnode, renderer);
        insertNode(elm, parent, anchor, renderer);
        mountVNodes(vnode.children, elm, renderer, null);
    }
    function patchStatic(n1, n2, renderer) {
        n2.elm = n1.elm;
        // slotAssignments can only apply to the top level element, never to a static part.
        patchSlotAssignment(n1, n2, renderer);
        // The `refs` object is blown away in every re-render, so we always need to re-apply them
        patchStaticParts(n1, n2, renderer);
    }
    function patchElement(n1, n2, renderer) {
        const elm = (n2.elm = n1.elm);
        patchElementPropsAndAttrsAndRefs$1(n1, n2, renderer);
        patchChildren(n1.children, n2.children, elm, renderer);
    }
    function mountStatic(vnode, parent, anchor, renderer) {
        const { owner } = vnode;
        const { cloneNode, isSyntheticShadowDefined } = renderer;
        const elm = (vnode.elm = cloneNode(vnode.fragment, true));
        // Define the root node shadow resolver
        linkNodeToShadow(elm, owner, renderer);
        applyElementRestrictions(elm, vnode);
        const { renderMode, shadowMode } = owner;
        if (isSyntheticShadowDefined) {
            // Marks this node as Static to propagate the shadow resolver. must happen after elm is assigned to the proper shadow
            if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {
                elm[KEY__SHADOW_STATIC] = true;
            }
        }
        // slotAssignments can only apply to the top level element, never to a static part.
        patchSlotAssignment(null, vnode, renderer);
        mountStaticParts(elm, vnode, renderer);
        insertNode(elm, parent, anchor, renderer);
    }
    function mountCustomElement(vnode, parent, anchor, renderer) {
        const { sel, owner, ctor } = vnode;
        const { createCustomElement } = renderer;
        /**
         * Note: if the upgradable constructor does not expect, or throw when we new it
         * with a callback as the first argument, we could implement a more advanced
         * mechanism that only passes that argument if the constructor is known to be
         * an upgradable custom element.
         */
        let vm;
        const upgradeCallback = (elm) => {
            // the custom element from the registry is expecting an upgrade callback
            vm = createViewModelHook(elm, vnode, renderer);
        };
        // Should never get a tag with upper case letter at this point; the compiler
        // should produce only tags with lowercase letters. However, the Java
        // compiler may generate tagnames with uppercase letters so - for backwards
        // compatibility, we lower case the tagname here.
        const normalizedTagname = sel.toLowerCase();
        const useNativeLifecycle = shouldUseNativeCustomElementLifecycle(ctor);
        const isFormAssociated = shouldBeFormAssociated(ctor);
        const elm = createCustomElement(normalizedTagname, upgradeCallback, useNativeLifecycle, isFormAssociated);
        vnode.elm = elm;
        vnode.vm = vm;
        linkNodeToShadow(elm, owner, renderer);
        applyStyleScoping(elm, owner, renderer);
        if (vm) {
            allocateChildren(vnode, vm);
        }
        patchElementPropsAndAttrsAndRefs$1(null, vnode, renderer);
        insertNode(elm, parent, anchor, renderer);
        if (vm) {
            {
                if (!useNativeLifecycle) {
                    {
                        // With synthetic lifecycle callbacks, it's possible for elements to be removed without the engine
                        // noticing it (e.g. `appendChild` the same host element twice). This test ensures we don't regress.
                        assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);
                    }
                    runConnectedCallback(vm);
                }
            }
        }
        mountVNodes(vnode.children, elm, renderer, null);
        if (vm) {
            appendVM(vm);
        }
    }
    function patchCustomElement(n1, n2, parent, renderer) {
        // TODO [#3331]: This if branch should be removed in 246 with lwc:dynamic
        if (n1.ctor !== n2.ctor) {
            // If the constructor differs, unmount the current component and mount a new one using the new
            // constructor.
            const anchor = renderer.nextSibling(n1.elm);
            unmount(n1, parent, renderer, true);
            mountCustomElement(n2, parent, anchor, renderer);
        }
        else {
            // Otherwise patch the existing component with new props/attrs/etc.
            const elm = (n2.elm = n1.elm);
            const vm = (n2.vm = n1.vm);
            patchElementPropsAndAttrsAndRefs$1(n1, n2, renderer);
            if (!isUndefined$1(vm)) {
                // in fallback mode, the allocation will always set children to
                // empty and delegate the real allocation to the slot elements
                allocateChildren(n2, vm);
                // Solves an edge case with slotted VFragments in native shadow mode.
                //
                // During allocation, in native shadow, slotted VFragment nodes are flattened and their text delimiters are removed
                // to avoid interfering with native slot behavior. When this happens, if any of the fragments
                // were not stable, the children must go through the dynamic diffing algo.
                //
                // If the new children (n2.children) contain no VFragments, but the previous children (n1.children) were dynamic,
                // the new nodes must be marked dynamic so that all nodes are properly updated. The only indicator that the new
                // nodes need to be dynamic comes from the previous children, so we check that to determine whether we need to
                // mark the new children dynamic.
                //
                // Example:
                // n1.children: [div, VFragment('', div, null, ''), div] => [div, div, null, div]; // marked dynamic
                // n2.children: [div, null, div] => [div, null, div] // marked ???
                const { shadowMode, renderMode } = vm;
                if (shadowMode == 0 /* ShadowMode.Native */ &&
                    renderMode !== 0 /* RenderMode.Light */ &&
                    hasDynamicChildren(n1.children)) {
                    // No-op if children has already been marked dynamic by 'allocateChildren()'.
                    markAsDynamicChildren(n2.children);
                }
            }
            // in fallback mode, the children will be always empty, so, nothing
            // will happen, but in native, it does allocate the light dom
            patchChildren(n1.children, n2.children, elm, renderer);
            if (!isUndefined$1(vm)) {
                // this will probably update the shadowRoot, but only if the vm is in a dirty state
                // this is important to preserve the top to bottom synchronous rendering phase.
                rerenderVM(vm);
            }
        }
    }
    function mountVNodes(vnodes, parent, renderer, anchor, start = 0, end = vnodes.length) {
        for (; start < end; ++start) {
            const vnode = vnodes[start];
            if (isVNode(vnode)) {
                mount(vnode, parent, renderer, anchor);
            }
        }
    }
    function unmount(vnode, parent, renderer, doRemove = false) {
        const { type, elm, sel } = vnode;
        // When unmounting a VNode subtree not all the elements have to removed from the DOM. The
        // subtree root, is the only element worth unmounting from the subtree.
        if (doRemove && type !== 5 /* VNodeType.Fragment */) {
            // The vnode might or might not have a data.renderer associated to it
            // but the removal used here is from the owner instead.
            removeNode(elm, parent, renderer);
        }
        switch (type) {
            case 5 /* VNodeType.Fragment */: {
                unmountVNodes(vnode.children, parent, renderer, doRemove);
                break;
            }
            case 2 /* VNodeType.Element */: {
                // Slot content is removed to trigger slotchange event when removing slot.
                // Only required for synthetic shadow.
                const shouldRemoveChildren = sel === 'slot' && vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;
                unmountVNodes(vnode.children, elm, renderer, shouldRemoveChildren);
                break;
            }
            case 3 /* VNodeType.CustomElement */: {
                const { vm } = vnode;
                // No need to unmount the children here, `removeVM` will take care of removing the
                // children.
                if (!isUndefined$1(vm)) {
                    removeVM(vm);
                }
            }
        }
    }
    function unmountVNodes(vnodes, parent, renderer, doRemove = false, start = 0, end = vnodes.length) {
        for (; start < end; ++start) {
            const ch = vnodes[start];
            if (isVNode(ch)) {
                unmount(ch, parent, renderer, doRemove);
            }
        }
    }
    function isVNode(vnode) {
        return vnode != null;
    }
    function linkNodeToShadow(elm, owner, renderer) {
        const { renderRoot, renderMode, shadowMode } = owner;
        const { isSyntheticShadowDefined } = renderer;
        // TODO [#1164]: this should eventually be done by the polyfill directly
        if (isSyntheticShadowDefined) {
            if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {
                elm[KEY__SHADOW_RESOLVER] = renderRoot[KEY__SHADOW_RESOLVER];
            }
        }
    }
    function insertFragmentOrNode(vnode, parent, anchor, renderer) {
        {
            unlockDomMutation();
        }
        if (isVFragment(vnode)) {
            const children = vnode.children;
            for (let i = 0; i < children.length; i += 1) {
                const child = children[i];
                if (!isNull(child)) {
                    renderer.insert(child.elm, parent, anchor);
                }
            }
        }
        else {
            renderer.insert(vnode.elm, parent, anchor);
        }
        {
            lockDomMutation();
        }
    }
    function insertNode(node, parent, anchor, renderer) {
        {
            unlockDomMutation();
        }
        renderer.insert(node, parent, anchor);
        {
            lockDomMutation();
        }
    }
    function removeNode(node, parent, renderer) {
        {
            unlockDomMutation();
        }
        renderer.remove(node, parent);
        {
            lockDomMutation();
        }
    }
    function patchElementPropsAndAttrsAndRefs$1(oldVnode, vnode, renderer) {
        if (isNull(oldVnode)) {
            applyEventListeners(vnode, renderer);
            applyStaticClassAttribute(vnode, renderer);
            applyStaticStyleAttribute(vnode, renderer);
        }
        const { owner } = vnode;
        // Attrs need to be applied to element before props IE11 will wipe out value on radio inputs if
        // value is set before type=radio.
        patchClassAttribute(oldVnode, vnode, renderer);
        patchStyleAttribute(oldVnode, vnode, renderer, owner);
        patchAttributes(oldVnode, vnode, renderer);
        patchProps(oldVnode, vnode, renderer);
        patchSlotAssignment(oldVnode, vnode, renderer);
        // The `refs` object is blown away in every re-render, so we always need to re-apply them
        applyRefs(vnode, owner);
    }
    function applyStyleScoping(elm, owner, renderer) {
        const { getClassList } = renderer;
        // Set the class name for `*.scoped.css` style scoping.
        const scopeToken = getScopeTokenClass(owner, /* legacy */ false);
        if (!isNull(scopeToken)) {
            // TODO [#2762]: this dot notation with add is probably problematic
            // probably we should have a renderer api for just the add operation
            getClassList(elm).add(scopeToken);
        }
        // TODO [#3733]: remove support for legacy scope tokens
        if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {
            const legacyScopeToken = getScopeTokenClass(owner, /* legacy */ true);
            if (!isNull(legacyScopeToken)) {
                // TODO [#2762]: this dot notation with add is probably problematic
                // probably we should have a renderer api for just the add operation
                getClassList(elm).add(legacyScopeToken);
            }
        }
        // Set property element for synthetic shadow DOM style scoping.
        const { stylesheetToken: syntheticToken } = owner.context;
        if (owner.shadowMode === 1 /* ShadowMode.Synthetic */) {
            if (!isUndefined$1(syntheticToken)) {
                elm.$shadowToken$ = syntheticToken;
            }
            if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {
                const legacyToken = owner.context.legacyStylesheetToken;
                if (!isUndefined$1(legacyToken)) {
                    elm.$legacyShadowToken$ = legacyToken;
                }
            }
        }
    }
    function applyDomManual(elm, vnode) {
        const { owner, data: { context }, } = vnode;
        if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && context?.lwc?.dom === "manual" /* LwcDomMode.Manual */) {
            elm.$domManual$ = true;
        }
    }
    function applyElementRestrictions(elm, vnode) {
        {
            const isSynthetic = vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;
            const isPortal = vnode.type === 2 /* VNodeType.Element */ && vnode.data.context?.lwc?.dom === "manual" /* LwcDomMode.Manual */;
            const isLight = vnode.owner.renderMode === 0 /* RenderMode.Light */;
            patchElementWithRestrictions(elm, {
                isPortal,
                isLight,
                isSynthetic,
            });
        }
    }
    function allocateChildren(vnode, vm) {
        // A component with slots will re-render because:
        // 1- There is a change of the internal state.
        // 2- There is a change on the external api (ex: slots)
        //
        // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the
        // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children
        // in a reused VCustomElement, there won't be any slotted children.
        // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.
        //
        // In case #2, we will always get a fresh VCustomElement.
        const children = vnode.aChildren || vnode.children;
        const { renderMode, shadowMode } = vm;
        {
            // If any of the children being allocated is a scoped slot fragment, make sure the receiving
            // component is a light DOM component. This is mainly to validate light dom parent running
            // in native shadow mode.
            if (renderMode !== 0 /* RenderMode.Light */ &&
                ArraySome.call(children, (child) => !isNull(child) && isVScopedSlotFragment(child))) {
                logError(`Invalid usage of 'lwc:slot-data' on ${getComponentTag(vm)} tag. Scoped slot content can only be passed to a light dom child.`);
            }
        }
        // If any of the children being allocated are VFragments, we remove the text delimiters and flatten all immediate
        // children VFragments to avoid them interfering with default slot behavior.
        const allocatedChildren = flattenFragmentsInChildren(children);
        vnode.children = allocatedChildren;
        vm.aChildren = allocatedChildren;
        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {
            // slow path
            allocateInSlot(vm, allocatedChildren, vnode.owner);
            // save the allocated children in case this vnode is reused.
            vnode.aChildren = allocatedChildren;
            // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
            vnode.children = EmptyArray;
        }
    }
    /**
     * Flattens the contents of all VFragments in an array of VNodes, removes the text delimiters on those VFragments, and
     * marks the resulting children array as dynamic. Uses a stack (array) to iteratively traverse the nested VFragments
     * and avoid the perf overhead of creating/destroying throwaway arrays/objects in a recursive approach.
     *
     * With the delimiters removed, the contents are marked dynamic so they are diffed correctly.
     *
     * This function is used for slotted VFragments to avoid the text delimiters interfering with slotting functionality.
     * @param children
     */
    function flattenFragmentsInChildren(children) {
        const flattenedChildren = [];
        // Initialize our stack with the direct children of the custom component and check whether we have a VFragment.
        // If no VFragment is found in children, we don't need to traverse anything or mark the children dynamic and can return early.
        const nodeStack = [];
        let fragmentFound = false;
        for (let i = children.length - 1; i > -1; i -= 1) {
            const child = children[i];
            ArrayPush$1.call(nodeStack, child);
            fragmentFound = fragmentFound || !!(child && isVFragment(child));
        }
        if (!fragmentFound) {
            return children;
        }
        let currentNode;
        while (!isUndefined$1((currentNode = ArrayPop.call(nodeStack)))) {
            if (!isNull(currentNode) && isVFragment(currentNode)) {
                const fChildren = currentNode.children;
                // Ignore the start and end text node delimiters
                for (let i = fChildren.length - 2; i > 0; i -= 1) {
                    ArrayPush$1.call(nodeStack, fChildren[i]);
                }
            }
            else {
                ArrayPush$1.call(flattenedChildren, currentNode);
            }
        }
        // We always mark the children as dynamic because nothing generates stable VFragments yet.
        // If/when stable VFragments are generated by the compiler, this code should be updated to
        // not mark dynamic if all flattened VFragments were stable.
        markAsDynamicChildren(flattenedChildren);
        return flattenedChildren;
    }
    function createViewModelHook(elm, vnode, renderer) {
        let vm = getAssociatedVMIfPresent(elm);
        // There is a possibility that a custom element is registered under tagName, in which case, the
        // initialization is already carry on, and there is nothing else to do here since this hook is
        // called right after invoking `document.createElement`.
        if (!isUndefined$1(vm)) {
            return vm;
        }
        const { sel, mode, ctor, owner } = vnode;
        vm = createVM(elm, ctor, renderer, {
            mode,
            owner,
            tagName: sel,
        });
        {
            assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
        }
        return vm;
    }
    function allocateInSlot(vm, children, owner) {
        const { cmpSlots: { slotAssignments: oldSlotsMapping }, } = vm;
        const cmpSlotsMapping = create(null);
        // Collect all slots into cmpSlotsMapping
        for (let i = 0, len = children.length; i < len; i += 1) {
            const vnode = children[i];
            if (isNull(vnode)) {
                continue;
            }
            let slotName = '';
            if (isVBaseElement(vnode) || isVStatic(vnode)) {
                slotName = vnode.slotAssignment ?? '';
            }
            else if (isVScopedSlotFragment(vnode)) {
                slotName = vnode.slotName;
            }
            // Can't use toString here because Symbol(1).toString() is 'Symbol(1)'
            // but elm.setAttribute('slot', Symbol(1)) is an error.
            // the following line also throws same error for symbols
            // Similar for Object.create(null)
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            const normalizedSlotName = '' + slotName;
            const vnodes = (cmpSlotsMapping[normalizedSlotName] =
                cmpSlotsMapping[normalizedSlotName] || []);
            ArrayPush$1.call(vnodes, vnode);
        }
        vm.cmpSlots = { owner, slotAssignments: cmpSlotsMapping };
        if (isFalse(vm.isDirty)) {
            // We need to determine if the old allocation is really different from the new one
            // and mark the vm as dirty
            const oldKeys = keys(oldSlotsMapping);
            if (oldKeys.length !== keys(cmpSlotsMapping).length) {
                markComponentAsDirty(vm);
                return;
            }
            for (let i = 0, len = oldKeys.length; i < len; i += 1) {
                const key = oldKeys[i];
                if (isUndefined$1(cmpSlotsMapping[key]) ||
                    oldSlotsMapping[key].length !== cmpSlotsMapping[key].length) {
                    markComponentAsDirty(vm);
                    return;
                }
                const oldVNodes = oldSlotsMapping[key];
                const vnodes = cmpSlotsMapping[key];
                for (let j = 0, a = cmpSlotsMapping[key].length; j < a; j += 1) {
                    if (oldVNodes[j] !== vnodes[j]) {
                        markComponentAsDirty(vm);
                        return;
                    }
                }
            }
        }
    }
    const DynamicChildren = new WeakSet();
    // dynamic children means it was either generated by an iteration in a template
    // or part of an unstable fragment, and will require a more complex diffing algo.
    function markAsDynamicChildren(children) {
        DynamicChildren.add(children);
    }
    function hasDynamicChildren(children) {
        return DynamicChildren.has(children);
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        const map = {};
        // TODO [#1637]: simplify this by assuming that all vnodes has keys
        for (let j = beginIdx; j <= endIdx; ++j) {
            const ch = children[j];
            if (isVNode(ch)) {
                const { key } = ch;
                if (key !== undefined) {
                    map[key] = j;
                }
            }
        }
        return map;
    }
    function updateDynamicChildren(oldCh, newCh, parent, renderer) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        const newChEnd = newCh.length - 1;
        let newEndIdx = newChEnd;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let before;
        let clonedOldCh = false;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (!isVNode(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (!isVNode(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (!isVNode(newStartVnode)) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (!isVNode(newEndVnode)) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newStartVnode)) {
                patch(oldStartVnode, newStartVnode, parent, renderer);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (isSameVnode(oldEndVnode, newEndVnode)) {
                patch(oldEndVnode, newEndVnode, parent, renderer);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patch(oldStartVnode, newEndVnode, parent, renderer);
                // In the case of fragments, the `elm` property of a vfragment points to the leading
                // anchor. To determine the next sibling of the whole fragment, we need to use the
                // trailing anchor as the argument to nextSibling():
                // [..., [leading, ...content, trailing], nextSibling, ...]
                let anchor;
                if (isVFragment(oldEndVnode)) {
                    anchor = renderer.nextSibling(oldEndVnode.trailing.elm);
                }
                else {
                    anchor = renderer.nextSibling(oldEndVnode.elm);
                }
                insertFragmentOrNode(oldStartVnode, parent, anchor, renderer);
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patch(oldEndVnode, newStartVnode, parent, renderer);
                insertFragmentOrNode(newStartVnode, parent, oldStartVnode.elm, renderer);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndefined$1(idxInOld)) {
                    // New element
                    mount(newStartVnode, parent, renderer, oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (isVNode(elmToMove)) {
                        if (elmToMove.sel !== newStartVnode.sel) {
                            // New element
                            mount(newStartVnode, parent, renderer, oldStartVnode.elm);
                        }
                        else {
                            patch(elmToMove, newStartVnode, parent, renderer);
                            // Delete the old child, but copy the array since it is read-only.
                            // The `oldCh` will be GC'ed after `updateDynamicChildren` is complete,
                            // so we only care about the `oldCh` object inside this function.
                            // To avoid cloning over and over again, we check `clonedOldCh`
                            // and only clone once.
                            if (!clonedOldCh) {
                                clonedOldCh = true;
                                oldCh = [...oldCh];
                            }
                            // We've already cloned at least once, so it's no longer read-only
                            oldCh[idxInOld] = undefined;
                            insertFragmentOrNode(elmToMove, parent, oldStartVnode.elm, renderer);
                        }
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an
                // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.
                let i = newEndIdx;
                let n;
                do {
                    n = newCh[++i];
                } while (!isVNode(n) && i < newChEnd);
                before = isVNode(n) ? n.elm : null;
                mountVNodes(newCh, parent, renderer, before, newStartIdx, newEndIdx + 1);
            }
            else {
                unmountVNodes(oldCh, parent, renderer, true, oldStartIdx, oldEndIdx + 1);
            }
        }
    }
    function updateStaticChildren(c1, c2, parent, renderer) {
        const c1Length = c1.length;
        const c2Length = c2.length;
        if (c1Length === 0) {
            // the old list is empty, we can directly insert anything new
            mountVNodes(c2, parent, renderer, null);
            return;
        }
        if (c2Length === 0) {
            // the old list is nonempty and the new list is empty so we can directly remove all old nodes
            // this is the case in which the dynamic children of an if-directive should be removed
            unmountVNodes(c1, parent, renderer, true);
            return;
        }
        // if the old list is not empty, the new list MUST have the same
        // amount of nodes, that's why we call this static children
        let anchor = null;
        for (let i = c2Length - 1; i >= 0; i -= 1) {
            const n1 = c1[i];
            const n2 = c2[i];
            if (n2 !== n1) {
                if (isVNode(n1)) {
                    if (isVNode(n2)) {
                        if (isSameVnode(n1, n2)) {
                            // both vnodes are equivalent, and we just need to patch them
                            patch(n1, n2, parent, renderer);
                            anchor = n2.elm;
                        }
                        else {
                            // removing the old vnode since the new one is different
                            unmount(n1, parent, renderer, true);
                            mount(n2, parent, renderer, anchor);
                            anchor = n2.elm;
                        }
                    }
                    else {
                        // removing the old vnode since the new one is null
                        unmount(n1, parent, renderer, true);
                    }
                }
                else if (isVNode(n2)) {
                    mount(n2, parent, renderer, anchor);
                    anchor = n2.elm;
                }
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const SymbolIterator = Symbol.iterator;
    function addVNodeToChildLWC(vnode) {
        ArrayPush$1.call(getVMBeingRendered().velements, vnode);
    }
    // [s]tatic [p]art
    function sp(partId, data, text) {
        // Static part will always have either text or data, it's guaranteed by the compiler.
        const type = isNull(text) ? 1 /* VStaticPartType.Element */ : 0 /* VStaticPartType.Text */;
        return {
            type,
            partId,
            data,
            text,
            elm: undefined, // elm is defined later
        };
    }
    // [s]coped [s]lot [f]actory
    function ssf(slotName, factory) {
        return {
            type: 6 /* VNodeType.ScopedSlotFragment */,
            factory,
            owner: getVMBeingRendered(),
            elm: undefined,
            sel: '__scoped_slot_fragment__',
            key: undefined,
            slotName,
        };
    }
    // [st]atic node
    function st(fragmentFactory, key, parts) {
        const owner = getVMBeingRendered();
        const fragment = fragmentFactory(parts);
        const vnode = {
            type: 4 /* VNodeType.Static */,
            sel: '__static__',
            key,
            elm: undefined,
            fragment,
            owner,
            parts,
            slotAssignment: undefined,
        };
        return vnode;
    }
    // [fr]agment node
    function fr(key, children, stable) {
        const owner = getVMBeingRendered();
        const useCommentNodes = isAPIFeatureEnabled(5 /* APIFeature.USE_COMMENTS_FOR_FRAGMENT_BOOKENDS */, owner.apiVersion);
        const leading = useCommentNodes ? co('') : t('');
        const trailing = useCommentNodes ? co('') : t('');
        return {
            type: 5 /* VNodeType.Fragment */,
            sel: '__fragment__',
            key,
            elm: undefined,
            children: [leading, ...children, trailing],
            stable,
            owner,
            leading,
            trailing,
        };
    }
    // [h]tml node
    function h(sel, data, children = EmptyArray) {
        const vmBeingRendered = getVMBeingRendered();
        {
            assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);
            assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);
            assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);
            assert.isTrue('key' in data, ` <${sel}> "key" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`);
            // checking reserved internal data properties
            assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);
            assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);
            forEach.call(children, (childVnode) => {
                if (childVnode != null) {
                    assert.isTrue('type' in childVnode &&
                        'sel' in childVnode &&
                        'elm' in childVnode &&
                        'key' in childVnode, `${childVnode} is not a vnode.`);
                }
            });
        }
        const { key, slotAssignment } = data;
        const vnode = {
            type: 2 /* VNodeType.Element */,
            sel,
            data,
            children,
            elm: undefined,
            key,
            owner: vmBeingRendered,
            slotAssignment,
        };
        return vnode;
    }
    // [t]ab[i]ndex function
    function ti(value) {
        // if value is greater than 0, we normalize to 0
        // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
        // If value is less than -1, we don't care
        const shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));
        {
            const vmBeingRendered = getVMBeingRendered();
            if (shouldNormalize) {
                logError(`Invalid tabindex value \`${toString$1(value)}\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);
            }
        }
        return shouldNormalize ? 0 : value;
    }
    // [s]lot element node
    function s(slotName, data, children, slotset) {
        {
            assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);
            assert.isTrue(isObject(data), `s() 2nd argument data must be an object.`);
            assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);
        }
        const vmBeingRendered = getVMBeingRendered();
        const { renderMode, apiVersion } = vmBeingRendered;
        if (!isUndefined$1(slotset) &&
            !isUndefined$1(slotset.slotAssignments) &&
            !isUndefined$1(slotset.slotAssignments[slotName]) &&
            slotset.slotAssignments[slotName].length !== 0) {
            const newChildren = [];
            const slotAssignments = slotset.slotAssignments[slotName];
            for (let i = 0; i < slotAssignments.length; i++) {
                const vnode = slotAssignments[i];
                if (!isNull(vnode)) {
                    const assignedNodeIsScopedSlot = isVScopedSlotFragment(vnode);
                    // The only sniff test for a scoped <slot> element is the presence of `slotData`
                    const isScopedSlotElement = !isUndefined$1(data.slotData);
                    // Check if slot types of parent and child are matching
                    if (assignedNodeIsScopedSlot !== isScopedSlotElement) {
                        {
                            logError(`Mismatched slot types for ${slotName === '' ? '(default)' : slotName} slot. Both parent and child component must use standard type or scoped type for a given slot.`, slotset.owner);
                        }
                        // Ignore slot content from parent
                        continue;
                    }
                    // If the passed slot content is factory, evaluate it and add the produced vnodes
                    if (assignedNodeIsScopedSlot) {
                        // Evaluate in the scope of the slot content's owner
                        // if a slotset is provided, there will always be an owner. The only case where owner is
                        // undefined is for root components, but root components cannot accept slotted content
                        setVMBeingRendered(slotset.owner);
                        try {
                            // The factory function is a template snippet from the slot set owner's template,
                            // hence switch over to the slot set owner's template reactive observer
                            const { tro } = slotset.owner;
                            tro.observe(() => {
                                ArrayPush$1.call(newChildren, vnode.factory(data.slotData, data.key));
                            });
                        }
                        finally {
                            setVMBeingRendered(vmBeingRendered);
                        }
                    }
                    else {
                        // This block is for standard slots (non-scoped slots)
                        let clonedVNode;
                        if (renderMode === 0 /* RenderMode.Light */ &&
                            isAPIFeatureEnabled(6 /* APIFeature.USE_LIGHT_DOM_SLOT_FORWARDING */, apiVersion) &&
                            (isVBaseElement(vnode) || isVStatic(vnode)) &&
                            // We only need to copy the vnodes when the slot assignment changes, copying every time causes issues with
                            // disconnected/connected callback firing.
                            vnode.slotAssignment !== data.slotAssignment) {
                            // When the light DOM slot assignment (slot attribute) changes we can't use the same reference
                            // to the vnode because the current way the diffing algo works, it will replace the original reference
                            // to the host element with a new one. This means the new element will be mounted and immediately unmounted.
                            // Creating a copy of the vnode to preserve a reference to the previous host element.
                            if (isUndefined$1(vnode.elm)) {
                                // vnode.elm is undefined during initial render.
                                // We don't need to clone at this point because it doesn't need to be unmounted.
                                vnode.slotAssignment = data.slotAssignment;
                            }
                            else {
                                // Clone when the vnode.elm is defined to ensure we don't lose reference to the previous element.
                                // This is specifically for slot forwarding.
                                clonedVNode = { ...vnode, slotAssignment: data.slotAssignment };
                            }
                        }
                        // If the slot content is standard type, the content is static, no additional
                        // processing needed on the vnode
                        ArrayPush$1.call(newChildren, clonedVNode ?? vnode);
                    }
                }
            }
            children = newChildren;
        }
        const { shadowMode } = vmBeingRendered;
        if (renderMode === 0 /* RenderMode.Light */) {
            // light DOM slots - backwards-compatible behavior uses flattening, new behavior uses fragments
            if (isAPIFeatureEnabled(2 /* APIFeature.USE_FRAGMENTS_FOR_LIGHT_DOM_SLOTS */, apiVersion)) {
                return fr(data.key, children, 0);
            }
            else {
                sc(children);
                return children;
            }
        }
        if (shadowMode === 1 /* ShadowMode.Synthetic */) {
            // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
            sc(children);
        }
        return h('slot', data, children);
    }
    // [c]ustom element node
    function c(sel, Ctor, data, children = EmptyArray) {
        const vmBeingRendered = getVMBeingRendered();
        {
            assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);
            assert.isTrue(isFunction$1(Ctor), `c() 2nd argument Ctor must be a function.`);
            assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);
            assert.isTrue(arguments.length === 3 || isArray$1(children), `c() 4nd argument data must be an array.`);
            // checking reserved internal data properties
            assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);
            assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);
            if (data.style && !isString(data.style)) {
                logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);
            }
            if (arguments.length === 4) {
                forEach.call(children, (childVnode) => {
                    if (childVnode != null) {
                        assert.isTrue('type' in childVnode &&
                            'sel' in childVnode &&
                            'elm' in childVnode &&
                            'key' in childVnode, `${childVnode} is not a vnode.`);
                    }
                });
            }
        }
        const { key, slotAssignment } = data;
        let elm, aChildren, vm;
        const vnode = {
            type: 3 /* VNodeType.CustomElement */,
            sel,
            data,
            children,
            elm,
            key,
            slotAssignment,
            ctor: Ctor,
            owner: vmBeingRendered,
            mode: 'open', // TODO [#1294]: this should be defined in Ctor
            aChildren,
            vm,
        };
        addVNodeToChildLWC(vnode);
        return vnode;
    }
    // [i]terable node
    function i(iterable, factory) {
        const list = [];
        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(list);
        const vmBeingRendered = getVMBeingRendered();
        if (isUndefined$1(iterable) || iterable === null) {
            {
                logError(`Invalid template iteration for value "${toString$1(iterable)}" in ${vmBeingRendered}. It must be an Array or an iterable Object.`, vmBeingRendered);
            }
            return list;
        }
        {
            assert.isFalse(isUndefined$1(iterable[SymbolIterator]), `Invalid template iteration for value \`${toString$1(iterable)}\` in ${vmBeingRendered}. It must be an array-like object and not \`null\` nor \`undefined\`.`);
        }
        const iterator = iterable[SymbolIterator]();
        {
            assert.isTrue(iterator && isFunction$1(iterator.next), `Invalid iterator function for "${toString$1(iterable)}" in ${vmBeingRendered}.`);
        }
        let next = iterator.next();
        let j = 0;
        let { value, done: last } = next;
        let keyMap;
        let iterationError;
        {
            keyMap = create(null);
        }
        while (last === false) {
            // implementing a look-back-approach because we need to know if the element is the last
            next = iterator.next();
            last = next.done;
            // template factory logic based on the previous collected value
            const vnode = factory(value, j, j === 0, last === true);
            if (isArray$1(vnode)) {
                ArrayPush$1.apply(list, vnode);
            }
            else {
                ArrayPush$1.call(list, vnode);
            }
            {
                const vnodes = isArray$1(vnode) ? vnode : [vnode];
                forEach.call(vnodes, (childVnode) => {
                    // Check that the child vnode is either an element or VStatic
                    if (!isNull(childVnode) && (isVBaseElement(childVnode) || isVStatic(childVnode))) {
                        const { key } = childVnode;
                        // In @lwc/engine-server the fragment doesn't have a tagName, default to the VM's tagName.
                        const { tagName } = vmBeingRendered;
                        if (isString(key) || isNumber(key)) {
                            if (keyMap[key] === 1 && isUndefined$1(iterationError)) {
                                iterationError = `Duplicated "key" attribute value in "<${tagName}>" for item number ${j}. A key with value "${key}" appears more than once in the iteration. Key values must be unique numbers or strings.`;
                            }
                            keyMap[key] = 1;
                        }
                        else if (isUndefined$1(iterationError)) {
                            iterationError = `Invalid "key" attribute value in "<${tagName}>" for item number ${j}. Set a unique "key" value on all iterated child elements.`;
                        }
                    }
                });
            }
            // preparing next value
            j += 1;
            value = next.value;
        }
        {
            if (!isUndefined$1(iterationError)) {
                logError(iterationError, vmBeingRendered);
            }
        }
        return list;
    }
    /**
     * [f]lattening
     * @param items
     */
    function f(items) {
        {
            assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');
        }
        const len = items.length;
        const flattened = [];
        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(flattened);
        for (let j = 0; j < len; j += 1) {
            const item = items[j];
            if (isArray$1(item)) {
                ArrayPush$1.apply(flattened, item);
            }
            else {
                ArrayPush$1.call(flattened, item);
            }
        }
        return flattened;
    }
    // [t]ext node
    function t(text) {
        let key, elm;
        return {
            type: 0 /* VNodeType.Text */,
            sel: '__text__',
            text,
            elm,
            key,
            owner: getVMBeingRendered(),
        };
    }
    // [co]mment node
    function co(text) {
        let elm, key;
        return {
            type: 1 /* VNodeType.Comment */,
            sel: '__comment__',
            text,
            elm,
            key,
            owner: getVMBeingRendered(),
        };
    }
    // [d]ynamic text
    function d(value) {
        return value == null ? '' : String(value);
    }
    // [b]ind function
    function b(fn) {
        const vmBeingRendered = getVMBeingRendered();
        if (isNull(vmBeingRendered)) {
            throw new Error();
        }
        const vm = vmBeingRendered;
        return function (event) {
            invokeEventListener(vm, fn, vm.component, event);
        };
    }
    // [k]ey function
    function k(compilerKey, obj) {
        switch (typeof obj) {
            case 'number':
            case 'string':
                return compilerKey + ':' + obj;
            case 'object':
                {
                    logError(`Invalid key value "${obj}" in ${getVMBeingRendered()}. Key must be a string or number.`);
                }
        }
    }
    // [g]lobal [id] function
    function gid(id) {
        const vmBeingRendered = getVMBeingRendered();
        if (isUndefined$1(id) || id === '') {
            {
                logError(`Invalid id value "${id}". The id attribute must contain a non-empty string.`, vmBeingRendered);
            }
            return id;
        }
        // We remove attributes when they are assigned a value of null
        if (isNull(id)) {
            return null;
        }
        const { idx, shadowMode } = vmBeingRendered;
        if (shadowMode === 1 /* ShadowMode.Synthetic */) {
            return StringReplace.call(id, /\S+/g, (id) => `${id}-${idx}`);
        }
        return id;
    }
    // [f]ragment [id] function
    function fid(url) {
        const vmBeingRendered = getVMBeingRendered();
        if (isUndefined$1(url) || url === '') {
            {
                if (isUndefined$1(url)) {
                    logError(`Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.`, vmBeingRendered);
                }
            }
            return url;
        }
        // We remove attributes when they are assigned a value of null
        if (isNull(url)) {
            return null;
        }
        const { idx, shadowMode } = vmBeingRendered;
        // Apply transformation only for fragment-only-urls, and only in shadow DOM
        if (shadowMode === 1 /* ShadowMode.Synthetic */ && /^#/.test(url)) {
            return `${url}-${idx}`;
        }
        return url;
    }
    /**
     * [ddc] - create a (deprecated) dynamic component via `<x-foo lwc:dynamic={Ctor}>`
     *
     * TODO [#3331]: remove usage of lwc:dynamic in 246
     * @param sel
     * @param Ctor
     * @param data
     * @param children
     */
    function ddc(sel, Ctor, data, children = EmptyArray) {
        {
            assert.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);
            assert.isTrue(isObject(data), `dc() 3nd argument data must be an object.`);
            assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 4nd argument data must be an array.`);
        }
        // null or undefined values should produce a null value in the VNodes
        if (isNull(Ctor) || isUndefined$1(Ctor)) {
            return null;
        }
        if (!isComponentConstructor(Ctor)) {
            throw new Error(`Invalid LWC Constructor ${toString$1(Ctor)} for custom element <${sel}>.`);
        }
        return c(sel, Ctor, data, children);
    }
    /**
     * [dc] - create a dynamic component via `<lwc:component lwc:is={Ctor}>`
     * @param Ctor
     * @param data
     * @param children
     */
    function dc(Ctor, data, children = EmptyArray) {
        {
            assert.isTrue(isObject(data), `dc() 2nd argument data must be an object.`);
            assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 3rd argument data must be an array.`);
        }
        // Null or undefined values should produce a null value in the VNodes.
        // This is the only value at compile time as the constructor will not be known.
        if (isNull(Ctor) || isUndefined$1(Ctor)) {
            return null;
        }
        if (!isComponentConstructor(Ctor)) {
            throw new Error(`Invalid constructor ${toString$1(Ctor)} is not a LightningElement constructor.`);
        }
        // Look up the dynamic component's name at runtime once the constructor is available.
        // This information is only known at runtime and is stored as part of registerComponent.
        const sel = getComponentRegisteredName(Ctor);
        if (isUndefined$1(sel) || sel === '') {
            throw new Error(`Invalid LWC constructor ${toString$1(Ctor)} does not have a registered name`);
        }
        return c(sel, Ctor, data, children);
    }
    /**
     * slow children collection marking mechanism. this API allows the compiler to signal
     * to the engine that a particular collection of children must be diffed using the slow
     * algo based on keys due to the nature of the list. E.g.:
     *
     * - slot element's children: the content of the slot has to be dynamic when in synthetic
     * shadow mode because the `vnode.children` might be the slotted
     * content vs default content, in which case the size and the
     * keys are not matching.
     * - children that contain dynamic components
     * - children that are produced by iteration
     * @param vnodes
     */
    function sc(vnodes) {
        {
            assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');
        }
        // We have to mark the vnodes collection as dynamic so we can later on
        // choose to use the snabbdom virtual dom diffing algo instead of our
        // static dummy algo.
        markAsDynamicChildren(vnodes);
        return vnodes;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar
     * libraries to sanitize HTML content. This hook process the content passed via the template to
     * lwc:inner-html directive.
     * It is meant to be overridden with setSanitizeHtmlContentHook, it throws an error by default.
     */
    let sanitizeHtmlContentHook = () => {
        // locker-service patches this function during runtime to sanitize HTML content.
        throw new Error('sanitizeHtmlContent hook must be implemented.');
    };
    /**
     * Sets the sanitizeHtmlContentHook.
     * @param newHookImpl
     */
    function setSanitizeHtmlContentHook(newHookImpl) {
        sanitizeHtmlContentHook = newHookImpl;
    }
    // [s]anitize [h]tml [c]ontent
    function shc(content) {
        return sanitizeHtmlContentHook(content);
    }
    const api = freeze({
        s,
        h,
        c,
        i,
        f,
        t,
        d,
        b,
        k,
        co,
        dc,
        fr,
        ti,
        st,
        gid,
        fid,
        shc,
        ssf,
        ddc,
        sp,
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const operationIdNameMapping = [
        'constructor',
        'render',
        'patch',
        'connectedCallback',
        'renderedCallback',
        'disconnectedCallback',
        'errorCallback',
        'lwc-hydrate',
        'lwc-rehydrate',
    ];
    // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
    const isUserTimingSupported = typeof performance !== 'undefined' &&
        typeof performance.mark === 'function' &&
        typeof performance.clearMarks === 'function' &&
        typeof performance.measure === 'function' &&
        typeof performance.clearMeasures === 'function';
    const start = !isUserTimingSupported
        ? noop
        : (markName) => {
            performance.mark(markName);
        };
    const end = !isUserTimingSupported
        ? noop
        : (measureName, markName) => {
            performance.measure(measureName, markName);
            // Clear the created marks and measure to avoid filling the performance entries buffer.
            // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
            performance.clearMarks(markName);
            performance.clearMeasures(measureName);
        };
    function getOperationName(opId) {
        return operationIdNameMapping[opId];
    }
    function getMeasureName(opId, vm) {
        return `${getComponentTag(vm)} - ${getOperationName(opId)}`;
    }
    function getMarkName(opId, vm) {
        // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
        // the right measures for components that are recursive.
        return `${getMeasureName(opId, vm)} - ${vm.idx}`;
    }
    /** Indicates if operations should be logged by the profiler. */
    let isProfilerEnabled = false;
    /** The currently assigned profiler dispatcher. */
    let currentDispatcher = noop;
    const profilerControl = {
        enableProfiler() {
            isProfilerEnabled = true;
        },
        disableProfiler() {
            isProfilerEnabled = false;
        },
        attachDispatcher(dispatcher) {
            currentDispatcher = dispatcher;
            this.enableProfiler();
        },
        detachDispatcher() {
            const dispatcher = currentDispatcher;
            currentDispatcher = noop;
            this.disableProfiler();
            return dispatcher;
        },
    };
    function logOperationStart(opId, vm) {
        {
            const markName = getMarkName(opId, vm);
            start(markName);
        }
        if (isProfilerEnabled) {
            currentDispatcher(opId, 0 /* Phase.Start */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);
        }
    }
    function logOperationEnd(opId, vm) {
        {
            const markName = getMarkName(opId, vm);
            const measureName = getMeasureName(opId, vm);
            end(measureName, markName);
        }
        if (isProfilerEnabled) {
            currentDispatcher(opId, 1 /* Phase.Stop */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);
        }
    }
    function logGlobalOperationStart(opId, vm) {
        {
            const opName = getOperationName(opId);
            const markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);
            start(markName);
        }
        if (isProfilerEnabled) {
            currentDispatcher(opId, 0 /* Phase.Start */, vm?.tagName, vm?.idx, vm?.renderMode, vm?.shadowMode);
        }
    }
    function logGlobalOperationEnd(opId, vm) {
        {
            const opName = getOperationName(opId);
            const markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);
            end(opName, markName);
        }
        if (isProfilerEnabled) {
            currentDispatcher(opId, 1 /* Phase.Stop */, vm?.tagName, vm?.idx, vm?.renderMode, vm?.shadowMode);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let isUpdatingTemplate = false;
    let vmBeingRendered = null;
    function getVMBeingRendered() {
        return vmBeingRendered;
    }
    function setVMBeingRendered(vm) {
        vmBeingRendered = vm;
    }
    function validateSlots(vm) {
        const { cmpSlots } = vm;
        for (const slotName in cmpSlots.slotAssignments) {
            assert.isTrue(isArray$1(cmpSlots.slotAssignments[slotName]), `Slots can only be set to an array, instead received ${toString$1(cmpSlots.slotAssignments[slotName])} for slot "${slotName}" in ${vm}.`);
        }
    }
    function validateLightDomTemplate(template, vm) {
        if (template === defaultEmptyTemplate) {
            return;
        }
        if (vm.renderMode === 0 /* RenderMode.Light */) {
            if (template.renderMode !== 'light') {
                logError(`Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode="light"' directive to the root template tag of ${getComponentTag(vm)}.`);
            }
        }
        else {
            if (!isUndefined$1(template.renderMode)) {
                logError(`Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ${getComponentTag(vm)} or set it to 'lwc:render-mode="shadow"`);
            }
        }
    }
    const browserExpressionSerializer = (partToken, classAttrToken) => {
        // This will insert the scoped style token as a static class attribute in the fragment
        // bypassing the need to call applyStyleScoping when mounting static parts.
        const type = StringCharAt.call(partToken, 0);
        switch (type) {
            case "c" /* STATIC_PART_TOKEN_ID.CLASS */:
                return classAttrToken;
            case "t" /* STATIC_PART_TOKEN_ID.TEXT */:
                // Using a single space here gives us a single empty text node
                return ' ';
            default:
                return '';
        }
    };
    // This function serializes the expressions generated by static content optimization.
    // Currently this is only needed for SSR.
    // TODO [#4078]: Split the implementation between @lwc/engine-dom and @lwc/engine-server
    function buildSerializeExpressionFn(parts) {
        {
            return browserExpressionSerializer;
        }
    }
    function buildParseFragmentFn(createFragmentFn) {
        return (strings, ...keys) => {
            const cache = create(null);
            return function (parts) {
                const { context: { hasScopedStyles, stylesheetToken, legacyStylesheetToken }, shadowMode, renderer, } = getVMBeingRendered();
                const hasStyleToken = !isUndefined$1(stylesheetToken);
                const isSyntheticShadow = shadowMode === 1 /* ShadowMode.Synthetic */;
                const hasLegacyToken = lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS && !isUndefined$1(legacyStylesheetToken);
                let cacheKey = 0;
                if (hasStyleToken && hasScopedStyles) {
                    cacheKey |= 1 /* FragmentCache.HAS_SCOPED_STYLE */;
                }
                if (hasStyleToken && isSyntheticShadow) {
                    cacheKey |= 2 /* FragmentCache.SHADOW_MODE_SYNTHETIC */;
                }
                // Cache is only here to prevent calling innerHTML multiple times which doesn't happen on the server.
                {
                    // Disable this on the server to prevent cache poisoning when expressions are used.
                    const cached = cache[cacheKey];
                    if (!isUndefined$1(cached)) {
                        return cached;
                    }
                }
                // If legacy stylesheet tokens are required, then add them to the rendered string
                const stylesheetTokenToRender = stylesheetToken + (hasLegacyToken ? ` ${legacyStylesheetToken}` : '');
                const classToken = hasScopedStyles && hasStyleToken ? ' ' + stylesheetTokenToRender : '';
                const classAttrToken = hasScopedStyles && hasStyleToken ? ` class="${stylesheetTokenToRender}"` : '';
                const attrToken = hasStyleToken && isSyntheticShadow ? ' ' + stylesheetTokenToRender : '';
                // In the browser, we provide the entire class attribute as a perf optimization to avoid applying it on mount.
                // The remaining class expression will be applied when the static parts are mounted.
                // In SSR, the entire class attribute (expression included) is assembled along with the fragment.
                // This is why in the browser we provide the entire class attribute and in SSR we only provide the class token.
                const exprClassToken = classAttrToken ;
                // TODO [#3624]: The implementation of this function should be specific to @lwc/engine-dom and @lwc/engine-server.
                // Find a way to split this in a future refactor.
                const serializeExpression = buildSerializeExpressionFn();
                let htmlFragment = '';
                for (let i = 0, n = keys.length; i < n; i++) {
                    switch (keys[i]) {
                        case 0: // styleToken in existing class attr
                            htmlFragment += strings[i] + classToken;
                            break;
                        case 1: // styleToken for added class attr
                            htmlFragment += strings[i] + classAttrToken;
                            break;
                        case 2: // styleToken as attr
                            htmlFragment += strings[i] + attrToken;
                            break;
                        case 3: // ${1}${2}
                            htmlFragment += strings[i] + classAttrToken + attrToken;
                            break;
                        default: // expressions ${partId:attributeName/textId}
                            htmlFragment +=
                                strings[i] + serializeExpression(keys[i], exprClassToken);
                            break;
                    }
                }
                htmlFragment += strings[strings.length - 1];
                cache[cacheKey] = createFragmentFn(htmlFragment, renderer);
                return cache[cacheKey];
            };
        };
    }
    // Note: at the moment this code executes, we don't have a renderer yet.
    const parseFragment = buildParseFragmentFn((html, renderer) => {
        const { createFragment } = renderer;
        return createFragment(html);
    });
    const parseSVGFragment = buildParseFragmentFn((html, renderer) => {
        const { createFragment, getFirstChild } = renderer;
        const fragment = createFragment('<svg>' + html + '</svg>');
        return getFirstChild(fragment);
    });
    function evaluateTemplate(vm, html) {
        {
            // in dev-mode, we support hot swapping of templates, which means that
            // the component instance might be attempting to use an old version of
            // the template, while internally, we have a replacement for it.
            html = getTemplateOrSwappedTemplate(html);
        }
        const isUpdatingTemplateInception = isUpdatingTemplate;
        const vmOfTemplateBeingUpdatedInception = vmBeingRendered;
        let vnodes = [];
        runWithBoundaryProtection(vm, vm.owner, () => {
            // pre
            vmBeingRendered = vm;
            logOperationStart(1 /* OperationId.Render */, vm);
        }, () => {
            // job
            const { component, context, cmpSlots, cmpTemplate, tro } = vm;
            tro.observe(() => {
                // Reset the cache memoizer for template when needed.
                if (html !== cmpTemplate) {
                    // Check that the template was built by the compiler.
                    if (!isTemplateRegistered(html)) {
                        throw new TypeError(`Invalid template returned by the render() method on ${vm.tagName}. It must return an imported template (e.g.: \`import html from "./${vm.def.name}.html"\`), instead, it has returned: ${toString$1(html)}.`);
                    }
                    if ("development" !== 'production') {
                        validateLightDomTemplate(html, vm);
                    }
                    // Perf opt: do not reset the shadow root during the first rendering (there is
                    // nothing to reset).
                    if (!isNull(cmpTemplate)) {
                        // It is important to reset the content to avoid reusing similar elements
                        // generated from a different template, because they could have similar IDs,
                        // and snabbdom just rely on the IDs.
                        resetComponentRoot(vm);
                    }
                    vm.cmpTemplate = html;
                    // Create a brand new template cache for the swapped templated.
                    context.tplCache = create(null);
                    // Set the computeHasScopedStyles property in the context, to avoid recomputing it repeatedly.
                    context.hasScopedStyles = computeHasScopedStyles(html, vm);
                    // Update the scoping token on the host element.
                    updateStylesheetToken(vm, html, /* legacy */ false);
                    if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {
                        updateStylesheetToken(vm, html, /* legacy */ true);
                    }
                    // Evaluate, create stylesheet and cache the produced VNode for future
                    // re-rendering.
                    const stylesheetsContent = getStylesheetsContent(vm, html);
                    context.styleVNodes =
                        stylesheetsContent.length === 0
                            ? null
                            : createStylesheet(vm, stylesheetsContent);
                }
                if ("development" !== 'production') {
                    // validating slots in every rendering since the allocated content might change over time
                    validateSlots(vm);
                    // add the VM to the list of host VMs that can be re-rendered if html is swapped
                    setActiveVM(vm);
                }
                // right before producing the vnodes, we clear up all internal references
                // to custom elements from the template.
                vm.velements = [];
                // Set the global flag that template is being updated
                isUpdatingTemplate = true;
                vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
                const { styleVNodes } = context;
                if (!isNull(styleVNodes)) {
                    ArrayUnshift.apply(vnodes, styleVNodes);
                }
            });
        }, () => {
            // post
            isUpdatingTemplate = isUpdatingTemplateInception;
            vmBeingRendered = vmOfTemplateBeingUpdatedInception;
            logOperationEnd(1 /* OperationId.Render */, vm);
        });
        {
            if (!isArray$1(vnodes)) {
                logError(`Compiler should produce html functions that always return an array.`);
            }
        }
        return vnodes;
    }
    function computeHasScopedStylesInStylesheets(stylesheets) {
        if (hasStyles(stylesheets)) {
            for (let i = 0; i < stylesheets.length; i++) {
                if (isTrue(stylesheets[i][KEY__SCOPED_CSS])) {
                    return true;
                }
            }
        }
        return false;
    }
    function computeHasScopedStyles(template, vm) {
        const { stylesheets } = template;
        const vmStylesheets = !isUndefined$1(vm) ? vm.stylesheets : null;
        return (computeHasScopedStylesInStylesheets(stylesheets) ||
            computeHasScopedStylesInStylesheets(vmStylesheets));
    }
    function hasStyles(stylesheets) {
        return !isUndefined$1(stylesheets) && !isNull(stylesheets) && stylesheets.length > 0;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let isInvokingRender = false;
    let vmBeingConstructed = null;
    function isBeingConstructed(vm) {
        return vmBeingConstructed === vm;
    }
    function invokeComponentCallback(vm, fn, args) {
        const { component, callHook, owner } = vm;
        runWithBoundaryProtection(vm, owner, noop, () => {
            callHook(component, fn, args);
        }, noop);
    }
    function invokeComponentConstructor(vm, Ctor) {
        const vmBeingConstructedInception = vmBeingConstructed;
        let error;
        logOperationStart(0 /* OperationId.Constructor */, vm);
        vmBeingConstructed = vm;
        /**
         * Constructors don't need to be wrapped with a boundary because for root elements
         * it should throw, while elements from template are already wrapped by a boundary
         * associated to the diffing algo.
         */
        try {
            // job
            const result = new Ctor();
            // Check indirectly if the constructor result is an instance of LightningElement. Using
            // the "instanceof" operator would not work here since Locker Service provides its own
            // implementation of LightningElement, so we indirectly check if the base constructor is
            // invoked by accessing the component on the vm.
            if (vmBeingConstructed.component !== result) {
                throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
            }
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            logOperationEnd(0 /* OperationId.Constructor */, vm);
            vmBeingConstructed = vmBeingConstructedInception;
            if (!isUndefined$1(error)) {
                addErrorComponentStack(vm, error);
                // re-throwing the original error annotated after restoring the context
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
    }
    function invokeComponentRenderMethod(vm) {
        const { def: { render }, callHook, component, owner, } = vm;
        const isRenderBeingInvokedInception = isInvokingRender;
        const vmBeingRenderedInception = getVMBeingRendered();
        let html;
        let renderInvocationSuccessful = false;
        runWithBoundaryProtection(vm, owner, () => {
            // pre
            isInvokingRender = true;
            setVMBeingRendered(vm);
        }, () => {
            // job
            vm.tro.observe(() => {
                html = callHook(component, render);
                renderInvocationSuccessful = true;
            });
        }, () => {
            // post
            isInvokingRender = isRenderBeingInvokedInception;
            setVMBeingRendered(vmBeingRenderedInception);
        });
        // If render() invocation failed, process errorCallback in boundary and return an empty template
        return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
    }
    function invokeEventListener(vm, fn, thisValue, event) {
        const { callHook, owner } = vm;
        runWithBoundaryProtection(vm, owner, noop, () => {
            // job
            if ("development" !== 'production') {
                assert.isTrue(isFunction$1(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);
            }
            callHook(thisValue, fn, [event]);
        }, noop);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const registeredComponentMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     * @param Ctor
     * @param metadata
     */
    function registerComponent(
    // We typically expect a LightningElementConstructor, but technically you can call this with anything
    Ctor, metadata) {
        if (isFunction$1(Ctor)) {
            {
                // There is no point in running this in production, because the version mismatch check relies
                // on code comments which are stripped out in production by minifiers
                checkVersionMismatch(Ctor, 'component');
            }
            // TODO [#3331]: add validation to check the value of metadata.sel is not an empty string.
            registeredComponentMap.set(Ctor, metadata);
        }
        // chaining this method as a way to wrap existing assignment of component constructor easily,
        // without too much transformation
        return Ctor;
    }
    function getComponentRegisteredTemplate(Ctor) {
        return registeredComponentMap.get(Ctor)?.tmpl;
    }
    function getComponentRegisteredName(Ctor) {
        return registeredComponentMap.get(Ctor)?.sel;
    }
    function getComponentAPIVersion(Ctor) {
        const metadata = registeredComponentMap.get(Ctor);
        const apiVersion = metadata?.apiVersion;
        if (isUndefined$1(apiVersion)) {
            // This should only occur in our Karma tests; in practice every component
            // is registered, and so this code path should not get hit. But to be safe,
            // return the lowest possible version.
            return LOWEST_API_VERSION;
        }
        return apiVersion;
    }
    function getTemplateReactiveObserver(vm) {
        return createReactiveObserver(() => {
            const { isDirty } = vm;
            if (isFalse(isDirty)) {
                markComponentAsDirty(vm);
                scheduleRehydration(vm);
            }
        });
    }
    function resetTemplateObserverAndUnsubscribe(vm) {
        const { tro, component } = vm;
        tro.reset();
    }
    function renderComponent(vm) {
        {
            assert.invariant(vm.isDirty, `${vm} is not dirty.`);
        }
        // The engine should only hold a subscription to a signal if it is rendered in the template.
        // Because of the potential presence of conditional rendering logic, we unsubscribe on each render
        // in the scenario where it is present in one condition but not the other.
        // For example:
        // 1. There is an lwc:if=true conditional where the signal is present on the template.
        // 2. The lwc:if changes to false and the signal is no longer present on the template.
        // If the signal is still subscribed to, the template will re-render when it receives a notification
        // from the signal, even though we won't be using the new value.
        resetTemplateObserverAndUnsubscribe(vm);
        const vnodes = invokeComponentRenderMethod(vm);
        vm.isDirty = false;
        vm.isScheduled = false;
        return vnodes;
    }
    function markComponentAsDirty(vm) {
        {
            const vmBeingRendered = getVMBeingRendered();
            assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);
            assert.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);
            assert.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);
        }
        vm.isDirty = true;
    }
    const cmpEventListenerMap = new WeakMap();
    function getWrappedComponentsListener(vm, listener) {
        if (!isFunction$1(listener)) {
            throw new TypeError('Expected an EventListener but received ' + typeof listener); // avoiding problems with non-valid listeners
        }
        let wrappedListener = cmpEventListenerMap.get(listener);
        if (isUndefined$1(wrappedListener)) {
            wrappedListener = function (event) {
                invokeEventListener(vm, listener, undefined, event);
            };
            cmpEventListenerMap.set(listener, wrappedListener);
        }
        return wrappedListener;
    }

    /*
     * Copyright (c) 2024, Salesforce, Inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let idx = 0;
    /** The internal slot used to associate different objects the engine manipulates with the VM */
    const ViewModelReflection = new WeakMap();
    function callHook(cmp, fn, args = []) {
        return fn.apply(cmp, args);
    }
    function setHook(cmp, prop, newValue) {
        cmp[prop] = newValue;
    }
    function getHook(cmp, prop) {
        return cmp[prop];
    }
    function rerenderVM(vm) {
        rehydrate(vm);
    }
    function connectRootElement(elm) {
        const vm = getAssociatedVM(elm);
        logGlobalOperationStart(7 /* OperationId.GlobalHydrate */, vm);
        // Usually means moving the element from one place to another, which is observable via
        // life-cycle hooks.
        if (vm.state === 1 /* VMState.connected */) {
            disconnectRootElement(elm);
        }
        runConnectedCallback(vm);
        rehydrate(vm);
        logGlobalOperationEnd(7 /* OperationId.GlobalHydrate */, vm);
    }
    function disconnectRootElement(elm) {
        const vm = getAssociatedVM(elm);
        resetComponentStateWhenRemoved(vm);
    }
    function appendVM(vm) {
        rehydrate(vm);
    }
    // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.
    function resetComponentStateWhenRemoved(vm) {
        const { state } = vm;
        if (state !== 2 /* VMState.disconnected */) {
            // Making sure that any observing record will not trigger the rehydrated on this vm
            resetTemplateObserverAndUnsubscribe(vm);
            runDisconnectedCallback(vm);
            // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
            runChildNodesDisconnectedCallback(vm);
            runLightChildNodesDisconnectedCallback(vm);
        }
    }
    // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.
    function removeVM(vm) {
        {
            if (!shouldUseNativeCustomElementLifecycle(vm.component.constructor)) {
                // With native lifecycle, we cannot be certain that connectedCallback was called before a component
                // was removed from the VDOM. If the component is disconnected, then connectedCallback will not fire
                // in native mode, although it will fire in synthetic mode due to appendChild triggering it.
                // See: W-14037619 for details
                assert.isTrue(vm.state === 1 /* VMState.connected */ || vm.state === 2 /* VMState.disconnected */, `${vm} must have been connected.`);
            }
        }
        resetComponentStateWhenRemoved(vm);
    }
    function getNearestShadowAncestor(owner) {
        let ancestor = owner;
        while (!isNull(ancestor) && ancestor.renderMode === 0 /* RenderMode.Light */) {
            ancestor = ancestor.owner;
        }
        return ancestor;
    }
    function createVM(elm, ctor, renderer, options) {
        const { mode, owner, tagName, hydrated } = options;
        const def = getComponentInternalDef(ctor);
        const apiVersion = getComponentAPIVersion(ctor);
        const vm = {
            elm,
            def,
            idx: idx++,
            state: 0 /* VMState.created */,
            isScheduled: false,
            isDirty: true,
            tagName,
            mode,
            owner,
            refVNodes: null,
            children: EmptyArray,
            aChildren: EmptyArray,
            velements: EmptyArray,
            cmpProps: create(null),
            cmpFields: create(null),
            cmpSlots: { slotAssignments: create(null) },
            cmpTemplate: null,
            hydrated: Boolean(hydrated),
            renderMode: def.renderMode,
            context: {
                stylesheetToken: undefined,
                hasTokenInClass: undefined,
                hasTokenInAttribute: undefined,
                legacyStylesheetToken: undefined,
                hasLegacyTokenInClass: undefined,
                hasLegacyTokenInAttribute: undefined,
                hasScopedStyles: undefined,
                styleVNodes: null,
                tplCache: EmptyObject,
                wiredConnecting: EmptyArray,
                wiredDisconnecting: EmptyArray,
            },
            // Properties set right after VM creation.
            tro: null,
            shadowMode: null,
            shadowMigrateMode: false,
            stylesheets: null,
            // Properties set by the LightningElement constructor.
            component: null,
            shadowRoot: null,
            renderRoot: null,
            callHook,
            setHook,
            getHook,
            renderer,
            apiVersion,
        };
        {
            vm.debugInfo = create(null);
        }
        vm.stylesheets = computeStylesheets(vm, def.ctor);
        const computedShadowMode = computeShadowMode(def, vm.owner, renderer, hydrated);
        if (lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE) {
            vm.shadowMode = 0 /* ShadowMode.Native */;
            vm.shadowMigrateMode = computedShadowMode === 1 /* ShadowMode.Synthetic */;
        }
        else {
            vm.shadowMode = computedShadowMode;
        }
        vm.tro = getTemplateReactiveObserver(vm);
        // We don't need to report the shadow mode if we're rendering in light DOM
        if (isReportingEnabled() && vm.renderMode === 1 /* RenderMode.Shadow */) {
            report("ShadowModeUsage" /* ReportingEventId.ShadowModeUsage */, {
                tagName: vm.tagName,
                mode: vm.shadowMode,
            });
        }
        {
            vm.toString = () => {
                return `[object:vm ${def.name} (${vm.idx})]`;
            };
        }
        // Create component instance associated to the vm and the element.
        invokeComponentConstructor(vm, def.ctor);
        // Initializing the wire decorator per instance only when really needed
        if (hasWireAdapters(vm)) {
            installWireAdapters(vm);
        }
        return vm;
    }
    function validateComponentStylesheets(vm, stylesheets) {
        let valid = true;
        const validate = (arrayOrStylesheet) => {
            if (isArray$1(arrayOrStylesheet)) {
                for (let i = 0; i < arrayOrStylesheet.length; i++) {
                    validate(arrayOrStylesheet[i]);
                }
            }
            else if (!isFunction$1(arrayOrStylesheet)) {
                // function assumed to be a stylesheet factory
                valid = false;
            }
        };
        if (!isArray$1(stylesheets)) {
            valid = false;
        }
        else {
            validate(stylesheets);
        }
        return valid;
    }
    // Validate and flatten any stylesheets defined as `static stylesheets`
    function computeStylesheets(vm, ctor) {
        warnOnStylesheetsMutation(ctor);
        const { stylesheets } = ctor;
        if (!isUndefined$1(stylesheets)) {
            const valid = validateComponentStylesheets(vm, stylesheets);
            if (valid) {
                return flattenStylesheets(stylesheets);
            }
            else {
                logError(`static stylesheets must be an array of CSS stylesheets. Found invalid stylesheets on <${vm.tagName}>`, vm);
            }
        }
        return null;
    }
    function warnOnStylesheetsMutation(ctor) {
        {
            let { stylesheets } = ctor;
            defineProperty(ctor, 'stylesheets', {
                enumerable: true,
                configurable: true,
                get() {
                    return stylesheets;
                },
                set(newValue) {
                    logWarnOnce(`Dynamically setting the "stylesheets" static property on ${ctor.name} ` +
                        'will not affect the stylesheets injected.');
                    stylesheets = newValue;
                },
            });
        }
    }
    // Compute the shadowMode/renderMode without creating a VM. This is used in some scenarios like hydration.
    function computeShadowAndRenderMode(Ctor, renderer) {
        const def = getComponentInternalDef(Ctor);
        const { renderMode } = def;
        // Assume null `owner` - this is what happens in hydration cases anyway
        // Also assume we are not in hydration mode for this exported API
        const shadowMode = computeShadowMode(def, /* owner */ null, renderer, false);
        return { renderMode, shadowMode };
    }
    function computeShadowMode(def, owner, renderer, hydrated) {
        if (
        // Force the shadow mode to always be native. Used for running tests with synthetic shadow patches
        // on, but components running in actual native shadow mode
        // hydration only supports native shadow
            isTrue(hydrated)) {
            return 0 /* ShadowMode.Native */;
        }
        const { isSyntheticShadowDefined } = renderer;
        let shadowMode;
        if (isSyntheticShadowDefined || lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE) {
            if (def.renderMode === 0 /* RenderMode.Light */) {
                // ShadowMode.Native implies "not synthetic shadow" which is consistent with how
                // everything defaults to native when the synthetic shadow polyfill is unavailable.
                shadowMode = 0 /* ShadowMode.Native */;
            }
            else if (def.shadowSupportMode === "native" /* ShadowSupportMode.Native */) {
                shadowMode = 0 /* ShadowMode.Native */;
            }
            else {
                const shadowAncestor = getNearestShadowAncestor(owner);
                if (!isNull(shadowAncestor) && shadowAncestor.shadowMode === 0 /* ShadowMode.Native */) {
                    // Transitive support for native Shadow DOM. A component in native mode
                    // transitively opts all of its descendants into native.
                    shadowMode = 0 /* ShadowMode.Native */;
                }
                else {
                    // Synthetic if neither this component nor any of its ancestors are configured
                    // to be native.
                    shadowMode = 1 /* ShadowMode.Synthetic */;
                }
            }
        }
        else {
            // Native if the synthetic shadow polyfill is unavailable.
            shadowMode = 0 /* ShadowMode.Native */;
        }
        return shadowMode;
    }
    function assertIsVM(obj) {
        if (!isObject(obj) || isNull(obj) || !('renderRoot' in obj)) {
            throw new TypeError(`${obj} is not a VM.`);
        }
    }
    function associateVM(obj, vm) {
        ViewModelReflection.set(obj, vm);
    }
    function getAssociatedVM(obj) {
        const vm = ViewModelReflection.get(obj);
        {
            assertIsVM(vm);
        }
        return vm;
    }
    function getAssociatedVMIfPresent(obj) {
        const maybeVm = ViewModelReflection.get(obj);
        {
            if (!isUndefined$1(maybeVm)) {
                assertIsVM(maybeVm);
            }
        }
        return maybeVm;
    }
    function rehydrate(vm) {
        if (isTrue(vm.isDirty)) {
            const children = renderComponent(vm);
            patchShadowRoot(vm, children);
        }
    }
    function patchShadowRoot(vm, newCh) {
        const { renderRoot, children: oldCh, renderer } = vm;
        // reset the refs; they will be set during `patchChildren`
        resetRefVNodes(vm);
        // caching the new children collection
        vm.children = newCh;
        if (newCh.length > 0 || oldCh.length > 0) {
            // patch function mutates vnodes by adding the element reference,
            // however, if patching fails it contains partial changes.
            if (oldCh !== newCh) {
                runWithBoundaryProtection(vm, vm, () => {
                    // pre
                    logOperationStart(2 /* OperationId.Patch */, vm);
                }, () => {
                    // job
                    patchChildren(oldCh, newCh, renderRoot, renderer);
                }, () => {
                    // post
                    logOperationEnd(2 /* OperationId.Patch */, vm);
                });
            }
        }
        if (vm.state === 1 /* VMState.connected */) {
            // If the element is connected, that means connectedCallback was already issued, and
            // any successive rendering should finish with the call to renderedCallback, otherwise
            // the connectedCallback will take care of calling it in the right order at the end of
            // the current rehydration process.
            runRenderedCallback(vm);
        }
    }
    function runRenderedCallback(vm) {
        const { def: { renderedCallback }, } = vm;
        if (!isUndefined$1(renderedCallback)) {
            logOperationStart(4 /* OperationId.RenderedCallback */, vm);
            invokeComponentCallback(vm, renderedCallback);
            logOperationEnd(4 /* OperationId.RenderedCallback */, vm);
        }
    }
    let rehydrateQueue = [];
    function flushRehydrationQueue() {
        logGlobalOperationStart(8 /* OperationId.GlobalRehydrate */);
        {
            assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);
        }
        const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);
        rehydrateQueue = []; // reset to a new queue
        for (let i = 0, len = vms.length; i < len; i += 1) {
            const vm = vms[i];
            try {
                rehydrate(vm);
            }
            catch (error) {
                if (i + 1 < len) {
                    // pieces of the queue are still pending to be rehydrated, those should have priority
                    if (rehydrateQueue.length === 0) {
                        addCallbackToNextTick(flushRehydrationQueue);
                    }
                    ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, i + 1));
                }
                // we need to end the measure before throwing.
                logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);
                // re-throwing the original error will break the current tick, but since the next tick is
                // already scheduled, it should continue patching the rest.
                throw error;
            }
        }
        logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);
    }
    function runConnectedCallback(vm) {
        const { state } = vm;
        if (state === 1 /* VMState.connected */) {
            return; // nothing to do since it was already connected
        }
        vm.state = 1 /* VMState.connected */;
        if (hasWireAdapters(vm)) {
            connectWireAdapters(vm);
        }
        const { connectedCallback } = vm.def;
        if (!isUndefined$1(connectedCallback)) {
            logOperationStart(3 /* OperationId.ConnectedCallback */, vm);
            invokeComponentCallback(vm, connectedCallback);
            logOperationEnd(3 /* OperationId.ConnectedCallback */, vm);
        }
        // This test only makes sense in the browser, with synthetic lifecycle, and when reporting is enabled or
        // we're in dev mode. This is to detect a particular issue with synthetic lifecycle.
        if (!shouldUseNativeCustomElementLifecycle(vm.component.constructor) &&
            ("development" !== 'production' )) {
            if (!vm.renderer.isConnected(vm.elm)) {
                {
                    logWarnOnce(`Element <${vm.tagName}> ` +
                        `fired a \`connectedCallback\` and rendered, but was not connected to the DOM. ` +
                        `Please ensure all components are actually connected to the DOM, e.g. using ` +
                        `\`document.body.appendChild(element)\`. This will not be supported in future versions of ` +
                        `LWC and could cause component errors. For details, see: https://sfdc.co/synthetic-lifecycle`);
                }
                report("ConnectedCallbackWhileDisconnected" /* ReportingEventId.ConnectedCallbackWhileDisconnected */, {
                    tagName: vm.tagName,
                });
            }
        }
    }
    function hasWireAdapters(vm) {
        return getOwnPropertyNames$1(vm.def.wire).length > 0;
    }
    function runDisconnectedCallback(vm) {
        {
            assert.isTrue(vm.state !== 2 /* VMState.disconnected */, `${vm} must be inserted.`);
        }
        if (isFalse(vm.isDirty)) {
            // this guarantees that if the component is reused/reinserted,
            // it will be re-rendered because we are disconnecting the reactivity
            // linking, so mutations are not automatically reflected on the state
            // of disconnected components.
            vm.isDirty = true;
        }
        vm.state = 2 /* VMState.disconnected */;
        if (hasWireAdapters(vm)) {
            disconnectWireAdapters(vm);
        }
        const { disconnectedCallback } = vm.def;
        if (!isUndefined$1(disconnectedCallback)) {
            logOperationStart(5 /* OperationId.DisconnectedCallback */, vm);
            invokeComponentCallback(vm, disconnectedCallback);
            logOperationEnd(5 /* OperationId.DisconnectedCallback */, vm);
        }
    }
    function runChildNodesDisconnectedCallback(vm) {
        const { velements: vCustomElementCollection } = vm;
        // Reporting disconnection for every child in inverse order since they are
        // inserted in reserved order.
        for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {
            const { elm } = vCustomElementCollection[i];
            // There are two cases where the element could be undefined:
            // * when there is an error during the construction phase, and an error
            //   boundary picks it, there is a possibility that the VCustomElement
            //   is not properly initialized, and therefore is should be ignored.
            // * when slotted custom element is not used by the element where it is
            //   slotted into it, as  a result, the custom element was never
            //   initialized.
            if (!isUndefined$1(elm)) {
                const childVM = getAssociatedVMIfPresent(elm);
                // The VM associated with the element might be associated undefined
                // in the case where the VM failed in the middle of its creation,
                // eg: constructor throwing before invoking super().
                if (!isUndefined$1(childVM)) {
                    resetComponentStateWhenRemoved(childVM);
                }
            }
        }
    }
    function runLightChildNodesDisconnectedCallback(vm) {
        const { aChildren: adoptedChildren } = vm;
        recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     * @param vnodes
     */
    function recursivelyDisconnectChildren(vnodes) {
        for (let i = 0, len = vnodes.length; i < len; i += 1) {
            const vnode = vnodes[i];
            if (!isNull(vnode) && !isUndefined$1(vnode.elm)) {
                switch (vnode.type) {
                    case 2 /* VNodeType.Element */:
                        recursivelyDisconnectChildren(vnode.children);
                        break;
                    case 3 /* VNodeType.CustomElement */: {
                        const vm = getAssociatedVM(vnode.elm);
                        resetComponentStateWhenRemoved(vm);
                        break;
                    }
                }
            }
        }
    }
    // This is a super optimized mechanism to remove the content of the root node (shadow root
    // for shadow DOM components and the root element itself for light DOM) without having to go
    // into snabbdom. Especially useful when the reset is a consequence of an error, in which case the
    // children VNodes might not be representing the current state of the DOM.
    function resetComponentRoot(vm) {
        recursivelyRemoveChildren(vm.children, vm);
        vm.children = EmptyArray;
        runChildNodesDisconnectedCallback(vm);
        vm.velements = EmptyArray;
    }
    // Helper function to remove all children of the root node.
    // If the set of children includes VFragment nodes, we need to remove the children of those nodes too.
    // Since VFragments can contain other VFragments, we need to traverse the entire of tree of VFragments.
    // If the set contains no VFragment nodes, no traversal is needed.
    function recursivelyRemoveChildren(vnodes, vm) {
        const { renderRoot, renderer: { remove }, } = vm;
        for (let i = 0, len = vnodes.length; i < len; i += 1) {
            const vnode = vnodes[i];
            if (!isNull(vnode)) {
                // VFragments are special; their .elm property does not point to the root element since they have no single root.
                if (isVFragment(vnode)) {
                    recursivelyRemoveChildren(vnode.children, vm);
                }
                else if (!isUndefined$1(vnode.elm)) {
                    remove(vnode.elm, renderRoot);
                }
            }
        }
    }
    function scheduleRehydration(vm) {
        if (isTrue(vm.isScheduled)) {
            return;
        }
        vm.isScheduled = true;
        if (rehydrateQueue.length === 0) {
            addCallbackToNextTick(flushRehydrationQueue);
        }
        ArrayPush$1.call(rehydrateQueue, vm);
    }
    function getErrorBoundaryVM(vm) {
        let currentVm = vm;
        while (!isNull(currentVm)) {
            if (!isUndefined$1(currentVm.def.errorCallback)) {
                return currentVm;
            }
            currentVm = currentVm.owner;
        }
    }
    function runWithBoundaryProtection(vm, owner, pre, job, post) {
        let error;
        pre();
        try {
            job();
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            post();
            if (!isUndefined$1(error)) {
                addErrorComponentStack(vm, error);
                const errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);
                // Error boundaries are not in effect when server-side rendering. `errorCallback`
                // is intended to allow recovery from errors - changing the state of a component
                // and instigating a re-render. That is at odds with the single-pass, synchronous
                // nature of SSR. For that reason, all errors bubble up to the `renderComponent`
                // call site.
                if (isUndefined$1(errorBoundaryVm)) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
                resetComponentRoot(vm); // remove offenders
                logOperationStart(6 /* OperationId.ErrorCallback */, vm);
                // error boundaries must have an ErrorCallback
                const errorCallback = errorBoundaryVm.def.errorCallback;
                invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
                logOperationEnd(6 /* OperationId.ErrorCallback */, vm);
            }
        }
    }
    function forceRehydration(vm) {
        // if we must reset the shadowRoot content and render the template
        // from scratch on an active instance, the way to force the reset
        // is by replacing the value of old template, which is used during
        // to determine if the template has changed or not during the rendering
        // process. If the template returned by render() is different from the
        // previous stored template, the styles will be reset, along with the
        // content of the shadowRoot, this way we can guarantee that all children
        // elements will be throw away, and new instances will be created.
        vm.cmpTemplate = () => [];
        if (isFalse(vm.isDirty)) {
            // forcing the vm to rehydrate in the next tick
            markComponentAsDirty(vm);
            scheduleRehydration(vm);
        }
    }
    function runFormAssociatedCustomElementCallback(vm, faceCb, args) {
        const { renderMode, shadowMode } = vm;
        if (shadowMode === 1 /* ShadowMode.Synthetic */ && renderMode !== 0 /* RenderMode.Light */) {
            throw new Error('Form associated lifecycle methods are not available in synthetic shadow. Please use native shadow or light DOM.');
        }
        invokeComponentCallback(vm, faceCb, args);
    }
    function runFormAssociatedCallback(elm, form) {
        const vm = getAssociatedVM(elm);
        const { formAssociatedCallback } = vm.def;
        if (!isUndefined$1(formAssociatedCallback)) {
            runFormAssociatedCustomElementCallback(vm, formAssociatedCallback, [form]);
        }
    }
    function runFormDisabledCallback(elm, disabled) {
        const vm = getAssociatedVM(elm);
        const { formDisabledCallback } = vm.def;
        if (!isUndefined$1(formDisabledCallback)) {
            runFormAssociatedCustomElementCallback(vm, formDisabledCallback, [disabled]);
        }
    }
    function runFormResetCallback(elm) {
        const vm = getAssociatedVM(elm);
        const { formResetCallback } = vm.def;
        if (!isUndefined$1(formResetCallback)) {
            runFormAssociatedCustomElementCallback(vm, formResetCallback);
        }
    }
    function runFormStateRestoreCallback(elm, state, reason) {
        const vm = getAssociatedVM(elm);
        const { formStateRestoreCallback } = vm.def;
        if (!isUndefined$1(formStateRestoreCallback)) {
            runFormAssociatedCustomElementCallback(vm, formStateRestoreCallback, [state, reason]);
        }
    }
    function resetRefVNodes(vm) {
        const { cmpTemplate } = vm;
        vm.refVNodes = !isNull(cmpTemplate) && cmpTemplate.hasRefs ? create(null) : null;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    //
    // The goal of this code is to detect invalid cross-root ARIA references in synthetic shadow DOM.
    // These invalid references should be fixed before the offending components can be migrated to native shadow DOM.
    // When invalid usage is detected, we warn in dev mode and call the reporting API if enabled.
    // See: https://sfdc.co/synthetic-aria
    //
    // Use the unpatched native getElementById/querySelectorAll rather than the synthetic one
    const getElementById = globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];
    const querySelectorAll = globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];
    // This is a "handoff" from synthetic-shadow to engine-core  we want to clean up after ourselves
    // so nobody else can misuse these global APIs.
    delete globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];
    delete globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];
    function isSyntheticShadowRootInstance(rootNode) {
        return rootNode !== document && isTrue(rootNode.synthetic);
    }
    function reportViolation$1(source, target, attrName) {
        // The vm is either for the source, the target, or both. Either one or both must be using synthetic
        // shadow for a violation to be detected.
        let vm = getAssociatedVMIfPresent(source.getRootNode().host);
        if (isUndefined$1(vm)) {
            vm = getAssociatedVMIfPresent(target.getRootNode().host);
        }
        if (isUndefined$1(vm)) {
            // vm should never be undefined here, but just to be safe, bail out and don't report
            return;
        }
        report("CrossRootAriaInSyntheticShadow" /* ReportingEventId.CrossRootAriaInSyntheticShadow */, {
            tagName: vm.tagName,
            attributeName: attrName,
        });
        {
            // Avoid excessively logging to the console in the case of duplicates.
            logWarnOnce(`Element <${source.tagName.toLowerCase()}> uses attribute "${attrName}" to reference element ` +
                `<${target.tagName.toLowerCase()}>, which is not in the same shadow root. This will break in native shadow DOM. ` +
                `For details, see: https://sfdc.co/synthetic-aria`, vm);
        }
    }
    function parseIdRefAttributeValue(attrValue) {
        // split on whitespace and skip empty strings after splitting
        return isString(attrValue) ? ArrayFilter.call(StringSplit.call(attrValue, /\s+/), Boolean) : [];
    }
    function detectSyntheticCrossRootAria(elm, attrName, attrValue) {
        const root = elm.getRootNode();
        if (!isSyntheticShadowRootInstance(root)) {
            return;
        }
        if (attrName === 'id') {
            // elm is the target, find the source
            if (!isString(attrValue) || attrValue.length === 0) {
                // if our id is null or empty, nobody can reference us
                return;
            }
            for (const idRefAttrName of ID_REFERENCING_ATTRIBUTES_SET) {
                // Query all global elements with this attribute. The attribute selector syntax `~=` is for values
                // that reference multiple IDs, separated by whitespace.
                const query = `[${idRefAttrName}~="${CSS.escape(attrValue)}"]`;
                const sourceElements = querySelectorAll.call(document, query);
                for (let i = 0; i < sourceElements.length; i++) {
                    const sourceElement = sourceElements[i];
                    const sourceRoot = sourceElement.getRootNode();
                    if (sourceRoot !== root) {
                        reportViolation$1(sourceElement, elm, idRefAttrName);
                        break;
                    }
                }
            }
        }
        else {
            // elm is the source, find the target
            const ids = parseIdRefAttributeValue(attrValue);
            for (const id of ids) {
                const target = getElementById.call(document, id);
                if (!isNull(target)) {
                    const targetRoot = target.getRootNode();
                    if (targetRoot !== root) {
                        // target element's shadow root is not the same as ours
                        reportViolation$1(elm, target, attrName);
                    }
                }
            }
        }
    }
    let enabled = false;
    // We want to avoid patching globals whenever possible, so this should be tree-shaken out in prod-mode and if
    // reporting is not enabled. It should also only run once
    function enableDetection$1() {
        if (enabled) {
            return; // don't double-apply the patches
        }
        enabled = true;
        const { setAttribute } = Element.prototype;
        // Detect calling `setAttribute` to set an idref or an id
        assign(Element.prototype, {
            setAttribute(attrName, attrValue) {
                setAttribute.call(this, attrName, attrValue);
                if (attrName === 'id' || ID_REFERENCING_ATTRIBUTES_SET.has(attrName)) {
                    detectSyntheticCrossRootAria(this, attrName, attrValue);
                }
            },
        });
        // Detect `elm.id = 'foo'`
        const idDescriptor = getOwnPropertyDescriptor$1(Element.prototype, 'id');
        if (!isUndefined$1(idDescriptor)) {
            const { get, set } = idDescriptor;
            // These should always be a getter and a setter, but if someone is monkeying with the global descriptor, ignore it
            if (isFunction$1(get) && isFunction$1(set)) {
                defineProperty(Element.prototype, 'id', {
                    get() {
                        return get.call(this);
                    },
                    set(value) {
                        set.call(this, value);
                        detectSyntheticCrossRootAria(this, 'id', value);
                    },
                    // On the default descriptor for 'id', enumerable and configurable are true
                    enumerable: true,
                    configurable: true,
                });
            }
        }
    }
    // Our detection logic relies on some modern browser features. We can just skip reporting the data
    // for unsupported browsers
    function supportsCssEscape() {
        return typeof CSS !== 'undefined' && isFunction$1(CSS.escape);
    }
    // If this page is not using synthetic shadow, then we don't need to install detection. Note
    // that we are assuming synthetic shadow is loaded before LWC.
    function isSyntheticShadowLoaded() {
        // We should probably be calling `renderer.isSyntheticShadowDefined`, but 1) we don't have access to the renderer,
        // and 2) this code needs to run in @lwc/engine-core, so it can access `logWarn()` and `report()`.
        return hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN);
    }
    // Detecting cross-root ARIA in synthetic shadow only makes sense for the browser
    if (supportsCssEscape() && isSyntheticShadowLoaded()) {
        // Always run detection in dev mode, so we can at least print to the console
        {
            enableDetection$1();
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    //
    // The goal of this code is to detect usages of non-standard reflected ARIA properties. These are caused by
    // legacy non-standard Element.prototype extensions added by the @lwc/aria-reflection package.
    //
    // See the README for @lwc/aria-reflection
    const NON_STANDARD_ARIA_PROPS = [
        'ariaActiveDescendant',
        'ariaControls',
        'ariaDescribedBy',
        'ariaDetails',
        'ariaErrorMessage',
        'ariaFlowTo',
        'ariaLabelledBy',
        'ariaOwns',
    ];
    function isGlobalAriaPolyfillLoaded() {
        // Sniff for the legacy polyfill being loaded. The reason this works is because ariaActiveDescendant is a
        // non-standard ARIA property reflection that is only supported in our legacy polyfill. See
        // @lwc/aria-reflection/README.md for details.
        return !isUndefined$1(getOwnPropertyDescriptor$1(Element.prototype, 'ariaActiveDescendant'));
    }
    function findVM(elm) {
        // If it's a shadow DOM component, then it has a host
        const { host } = elm.getRootNode();
        const vm = isUndefined$1(host) ? undefined : getAssociatedVMIfPresent(host);
        if (!isUndefined$1(vm)) {
            return vm;
        }
        // Else it might be a light DOM component. Walk up the tree trying to find the owner
        let parentElement = elm;
        while (!isNull((parentElement = parentElement.parentElement))) {
            if (parentElement instanceof BaseBridgeElement) {
                // parentElement is an LWC component
                const vm = getAssociatedVMIfPresent(parentElement);
                if (!isUndefined$1(vm)) {
                    return vm;
                }
            }
        }
        // If we return undefined, it's because the element was rendered wholly outside a LightningElement
    }
    function checkAndReportViolation(elm, prop, isSetter, setValue) {
        const vm = findVM(elm);
        {
            logWarnOnce(`Element <${elm.tagName.toLowerCase()}> ` +
                (isUndefined$1(vm) ? '' : `owned by <${vm.elm.tagName.toLowerCase()}> `) +
                `uses non-standard property "${prop}". This will be removed in a future version of LWC. ` +
                `See https://sfdc.co/deprecated-aria`);
        }
        let setValueType;
        if (isSetter) {
            // `typeof null` is "object" which is not very useful for detecting null.
            // We mostly want to know null vs undefined vs other types here, due to
            // https://github.com/salesforce/lwc/issues/3284
            setValueType = isNull(setValue) ? 'null' : typeof setValue;
        }
        report("NonStandardAriaReflection" /* ReportingEventId.NonStandardAriaReflection */, {
            tagName: vm?.tagName,
            propertyName: prop,
            isSetter,
            setValueType,
        });
    }
    function enableDetection() {
        const { prototype } = Element;
        for (const prop of NON_STANDARD_ARIA_PROPS) {
            const descriptor = getOwnPropertyDescriptor$1(prototype, prop);
            // The descriptor should exist because the @lwc/aria-reflection polyfill has run by now.
            // This happens automatically because of the ordering of imports.
            {
                /* istanbul ignore if */
                if (isUndefined$1(descriptor) ||
                    isUndefined$1(descriptor.get) ||
                    isUndefined$1(descriptor.set)) {
                    // should never happen
                    throw new Error('detect-non-standard-aria.ts loaded before @lwc/aria-reflection');
                }
            }
            const { get, set } = descriptor;
            // It's important for this defineProperty call to happen _after_ ARIA accessors are applied to the
            // BaseBridgeElement and LightningElement prototypes. Otherwise, we will log/report for access of non-standard
            // props on these prototypes, which we actually don't want. We only care about access on generic HTMLElements.
            defineProperty(prototype, prop, {
                get() {
                    checkAndReportViolation(this, prop, false, undefined);
                    return get.call(this);
                },
                set(val) {
                    checkAndReportViolation(this, prop, true, val);
                    return set.call(this, val);
                },
                configurable: true,
                enumerable: true,
            });
        }
    }
    // No point in running this code if we're not in a browser, or if the global polyfill is not loaded
    if (isGlobalAriaPolyfillLoaded()) {
        // Always run detection in dev mode, so we can at least print to the console
        {
            enableDetection();
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let hooksAreSet = false;
    function setHooks(hooks) {
        assert.isFalse(hooksAreSet, 'Hooks are already overridden, only one definition is allowed.');
        hooksAreSet = true;
        setSanitizeHtmlContentHook(hooks.sanitizeHtmlContent);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // See @lwc/engine-core/src/framework/template.ts
    const TEMPLATE_PROPS = ['slots', 'stylesheetToken', 'stylesheets', 'renderMode'];
    // Expandos that may be placed on a stylesheet factory function, and which are meaningful to LWC at runtime
    const STYLESHEET_PROPS = [
        // SEE `KEY__SCOPED_CSS` in @lwc/style-compiler
        '$scoped$',
    ];
    // Via https://www.npmjs.com/package/object-observer
    const ARRAY_MUTATION_METHODS = [
        'pop',
        'push',
        'shift',
        'unshift',
        'reverse',
        'sort',
        'fill',
        'splice',
        'copyWithin',
    ];
    let mutationTrackingDisabled = false;
    function getOriginalArrayMethod(prop) {
        switch (prop) {
            case 'pop':
                return ArrayPop;
            case 'push':
                return ArrayPush$1;
            case 'shift':
                return ArrayShift;
            case 'unshift':
                return ArrayUnshift;
            case 'reverse':
                return ArrayReverse;
            case 'sort':
                return ArraySort;
            case 'fill':
                return ArrayFill;
            case 'splice':
                return ArraySplice;
            case 'copyWithin':
                return ArrayCopyWithin;
        }
    }
    function reportViolation(type, eventId, prop) {
        {
            logWarnOnce(`Mutating the "${prop}" property on a ${type} ` +
                `is deprecated and will be removed in a future version of LWC. ` +
                `See: https://sfdc.co/template-mutation`);
        }
        report(eventId, { propertyName: prop });
    }
    function reportTemplateViolation(prop) {
        reportViolation('template', "TemplateMutation" /* ReportingEventId.TemplateMutation */, prop);
    }
    function reportStylesheetViolation(prop) {
        reportViolation('stylesheet', "StylesheetMutation" /* ReportingEventId.StylesheetMutation */, prop);
    }
    // Warn if the user tries to mutate a stylesheets array, e.g.:
    // `tmpl.stylesheets.push(someStylesheetFunction)`
    function warnOnArrayMutation(stylesheets) {
        // We can't handle users calling Array.prototype.slice.call(tmpl.stylesheets), but
        // we can at least warn when they use the most common mutation methods.
        for (const prop of ARRAY_MUTATION_METHODS) {
            const originalArrayMethod = getOriginalArrayMethod(prop);
            stylesheets[prop] = function arrayMutationWarningWrapper() {
                reportTemplateViolation('stylesheets');
                // @ts-expect-error can't properly determine the right `this`
                return originalArrayMethod.apply(this, arguments);
            };
        }
    }
    // Warn if the user tries to mutate a stylesheet factory function, e.g.:
    // `stylesheet.$scoped$ = true`
    function warnOnStylesheetFunctionMutation(stylesheet) {
        for (const prop of STYLESHEET_PROPS) {
            let value = stylesheet[prop];
            defineProperty(stylesheet, prop, {
                enumerable: true,
                configurable: true,
                get() {
                    return value;
                },
                set(newValue) {
                    reportStylesheetViolation(prop);
                    value = newValue;
                },
            });
        }
    }
    // Warn on either array or stylesheet (function) mutation, in a deeply-nested array
    function trackStylesheetsMutation(stylesheets) {
        traverseStylesheets(stylesheets, (subStylesheets) => {
            if (isArray$1(subStylesheets)) {
                warnOnArrayMutation(subStylesheets);
            }
            else {
                warnOnStylesheetFunctionMutation(subStylesheets);
            }
        });
    }
    // Deep-traverse an array (of arrays) of stylesheet factory functions, and call the callback for every array/function
    function traverseStylesheets(stylesheets, callback) {
        callback(stylesheets);
        for (let i = 0; i < stylesheets.length; i++) {
            const stylesheet = stylesheets[i];
            if (isArray$1(stylesheet)) {
                traverseStylesheets(stylesheet, callback);
            }
            else {
                callback(stylesheet);
            }
        }
    }
    function trackMutations(tmpl) {
        if (!isUndefined$1(tmpl.stylesheets)) {
            trackStylesheetsMutation(tmpl.stylesheets);
        }
        for (const prop of TEMPLATE_PROPS) {
            let value = tmpl[prop];
            defineProperty(tmpl, prop, {
                enumerable: true,
                configurable: true,
                get() {
                    return value;
                },
                set(newValue) {
                    if (!mutationTrackingDisabled) {
                        reportTemplateViolation(prop);
                    }
                    value = newValue;
                },
            });
        }
        const originalDescriptor = getOwnPropertyDescriptor$1(tmpl, 'stylesheetTokens');
        defineProperty(tmpl, 'stylesheetTokens', {
            enumerable: true,
            configurable: true,
            get: originalDescriptor.get,
            set(value) {
                reportTemplateViolation('stylesheetTokens');
                // Avoid logging/reporting twice (for both stylesheetToken and stylesheetTokens)
                mutationTrackingDisabled = true;
                originalDescriptor.set.call(this, value);
                mutationTrackingDisabled = false;
            },
        });
    }
    function addLegacyStylesheetTokensShim(tmpl) {
        // When ENABLE_FROZEN_TEMPLATE is false, then we shim stylesheetTokens on top of stylesheetToken for anyone who
        // is accessing the old internal API (backwards compat). Details: W-14210169
        defineProperty(tmpl, 'stylesheetTokens', {
            enumerable: true,
            configurable: true,
            get() {
                const { stylesheetToken } = this;
                if (isUndefined$1(stylesheetToken)) {
                    return stylesheetToken;
                }
                // Shim for the old `stylesheetTokens` property
                // See https://github.com/salesforce/lwc/pull/2332/files#diff-7901555acef29969adaa6583185b3e9bce475cdc6f23e799a54e0018cb18abaa
                return {
                    hostAttribute: `${stylesheetToken}-host`,
                    shadowAttribute: stylesheetToken,
                };
            },
            set(value) {
                // If the value is null or some other exotic object, you would be broken anyway in the past
                // because the engine would try to access hostAttribute/shadowAttribute, which would throw an error.
                // However it may be undefined in newer versions of LWC, so we need to guard against that case.
                this.stylesheetToken = isUndefined$1(value) ? undefined : value.shadowAttribute;
            },
        });
    }
    function freezeTemplate(tmpl) {
        // TODO [#2782]: remove this flag and delete the legacy behavior
        {
            // template is not frozen - shim, report, and warn
            // this shim should be applied in both dev and prod
            addLegacyStylesheetTokensShim(tmpl);
            // When ENABLE_FROZEN_TEMPLATE is false, we want to warn in dev mode whenever someone is mutating the template
            {
                trackMutations(tmpl);
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.
     * This API is subject to change or being removed.
     * @param elm
     */
    function getComponentConstructor(elm) {
        let ctor = null;
        // intentionally checking for undefined due to some funky libraries patching weakmap.get
        // to throw when undefined.
        if (!isUndefined$1(elm)) {
            const vm = getAssociatedVMIfPresent(elm);
            if (!isUndefined$1(vm)) {
                ctor = vm.def.ctor;
            }
        }
        return ctor;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     * @param obj
     */
    function readonly(obj) {
        {
            // TODO [#1292]: Remove the readonly decorator
            if (arguments.length !== 1) {
                logError('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');
            }
        }
        return getReadOnlyProxy(obj);
    }
    /** version: 6.4.5 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * Displays the header for a custom element.
     * @param ce The custom element to get the header for.
     * @param componentInstance component instance associated with the custom element.
     */
    function getHeaderForCustomElement(ce, componentInstance) {
        // [element]
        // LWC component instance: [vm.component]
        return [
            'div',
            {},
            ['object', { object: ce, config: { skip: true } }],
            [
                'div',
                {},
                ['span', { style: 'margin: 0 5px; color: red' }, 'LWC:'],
                ['object', { object: componentInstance }],
            ],
        ];
    }
    function getHeaderForComponentInstance(componentInstance, debugInfo) {
        if (keys(debugInfo).length === 0) {
            // there is no debug information, no need to customize this component instance
            return null;
        }
        // [component]
        // Debug information: [vm.debugInfo]
        return [
            'div',
            {},
            ['object', { object: componentInstance, config: { skip: true } }],
            [
                'div',
                {},
                ['span', { style: 'margin: 0 5px; color: red' }, 'Debug:'],
                ['object', { object: debugInfo }],
            ],
        ];
    }
    const LightningElementFormatter = {
        name: 'LightningElementFormatter',
        header(obj, config) {
            const vm = getAssociatedVMIfPresent(obj);
            if (!isUndefined$1(vm) && (isUndefined$1(config) || !config.skip)) {
                if (obj instanceof HTMLElement) {
                    return getHeaderForCustomElement(obj, vm.component);
                }
                else {
                    return getHeaderForComponentInstance(obj, vm.debugInfo);
                }
            }
            return null;
        },
        hasBody() {
            return false;
        },
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function init() {
        const devtoolsFormatters = globalThis.devtoolsFormatters || [];
        ArrayPush$1.call(devtoolsFormatters, LightningElementFormatter);
        globalThis.devtoolsFormatters = devtoolsFormatters;
    }
    {
        init();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    //
    // Feature detection
    //
    // This check for constructable style sheets is similar to Fast's:
    // https://github.com/microsoft/fast/blob/d49d1ec/packages/web-components/fast-element/src/dom.ts#L51-L53
    // See also: https://github.com/whatwg/webidl/issues/1027#issuecomment-934510070
    const supportsConstructableStylesheets = isFunction$1(CSSStyleSheet.prototype.replaceSync) && isArray$1(document.adoptedStyleSheets);
    const stylesheetCache = new Map();
    function createFreshStyleElement(content) {
        const elm = document.createElement('style');
        elm.type = 'text/css';
        elm.textContent = content;
        // Add an attribute to distinguish global styles added by LWC as opposed to other frameworks/libraries on the page
        elm.setAttribute('data-rendered-by-lwc', '');
        return elm;
    }
    function createStyleElement(content, cacheData) {
        const { element, usedElement } = cacheData;
        // If the <style> was already used, then we should clone it. We cannot insert
        // the same <style> in two places in the DOM.
        if (usedElement) {
            // This `<style>` may be repeated multiple times in the DOM, so cache it. It's a bit
            // faster to call `cloneNode()` on an existing node than to recreate it every time.
            return element.cloneNode(true);
        }
        // We don't clone every time, because that would be a perf tax on the first time
        cacheData.usedElement = true;
        return element;
    }
    function createConstructableStylesheet(content) {
        const stylesheet = new CSSStyleSheet();
        stylesheet.replaceSync(content);
        return stylesheet;
    }
    function insertConstructableStylesheet(content, target, cacheData) {
        const { adoptedStyleSheets } = target;
        const { stylesheet } = cacheData;
        // The reason we prefer .push() rather than reassignment is for perf: https://github.com/salesforce/lwc/pull/2683
        adoptedStyleSheets.push(stylesheet);
    }
    function insertStyleElement(content, target, cacheData) {
        const elm = createStyleElement(content, cacheData);
        target.appendChild(elm);
    }
    function getCacheData(content, useConstructableStylesheet) {
        let cacheData = stylesheetCache.get(content);
        if (isUndefined$1(cacheData)) {
            cacheData = {
                stylesheet: undefined,
                element: undefined,
                roots: undefined,
                global: false,
                usedElement: false,
            };
            stylesheetCache.set(content, cacheData);
        }
        // Create <style> elements or CSSStyleSheets on-demand, as needed
        if (useConstructableStylesheet && isUndefined$1(cacheData.stylesheet)) {
            cacheData.stylesheet = createConstructableStylesheet(content);
        }
        else if (!useConstructableStylesheet && isUndefined$1(cacheData.element)) {
            cacheData.element = createFreshStyleElement(content);
        }
        return cacheData;
    }
    function insertGlobalStylesheet(content) {
        // Force a <style> element for global stylesheets. See comment below.
        const cacheData = getCacheData(content, false);
        if (cacheData.global) {
            // already inserted
            return;
        }
        cacheData.global = true; // mark inserted
        // TODO [#2922]: use document.adoptedStyleSheets in supported browsers. Currently we can't, due to backwards compat.
        insertStyleElement(content, document.head, cacheData);
    }
    function insertLocalStylesheet(content, target) {
        const cacheData = getCacheData(content, supportsConstructableStylesheets);
        let { roots } = cacheData;
        if (isUndefined$1(roots)) {
            roots = cacheData.roots = new WeakSet(); // lazily initialize (not needed for global styles)
        }
        else if (roots.has(target)) {
            // already inserted
            return;
        }
        roots.add(target); // mark inserted
        // Constructable stylesheets are only supported in certain browsers:
        // https://caniuse.com/mdn-api_document_adoptedstylesheets
        // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2460
        if (supportsConstructableStylesheets) {
            insertConstructableStylesheet(content, target, cacheData);
        }
        else {
            // Fall back to <style> element
            insertStyleElement(content, target, cacheData);
        }
    }
    function insertStylesheet(content, target) {
        if (isUndefined$1(target)) {
            // global
            insertGlobalStylesheet(content);
        }
        else {
            // local
            insertLocalStylesheet(content, target);
        }
    }

    /*
     * Copyright (c) 2023, Salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const cachedConstructors = new Map();
    const nativeLifecycleElementsToUpgradedByLWC = new WeakMap();
    let elementBeingUpgradedByLWC = false;
    // Creates a constructor that is intended to be used directly as a custom element, except that the upgradeCallback is
    // passed in to the constructor so LWC can reuse the same custom element constructor for multiple components.
    // Another benefit is that only LWC can create components that actually do anything  if you do
    // `customElements.define('x-foo')`, then you don't have access to the upgradeCallback, so it's a dummy custom element.
    // This class should be created once per tag name.
    const createUpgradableConstructor = (isFormAssociated) => {
        // TODO [#2972]: this class should expose observedAttributes as necessary
        class UpgradableConstructor extends HTMLElement {
            constructor(upgradeCallback, useNativeLifecycle) {
                super();
                if (useNativeLifecycle) {
                    // When in native lifecycle mode, we need to keep track of instances that were created outside LWC
                    // (i.e. not created by `lwc.createElement()`). If the element uses synthetic lifecycle, then we don't
                    // need to track this.
                    nativeLifecycleElementsToUpgradedByLWC.set(this, elementBeingUpgradedByLWC);
                }
                // If the element is not created using lwc.createElement(), e.g. `document.createElement('x-foo')`,
                // then elementBeingUpgradedByLWC will be false
                if (elementBeingUpgradedByLWC) {
                    upgradeCallback(this);
                }
                // TODO [#2970]: LWC elements cannot be upgraded via new Ctor()
                // Do we want to support this? Throw an error? Currently for backwards compat it's a no-op.
            }
            connectedCallback() {
                if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {
                    connectRootElement(this);
                }
            }
            disconnectedCallback() {
                if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {
                    disconnectRootElement(this);
                }
            }
            formAssociatedCallback(form) {
                if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {
                    runFormAssociatedCallback(this, form);
                }
            }
            formDisabledCallback(disabled) {
                if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {
                    runFormDisabledCallback(this, disabled);
                }
            }
            formResetCallback() {
                if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {
                    runFormResetCallback(this);
                }
            }
            formStateRestoreCallback(state, reason) {
                if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {
                    runFormStateRestoreCallback(this, state, reason);
                }
            }
        }
        if (isFormAssociated) {
            // Perf optimization - the vast majority of components have formAssociated=false,
            // so we can skip the setter in those cases, since undefined works the same as false.
            // @ts-expect-error type-mismatch
            UpgradableConstructor.formAssociated = isFormAssociated;
        }
        return UpgradableConstructor;
    };
    function getUpgradableConstructor(tagName, isFormAssociated) {
        let UpgradableConstructor = cachedConstructors.get(tagName);
        if (isUndefined$1(UpgradableConstructor)) {
            if (!isUndefined$1(customElements.get(tagName))) {
                throw new Error(`Unexpected tag name "${tagName}". This name is a registered custom element, preventing LWC to upgrade the element.`);
            }
            UpgradableConstructor = createUpgradableConstructor(isFormAssociated);
            customElements.define(tagName, UpgradableConstructor);
            cachedConstructors.set(tagName, UpgradableConstructor);
        }
        return UpgradableConstructor;
    }
    const createCustomElement = (tagName, upgradeCallback, useNativeLifecycle, isFormAssociated) => {
        const UpgradableConstructor = getUpgradableConstructor(tagName, isFormAssociated);
        if (Boolean(UpgradableConstructor.formAssociated) !== isFormAssociated) {
            throw new Error(`<${tagName}> was already registered with formAssociated=${UpgradableConstructor.formAssociated}. It cannot be re-registered with formAssociated=${isFormAssociated}. Please rename your component to have a different name than <${tagName}>`);
        }
        elementBeingUpgradedByLWC = true;
        try {
            return new UpgradableConstructor(upgradeCallback, useNativeLifecycle);
        }
        finally {
            elementBeingUpgradedByLWC = false;
        }
    };

    /*
     * Copyright (c) 2024, Salesforce, Inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * A factory function that produces a renderer.
     * Renderer encapsulates operations that are required to render an LWC component into the underlying
     * runtime environment. In the case of @lwc/enigne-dom, it is meant to be used in a DOM environment.
     * @param baseRenderer Either null or the base renderer imported from 'lwc'.
     * @returns The created renderer
     * @example
     * import { renderer, rendererFactory } from 'lwc';
     * const customRenderer = rendererFactory(renderer);
     */
    function rendererFactory(baseRenderer) {
        // Type assertion because this is replaced by rollup with an object, not a string.
        // See `injectInlineRenderer` in /scripts/rollup/rollup.config.js
        const renderer = (function (exports) {

        /**
         * Copyright (c) 2024 Salesforce, Inc.
         */
        /*
         * Copyright (c) 2018, salesforce.com, inc.
         * All rights reserved.
         * SPDX-License-Identifier: MIT
         * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
         */
        /**
         *
         * @param value
         * @param msg
         */
        function invariant(value, msg) {
            if (!value) {
                throw new Error(`Invariant Violation: ${msg}`);
            }
        }
        /**
         *
         * @param value
         * @param msg
         */
        function isTrue$1(value, msg) {
            if (!value) {
                throw new Error(`Assert Violation: ${msg}`);
            }
        }
        /**
         *
         * @param value
         * @param msg
         */
        function isFalse$1(value, msg) {
            if (value) {
                throw new Error(`Assert Violation: ${msg}`);
            }
        }
        /**
         *
         * @param msg
         */
        function fail(msg) {
            throw new Error(msg);
        }

        var assert = /*#__PURE__*/Object.freeze({
            __proto__: null,
            fail: fail,
            invariant: invariant,
            isFalse: isFalse$1,
            isTrue: isTrue$1
        });
        /**
         * Determines whether the argument is `undefined`.
         * @param obj Value to test
         * @returns `true` if the value is `undefined`.
         */
        function isUndefined(obj) {
            return obj === undefined;
        }
        /**
         * Determines whether the argument is `null`.
         * @param obj Value to test
         * @returns `true` if the value is `null`.
         */
        function isNull(obj) {
            return obj === null;
        }
        /** version: 6.4.5 */

        /*
         * Copyright (c) 2023, salesforce.com, inc.
         * All rights reserved.
         * SPDX-License-Identifier: MIT
         * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
         */
        class WireContextSubscriptionEvent extends CustomEvent {
            constructor(adapterToken, { setNewContext, setDisconnectedCallback }) {
                super(adapterToken, {
                    bubbles: true,
                    composed: true,
                });
                this.setNewContext = setNewContext;
                this.setDisconnectedCallback = setDisconnectedCallback;
            }
        }
        function registerContextConsumer(elm, adapterContextToken, subscriptionPayload) {
            dispatchEvent(elm, new WireContextSubscriptionEvent(adapterContextToken, subscriptionPayload));
        }
        function registerContextProvider(elm, adapterContextToken, onContextSubscription) {
            addEventListener(elm, adapterContextToken, ((evt) => {
                evt.stopImmediatePropagation();
                const { setNewContext, setDisconnectedCallback } = evt;
                onContextSubscription({
                    setNewContext,
                    setDisconnectedCallback,
                });
            }));
        }

        /*
         * Copyright (c) 2018, salesforce.com, inc.
         * All rights reserved.
         * SPDX-License-Identifier: MIT
         * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
         */
        function cloneNode(node, deep) {
            return node.cloneNode(deep);
        }
        function createElement(tagName, namespace) {
            return isUndefined(namespace)
                ? document.createElement(tagName)
                : document.createElementNS(namespace, tagName);
        }
        function createText(content) {
            return document.createTextNode(content);
        }
        function createComment(content) {
            return document.createComment(content);
        }
        // Parse the fragment HTML string into DOM
        function createFragment(html) {
            const template = document.createElement('template');
            template.innerHTML = html;
            return template.content.firstChild;
        }
        function insert(node, parent, anchor) {
            parent.insertBefore(node, anchor);
        }
        function remove(node, parent) {
            parent.removeChild(node);
        }
        function nextSibling(node) {
            return node.nextSibling;
        }
        function previousSibling(node) {
            return node.previousSibling;
        }
        function attachShadow(element, options) {
            // `shadowRoot` will be non-null in two cases:
            //   1. upon initial load with an SSR-generated DOM, while in Shadow render mode
            //   2. when a webapp author places <c-app> in their static HTML and mounts their
            //      root component with customElement.define('c-app', Ctor)
            if (!isNull(element.shadowRoot)) {
                return element.shadowRoot;
            }
            return element.attachShadow(options);
        }
        function setText(node, content) {
            node.nodeValue = content;
        }
        function getProperty(node, key) {
            return node[key];
        }
        function setProperty(node, key, value) {
            node[key] = value;
        }
        function getAttribute(element, name, namespace) {
            return isUndefined(namespace)
                ? element.getAttribute(name)
                : element.getAttributeNS(namespace, name);
        }
        function setAttribute(element, name, value, namespace) {
            return isUndefined(namespace)
                ? element.setAttribute(name, value)
                : element.setAttributeNS(namespace, name, value);
        }
        function removeAttribute(element, name, namespace) {
            if (isUndefined(namespace)) {
                element.removeAttribute(name);
            }
            else {
                element.removeAttributeNS(namespace, name);
            }
        }
        function addEventListener(target, type, callback, options) {
            target.addEventListener(type, callback, options);
        }
        function removeEventListener(target, type, callback, options) {
            target.removeEventListener(type, callback, options);
        }
        function dispatchEvent(target, event) {
            return target.dispatchEvent(event);
        }
        function getClassList(element) {
            return element.classList;
        }
        function setCSSStyleProperty(element, name, value, important) {
            // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to
            // represent elements in the engine?
            element.style.setProperty(name, value, important ? 'important' : '');
        }
        function getBoundingClientRect(element) {
            return element.getBoundingClientRect();
        }
        function querySelector(element, selectors) {
            return element.querySelector(selectors);
        }
        function querySelectorAll(element, selectors) {
            return element.querySelectorAll(selectors);
        }
        function getElementsByTagName(element, tagNameOrWildCard) {
            return element.getElementsByTagName(tagNameOrWildCard);
        }
        function getElementsByClassName(element, names) {
            return element.getElementsByClassName(names);
        }
        function getChildren(element) {
            return element.children;
        }
        function getChildNodes(element) {
            return element.childNodes;
        }
        function getFirstChild(element) {
            return element.firstChild;
        }
        function getFirstElementChild(element) {
            return element.firstElementChild;
        }
        function getLastChild(element) {
            return element.lastChild;
        }
        function getLastElementChild(element) {
            return element.lastElementChild;
        }
        function isConnected(node) {
            return node.isConnected;
        }
        function assertInstanceOfHTMLElement(elm, msg) {
            assert.invariant(elm instanceof HTMLElement, msg);
        }
        function ownerDocument(element) {
            return element.ownerDocument;
        }
        function getTagName(elm) {
            return elm.tagName;
        }
        function attachInternals(elm) {
            return attachInternalsFunc.call(elm);
        }
        // Use the attachInternals method from HTMLElement.prototype because access to it is removed
        // in HTMLBridgeElement, ie: elm.attachInternals is undefined.
        // Additionally, cache the attachInternals method to protect against 3rd party monkey-patching.
        const attachInternalsFunc = typeof ElementInternals !== 'undefined'
            ? HTMLElement.prototype.attachInternals
            : () => {
                throw new Error('attachInternals API is not supported in this browser environment.');
            };

        exports.addEventListener = addEventListener;
        exports.assertInstanceOfHTMLElement = assertInstanceOfHTMLElement;
        exports.attachInternals = attachInternals;
        exports.attachShadow = attachShadow;
        exports.cloneNode = cloneNode;
        exports.createComment = createComment;
        exports.createElement = createElement;
        exports.createFragment = createFragment;
        exports.createText = createText;
        exports.dispatchEvent = dispatchEvent;
        exports.getAttribute = getAttribute;
        exports.getBoundingClientRect = getBoundingClientRect;
        exports.getChildNodes = getChildNodes;
        exports.getChildren = getChildren;
        exports.getClassList = getClassList;
        exports.getElementsByClassName = getElementsByClassName;
        exports.getElementsByTagName = getElementsByTagName;
        exports.getFirstChild = getFirstChild;
        exports.getFirstElementChild = getFirstElementChild;
        exports.getLastChild = getLastChild;
        exports.getLastElementChild = getLastElementChild;
        exports.getProperty = getProperty;
        exports.getTagName = getTagName;
        exports.insert = insert;
        exports.isConnected = isConnected;
        exports.nextSibling = nextSibling;
        exports.ownerDocument = ownerDocument;
        exports.previousSibling = previousSibling;
        exports.querySelector = querySelector;
        exports.querySelectorAll = querySelectorAll;
        exports.registerContextConsumer = registerContextConsumer;
        exports.registerContextProvider = registerContextProvider;
        exports.remove = remove;
        exports.removeAttribute = removeAttribute;
        exports.removeEventListener = removeEventListener;
        exports.setAttribute = setAttribute;
        exports.setCSSStyleProperty = setCSSStyleProperty;
        exports.setProperty = setProperty;
        exports.setText = setText;

        return exports;

    })({});
        // Meant to inherit any properties passed via the base renderer as the argument to the factory.
        Object.setPrototypeOf(renderer, baseRenderer);
        return renderer;
    }

    /*
     * Copyright (c) 2023, Salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * The base renderer that will be used by engine-core.
     * This will be used for DOM operations when lwc is running in a browser environment.
     */
    const renderer = assign(
    // The base renderer will invoke the factory with null and assign additional properties that are
    // shared across renderers
    rendererFactory(null), 
    // Properties that are either not required to be sandboxed or rely on a globally shared information
    {
        // insertStyleSheet implementation shares a global cache of stylesheet data
        insertStylesheet,
        // relies on a shared global cache
        createCustomElement,
        defineCustomElement: getUpgradableConstructor,
        isSyntheticShadowDefined: hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN),
    });
    function clearNode(node) {
        const childNodes = renderer.getChildNodes(node);
        for (let i = childNodes.length - 1; i >= 0; i--) {
            renderer.remove(childNodes[i], node);
        }
    }
    /**
     * The real `buildCustomElementConstructor`. Should not be accessible to external users!
     * @internal
     * @param Ctor LWC constructor to build
     * @returns A Web Component class
     * @see {@linkcode deprecatedBuildCustomElementConstructor}
     */
    function buildCustomElementConstructor(Ctor) {
        var _a;
        const HtmlPrototype = getComponentHtmlPrototype(Ctor);
        const { observedAttributes } = HtmlPrototype;
        const { attributeChangedCallback } = HtmlPrototype.prototype;
        return _a = class extends HTMLElement {
                constructor() {
                    super();
                    if (!isNull(this.shadowRoot)) {
                        {
                            // eslint-disable-next-line no-console
                            console.warn(`Found an existing shadow root for the custom element "${Ctor.name}". Call \`hydrateComponent\` instead.`);
                        }
                        clearNode(this.shadowRoot);
                    }
                    // Compute renderMode/shadowMode in advance. This must be done before `createVM` because `createVM` may
                    // mutate the element.
                    const { shadowMode, renderMode } = computeShadowAndRenderMode(Ctor, renderer);
                    // Native shadow components are allowed to have pre-existing `childNodes` before upgrade. This supports
                    // use cases where a custom element has declaratively-defined slotted content, e.g.:
                    // https://github.com/salesforce/lwc/issues/3639
                    const isNativeShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 0 /* ShadowMode.Native */;
                    if (!isNativeShadow && this.childNodes.length > 0) {
                        {
                            // eslint-disable-next-line no-console
                            console.warn(`Light DOM and synthetic shadow custom elements cannot have child nodes. ` +
                                `Ensure the element is empty, including whitespace.`);
                        }
                        clearNode(this);
                    }
                    createVM(this, Ctor, renderer, {
                        mode: 'open',
                        owner: null,
                        tagName: this.tagName,
                    });
                }
                connectedCallback() {
                    connectRootElement(this);
                }
                disconnectedCallback() {
                    disconnectRootElement(this);
                }
                attributeChangedCallback(name, oldValue, newValue) {
                    attributeChangedCallback.call(this, name, oldValue, newValue);
                }
                formAssociatedCallback(form) {
                    runFormAssociatedCallback(this, form);
                }
                formDisabledCallback(disabled) {
                    runFormDisabledCallback(this, disabled);
                }
                formResetCallback() {
                    runFormResetCallback(this);
                }
                formStateRestoreCallback(state, reason) {
                    runFormStateRestoreCallback(this, state, reason);
                }
            },
            _a.observedAttributes = observedAttributes,
            // Note CustomElementConstructor is not upgraded by LWC and inherits directly from HTMLElement which means it calls the native
            // attachInternals API.
            _a.formAssociated = Boolean(Ctor.formAssociated),
            _a;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // TODO [#2472]: Remove this workaround when appropriate.
    // eslint-disable-next-line @lwc/lwc-internal/no-global-node
    const _Node$1 = Node;
    const ConnectingSlot = new WeakMap();
    const DisconnectingSlot = new WeakMap();
    function callNodeSlot(node, slot) {
        {
            assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);
        }
        const fn = slot.get(node);
        if (!isUndefined$1(fn)) {
            fn(node);
        }
        return node; // for convenience
    }
    let monkeyPatched = false;
    function monkeyPatchDomAPIs() {
        if (monkeyPatched) {
            // don't double-patch
            return;
        }
        monkeyPatched = true;
        // Monkey patching Node methods to be able to detect the insertions and removal of root elements
        // created via createElement.
        const { appendChild, insertBefore, removeChild, replaceChild } = _Node$1.prototype;
        assign(_Node$1.prototype, {
            appendChild(newChild) {
                const appendedNode = appendChild.call(this, newChild);
                return callNodeSlot(appendedNode, ConnectingSlot);
            },
            insertBefore(newChild, referenceNode) {
                const insertedNode = insertBefore.call(this, newChild, referenceNode);
                return callNodeSlot(insertedNode, ConnectingSlot);
            },
            removeChild(oldChild) {
                const removedNode = removeChild.call(this, oldChild);
                return callNodeSlot(removedNode, DisconnectingSlot);
            },
            replaceChild(newChild, oldChild) {
                const replacedNode = replaceChild.call(this, newChild, oldChild);
                callNodeSlot(replacedNode, DisconnectingSlot);
                callNodeSlot(newChild, ConnectingSlot);
                return replacedNode;
            },
        });
    }
    {
        // In dev mode, we must eagerly patch these DOM APIs because `restrictions.ts` in `@lwc/engine-core` does
        // its own monkey-patching, and the assumption is that its monkey patches will apply on top of our own.
        // If we _don't_ eagerly monkey-patch, then APIs like `element.appendChild` could end up calling through
        // directly to the native DOM APIs instead, which would bypass synthetic custom element lifecycle
        // and cause rendering/`connectedCallback`/`disconnectedCallback` not to fire.
        // In prod mode, we avoid global patching as a slight perf optimization and because it's good practice
        // in general to avoid global patching.
        // See issue #4242 for details.
        monkeyPatchDomAPIs();
    }
    // For some reason, JSDOC says "options.is" is a syntax error. And we can't disable the rule using
    // `eslint-disable-next-line` because that gets included in the JSDOC, so we need this workaround.
    /* eslint-disable jsdoc/valid-types */
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
     * difference that in the options, you can pass the `is` property set to a Constructor instead of
     * just a string value. The intent is to allow the creation of an element controlled by LWC without
     * having to register the element as a custom element.
     * @param sel The tagname of the element to create
     * @param options Control the behavior of the created element
     * @param options.is The LWC component that the element should be
     * @param options.mode What kind of shadow root to use
     * @returns The created HTML element
     * @throws Throws when called with invalid parameters.
     * @example
     * const el = createElement('x-foo', { is: FooCtor });
     */
    function createElement(
    /* eslint-enable jsdoc/valid-types */
    sel, options) {
        if (!isObject(options) || isNull(options)) {
            throw new TypeError(`"createElement" function expects an object as second parameter but received "${toString$1(options)}".`);
        }
        const Ctor = options.is;
        if (!isFunction$1(Ctor)) {
            throw new TypeError(`"createElement" function expects an "is" option with a valid component constructor.`);
        }
        const { createCustomElement } = renderer;
        // tagName must be all lowercase, unfortunately, we have legacy code that is
        // passing `sel` as a camel-case, which makes them invalid custom elements name
        // the following line guarantees that this does not leaks beyond this point.
        const tagName = StringToLowerCase.call(sel);
        const apiVersion = getComponentAPIVersion(Ctor);
        const useNativeCustomElementLifecycle = 
        // temporary "kill switch"
        !lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE &&
            isAPIFeatureEnabled(7 /* APIFeature.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE */, apiVersion);
        const isFormAssociated = shouldBeFormAssociated(Ctor);
        // the custom element from the registry is expecting an upgrade callback
        /*
         * Note: if the upgradable constructor does not expect, or throw when we new it
         * with a callback as the first argument, we could implement a more advanced
         * mechanism that only passes that argument if the constructor is known to be
         * an upgradable custom element.
         */
        const upgradeCallback = (elm) => {
            createVM(elm, Ctor, renderer, {
                tagName,
                mode: options.mode !== 'closed' ? 'open' : 'closed',
                owner: null,
            });
            if (!useNativeCustomElementLifecycle) {
                // Monkey-patch on-demand, because if there are no components on the page using an old API
                // version, then we don't want to monkey patch at all
                monkeyPatchDomAPIs();
                ConnectingSlot.set(elm, connectRootElement);
                DisconnectingSlot.set(elm, disconnectRootElement);
            }
        };
        return createCustomElement(tagName, upgradeCallback, useNativeCustomElementLifecycle, isFormAssociated);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // TODO [#2472]: Remove this workaround when appropriate.
    // eslint-disable-next-line @lwc/lwc-internal/no-global-node
    const _Node = Node;
    /**
     * EXPERIMENTAL: The purpose of this function is to detect shadowed nodes. THIS API WILL BE REMOVED
     * ONCE LOCKER V1 IS NO LONGER SUPPORTED.
     * @param node Node to check
     * @returns `true` if the the node is shadowed
     * @example isNodeShadowed(document.querySelector('my-component'))
     */
    function isNodeShadowed(node) {
        if (isFalse(node instanceof _Node)) {
            return false;
        }
        // It's debatable whether shadow root instances should be considered as shadowed, but we keep
        // this unchanged for legacy reasons (#1250).
        if (node instanceof ShadowRoot) {
            return false;
        }
        const rootNode = node.getRootNode();
        // Handle the native case. We can return early here because an invariant of LWC is that
        // synthetic roots cannot be descendants of native roots.
        if (rootNode instanceof ShadowRoot &&
            isFalse(hasOwnProperty$1.call(getPrototypeOf$1(rootNode), 'synthetic'))) {
            return true;
        }
        // TODO [#1252]: Old behavior that is still used by some pieces of the platform. Manually
        // inserted nodes without the `lwc:dom=manual` directive will be considered as global elements.
        return renderer.isSyntheticShadowDefined && !isUndefined$1(node[KEY__SHADOW_RESOLVER]);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ComponentConstructorToCustomElementConstructorMap = new Map();
    function getCustomElementConstructor(Ctor) {
        if (Ctor === LightningElement) {
            throw new TypeError(`Invalid Constructor. LightningElement base class can't be claimed as a custom element.`);
        }
        let ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);
        if (isUndefined$1(ce)) {
            ce = buildCustomElementConstructor(Ctor);
            ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);
        }
        return ce;
    }
    /**
     * This static getter builds a Web Component class from a LWC constructor so it can be registered
     * as a new element via customElements.define() at any given time.
     * @example
     * import Foo from 'ns/foo';
     * customElements.define('x-foo', Foo.CustomElementConstructor);
     * const elm = document.createElement('x-foo');
     */
    defineProperty(LightningElement, 'CustomElementConstructor', {
        get() {
            return getCustomElementConstructor(this);
        },
    });
    freeze(LightningElement);
    seal(LightningElement.prototype);

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function addEventListener(target, type, callback, options) {
        target.addEventListener(type, callback, options);
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * Creates a context provider, given a wire adapter constructor.
     * @param adapter The wire adapter to create a context provider for.
     * @returns A new context provider.
     */
    function createContextProvider(adapter) {
        return createContextProviderWithRegister(adapter, registerContextProvider);
    }
    function registerContextProvider(elm, adapterContextToken, onContextSubscription) {
        addEventListener(elm, adapterContextToken, ((evt) => {
            evt.stopImmediatePropagation();
            const { setNewContext, setDisconnectedCallback } = evt;
            onContextSubscription({
                setNewContext,
                setDisconnectedCallback,
            });
        }));
    }
    /** version: 6.4.5 */

    /**
     * LWC Hot Module Replacement(HMR) client code 
     */
    const hotModuleCbs = new Map();
    function accept(modulePath, cb) {
        const callbacks = hotModuleCbs.get(modulePath) || [];
        callbacks.push(cb);
        hotModuleCbs.set(modulePath, callbacks);
    }
    /**
     * API call for owner module to ingest updates to dependencies.
     * @param ownerPath {string} The owner module's path or module identifier.
     * @param modulePath {string} The module path.
     * @param cb {function} The callback function to invoke for self update.
     */
    function acceptDeps(_ownerPath, modulePath, cb) {
        const callbacks = hotModuleCbs.get(modulePath) || [];
        callbacks.push(cb);
        hotModuleCbs.set(modulePath, callbacks);
    }
    const activeModules = new Map();
    const staleModules = new Map();
    /**
     * Register a module path used by the client along with its state.
     * @param modulePath {string} The module path.
     * @param hash {string} A hash representation of the module's source to perform freshness check.
     * @param compileOptions {object} The compiler config that was used to bundle this module.
     */
    function register(modulePath, hash, compileOptions) {
        const moduleState = {
            modulePath,
            hash,
            compileOptions,
        };
        const staleModule = activeModules.get(moduleState.modulePath);
        if (staleModule) {
            // This is a new version of an existing module
            // Potentially clean up old handlers, call dispose()
            staleModules.set(modulePath, staleModule);
        }
        activeModules.set(modulePath, moduleState);
    }
    function updateHandler(modulePath) {
        let callbacks = [];
        if (activeModules.has(modulePath)) {
            // Create a copy of the callbacks to retain the current list in a closure for when the hot
            // module is available. Otherwise, the incoming hot module's callback will also be invoked
            // and removed. Thus future updates won't have a callback to process.
            callbacks = [...hotModuleCbs.get(modulePath)];
            return (hotModule) => {
                callbacks.forEach((cb) => {
                    cb(hotModule);
                });
                const existingCbs = hotModuleCbs.get(modulePath) || [];
                hotModuleCbs.set(modulePath, existingCbs.filter((cb) => !callbacks.includes(cb)));
            };
        }
    }
    /**
     * Get module state for all active modules on the client.
     * @returns An array of objects containing modulePath, hash and compiler config.
     */
    function getActiveModules() {
        return Array.from(activeModules.values());
    }

    /**
     * This module is responsible for notfying the user about module updates in the server
     **/
    class NotifyModuleUpdate {
        constructor() {
            this.observers = new Set();
        }
        register(observer) {
            if (observer) {
                this.observers.add(observer);
            }
        }
        deregister(observer) {
            if (observer) {
                this.observers.delete(observer);
            }
        }
        notify(message) {
            this.observers.forEach((observer) => observer.notify(message));
        }
    }

    class Connection {
        constructor() {
            this.protocol = 'ws';
            this.host = 'localhost';
            this.port = '8080';
        }
        init(protocol, host, port) {
            this.protocol = protocol;
            this.host = host;
            this.port = port;
        }
        fetchModule(modulePath) {
            const fetchData = { type: 'fetch', data: { modulePath } };
            // fetch the new module from the server
            // eval it and return the new module
            this.send(fetchData);
        }
        initializeConnection(initCallback, messageCallback) {
            const socket = new WebSocket(`${this.protocol}://${this.host}:${this.port}`);
            if (socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
                // eslint-disable-next-line no-console
                console.error(`Failed to start a WebSocket connection. Running page without Local Development support.`);
                return false;
            }
            this.socket = socket;
            this.socket.addEventListener('open', () => {
                initCallback();
            });
            this.socket.addEventListener('message', ({ data }) => {
                if (data) {
                    // When there is an update, handle the incoming message and request an updated module
                    messageCallback(JSON.parse(data));
                }
            });
            return true;
        }
        send(data) {
            if (this.socket && this.socket.readyState === this.socket.OPEN) {
                this.socket.send(JSON.stringify(data));
            }
        }
        close() {
            var _a;
            (_a = this.socket) === null || _a === void 0 ? void 0 : _a.close();
        }
    }

    class ConsoleNotifier {
        notify(message) {
            switch (message.eventType) {
                case 'create':
                    console.log(`A new module was added at ${message.modulePath}`);
                    break;
                case 'delete':
                    console.log(`A module was deleted at ${message.modulePath}`);
                    break;
                case 'update':
                    console.log(`A module was updated at ${message.modulePath}`);
                    break;
                case 'hot-swapped':
                    console.log(`A module was hot swapped at ${message.modulePath}`);
                    break;
            }
            if (message.action) {
                console.log(`Taking the following action on module update ${message.action.message}`);
            }
        }
    }

    function initCallback() {
        const activeModules = getActiveModules();
        const initData = {
            type: 'init',
            data: {
                url: window.location.href,
                activePaths: activeModules.map((m) => {
                    return { type: 'register', data: m };
                }),
                target: 'LEX',
            },
        };
        if (activeModules.length) {
            hmrClient === null || hmrClient === void 0 ? void 0 : hmrClient.connection.send(initData);
        }
    }
    const pendingHandlers = new Map();
    let hotModuleCounter = 0;
    function messageCallback(data) {
        switch (data.type) {
            // Some paths were updated
            case 'update': {
                const moduleUpdate = data;
                moduleUpdate.data.forEach(({ modulePath }) => {
                    hmrClient === null || hmrClient === void 0 ? void 0 : hmrClient.notifyModuleUpdate.notify({
                        eventType: 'update',
                        modulePath,
                    });
                    const handler = updateHandler(modulePath);
                    if (handler) {
                        // Possibly use the module hash as key and allow overlapping handlers for same path.
                        pendingHandlers.set(modulePath, handler);
                        hmrClient === null || hmrClient === void 0 ? void 0 : hmrClient.connection.fetchModule(modulePath);
                    }
                });
                break;
            }
            // In coming hot module
            case 'module-update': {
                const hotModules = data;
                hotModules.data.forEach(({ modulePath, src }) => {
                    hmrClient === null || hmrClient === void 0 ? void 0 : hmrClient.notifyModuleUpdate.notify({
                        eventType: 'hot-swapped',
                        modulePath,
                    });
                    const descriptors = extractDescriptorsFromSource(src);
                    if (descriptors) {
                        const handler = pendingHandlers.get(modulePath);
                        // Create temporary descriptor for the hot module
                        const hotModulePath = modulePath + `-hmr-${hotModuleCounter++}`;
                        const evaledModule = hmrClient === null || hmrClient === void 0 ? void 0 : hmrClient.moduleHandlerHooks.evaluateModule(descriptors.parentDescriptor, hotModulePath, adaptSourceForLex(src, hotModulePath, descriptors.parentDescriptor));
                        handler(evaledModule);
                    }
                });
                break;
            }
            case 'module-delete': {
                const deletedModule = data;
                deletedModule.data.forEach(({ modulePath }) => {
                    hmrClient === null || hmrClient === void 0 ? void 0 : hmrClient.notifyModuleUpdate.notify({
                        eventType: 'delete',
                        modulePath,
                    });
                });
                // A module was deleted
                // reload page?
                break;
            }
            case 'error':
                // eslint-disable-next-line no-console
                console.log('LWC dev server encountered an error, reloading page');
                window.location.reload();
                break;
        }
    }
    function extractDescriptorsFromSource(src) {
        const amdPattern = /^define\('([^']+)',\s*\[([^\]]*)\],/;
        const match = amdPattern.exec(src);
        if (match) {
            return {
                parentDescriptor: match[1],
                deps: match[2].split(',').map((i) => i.trim().replace("'", '')),
            };
        }
    }
    /**
     * Adapt source provided by dev server to LEX format.
     * Note: This logic comes from [core:]BundleModuleDefFactory.processCompiledCode()
     * @param src compiled module file
     */
    function adaptSourceForLex(src, hotModulePath, parentDescriptor) {
        return src
            .replace(`define('${parentDescriptor}',`, `function() { $A.componentService.addModule('${hotModulePath}', '${hotModulePath}',`)
            .concat('}');
    }
    class HMRClient {
        constructor(moduleHandlerHooks) {
            this.notifyModuleUpdate = new NotifyModuleUpdate();
            this.connection = new Connection();
            this.moduleHandlerHooks = moduleHandlerHooks;
        }
    }
    let hmrClient;
    function initializeClient(protocol, host, port, hotModuleHandler, observer) {
        if (!hmrClient) {
            hmrClient = new HMRClient(hotModuleHandler);
            // Register any container specific observers
            hmrClient.notifyModuleUpdate.register(observer);
            // Register a console logger
            hmrClient.notifyModuleUpdate.register(new ConsoleNotifier());
            // Initialize connection to dev server
            hmrClient.connection.init(protocol, host, port);
            hmrClient.connection.initializeConnection(initCallback, messageCallback);
        }
    }

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        accept: accept,
        acceptDeps: acceptDeps,
        initializeHmrClient: initializeClient,
        register: register
    });

    exports.LightningElement = LightningElement;
    exports.__unstable__ProfilerControl = profilerControl;
    exports.__unstable__ReportingControl = reportingControl;
    exports.createContextProvider = createContextProvider;
    exports.createElement = createElement;
    exports.freezeTemplate = freezeTemplate;
    exports.getComponentConstructor = getComponentConstructor;
    exports.getComponentDef = getComponentDef;
    exports.hot = index;
    exports.isComponentConstructor = isComponentConstructor;
    exports.isNodeFromTemplate = isNodeShadowed;
    exports.parseFragment = parseFragment;
    exports.parseSVGFragment = parseSVGFragment;
    exports.readonly = readonly;
    exports.registerComponent = registerComponent;
    exports.registerDecorators = registerDecorators;
    exports.registerTemplate = registerTemplate;
    exports.renderer = renderer;
    exports.rendererFactory = rendererFactory;
    exports.sanitizeAttribute = sanitizeAttribute;
    exports.setFeatureFlag = setFeatureFlag;
    exports.setHooks = setHooks;
    exports.swapComponent = swapComponent;
    exports.swapStyle = swapStyle;
    exports.swapTemplate = swapTemplate;
    exports.unwrap = unwrap;

    return exports;

})({});
/** LWC OSS version: 6.4.5
    lwc-platform version: 250.8.3-6.4.5 */

/**
 * Copyright (C) 2018 salesforce.com, inc.
 */
this.Aura = this.Aura || {};
this.Aura.WireService = (function (exports) {
    'use strict';

    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */
    /**
     * Copyright (c) 2024 Salesforce, Inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     *
     * @param value
     * @param msg
     */
    /**
     * Determines whether the argument is `undefined`.
     * @param obj Value to test
     * @returns `true` if the value is `undefined`.
     */
    function isUndefined(obj) {
        return obj === undefined;
    }
    /** version: 6.4.5 */

    /*
     * Copyright (c) 2024, Salesforce, Inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ValueChangedEventType = 'ValueChangedEvent';
    /**
     * Event fired by wire adapters to emit a new value.
     */
    class ValueChangedEvent {
        constructor(value) {
            this.type = ValueChangedEventType;
            this.value = value;
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { freeze, defineProperty, isExtensible } = Object;
    // This value needs to be in sync with wiring.ts from @lwc/engine-core
    const DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    const DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
    /**
     * Registers a wire adapter factory for Lightning Platform.
     * @param adapterId Adapter ID object
     * @param adapterEventTargetCallback Adapter factory function
     * @throws when parameters are not valid
     * @deprecated
     */
    function register(adapterId, adapterEventTargetCallback) {
        if (adapterId == null || !isExtensible(adapterId)) {
            throw new TypeError('adapter id must be extensible');
        }
        if (typeof adapterEventTargetCallback !== 'function') {
            throw new TypeError('adapter factory must be a callable');
        }
        if ('adapter' in adapterId) {
            throw new TypeError('adapter id is already associated to an adapter factory');
        }
        const AdapterClass = class extends LegacyWireAdapterBridge {
            constructor(dataCallback) {
                super(dataCallback);
                adapterEventTargetCallback(this.eventTarget);
            }
        };
        freeze(AdapterClass);
        freeze(AdapterClass.prototype);
        defineProperty(adapterId, 'adapter', {
            writable: false,
            configurable: false,
            value: AdapterClass,
        });
    }
    /**
     * Registers the wire service. noop
     * @deprecated
     */
    function registerWireService() { }
    const { forEach, splice: ArraySplice, indexOf: ArrayIndexOf } = Array.prototype;
    // wire event target life cycle connectedCallback hook event type
    const CONNECT = 'connect';
    // wire event target life cycle disconnectedCallback hook event type
    const DISCONNECT = 'disconnect';
    // wire event target life cycle config changed hook event type
    const CONFIG = 'config';
    function removeListener(listeners, toRemove) {
        const idx = ArrayIndexOf.call(listeners, toRemove);
        if (idx > -1) {
            ArraySplice.call(listeners, idx, 1);
        }
    }
    function isEmptyConfig(config) {
        return Object.keys(config).length === 0;
    }
    function isValidConfig(config, params) {
        // The config is valid if there is no params, or if exist a param for which config[param] !== undefined.
        return params.length === 0 || params.some((param) => !isUndefined(config[param]));
    }
    function isDifferentConfig(newConfig, oldConfig, params) {
        return params.some((param) => newConfig[param] !== oldConfig[param]);
    }
    class LegacyWireAdapterBridge {
        constructor(callback) {
            this.connecting = [];
            this.disconnecting = [];
            this.configuring = [];
            this.isFirstUpdate = true;
            this.callback = callback;
            this.wiredElementHost = callback[DeprecatedWiredElementHost];
            this.dynamicParamsNames = callback[DeprecatedWiredParamsMeta];
            this.eventTarget = {
                addEventListener: (type, listener) => {
                    switch (type) {
                        case CONNECT: {
                            this.connecting.push(listener);
                            break;
                        }
                        case DISCONNECT: {
                            this.disconnecting.push(listener);
                            break;
                        }
                        case CONFIG: {
                            this.configuring.push(listener);
                            if (this.currentConfig !== undefined) {
                                listener.call(undefined, this.currentConfig);
                            }
                            break;
                        }
                        default:
                            throw new Error(`Invalid event type ${type}.`);
                    }
                },
                removeEventListener: (type, listener) => {
                    switch (type) {
                        case CONNECT: {
                            removeListener(this.connecting, listener);
                            break;
                        }
                        case DISCONNECT: {
                            removeListener(this.disconnecting, listener);
                            break;
                        }
                        case CONFIG: {
                            removeListener(this.configuring, listener);
                            break;
                        }
                        default:
                            throw new Error(`Invalid event type ${type}.`);
                    }
                },
                dispatchEvent: (evt) => {
                    if (evt instanceof ValueChangedEvent) {
                        const value = evt.value;
                        this.callback(value);
                    }
                    else if (evt.type === 'wirecontextevent') {
                        // TODO [#1357]: remove this branch
                        return this.wiredElementHost.dispatchEvent(evt);
                    }
                    else {
                        throw new Error(`Invalid event type ${evt.type}.`);
                    }
                    return false; // canceling signal since we don't want this to propagate
                },
            };
        }
        update(config) {
            if (this.isFirstUpdate) {
                // this is a special case for legacy wire adapters: when all the config params are undefined,
                // the config on the wire adapter should not be called until one of them changes.
                this.isFirstUpdate = false;
                if (!isEmptyConfig(config) && !isValidConfig(config, this.dynamicParamsNames)) {
                    return;
                }
            }
            if (isUndefined(this.currentConfig) ||
                isDifferentConfig(config, this.currentConfig, this.dynamicParamsNames)) {
                this.currentConfig = config;
                forEach.call(this.configuring, (listener) => {
                    listener.call(undefined, config);
                });
            }
        }
        connect() {
            forEach.call(this.connecting, (listener) => listener.call(undefined));
        }
        disconnect() {
            forEach.call(this.disconnecting, (listener) => listener.call(undefined));
        }
    }
    /** version: 6.4.5 */

    exports.ValueChangedEvent = ValueChangedEvent;
    exports.register = register;
    exports.registerWireService = registerWireService;

    return exports;

})({});
/** LWC OSS version: 6.4.5
    lwc-platform version: 250.8.3-6.4.5 */

try {
/*!
 * Copyright (c) 2017-present, salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Bundle from @locker/aura
 * Generated: 2024-05-21
 * Version: 0.21.7
 */

var AuraLocker = function () {
function DOMPurify(w) {
  if (typeof window.DOMPurify !== 'undefined') {
    return new window.DOMPurify(w);
  } else {
    throw new Error('Missing dependency on DOMPurify');
  }
}
var AuraLocker = function (exports, DOMPurify) {
  'use strict';

  // Declare shorthand functions. Sharing these declarations accross modules
  // improves both consitency and minification. Unused declarations are dropped
  // by the tree shaking process.
  const {
    stringify
  } = JSON;
  const {
    assign,
    create: create$1,
    defineProperties,
    freeze,
    getOwnPropertyDescriptors,
    getOwnPropertyNames,
    getOwnPropertySymbols,
    isFrozen,
    entries: ObjectEntries,
    keys: ObjectKeys,
    values: ObjectValues,
    seal,
    create: ObjectCreate
  } = Object;
  const {
    apply,
    construct,
    defineProperty,
    deleteProperty,
    get,
    getOwnPropertyDescriptor,
    getPrototypeOf,
    has,
    isExtensible,
    ownKeys,
    preventExtensions,
    set,
    setPrototypeOf
  } = Reflect;

  /**
   * Currying is the process of transforming a function that takes multiple
   * arguments into a function that takes just a single argument and returns
   * another function if any arguments are still needed.
   *
   * Here we create such a function that take one argument, a function that needs
   * to be applied on an object, and return a new function that encapsulates
   * the function and can be applied on an object.
   *
   * Without uncurryThis():
   * hasOwnProperty = Object.prototype.hasOwnProperty;
   * hasOwnProperty.apply(someObject);
   *
   * With uncurryThis():
   * hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
   * hasOwnProperty(someObject);
   *
   * Using uncurryThis(), more than just a syntactic sugar, is an effective
   * defense mechanism which prevents .call() and .apply() from being tampered
   * by any code that loads after uncurryThis() and before freezing.
   */
  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);
  const ObjectToString = uncurryThis(Object.prototype.toString);
  const ObjectHasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
  const FunctionBind = uncurryThis(Function.prototype.bind);
  const FunctionToString = uncurryThis(Function.prototype.toString);
  const ArrayForEach = uncurryThis(Array.prototype.forEach);
  const ArraySlice = uncurryThis(Array.prototype.slice);
  const StringReplace = uncurryThis(String.prototype.replace);

  /**
   * Detect if the parameter is a primitive.
   * - NaN and Infinity are 'numbers'.
   * - null is object but we detect it and return early.
   */
  function isPrimitive(value) {
    if (value === null || value === undefined) {
      return true;
    }
    switch (typeof value) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'symbol':
        return true;
      default:
        return false;
    }
  }

  /**
   * Return value as string.
   */
  function asString(value) {
    try {
      return String(value);
    } catch (e) {
      return '';
    }
  }
  const nativeSourceTemplate = StringReplace(FunctionToString(defineProperty), /defineProperty/g, '__NAME__');

  /**
   * Mask the toString method of `func` with that of `reference`.
   */
  function maskToString(func, reference) {
    const source = typeof reference === 'function' ? FunctionToString(reference) : StringReplace(nativeSourceTemplate, /__NAME__/g, asString(reference));
    defineProperty(func, 'toString', {
      enumerable: false,
      configurable: true,
      writable: true,
      value() {
        return source;
      }
    });
    return func;
  }
  function isPositiveInteger(value) {
    if (typeof value === 'symbol') return false;
    const num = Number(value);
    return Number.isInteger(num) && num >= 0;
  }
  const {
    isArray
  } = Array;

  /**
   * Return value as Array.
   */
  function asArray(value) {
    if (isArray(value)) {
      return value;
    }
    return [value];
  }
  /**
   * Creates an array of unique values from two arrays.
   * This is 33% faster than Array.concat() on 2x100 arrays.
   * Dedupe using a Set is 14x slower: Array.from(new Set([...a, ...b])).
   */
  function ArrayMerge(a, b) {
    a = asArray(a);
    b = asArray(b);
    const unique = {};
    const result = [];
    for (let i = 2; i--; a = b) {
      for (let j = 0, n = a.length; j < n; j++) {
        const value = a[j];
        unique[value] = unique[value] || result.push(value);
      }
    }
    return result;
  }

  /**
   * A fast uncurried Array.forEach() implementation for dense arrays.
   * Avoid using with:
   * - sparse arrays
   * - arrays containing user data (which could be sparse)
   *
   * Note: The native forEach function, to optimize sparse arrays, must check whether
   * each slot in the array has ever been assigned or not (a simple null or undefined
   * check is not sufficient). However, sparse arrays are very rare in the real world,
   * and removing the check improves performance by 50x.
   */
  function fastArrayForEach(array, callback) {
    for (let i = 0, n = array.length; i < n; i++) {
      callback(array[i], i, array);
    }
  }

  // Prevent an adversary from using TOCTTOU (time-of-check-to-time-of-use) to
  // skip some intermediate ancestors by stringify/propify the property name
  // once, first.
  function asPropertyName(value) {
    if (typeof value === 'symbol') {
      return value;
    }
    const string = String(value);
    const maybeIndex = Number(string);
    if (maybeIndex > -1 && maybeIndex % 1 === 0) {
      return maybeIndex;
    }
    return string;
  }

  // @TODO: remove these functions. Our filtering mechanism should not
  // rely on the more expensive operation.

  function isObject(obj) {
    return typeof obj === 'object' && obj !== null && !isArray(obj);
  }
  function isObjectObject(value) {
    return typeof value === 'object' && value !== null && ObjectToString(value) === '[object Object]';
  }

  // https://github.com/jonschlinkert/is-plain-object
  // Copyright  2017, Jon Schlinkert. Released under the MIT License.
  function isPlainObject(value) {
    if (isObjectObject(value) === false) {
      return false;
    }

    // If has modified constructor
    const ctor = value.constructor;
    if (typeof ctor !== 'function') {
      return false;
    }
    try {
      // If has modified prototype
      const proto = ctor.prototype;
      if (isObjectObject(proto) === false) {
        return false;
      }
      // If constructor does not have an Object-specific method
      if (proto.hasOwnProperty('isPrototypeOf') === false) {
        return false;
      }
    } catch (e) {
      /* Assume is  object when throws */
    }

    // Most likely a plain Object
    return true;
  }
  const {
    resolve: PromiseResolve
  } = Promise;
  function isPromise(value) {
    if (typeof value !== 'object' || value === null) {
      return false;
    }
    try {
      return PromiseResolve(value) === value;
    } catch (e) {
      // Continue.
    }
    if (value instanceof Promise) {
      return true;
    }
    if (typeof value.then === 'function' && typeof value.catch === 'function' && typeof value.constructor === 'function') {
      const {
        constructor
      } = value;
      return constructor.name === 'Promise' && constructor.toString().includes('[native code]');
    }
    return false;
  }
  function isNode(el) {
    try {
      return el instanceof Node;
    } catch (e) {
      return false;
    }
  }
  function isNodeList(el) {
    try {
      return el instanceof NodeList || el instanceof HTMLCollection;
    } catch (e) {
      return false;
    }
  }

  /**
   * Is the given node a shadowRoot?
   * @param {Node} node
   */
  function isShadowRoot(node) {
    return typeof window.ShadowRoot !== 'undefined' ? node instanceof ShadowRoot : false;
  }
  function isWindowLikeObject(obj) {
    return !!obj && typeof obj === 'object' && obj === obj['window'];
  }
  function isSharedElement(el) {
    return el === document.body || el === document.head || el === document.documentElement;
  }

  // @TODO: This repair will make it out as its own independent shim since

  // Prevent accessing global properties by calling legacy accessors with
  // thisArg == null, causing the real window object to be exposed to the
  // function as thisArg when the getter is invoked.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1253016

  // Prevent bypassing access checks on all required objects and leak
  // anything from another page.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=403596

  function repairAccessors(realmRec) {
    const {
      unsafeGlobal
    } = realmRec;
    defineProperties(unsafeGlobal.Object.prototype, {
      __defineGetter__: {
        value: function (prop, func) {
          return defineProperty(this, prop, {
            get: func,
            enumerable: true,
            configurable: true
          });
        }
      },
      __defineSetter__: {
        value: function (prop, func) {
          return defineProperty(this, prop, {
            set: func,
            enumerable: true,
            configurable: true
          });
        }
      },
      __lookupGetter__: {
        value: function (prop) {
          prop = asPropertyName(prop);
          let base = this;
          let desc;
          while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {
            base = getPrototypeOf(base);
          }
          return desc && desc.get;
        }
      },
      __lookupSetter__: {
        value: function (prop) {
          prop = asPropertyName(prop);
          let base = this;
          let desc;
          while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {
            base = getPrototypeOf(base);
          }
          return desc && desc.set;
        }
      }
    });
  }

  /**
   * Get all intrinsics:
   *
   * 1. Named intrinsics: available as data properties of
   * the global object.
   *
   * 2. Anonymous intrinsics: not otherwise reachable by own property
   * name traversal.
   *
   * https://tc39.github.io/ecma262/#table-7
   */
  function getIntrinsics(realmRec) {
    const {
      unsafeGlobal: _
    } = realmRec;

    // Anonymous intrinsics.

    const SymbolIterator = typeof _.Symbol && _.Symbol.iterator || '@@iterator';
    const ArrayIteratorInstance = new _.Array()[SymbolIterator]();
    const ArrayIteratorPrototype = getPrototypeOf(ArrayIteratorInstance);
    const IteratorPrototype = getPrototypeOf(ArrayIteratorPrototype);
    const AsyncFunctionInstance = _.eval('(async function(){})');
    const AsyncFunction = AsyncFunctionInstance.constructor;
    const AsyncFunctionPrototype = AsyncFunction.prototype;

    // Ensure parsing doesn't fail on platforms that don't support Generator Functions.
    let GeneratorFunctionInstance;
    try {
      GeneratorFunctionInstance = _.eval('(function*(){})');
    } catch (e) {
      if (!(e instanceof SyntaxError)) {
        // Re-throw
        throw e;
      }
    }
    const GeneratorFunction = GeneratorFunctionInstance && GeneratorFunctionInstance.constructor;
    const Generator = GeneratorFunctionInstance && GeneratorFunction.prototype;
    const GeneratorPrototype = GeneratorFunctionInstance && Generator.prototype;

    // Ensure parsing doesn't fail on platforms that don't support Async Generator Functions.
    let AsyncGeneratorFunctionInstance;
    try {
      AsyncGeneratorFunctionInstance = _.eval('(async function*(){})');
    } catch (e) {
      if (!(e instanceof SyntaxError)) {
        // Re-throw
        throw e;
      }
    }
    const AsyncGeneratorFunction = AsyncGeneratorFunctionInstance && AsyncGeneratorFunctionInstance.constructor;
    const AsyncGenerator = AsyncGeneratorFunctionInstance && AsyncGeneratorFunction.prototype;
    const AsyncGeneratorPrototype = AsyncGeneratorFunctionInstance && AsyncGenerator.prototype;

    // const AsyncFromSyncIteratorPrototype = undefined // not reacheable
    const AsyncIteratorPrototype = AsyncGeneratorFunctionInstance && getPrototypeOf(AsyncGeneratorPrototype);
    const MapIteratorObject = new _.Map()[SymbolIterator]();
    const MapIteratorPrototype = getPrototypeOf(MapIteratorObject);
    const SetIteratorObject = new _.Set()[SymbolIterator]();
    const SetIteratorPrototype = getPrototypeOf(SetIteratorObject);
    const StringIteratorObject = new _.String()[SymbolIterator]();
    const StringIteratorPrototype = getPrototypeOf(StringIteratorObject);
    const ThrowTypeError = _.eval('(function () { "use strict"; return Object.getOwnPropertyDescriptor(arguments, "callee").get; })()');
    const TypedArray = getPrototypeOf(Int8Array);
    const TypedArrayPrototype = TypedArray.prototype;

    // Named intrinsics

    return {
      // *** Table 7

      // %Array%
      Array: _.Array,
      // %ArrayBuffer%
      ArrayBuffer: _.ArrayBuffer,
      // %ArrayBufferPrototype%
      ArrayBufferPrototype: _.ArrayBuffer.prototype,
      // %ArrayIteratorPrototype%
      ArrayIteratorPrototype,
      // %ArrayPrototype%
      ArrayPrototype: _.Array.prototype,
      // %ArrayProto_entries%
      ArrayProto_entries: _.Array.prototype.entries,
      // %ArrayProto_foreach%
      ArrayProto_foreach: _.Array.prototype.forEach,
      // %ArrayProto_keys%
      ArrayProto_keys: _.Array.prototype.forEach,
      // %ArrayProto_values%
      ArrayProto_values: _.Array.prototype.values,
      // %AsyncFromSyncIteratorPrototype%
      // AsyncFromSyncIteratorPrototype, // Not reacheable
      // %AsyncFunction%
      AsyncFunction,
      // %AsyncFunctionPrototype%
      AsyncFunctionPrototype,
      // %AsyncGenerator%
      AsyncGenerator,
      // %AsyncGeneratorFunction%
      AsyncGeneratorFunction,
      // %AsyncGeneratorPrototype%
      AsyncGeneratorPrototype,
      // %AsyncIteratorPrototype%
      AsyncIteratorPrototype,
      // %Boolean%
      Boolean: _.Boolean,
      // %BooleanPrototype%
      BooleanPrototype: _.Boolean.prototype,
      // %DataView%
      DataView: _.DataView,
      // %DataViewPrototype%
      DataViewPrototype: _.DataView.prototype,
      // %Date%
      Date: _.Date,
      // %DatePrototype%
      DatePrototype: _.Date.prototype,
      // %decodeURI%
      decodeURI: _.decodeURI,
      // %decodeURIComponent%
      decodeURIComponent: _.decodeURIComponent,
      // %encodeURI%
      encodeURI: _.encodeURI,
      // %encodeURIComponent%
      encodeURIComponent: _.encodeURIComponent,
      // %Error%
      Error: _.Error,
      // %ErrorPrototype%
      ErrorPrototype: _.Error.prototype,
      // %eval%
      // eval: sandbox.eval,
      // %EvalError%
      EvalError: _.EvalError,
      // %EvalErrorPrototype%
      EvalErrorPrototype: _.EvalError.prototype,
      // %Float32Array%
      Float32Array: _.Float32Array,
      // %Float32ArrayPrototype%
      Float32ArrayPrototype: _.Float32Array.prototype,
      // %Float64Array%
      Float64Array: _.Float64Array,
      // %Float64ArrayPrototype%
      Float64ArrayPrototype: _.Float64Array.prototype,
      // %Function%
      Function: _.Function,
      // %FunctionPrototype%
      FunctionPrototype: Function.prototype,
      // %Generator%
      Generator,
      // %GeneratorFunction%
      GeneratorFunction,
      // %GeneratorPrototype%
      GeneratorPrototype,
      // %Int8Array%
      Int8Array: _.Int8Array,
      // %Int8ArrayPrototype%
      Int8ArrayPrototype: _.Int8Array.prototype,
      // %Int16Array%
      Int16Array: _.Int16Array,
      // %Int16ArrayPrototype%,
      Int16ArrayPrototype: _.Int16Array.prototype,
      // %Int32Array%
      Int32Array: _.Int32Array,
      // %Int32ArrayPrototype%
      Int32ArrayPrototype: _.Int32Array.prototype,
      // %isFinite%
      isFinite: _.isFinite,
      // %isNaN%
      isNaN: _.isNaN,
      // %IteratorPrototype%
      IteratorPrototype,
      // %JSON%
      JSON: _.JSON,
      // %JSONParse%
      JSONParse: _.JSON.parse,
      // %Map%
      Map: _.Map,
      // %MapIteratorPrototype%
      MapIteratorPrototype,
      // %MapPrototype%
      MapPrototype: _.Map.prototype,
      // %Math%
      Math: _.Math,
      // %Number%
      Number: _.Number,
      // %NumberPrototype%
      NumberPrototype: _.Number.prototype,
      // %Object%
      Object: _.Object,
      // %ObjectPrototype%
      ObjectPrototype: _.Object.prototype,
      // %ObjProto_toString%
      ObjProto_toString: _.Object.prototype.toString,
      // %ObjProto_valueOf%
      ObjProto_valueOf: _.Object.prototype.valueOf,
      // %parseFloat%
      parseFloat: _.parseFloat,
      // %parseInt%
      parseInt: _.parseInt,
      // %Promise%
      Promise: _.Promise,
      // %Promise_all%
      Promise_all: _.Promise.all,
      // %Promise_reject%
      Promise_reject: _.Promise.reject,
      // %Promise_resolve%
      Promise_resolve: _.Promise.resolve,
      // %PromiseProto_then%
      PromiseProto_then: _.Promise.prototype.then,
      // %PromisePrototype%
      PromisePrototype: _.Promise.prototype,
      // %Proxy%
      Proxy: _.Proxy,
      // %RangeError%
      RangeError: _.RangeError,
      // %RangeErrorPrototype%
      RangeErrorPrototype: _.RangeError.prototype,
      // %ReferenceError%
      ReferenceError: _.ReferenceError,
      // %ReferenceErrorPrototype%
      ReferenceErrorPrototype: _.ReferenceError.prototype,
      // %Reflect%
      Reflect: _.Reflect,
      // %RegExp%
      RegExp: _.RegExp,
      // %RegExpPrototype%
      RegExpPrototype: _.RegExp.prototype,
      // %Set%
      Set: _.Set,
      // %SetIteratorPrototype%
      SetIteratorPrototype,
      // %SetPrototype%
      SetPrototype: _.Set.prototype,
      // %SharedArrayBuffer%
      // SharedArrayBuffer: undefined, // Deprecated on Jan 5, 2018
      // %SharedArrayBufferPrototype%
      // SharedArrayBufferPrototype: undefined, // Deprecated on Jan 5, 2018
      // %String%
      String: _.String,
      // %StringIteratorPrototype%
      StringIteratorPrototype,
      // %StringPrototype%
      StringPrototype: _.String.prototype,
      // %Symbol%
      Symbol: _.Symbol,
      // %SymbolPrototype%
      SymbolPrototype: _.Symbol.prototype,
      // %SyntaxError%
      SyntaxError: _.SyntaxError,
      // %SyntaxErrorPrototype%
      SyntaxErrorPrototype: _.SyntaxError.prototype,
      // %ThrowTypeError%
      ThrowTypeError,
      // %TypedArray%
      TypedArray,
      // %TypedArrayPrototype%
      TypedArrayPrototype,
      // %TypeError%
      TypeError: _.TypeError,
      // %TypeErrorPrototype%
      TypeErrorPrototype: _.TypeError.prototype,
      // %Uint8Array%
      Uint8Array: _.Uint8Array,
      // %Uint8ArrayPrototype%
      Uint8ArrayPrototype: _.Uint8Array.prototype,
      // %Uint8ClampedArray%
      Uint8ClampedArray: _.Uint8ClampedArray,
      // %Uint8ClampedArrayPrototype%
      Uint8ClampedArrayPrototype: _.Uint8ClampedArray.prototype,
      // %Uint16Array%
      Uint16Array: _.Uint16Array,
      // %Uint16ArrayPrototype%
      Uint16ArrayPrototype: Uint16Array.prototype,
      // %Uint32Array%
      Uint32Array: _.Uint32Array,
      // %Uint32ArrayPrototype%
      Uint32ArrayPrototype: _.Uint32Array.prototype,
      // %URIError%
      URIError: _.URIError,
      // %URIErrorPrototype%
      URIErrorPrototype: _.URIError.prototype,
      // %WeakMap%
      WeakMap: _.WeakMap,
      // %WeakMapPrototype%
      WeakMapPrototype: _.WeakMap.prototype,
      // %WeakSet%
      WeakSet: _.WeakSet,
      // %WeakSetPrototype%
      WeakSetPrototype: _.WeakSet.prototype,
      // *** Annex B

      // %escape%
      escape: _.escape,
      // %unescape%
      unescape: _.unescape

      // @TODO: other special cases
    };
  }

  /**
   * For a special set of properties (defined below), it ensures that the
   * effect of freezing does not suppress the ability to override these
   * properties on derived objects by simple assignment.
   *
   * Because of lack of sufficient foresight at the time, ES5 unfortunately
   * specified that a simple assignment to a non-existent property must fail if
   * it would override a non-writable data property of the same name (e.g. the
   * target object doesn't have an own-property by that name, but it inherits
   * from an object which does, and the inherited property is non-writable).
   * (In retrospect, this was a mistake, but it is now too late and we must
   * live with the consequences.) As a result, simply freezing an object to
   * make it tamper proof has the unfortunate side effect of breaking
   * previously correct code that is considered to have followed JS best
   * practices, if this previous code used assignment to override.
   *
   * For example, the following code violates no JavaScript best practice but
   * nevertheless fails without the repair:
   *
   * Object.freeze(Object.prototype);
   *
   * function Point(x, y) {
   *   this.x = x;
   *   this.y = y;
   * }
   *
   * Point.prototype.toString = function() { return `<${this.x},${this.y}>`; };
   *
   * The problem is that the override will cause the assignment to
   * Point.prototype.toString to fail because Point.prototype inherits from
   * Object.prototype, and Object.freeze made Object.prototype.toString into a
   * non-writable data property.
   *
   * Another common pattern is:
   *
   *  Object.freeze(Error.prototype);
   *  e = new Error();
   *  e.message = 'something';
   *
   * To work around this mistake, deepFreeze(), prior to freezing, replaces
   * selected configurable own data properties with accessor properties which
   * simulate what we should have specified -- that assignments to derived
   * objects succeed if otherwise possible.
   */
  function beMutable(obj, prop, desc) {
    if ('value' in desc && desc.configurable) {
      const value = desc.value;

      // eslint-disable-next-line no-inner-declarations
      function getter() {
        return value;
      }

      // Re-attach the data propery value to the object tree to make
      // it discoverable by the deep-freeze traversal algorithm.
      getter.value = value;

      // eslint-disable-next-line no-inner-declarations
      function setter(newValue) {
        if (obj === this) {
          const name = obj.constructor.name;
          throw new TypeError(`Cannot assign to read only property '${prop}' of object '${name}'`);
        }
        if (ObjectHasOwnProperty(this, prop)) {
          this[prop] = newValue;
        } else {
          defineProperty(this, prop, {
            value: newValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      defineProperty(obj, prop, {
        get: getter,
        set: setter,
        enumerable: desc.enumerable,
        configurable: false
      });
    }
  }
  function beMutableProperties(obj) {
    if (!obj) {
      return;
    }
    const descs = getOwnPropertyDescriptors(obj);
    if (!descs) {
      return;
    }
    ownKeys(obj).forEach(prop => beMutable(obj, prop, descs[prop]));
  }
  function beMutableProperty(obj, prop) {
    if (!obj) {
      return;
    }
    const desc = getOwnPropertyDescriptor(obj, prop);
    if (!desc) {
      return;
    }
    beMutable(obj, prop, desc);
  }

  /**
   * These properties are subject to the override mistake.
   */
  function repairDataProperties(realmRec) {
    const {
      eagerFreezeIntrinsics: i
    } = realmRec;
    fastArrayForEach([i.ObjectPrototype, i.ArrayPrototype
    // i.BooleanPrototype,
    // i.DatePrototype,
    // i.NumberPrototype,
    // i.StringPrototype,

    // i.IteratorPrototype,
    // i.ArrayIteratorPrototype,

    // i.PromisePrototype,
    // i.DataViewPrototype,

    // i.TypedArray,
    // i.Int8ArrayPrototype,
    // i.Int16ArrayPrototype,
    // i.Int32ArrayPrototype,
    // i.Uint8Array,
    // i.Uint16Array,
    // i.Uint32Array
    ], beMutableProperties);
    fastArrayForEach([i.FunctionPrototype, i.GeneratorPrototype, i.AsyncFunctionPrototype, i.AsyncGeneratorPrototype], proto => beMutableProperty(proto, 'name'));
    fastArrayForEach([i.ErrorPrototype, i.EvalErrorPrototype, i.RangeErrorPrototype, i.ReferenceErrorPrototype, i.SyntaxErrorPrototype, i.TypeErrorPrototype, i.URIErrorPrototype], proto => beMutableProperty(proto, 'message'));
  }
  function installPolyfills(realmRec) {
    const {
      unsafeGlobal: g
    } = realmRec;

    // https://github.com/tc39/proposal-observable/blob/master/src/Observable.js
    if (!g.Symbol['observable']) {
      defineProperty(g.Symbol, 'observable', {
        value: g.Symbol('observable')
      });
    }
  }

  // Adapted from SES/Caja

  // Objects that are deeply frozen
  const frozenSet = new WeakSet();

  /**
   * "deepFreeze()" acts like "Object.freeze()", except that:
   *
   * To deepFreeze an object is to freeze it and all objects transitively
   * reachable from it via transitive reflective property and prototype
   * traversal.
   */
  function deepFreeze(node) {
    if (frozenSet.has(node)) {
      return;
    }

    // Objects that we're attempting to freeze.
    const freezingSet = new Set();

    // If val is something we should be freezing but aren't yet,
    // add it to freezingSet.
    function enqueue(val) {
      if (Object(val) !== val) {
        // ignore primitives
        return;
      }
      const type = typeof val;
      if (type !== 'object' && type !== 'function') {
        // future proof: break until someone figures out what it should do
        throw new TypeError(`Unexpected typeof: ${type}`);
      }
      if (frozenSet.has(val) || freezingSet.has(val)) {
        // Ignore if already frozen or freezing
        return;
      }
      freezingSet.add(val);
    }
    function doFreeze(obj) {
      // Immediately freeze the object to ensure reactive
      // objects such as proxies won't add properties
      // during traversal, before they get frozen.

      // Object are verified before being enqueued,
      // therefore this is a valid candidate.
      // Throws if this fails (strict mode).
      freeze(obj);

      // get stable/immutable outbound links before a Proxy has a chance to do
      // something sneaky.
      const proto = getPrototypeOf(obj);
      const descs = getOwnPropertyDescriptors(obj);
      enqueue(proto);
      ownKeys(descs).forEach(name => {
        const desc = descs[name];
        if ('value' in desc) {
          enqueue(desc.value);
        } else {
          enqueue(desc.get);
          enqueue(desc.set);
        }
      });
    }
    function dequeue() {
      // New values added before forEach() has finished will be visited.
      freezingSet.forEach(doFreeze);
    }
    function commit() {
      // "Committing" the changes upon exit guards against exceptions aborting
      // the deep freeze process, which could leave the system in a state
      // where unfrozen objects are never frozen when no longer discoverable by
      // subsequent invocations of deep-freeze because all object owning a reference
      // to them are frozen.
      freezingSet.forEach(frozenSet.add, frozenSet);
    }
    enqueue(node);
    dequeue();
    commit();
  }

  /*!
   * Copyright (C) 2023 salesforce.com, inc.
   */
  // @ts-ignore: Prevent cannot find name 'trustedTypes' error.
  const SUPPORTS_TRUSTED_TYPES = typeof trustedTypes !== 'undefined';
  function createTrustedTypesPolicy(name, options) {
    // @ts-ignore: Prevent cannot find name 'trustedTypes' error.
    return trustedTypes.createPolicy(name, options);
  }
  function createFallbackPolicy(_name, options) {
    return options;
  }
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types
  const createPolicy = SUPPORTS_TRUSTED_TYPES ? createTrustedTypesPolicy : createFallbackPolicy;
  const policyOptions = {
    createHTML(value) {
      return value;
    },
    createScript(value) {
      return value;
    },
    createScriptURL(value) {
      return value;
    }
  };
  // Temporarily surround in try-catch until migration to AMD run.
  try {
    // istanbul ignore next: this creates a special policy described here https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicyFactory/createPolicy
    createPolicy('default', {
      createHTML(dirty) {
        // Treat null & undefined separately
        if (dirty === 'null' || dirty === 'undefined') {
          return dirty;
        }
        return dirty;
      },
      // Ignore typescript type validation for this policy.
      // Returning `undefined` from a TT policy blocks usages
      // of specific DOM sinks affected by this hook.
      // We want to block eval and inline scripts.
      // @ts-ignore
      createScript(dirty) {
        // Treat null & undefined separately
        if (dirty === 'null' || dirty === 'undefined') {
          return dirty;
        }
        // Block script evaluation
        return undefined;
      },
      createScriptURL(dirty) {
        // Treat null & undefined separately
        if (dirty === 'null' || dirty === 'undefined') {
          return dirty;
        }
        return dirty;
      }
    });
  } catch (_unused) {
    // swallow
  }
  const trusted = createPolicy('trusted', policyOptions);
  /*! version: 0.21.7 */

  /* eslint-disable prettier/prettier */
  /**
   * Initially copied from https://github.com/Agoric/realms-shim/blob/ac709c7b1b/src/sourceParser.js
   * Added `export` statements
   */
  // The proposed dynamic import expression is the only syntax currently
  // proposed, that can appear in non-module JavaScript code, that
  // enables direct access to the outside world that cannot be
  // surpressed or intercepted without parsing and rewriting. Instead,
  // this shim conservatively rejects any source text that seems to
  // contain such an expression. To do this safely without parsing, we
  // must also reject some valid programs, i.e., those containing
  // apparent import expressions in literal strings or comments.

  // The current conservative rule looks for the identifier "import"
  // followed by either an open paren or something that looks like the
  // beginning of a comment.

  // this \s *must* match all kinds of syntax-defined whitespace. If e.g.
  // U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as
  // whitespace by the parser, but not matched by /\s/, then this would admit
  // an attack like: import\u2028('power.js') . We're trying to distinguish
  // something like that from something like importnotreally('power.js') which
  // is perfectly safe.

  const importPattern = /(?:^|[^.\s])\s*\bimport\s*(?:\([^)]|\/[/*]|<!--)/;
  function rejectImportExpressions(s) {
    const patternIndex = s.search(importPattern);
    if (patternIndex !== -1) {
      const importIndex = s.indexOf('import', patternIndex);
      const linenum = s.slice(0, importIndex).split('\n').length; // more or less
      throw new SyntaxError(`possible import expression rejected around line ${linenum}`);
    }
  }

  /**
   * This whilelist represents properties of the global object
   * which, by definition, do not provide authority or access to globals.
   *
   * We want to declare these globals as constants to prevent de-optimization
   * by the with() and the Proxy() of the  evaluator.
   */
  const stdlib = [
  // *** 18.2 Function Properties of the Global Object

  // 'eval', // This property must be sanitized.
  'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
  // *** 18.3 Constructor Properties of the Global Object

  'Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array',
  // 'Function', // This property must be sanitized.
  'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'RegExp', 'Set',
  // 'SharedArrayBuffer', / Deprecated on Jan 5, 2018
  'String', 'Symbol', 'SyntaxError', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'URIError', 'WeakMap', 'WeakSet',
  // *** 18.4 Other Properties of the Global Object

  'Atomics', 'JSON', 'Math', 'Reflect',
  // *** Annex B

  'escape', 'unescape',
  // *** ECMA-402

  'Intl'];
  let evalEvaluatorFactory;

  // Remove when SecureWindow is refactored to use sandbox
  let unfrozenSet;
  function setUnfrozenSet(names) {
    unfrozenSet = new Set(names);
  }

  /**
   * This ecaluator declares commonly used references like
   * "window" and the JS standard lib as constants to allow
   * the JIT optimizer to link to static references.
   */
  function createEvalEvaluatorFactory(sandbox) {
    const {
      realmRec: {
        unsafeFunction
      }
    } = sandbox;

    // Function and eval are not in our standard lib. Only Function
    // is added here since eval needs to context switch and can't be
    // a constant.
    return unsafeFunction(`
    with (arguments[0]) {
      const {${stdlib.join(',')}, Function, window, document} = arguments[0];
      return function() {
        'use strict';
        return eval(arguments[0]);
      };
    }
  `);
  }
  class FreezingHandler {
    constructor(sandbox) {
      const {
        realmRec: {
          unsafeGlobal,
          unsafeEval
        }
      } = sandbox;
      this.unsafeGlobal = unsafeGlobal;
      this.unsafeEval = unsafeEval;
    }
    setInternalEval() {
      // This sentinel allows one scoped direct eval.
      this.isInternalEval = true;
    }
    clearInternalEval() {
      // Return to safe eval.
      this.isInternalEval = false;
    }
    get(target, prop) {
      // Special treatment for eval.
      if (prop === 'eval') {
        if (this.isInternalEval) {
          this.isInternalEval = false;
          return this.unsafeEval;
        }
        return target.eval;
      }
      if (prop === Symbol.unscopables) {
        return undefined;
      }
      // Properties of global.
      if (prop in target) {
        const value = target[prop];
        if (unfrozenSet && unfrozenSet.has(prop)) {
          deepFreeze(value);
          unfrozenSet.delete(prop);
        }
        return value;
      }
      // Prevent a lookup for other properties.
      return undefined;
    }
    has(target, prop) {
      if (prop === 'eval') {
        return true;
      }
      if (prop === 'arguments') {
        return false;
      }
      if (prop in target) {
        return true;
      }
      if (prop in this.unsafeGlobal) {
        return true;
      }
      return false;
    }
  }
  function createEvalEvaluator(sandbox) {
    const {
      globalObject,
      realmRec
    } = sandbox;

    // Lazy define and use the factory.
    if (!evalEvaluatorFactory) {
      evalEvaluatorFactory = createEvalEvaluatorFactory(sandbox);
    }
    function evaluator(src) {
      // This proxy has several functions:
      // 1. works with the sentinel to alternate between direct eval and confined eval.
      // 2. shadows all properties of the hidden global by declaring them as undefined.
      // 3. resolves all existing properties of the secure global.
      const handler = new FreezingHandler(sandbox);
      const proxy = new Proxy(globalObject, handler);
      const scopedEvaluator = evalEvaluatorFactory(proxy);
      src = `${src}`;
      if (realmRec.apiOptions.W6043924_rejectImportExpressions) {
        rejectImportExpressions(src);
      }
      src = trusted.createScript(src);
      handler.setInternalEval();
      // Ensure that "this" resolves to the secure global.
      const result = scopedEvaluator.call(globalObject, src);
      handler.clearInternalEval();
      return result;
    }

    // Mimic the native eval() function. New properties are
    // by default non-writable and non-configurable.
    defineProperties(evaluator, {
      name: {
        value: 'eval'
      }
    });

    // This instance is namespace-specific, and therefore doesn't
    // need to be frozen (only the objects reachable from it).
    return evaluator;
  }

  /**
   * A safe version of the native Function which relies on
   * the safety of evalEvaluator for confinement.
   */
  function createFunctionEvaluator(sandbox) {
    const {
      realmRec: {
        unsafeFunction,
        unsafeGlobal
      }
    } = sandbox;
    const evaluator = function evaluator(...params) {
      const functionBody = `${params.pop() || ''}`;
      let functionParams = `${params.join(',')}`;

      // Is this a real functionBody, or is someone attempting an injection
      // attack? This will throw a SyntaxError if the string is not actually a
      // function body. We coerce the body into a real string above to prevent
      // someone from passing an object with a toString() that returns a safe
      // string the first time, but an evil string the second time.
      // eslint-disable-next-line no-new, new-cap
      new unsafeFunction(functionBody);
      if (functionParams.includes(')')) {
        // If the formal parameters string include ) - an illegal
        // character - it may make the combined function expression
        // compile. We avoid this problem by checking for this early on.

        // note: v8 throws just like this does, but chrome accepts e.g. 'a = new Date()'
        throw new unsafeGlobal.SyntaxError('Function arg string contains parenthesis');
        // @TODO: shim integrity threat if they change SyntaxError
      }

      if (functionParams.length > 0) {
        // If the formal parameters include an unbalanced block comment, the
        // function must be rejected. Since JavaScript does not allow nested
        // comments we can include a trailing block comment to catch this.
        functionParams += '\n/*``*/';
      }
      const src = `(function(${functionParams}){\n${functionBody}\n})`;
      return sandbox.evalEvaluator(src);
    };

    // Ensure that the different Function instances of the different
    // sandboxes all answer properly when used with the instanceof
    // operator to preserve indentity.
    const FunctionPrototype = unsafeFunction.prototype;

    // Mimic the native signature. New properties are
    // by default non-writable and non-configurable.
    defineProperties(evaluator, {
      name: {
        value: 'Function'
      },
      prototype: {
        value: FunctionPrototype
      }
    });

    // This instance is namespace-specific, and therefore doesn't
    // need to be frozen (only the objects reachable from it).
    return evaluator;
  }
  const sanitized = new WeakSet();
  function freezeIntrinsics(realmRec) {
    const {
      eagerFreezeIntrinsics
    } = realmRec;
    deepFreeze(eagerFreezeIntrinsics);
  }
  function freezeIntrinsicsDeprecated(realmRec) {
    const {
      unsafeGlobal
    } = realmRec;
    seal(unsafeGlobal.Object.prototype);
  }

  // locking down the environment
  function sanitize(realmRec) {
    if (sanitized.has(realmRec)) {
      return;
    }
    if (realmRec.shouldFreeze) {
      // Temporary until SecureWindow is refactored
      // @TODO See #754.
      const names = [];
      for (const name in Window) {
        if (Window$1[name] === RAW) {
          names.push(name);
        }
      }
      setUnfrozenSet(names);
    } else {
      freezeIntrinsicsDeprecated(realmRec);
    }
    setElementRealm(realmRec);
    setDocumentRealm(realmRec);
    setWindowRealm(realmRec);
    sanitized.add(realmRec);
  }
  const keyToSandbox = new Map();
  function createSandbox(key, realmRec) {
    // Lazy sanitize the execution environment.
    sanitize(realmRec);
    const sandbox = {
      realmRec
    };
    const {
      unsafeGlobal
    } = realmRec;

    /**
     * The sequencing of the following operations is curcial. We
     * need "Function" available on global when we create "eval"
     * in order for the constant to link to it.
     * 1. We create the global, minus "eval" and "Function".
     * 2. We create "Function" and expose it on the global.
     * 3. We create "eval" and expose it on the global.
     */

    if (realmRec.isBrowser) {
      sandbox.globalObject = SecureWindow(unsafeGlobal, key);
    } else {
      sandbox.globalObject = SecureGlobal(unsafeGlobal, key);
    }
    sandbox.FunctionEvaluator = createFunctionEvaluator(sandbox);
    defineProperty(sandbox.globalObject, 'Function', {
      value: sandbox.FunctionEvaluator
    });

    // The "eval" property needs to be configurable to comply with the
    // Proxy invariants.
    sandbox.evalEvaluator = createEvalEvaluator(sandbox);
    defineProperty(sandbox.globalObject, 'eval', {
      value: sandbox.evalEvaluator,
      configurable: true
    });
    return freeze(sandbox);
  }
  function getSandbox(key, realmRec) {
    let sandbox = keyToSandbox.get(key);
    if (!sandbox) {
      sandbox = createSandbox(key, realmRec);
      keyToSandbox.set(key, sandbox);
    }
    return sandbox;
  }

  // Adapted from SES/Caja

  /**
   * The process to repair constructors:
   * 1. Obtain the prototype from an instance
   * 2. Create a substitute noop constructor
   * 3. Replace its prototype property with the original prototype
   * 4. Replace its prototype property's constructor with itself
   * 5. Replace its [[Prototype]] slot with the noop constructor of Function
   */
  function repairFunction(realmRec, functionName, functionDecl) {
    const {
      unsafeGlobal,
      unsafeEval,
      unsafeFunction
    } = realmRec;
    let FunctionInstance;
    try {
      FunctionInstance = unsafeEval(`(${functionDecl}(){})`);
    } catch (e) {
      if (!(e instanceof SyntaxError)) {
        // Re-throw
        throw e;
      }
      // Prevent failure on platforms where generators are not supported.
      return;
    }
    const FunctionPrototype = getPrototypeOf(FunctionInstance);
    const RealmFunction = unsafeFunction('return function(){}');
    defineProperties(RealmFunction, {
      name: {
        value: functionName
      },
      prototype: {
        value: FunctionPrototype
      }
    });
    defineProperty(FunctionPrototype, 'constructor', {
      value: RealmFunction
    });

    // Prevent loop in case of Function.
    if (RealmFunction !== unsafeGlobal.Function.prototype.constructor) {
      setPrototypeOf(RealmFunction, unsafeGlobal.Function.prototype.constructor);
    }
  }

  /**
   * This block replaces the original Function constructor, and the original
   * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with
   * safe replacements that preserve SES confinement. After this block is done,
   * the originals should no longer be reachable.
   */
  function repairFunctions(realmRec) {
    // Here, the order of operation is important: Function needs to be
    // repaired first since the other constructors need it.
    repairFunction(realmRec, 'Function', 'function');
    repairFunction(realmRec, 'GeneratorFunction', 'function*');
    repairFunction(realmRec, 'AsyncFunction', 'async function');
    repairFunction(realmRec, 'AsyncGeneratorFunction', 'async function*');
  }
  let warn = typeof console !== 'undefined' ? console.warn : function () {}; // eslint-disable-line no-console
  let error = Error;
  let severity = {
    QUIET: 'QUIET',
    FATAL: 'FATAL',
    ALERT: 'ALERT'
  };
  function registerReportAPI(api) {
    if (api) {
      warn = api.warn;
      error = api.error;
      severity = api.severity;
    }
  }

  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  var _URLCtor$prototype$LWS;
  const {
    apply: ReflectApply$LWS$1,
    construct: ReflectConstruct$LWS,
    defineProperty: ReflectDefineProperty$LWS$1,
    deleteProperty: ReflectDeleteProperty$LWS$1,
    get: ReflectGet$LWS,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS$1,
    has: ReflectHas$LWS,
    isExtensible: ReflectIsExtensible$LWS,
    ownKeys: ReflectOwnKeys$LWS$1,
    preventExtensions: ReflectPreventExtensions$LWS,
    set: ReflectSet$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS$1
  } = Reflect;
  const ObjectCtor$LWS$1 = Object;
  const {
    assign: ObjectAssign$LWS$1,
    freeze: ObjectFreeze$LWS$1,
    defineProperties: ObjectDefineProperties$LWS,
    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
    getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
    keys: ObjectKeys$LWS$1,
    preventExtensions: ObjectPreventExtensions$LWS,
    prototype: ObjectProto$LWS$1
  } = ObjectCtor$LWS$1;
  const {
    hasOwn: OriginalObjectHasOwn$LWS$1
  } = ObjectCtor$LWS$1;
  const {
    __lookupGetter__: ObjectProtoLookupGetter$LWS$1,
    __lookupSetter__: ObjectProtoLookupSetter$LWS$1,
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS$1
  } = ObjectProto$LWS$1;
  const {
    toString: ObjectProtoToString$LWS$1
  } = ObjectProto$LWS$1;
  function isObject$LWS$1(value$LWS) {
    return typeof value$LWS === 'object' && value$LWS !== null;
  }
  function isObjectLike$LWS(value$LWS) {
    return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
  }
  const ObjectHasOwn$LWS$1 = typeof OriginalObjectHasOwn$LWS$1 === 'function' ? OriginalObjectHasOwn$LWS$1 : /* istanbul ignore next: currently unreachable via tests */function ObjectHasOwn$LWS(object$LWS, key$LWS) {
    return ReflectApply$LWS$1(ObjectProtoHasOwnProperty$LWS$1, object$LWS, [key$LWS]);
  };
  function ObjectLookupOwnGetter$LWS$1(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : ReflectApply$LWS$1(ObjectProtoLookupGetter$LWS$1, object$LWS, [key$LWS]);
  }
  function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : ReflectApply$LWS$1(ObjectProtoLookupSetter$LWS$1, object$LWS, [key$LWS]);
  }
  function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : object$LWS[key$LWS];
  }
  const SymbolCtor$LWS$1 = Symbol;
  const {
    asyncIterator: SymbolAsyncIterator$LWS,
    for: SymbolFor$LWS$1,
    iterator: SymbolIterator$LWS$1,
    toStringTag: SymbolToStringTag$LWS$1,
    unscopables: SymbolUnscopables$LWS$1
  } = SymbolCtor$LWS$1;
  const {
    toString: SymbolProtoToString$LWS,
    valueOf: SymbolProtoValueOf$LWS
  } = SymbolCtor$LWS$1.prototype;
  const ArrayCtor$LWS$1 = Array;
  const {
    prototype: ArrayProto$LWS$1
  } = ArrayCtor$LWS$1;
  const {
    at: ArrayProtoAt$LWS$1,
    concat: ArrayProtoConcat$LWS$1,
    copyWithin: ArrayProtoCopyWithin$LWS$1,
    entries: ArrayProtoEntries$LWS$1,
    every: ArrayProtoEvery$LWS$1,
    fill: ArrayProtoFill$LWS$1,
    findIndex: ArrayProtoFindIndex$LWS$1,
    flat: ArrayProtoFlat$LWS$1,
    flatMap: ArrayProtoFlatMap$LWS$1,
    forEach: ArrayProtoForEach$LWS$1,
    keys: ArrayProtoKeys$LWS$1,
    lastIndexOf: ArrayProtoLastIndexOf$LWS$1,
    pop: ArrayProtoPop$LWS$1,
    reduce: ArrayProtoReduce$LWS$1,
    reduceRight: ArrayProtoReduceRight$LWS$1,
    reverse: ArrayProtoReverse$LWS$1,
    some: ArrayProtoSome$LWS$1,
    toLocaleString: ArrayProtoToLocaleString$LWS$1,
    values: ArrayProtoValues$LWS$1,
    [SymbolIterator$LWS$1]: ArrayProtoSymbolIterator$LWS$1
  } = ArrayProto$LWS$1;
  const ArrayUnscopables$LWS$1 = ObjectFreeze$LWS$1(ObjectAssign$LWS$1({
    __proto__: null
  }, ArrayProto$LWS$1[SymbolUnscopables$LWS$1]));
  // Used by '@locker/near-membrane-dom'.
  const {
    includes: ArrayProtoIncludes$LWS$1,
    map: ArrayProtoMap$LWS$1,
    splice: ArrayProtoSplice$LWS$1,
    sort: ArrayProtoSort$LWS$1,
    unshift: ArrayProtoUnshift$LWS$1
  } = ArrayProto$LWS$1;
  const {
    filter: ArrayProtoFilter$LWS$1,
    find: ArrayProtoFind$LWS$1,
    indexOf: ArrayProtoIndexOf$LWS$1,
    join: ArrayProtoJoin$LWS$1,
    push: ArrayProtoPush$LWS$1,
    shift: ArrayProtoShift$LWS$1,
    slice: ArrayProtoSlice$LWS$1,
    toString: ArrayProtoToString$LWS$1
  } = ArrayProto$LWS$1;
  const {
    isArray: ArrayIsArray$LWS$1
  } = ArrayCtor$LWS$1;
  function ArrayConcat$LWS(array$LWS, ...args$LWS) {
    // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
    const result$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
    for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const value$LWS = args$LWS[i$LWS];
      if (ArrayIsArray$LWS$1(value$LWS)) {
        ReflectApply$LWS$1(ArrayProtoPush$LWS$1, result$LWS, value$LWS);
      } else {
        result$LWS[result$LWS.length] = value$LWS;
      }
    }
    return result$LWS;
  }
  function toSafeArray$LWS$1(array$LWS) {
    ReflectSetPrototypeOf$LWS$1(array$LWS, null);
    array$LWS.at = ArrayProtoAt$LWS$1;
    array$LWS.concat = ArrayProtoConcat$LWS$1;
    // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
    // https://bugs.chromium.org/p/v8/issues/detail?id=13202
    // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
    //
    // In V8 setting the constructor property of an array, promise, regexp, or
    // typed array triggers a de-opt because it could change an instance's
    // @@species. This de-opt affects at least `Array#splice` and occurs even
    // if the prototype of the array is change or nulled beforehand. Further,
    // the de-opt persists after a page refresh. It is not until navigating to
    // a different page that the performance of `Array#splice` is restored.
    array$LWS.copyWithin = ArrayProtoCopyWithin$LWS$1;
    array$LWS.entries = ArrayProtoEntries$LWS$1;
    array$LWS.every = ArrayProtoEvery$LWS$1;
    array$LWS.fill = ArrayProtoFill$LWS$1;
    array$LWS.filter = ArrayProtoFilter$LWS$1;
    array$LWS.find = ArrayProtoFind$LWS$1;
    array$LWS.findIndex = ArrayProtoFindIndex$LWS$1;
    array$LWS.flat = ArrayProtoFlat$LWS$1;
    array$LWS.flatMap = ArrayProtoFlatMap$LWS$1;
    array$LWS.forEach = ArrayProtoForEach$LWS$1;
    array$LWS.includes = ArrayProtoIncludes$LWS$1;
    array$LWS.indexOf = ArrayProtoIndexOf$LWS$1;
    array$LWS.join = ArrayProtoJoin$LWS$1;
    array$LWS.keys = ArrayProtoKeys$LWS$1;
    array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS$1;
    array$LWS.map = ArrayProtoMap$LWS$1;
    array$LWS.pop = ArrayProtoPop$LWS$1;
    array$LWS.push = ArrayProtoPush$LWS$1;
    array$LWS.reduce = ArrayProtoReduce$LWS$1;
    array$LWS.reduceRight = ArrayProtoReduceRight$LWS$1;
    array$LWS.reverse = ArrayProtoReverse$LWS$1;
    array$LWS.shift = ArrayProtoShift$LWS$1;
    array$LWS.slice = ArrayProtoSlice$LWS$1;
    array$LWS.some = ArrayProtoSome$LWS$1;
    array$LWS.sort = ArrayProtoSort$LWS$1;
    array$LWS.splice = ArrayProtoSplice$LWS$1;
    array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS$1;
    array$LWS.toString = ArrayProtoToString$LWS$1;
    array$LWS.unshift = ArrayProtoUnshift$LWS$1;
    array$LWS.values = ArrayProtoValues$LWS$1;
    array$LWS[SymbolIterator$LWS$1] = ArrayProtoSymbolIterator$LWS$1;
    array$LWS[SymbolUnscopables$LWS$1] = ArrayUnscopables$LWS$1;
    ReflectSetPrototypeOf$LWS$1(array$LWS, ArrayProto$LWS$1);
    return array$LWS;
  }
  const ArrayBufferCtor$LWS = ArrayBuffer;
  const {
    isView: ArrayBufferIsView$LWS
  } = ArrayBufferCtor$LWS;
  const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(ArrayBufferCtor$LWS.prototype, 'byteLength');

  // https://caniuse.com/bigint
  const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
  const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : /* istanbul ignore next: currently unreachable via tests */undefined;
  const {
    valueOf: BooleanProtoValueOf$LWS
  } = Boolean.prototype;

  // Locker build constants.
  const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
  // This package is bundled by third-parties that have their own build time
  // replacement logic. Instead of customizing each build system to be aware
  // of this package we implement a two phase debug mode by performing small
  // runtime checks to determine phase one, our code is unminified, and
  // phase two, the user opted-in to custom devtools formatters. Phase one
  // is used for light weight initialization time debug while phase two is
  // reserved for post initialization runtime
  const LOCKER_UNMINIFIED_FLAG$LWS =
  // eslint-disable-next-line @typescript-eslint/naming-convention
  /* istanbul ignore next */
  `${function LOCKER_UNMINIFIED_FLAG$LWS() {
    return LOCKER_UNMINIFIED_FLAG$LWS.name;
  }()}`.includes('LOCKER_UNMINIFIED_FLAG');
  // Locker key constants.
  const LOCKER_SERVICE_KEY$LWS = 'LSKey';
  const LOCKER_SERVICE_KEY_LOWERED$LWS = 'lskey';
  // Character constants.
  const CHAR_QUOTE_DOUBLE$LWS = '"';
  const CHAR_QUOTE_SINGLE$LWS = "'";
  // Compiler constants.
  const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
  const UNCOMPILED_TOP_NAME$LWS = `uncompiledTop${LOCKER_IDENTIFIER_MARKER$LWS}`;
  const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
  // Error message constants.
  const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = 'Illegal property access.';
  const ERR_INVALID_SANDBOX_KEY$LWS = 'Invalid sandbox key.';
  // Near-membrane constants.
  const LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS = SymbolFor$LWS$1('@@lockerNearMembraneIsMasked');
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1 = SymbolFor$LWS$1('@@lockerNearMembraneSerializedValue');
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1 = SymbolFor$LWS$1('@@lockerNearMembrane');
  const LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS = SymbolFor$LWS$1('@@lockerNearMembraneUnmaskedValue');
  // Legacy symbol used by packages/locker-core-engine/src/LockerFilter.js.
  const SYMBOL_LIVE_OBJECT$LWS = SymbolFor$LWS$1('@@lockerLiveValue');
  // Object brand constants.
  const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
  const TO_STRING_BRAND_ARRAY_BUFFER$LWS = '[object ArrayBuffer]';
  const TO_STRING_BRAND_BIG_INT$LWS$1 = '[object BigInt]';
  const TO_STRING_BRAND_BOOLEAN$LWS$1 = '[object Boolean]';
  const TO_STRING_BRAND_DATE$LWS = '[object Date]';
  const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
  const TO_STRING_BRAND_MAP$LWS = '[object Map]';
  const TO_STRING_BRAND_NULL$LWS = '[object Null]';
  const TO_STRING_BRAND_NUMBER$LWS$1 = '[object Number]';
  const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
  const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
  const TO_STRING_BRAND_SET$LWS = '[object Set]';
  const TO_STRING_BRAND_STRING$LWS$1 = '[object String]';
  const TO_STRING_BRAND_SYMBOL$LWS$1 = '[object Symbol]';
  const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
  const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
  const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
  // Sandbox constants.
  const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
  const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
  const DateCtor$LWS = Date;
  const {
    now: DateNow$LWS
  } = DateCtor$LWS;
  const {
    valueOf: DateProtoValueOf$LWS
  } = DateCtor$LWS.prototype;

  // Used by '@locker/near-membrane-base'
  const ErrorCtor$LWS$1 = Error;
  // Used by '@locker/near-membrane-' packages.
  const TypeErrorCtor$LWS$1 = TypeError;
  class LockerSecurityError$LWS extends Error {
    constructor(message$LWS) {
      super(`Lightning Web Security: ${message$LWS}`);
    }
  }
  const ProxyCtor$LWS = Proxy;
  const {
    revocable: ProxyRevocable$LWS
  } = ProxyCtor$LWS;
  function createRevokedProxy$LWS(object$LWS) {
    const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
      __proto__: null
    });
    revocable$LWS.revoke();
    return revocable$LWS.proxy;
  }
  function isRevokedProxy$LWS(value$LWS) {
    try {
      // 7.2.2 IsArray ( argument )
      // https://tc39.es/ecma262/#sec-isarray
      // Step 3a: Perform ? ValidateNonRevokedProxy(argument).
      ArrayIsArray$LWS$1(value$LWS);
      return false;
      // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
    return true;
  }
  const {
    bind: FunctionProtoBind$LWS,
    toString: FunctionProtoToString$LWS
  } = Function.prototype;
  function createUnmaskableTraps$LWS(func$LWS) {
    let handshakeUnmaskFlag$LWS = false;
    return {
      defineProperty(target$LWS, key$LWS, desc$LWS) {
        // Defining forgeries of handshake properties is not allowed.
        if (key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return ReflectDefineProperty$LWS$1(target$LWS, key$LWS, desc$LWS);
      },
      get(target$LWS, key$LWS, receiver$LWS, handshake$LWS = false) {
        // Only allow accessing handshake property values if the "has"
        // trap has been triggered immediately BEFORE and the property
        // does NOT exist.
        handshakeUnmaskFlag$LWS && (handshakeUnmaskFlag$LWS = handshake$LWS);
        const isUnmaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
        if (handshakeUnmaskFlag$LWS) {
          // Exit without performing a [[Get]] for
          // `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL` properties
          // because we know that when the
          // `handshakeUnmaskFlag` is ON that
          // there are NO shadowed values.
          if (isUnmaskedSymbol$LWS) {
            return func$LWS;
          }
        }
        const result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        // Getting forged values of `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL`
        // properties is not allowed.
        if (result$LWS !== undefined && isUnmaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      getOwnPropertyDescriptor(target$LWS, key$LWS) {
        const result$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        // Getting forged descriptors of handshake properties is not allowed.
        if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      has(target$LWS, key$LWS) {
        const result$LWS = ReflectHas$LWS(target$LWS, key$LWS);
        const isUnmaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
        if (result$LWS) {
          handshakeUnmaskFlag$LWS = false;
          // Checking the existence of forged `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL`
          // properties is not allowed.
          if (isUnmaskedSymbol$LWS) {
            throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
        } else {
          // The `handshakeUnmaskFlag` is ON if the
          // handshake property does NOT exist on the object or its
          // [[Prototype]].
          handshakeUnmaskFlag$LWS = isUnmaskedSymbol$LWS;
        }
        return result$LWS;
      },
      set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
        // Setting forged values of handshake properties is not allowed.
        if (key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
      }
    };
  }
  function getUnmaskedFunction$LWS(func$LWS) {
    const unmasked$LWS = LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS in func$LWS ? undefined : func$LWS[LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS];
    return unmasked$LWS === undefined ? func$LWS : unmasked$LWS;
  }
  function isMaskedFunction$LWS(value$LWS) {
    // To extract the flag value of a blue near-membrane proxy we must perform
    // a two step handshake. First, we trigger the "has" trap for the
    // `LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL` property which must report
    // `false`. Second, we trigger the "get" trap to return the flag value.
    return typeof value$LWS === 'function' && !(LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS] === true;
  }
  function maskFunction$LWS(func$LWS, maskFunc$LWS, trapInvokers$LWS) {
    let applyTrapInvoker$LWS = ReflectApply$LWS$1;
    let constructTrapInvoker$LWS = ReflectConstruct$LWS;
    let definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS$1;
    let getTrapInvoker$LWS = ReflectGet$LWS;
    let getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS;
    let hasTrapInvoker$LWS = ReflectHas$LWS;
    let setTrapInvoker$LWS = ReflectSet$LWS;
    if (trapInvokers$LWS) {
      ({
        apply: applyTrapInvoker$LWS = ReflectApply$LWS$1,
        construct: constructTrapInvoker$LWS = ReflectConstruct$LWS,
        defineProperty: definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS$1,
        get: getTrapInvoker$LWS = ReflectGet$LWS,
        getOwnPropertyDescriptor: getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS,
        has: hasTrapInvoker$LWS = ReflectHas$LWS,
        set: setTrapInvoker$LWS = ReflectSet$LWS
      } = trapInvokers$LWS);
    }
    let handshakeFlag$LWS = false;
    let handshakeProxyMaskedFlag$LWS = false;
    let lastProxyTrapCalled$LWS = 0 /* ProxyHandlerTraps.None */;
    const proxy$LWS = new ProxyCtor$LWS(maskFunc$LWS, {
      apply(_target$LWS, thisArg$LWS, args$LWS) {
        lastProxyTrapCalled$LWS = 1 /* ProxyHandlerTraps.Apply */;
        if (thisArg$LWS === proxy$LWS || thisArg$LWS === maskFunc$LWS) {
          thisArg$LWS = func$LWS;
        }
        return applyTrapInvoker$LWS(func$LWS, thisArg$LWS, args$LWS);
      },
      construct(_target$LWS, args$LWS, newTarget$LWS) {
        lastProxyTrapCalled$LWS = 2 /* ProxyHandlerTraps.Construct */;
        if (newTarget$LWS === proxy$LWS || newTarget$LWS === maskFunc$LWS) {
          newTarget$LWS = func$LWS;
        }
        return constructTrapInvoker$LWS(func$LWS, args$LWS, newTarget$LWS);
      },
      defineProperty(target$LWS, key$LWS, desc$LWS) {
        lastProxyTrapCalled$LWS = 4 /* ProxyHandlerTraps.DefineProperty */;
        // Defining forgeries of handshake properties is not allowed.
        if (key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return definePropertyTrapInvoker$LWS(target$LWS, key$LWS, desc$LWS);
      },
      deleteProperty(target$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
        return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
      },
      get(target$LWS, key$LWS, receiver$LWS) {
        // Only allow accessing handshake property values if the "has"
        // trap has been triggered immediately BEFORE and the property does
        // NOT exist.
        handshakeFlag$LWS && (handshakeFlag$LWS = lastProxyTrapCalled$LWS === 128 /* ProxyHandlerTraps.Has */);
        handshakeProxyMaskedFlag$LWS && (handshakeProxyMaskedFlag$LWS = handshakeFlag$LWS);
        lastProxyTrapCalled$LWS = 16 /* ProxyHandlerTraps.Get */;
        const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
        if (handshakeProxyMaskedFlag$LWS) {
          // Exit without performing a [[Get]] for
          // `LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL` properties
          // because we know that when the `handshakeProxyMaskedFlag`
          // is ON that there are NO shadowed values.
          if (isProxyMaskedSymbol$LWS) {
            return true;
          }
        }
        const result$LWS = getTrapInvoker$LWS(target$LWS, key$LWS, receiver$LWS, handshakeFlag$LWS);
        // Getting forged values of handshake properties is not allowed.
        if (result$LWS !== undefined && isProxyMaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      getOwnPropertyDescriptor(target$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
        const result$LWS = getOwnPropertyDescriptorTrapInvoker$LWS(target$LWS, key$LWS);
        // Getting forged descriptors of handshake properties is not allowed.
        if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      getPrototypeOf(target$LWS) {
        lastProxyTrapCalled$LWS = 64 /* ProxyHandlerTraps.GetPrototypeOf */;
        return ReflectGetPrototypeOf$LWS$1(target$LWS);
      },
      has(target$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 128 /* ProxyHandlerTraps.Has */;
        const result$LWS = hasTrapInvoker$LWS(target$LWS, key$LWS);
        const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
        if (result$LWS) {
          handshakeFlag$LWS = false;
          // Checking the existence of forged handshake properties is not allowed.
          if (isProxyMaskedSymbol$LWS) {
            throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
        } else {
          // The `handshakeFlag` is ON if the handshake property does NOT
          // exist on the object or its [[Prototype]].
          handshakeFlag$LWS = true;
          handshakeProxyMaskedFlag$LWS = isProxyMaskedSymbol$LWS;
        }
        return result$LWS;
      },
      isExtensible(target$LWS) {
        lastProxyTrapCalled$LWS = 256 /* ProxyHandlerTraps.IsExtensible */;
        return ReflectIsExtensible$LWS(target$LWS);
      },
      ownKeys(target$LWS) {
        lastProxyTrapCalled$LWS = 512 /* ProxyHandlerTraps.OwnKeys */;
        return ReflectOwnKeys$LWS$1(target$LWS);
      },
      preventExtensions(target$LWS) {
        lastProxyTrapCalled$LWS = 1024 /* ProxyHandlerTraps.PreventExtensions */;
        return ReflectPreventExtensions$LWS(target$LWS);
      },
      set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
        lastProxyTrapCalled$LWS = 2048 /* ProxyHandlerTraps.Set */;
        // Setting forged values of handshake properties is not allowed.
        if (key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return setTrapInvoker$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
      },
      setPrototypeOf(target$LWS, proto$LWS) {
        lastProxyTrapCalled$LWS = 4096 /* ProxyHandlerTraps.SetPrototypeOf */;
        return ReflectSetPrototypeOf$LWS$1(target$LWS, proto$LWS);
      }
    });
    return proxy$LWS;
  }
  function noop$LWS$1() {
    // No operation performed.
  }
  const MapCtor$LWS$1 = Map;
  const {
    prototype: MapProto$LWS$1
  } = MapCtor$LWS$1;
  const {
    clear: MapProtoClear$LWS$1,
    delete: MapProtoDelete$LWS$1,
    forEach: MapProtoForEach$LWS$1,
    get: MapProtoGet$LWS$1,
    has: MapProtoHas$LWS$1,
    keys: MapProtoKeys$LWS$1,
    values: MapProtoValues$LWS$1,
    [SymbolIterator$LWS$1]: MapProtoSymbolIterator$LWS$1,
    [SymbolToStringTag$LWS$1]: MapProtoSymbolToStringTag$LWS$1
  } = MapProto$LWS$1;
  const {
    entries: MapProtoEntries$LWS$1,
    set: MapProtoSet$LWS$1
  } = MapProto$LWS$1;
  const MapProtoSizeGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(MapProto$LWS$1, 'size');
  function toSafeMap$LWS$1(map$LWS) {
    ReflectSetPrototypeOf$LWS$1(map$LWS, null);
    map$LWS.clear = MapProtoClear$LWS$1;
    map$LWS.delete = MapProtoDelete$LWS$1;
    map$LWS.entries = MapProtoEntries$LWS$1;
    map$LWS.forEach = MapProtoForEach$LWS$1;
    map$LWS.get = MapProtoGet$LWS$1;
    map$LWS.has = MapProtoHas$LWS$1;
    map$LWS.keys = MapProtoKeys$LWS$1;
    map$LWS.set = MapProtoSet$LWS$1;
    ReflectDefineProperty$LWS$1(map$LWS, 'size', {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: MapProtoSizeGetter$LWS$1,
      set: undefined
    });
    map$LWS.values = MapProtoValues$LWS$1;
    map$LWS[SymbolIterator$LWS$1] = MapProtoSymbolIterator$LWS$1;
    map$LWS[SymbolToStringTag$LWS$1] = MapProtoSymbolToStringTag$LWS$1;
    ReflectSetPrototypeOf$LWS$1(map$LWS, MapProto$LWS$1);
    return map$LWS;
  }
  const NumberCtor$LWS$1 = Number;
  // Used by '@locker/near-membrane-dom'.
  const {
    isFinite: NumberIsFinite$LWS$1,
    isInteger: NumberIsInteger$LWS$1,
    isNaN: NumberIsNaN$LWS$1
  } = NumberCtor$LWS$1;
  const {
    toFixed: NumberProtoToFixed$LWS,
    valueOf: NumberProtoValueOf$LWS
  } = NumberCtor$LWS$1.prototype;
  const StringCtor$LWS$1 = String;
  const {
    prototype: StringProto$LWS$1
  } = StringCtor$LWS$1;
  const {
    charAt: StringProtoCharAt$LWS,
    charCodeAt: StringProtoCharCodeAt$LWS,
    endsWith: StringProtoEndsWith$LWS,
    includes: StringProtoIncludes$LWS,
    indexOf: StringProtoIndexOf$LWS,
    lastIndexOf: StringProtoLastIndexOf$LWS,
    match: StringProtoMatch$LWS,
    replace: StringProtoReplace$LWS,
    slice: StringProtoSlice$LWS$1,
    split: StringProtoSplit$LWS,
    startsWith: StringProtoStartsWith$LWS,
    substring: StringProtoSubstring$LWS,
    toLowerCase: StringProtoToLowerCase$LWS,
    toUpperCase: StringProtoToUpperCase$LWS,
    valueOf: StringProtoValueOf$LWS$1
  } = StringProto$LWS$1;
  const quoteCharRegExpRegistry$LWS = {
    __proto__: null,
    [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
    [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
  };
  const URLCtor$LWS = typeof URL === 'function' ? URL : /* istanbul ignore next: unreachable in test env */undefined;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const URLProtoToString$LWS = URLCtor$LWS == null || (_URLCtor$prototype$LWS = URLCtor$LWS.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString;
  // To extract the function body start the match from the beginning of the
  // source code with the character class `[\s\S]` instead of `.` because `[\s\S]`
  // matches everything including newlines where as `.` matches everything except
  // newlines. Next, continue matching past the opening left curly bracket of the
  // function and beyond optional whitespace and newline. Finally, capture the
  // function body up to, but not including, optional newline and whitespace by
  // the closing right curly bracket at the end of the source code. The alternate
  // pattern matches arrow functions without brackets.
  const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;
  function capitalizeFirstChar$LWS(string$LWS) {
    const {
      length: length$LWS
    } = string$LWS;
    if (length$LWS) {
      const upper$LWS = ReflectApply$LWS$1(StringProtoToUpperCase$LWS, string$LWS[0], []);
      return length$LWS === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS$1, string$LWS, [1]);
    }
    return '';
  }
  function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
    return quoteChar$LWS + ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [quoteCharRegExpRegistry$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
  }
  function extractFunctionBodySource$LWS(func$LWS) {
    var _ref$LWS, _match$$LWS;
    const source$LWS = ReflectApply$LWS$1(FunctionProtoToString$LWS, func$LWS, []);
    const match$LWS = ReflectApply$LWS$1(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]);
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : '';
  }
  function isConvertibleToString$LWS(value$LWS) {
    if (typeof value$LWS !== 'symbol') {
      try {
        // Attempt to coerce `value` to a string with the ToString operation.
        // Section 7.1.17 ToString ( argument )
        // https://tc39.es/ecma262/#sec-tostring
        return `${value$LWS}` !== undefined;
        // eslint-disable-next-line no-empty
      } catch (_unused2$LWS) {}
    }
    return false;
  }
  // Use `toString()` to coerce values using the default string concatenation
  // operation.
  function toString$LWS(value$LWS) {
    return typeof value$LWS === 'string' ? value$LWS :
    // Attempt to coerce `value` to a string with the ToString operation.
    // Section 7.1.17 ToString ( argument )
    // https://tc39.es/ecma262/#sec-tostring
    `${value$LWS}`;
  }
  // Use `toSafeTemplateStringValue()` for values embedded in template strings,
  // like error messages, because it coerces more values, including symbols,
  // to strings without throwing exceptions.
  function toSafeTemplateStringValue$LWS(value$LWS) {
    if (typeof value$LWS === 'string') {
      return value$LWS;
    }
    try {
      if (typeof value$LWS === 'function') {
        return ReflectApply$LWS$1(FunctionProtoToString$LWS, value$LWS, []);
      }
      if (typeof value$LWS === 'object' && value$LWS !== null) {
        if (URLCtor$LWS && value$LWS instanceof URLCtor$LWS) {
          return ReflectApply$LWS$1(URLProtoToString$LWS, value$LWS, []);
        }
        const result$LWS = ReflectApply$LWS$1(ObjectProtoToString$LWS$1, value$LWS, []);
        return result$LWS === TO_STRING_BRAND_SYMBOL$LWS$1 ? ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
      }
      if (typeof value$LWS === 'symbol') {
        return ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []);
      }
      // Attempt to coerce `value` to a string with the String() constructor.
      // Section 22.1.1.1 String ( value )
      // https://tc39.es/ecma262/#sec-string-constructor-string-value
      return StringCtor$LWS$1(value$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused3$LWS) {}
    return '[object Unknown]';
  }
  const RegExpCtor$LWS$1 = RegExp;
  const {
    prototype: RegExpProto$LWS$1
  } = RegExpCtor$LWS$1;
  const {
    exec: RegExpProtoExec$LWS,
    test: RegExpProtoTest$LWS$1
  } = RegExpProto$LWS$1;
  const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS$1(RegExpProto$LWS$1, 'source');
  const endsWithWordCharRegExp$LWS = /\w$/;
  const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;
  const startsWithWordCharRegExp$LWS = /^\w/;
  function toRegExpEscapedIdentifierName$LWS(identifier$LWS) {
    return (startsWithWordCharRegExp$LWS.test(identifier$LWS) ? '\\b' : '') + toRegExpEscapedString$LWS(identifier$LWS) + (endsWithWordCharRegExp$LWS.test(identifier$LWS) ? '\\b' : '');
  }
  function toRegExpEscapedString$LWS(string$LWS) {
    return ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, '\\$&']);
  }
  const SetCtor$LWS$1 = Set;
  const {
    prototype: SetProto$LWS$1
  } = SetCtor$LWS$1;
  const {
    clear: SetProtoClear$LWS,
    delete: SetProtoDelete$LWS,
    entries: SetProtoEntries$LWS,
    forEach: SetProtoForEach$LWS,
    has: SetProtoHas$LWS$1,
    keys: SetProtoKeys$LWS,
    [SymbolIterator$LWS$1]: SetProtoSymbolIterator$LWS,
    [SymbolToStringTag$LWS$1]: SetProtoSymbolToStringTag$LWS
  } = SetProto$LWS$1;
  const {
    add: SetProtoAdd$LWS$1,
    values: SetProtoValues$LWS$1
  } = SetProto$LWS$1;
  const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(SetProto$LWS$1, 'size');
  function toSafeSet$LWS(set$LWS) {
    ReflectSetPrototypeOf$LWS$1(set$LWS, null);
    set$LWS.add = SetProtoAdd$LWS$1;
    set$LWS.clear = SetProtoClear$LWS;
    set$LWS.delete = SetProtoDelete$LWS;
    set$LWS.entries = SetProtoEntries$LWS;
    set$LWS.forEach = SetProtoForEach$LWS;
    set$LWS.has = SetProtoHas$LWS$1;
    set$LWS.keys = SetProtoKeys$LWS;
    ReflectDefineProperty$LWS$1(set$LWS, 'size', {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: SetProtoSizeGetter$LWS,
      set: undefined
    });
    set$LWS.values = SetProtoValues$LWS$1;
    set$LWS[SymbolIterator$LWS$1] = SetProtoSymbolIterator$LWS;
    set$LWS[SymbolToStringTag$LWS$1] = SetProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS$1(set$LWS, SetProto$LWS$1);
    return set$LWS;
  }
  const WeakMapCtor$LWS$1 = WeakMap;
  const {
    prototype: WeakMapProto$LWS$1
  } = WeakMapCtor$LWS$1;
  const {
    has: WeakMapProtoHas$LWS$1
  } = WeakMapProto$LWS$1;
  const {
    delete: WeakMapProtoDelete$LWS$1,
    get: WeakMapProtoGet$LWS$1,
    set: WeakMapProtoSet$LWS$1,
    [SymbolToStringTag$LWS$1]: WeakMapProtoSymbolToStringTag$LWS$1
  } = WeakMapProto$LWS$1;
  function toSafeWeakMap$LWS$1(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS$1(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS$1;
    weakMap$LWS.get = WeakMapProtoGet$LWS$1;
    weakMap$LWS.has = WeakMapProtoHas$LWS$1;
    weakMap$LWS.set = WeakMapProtoSet$LWS$1;
    weakMap$LWS[SymbolToStringTag$LWS$1] = WeakMapProtoSymbolToStringTag$LWS$1;
    ReflectSetPrototypeOf$LWS$1(weakMap$LWS, WeakMapProto$LWS$1);
    return weakMap$LWS;
  }
  const WeakSetCtor$LWS$1 = WeakSet;
  const {
    prototype: WeakSetProto$LWS$1
  } = WeakSetCtor$LWS$1;
  const {
    has: WeakSetProtoHas$LWS$1
  } = WeakSetProto$LWS$1;
  const {
    add: WeakSetProtoAdd$LWS$1,
    delete: WeakSetProtoDelete$LWS$1,
    [SymbolToStringTag$LWS$1]: WeakSetProtoSymbolToStringTag$LWS$1
  } = WeakSetProto$LWS$1;
  function toSafeWeakSet$LWS$1(weakSet$LWS) {
    ReflectSetPrototypeOf$LWS$1(weakSet$LWS, null);
    weakSet$LWS.add = WeakSetProtoAdd$LWS$1;
    weakSet$LWS.delete = WeakSetProtoDelete$LWS$1;
    weakSet$LWS.has = WeakSetProtoHas$LWS$1;
    weakSet$LWS[SymbolToStringTag$LWS$1] = WeakSetProtoSymbolToStringTag$LWS$1;
    ReflectSetPrototypeOf$LWS$1(weakSet$LWS, WeakSetProto$LWS$1);
    return weakSet$LWS;
  }
  const {
    toStringTag: TO_STRING_TAG_SYMBOL$LWS
  } = Symbol;
  // Regular expressions from Acorn:
  //     acorn/src/parseutil.js
  //     acorn/src/whitespace.js
  const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
  const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
  const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  function getBrandByTrialAndError$LWS(value$LWS) {
    // Trail and error attempts are performed in order of most likely,
    // e.g. those values that have a @@toStringTag defined by default,
    // to least likely.
    //
    // Internally these brand checks rely on native methods that throw and catch
    // an exception when they operate on values with unexpected internal slot
    // entries.
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
    try {
      if ('byteLength' in value$LWS) {
        ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
        return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused4$LWS) {}
    // Section 21.4.4 Properties of the Date Prototype Object
    // https://tc39.es/ecma262/#thistimevalue
    // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
    //     a. Return value.[[DateValue]].
    // Step 2: Throw a TypeError exception.
    try {
      if ('toLocaleDateString' in value$LWS) {
        ReflectApply$LWS$1(DateProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_DATE$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused5$LWS) {}
    // Section 24.1.3.10 get Map.prototype.size
    // https://tc39.es/ecma262/#sec-get-map.prototype.size
    // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).
    try {
      if ('get' in value$LWS && 'size' in value$LWS) {
        ReflectApply$LWS$1(MapProtoSizeGetter$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_MAP$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused6$LWS) {}
    // Section 24.2.3.9 get Set.prototype.size
    // https://tc39.es/ecma262/#sec-get-set.prototype.size
    // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).
    try {
      if ('add' in value$LWS && 'size' in value$LWS) {
        ReflectApply$LWS$1(SetProtoSizeGetter$LWS, value$LWS, []);
        return TO_STRING_BRAND_SET$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused7$LWS) {}
    // Section 24.3.3.4 WeakMap.prototype.has ( key )
    // https://tc39.es/ecma262/#sec-weakmap.prototype.has
    // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).
    try {
      if ('get' in value$LWS && !('size' in value$LWS)) {
        ReflectApply$LWS$1(WeakMapProtoHas$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_WEAK_MAP$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}
    // Section 24.4.3.4 WeakSet.prototype.has ( value )
    // https://tc39.es/ecma262/#sec-weakset.prototype.has
    // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).
    try {
      if ('add' in value$LWS && !('size' in value$LWS)) {
        ReflectApply$LWS$1(WeakSetProtoHas$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_WEAK_SET$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused9$LWS) {}
    // The following checks are for the rare occurrence of object, i.e. boxed,
    // primitive values or those objects without a default @@toStringTag.
    // Section 21.1.3 Properties of the Number Prototype Object
    // https://tc39.es/ecma262/#thisnumbervalue
    // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
    //     a. Let n be value.[[NumberData]].
    //     b. Assert: Type(n) is Number.
    try {
      if ('toPrecision' in value$LWS) {
        ReflectApply$LWS$1(NumberProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_NUMBER$LWS$1;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused10$LWS) {}
    // Section 20.4.3 Properties of the Symbol Prototype Object
    // https://tc39.es/ecma262/#thissymbolvalue
    // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
    //     a. Let s be value.[[SymbolData]].
    //     b. Assert: Type(s) is Symbol.
    try {
      if ('description' in value$LWS) {
        ReflectApply$LWS$1(SymbolProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_SYMBOL$LWS$1;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused11$LWS) {}
    // Perform heavier checks last.
    // Section 22.2.6.13 get RegExp.prototype.source
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    try {
      if (ObjectHasOwn$LWS$1(value$LWS, 'lastIndex')) {
        ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, value$LWS, []);
        return TO_STRING_BRAND_REG_EXP$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}
    // Section 22.1.3 Properties of the String Prototype Object
    // https://tc39.es/ecma262/#thisstringvalue
    // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
    //     a. Let s be value.[[StringData]].
    //     b. Assert: Type(s) is String.
    try {
      if (ObjectHasOwn$LWS$1(value$LWS, 'length')) {
        ReflectApply$LWS$1(StringProtoValueOf$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_STRING$LWS$1;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
    // Section 20.3.3 Properties of the Boolean Prototype Object
    // https://tc39.es/ecma262/#thisbooleanvalue
    // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
    //     a. Let b be value.[[BooleanData]].
    //     b. Assert: Type(b) is Boolean.
    try {
      ReflectApply$LWS$1(BooleanProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BOOLEAN$LWS$1;
      // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
    // istanbul ignore else: All platforms that LWS runs tests in support BigInt
    if (SUPPORTS_BIG_INT$LWS) {
      try {
        // Section 21.2.3 Properties of the BigInt Prototype Object
        // https://tc39.es/ecma262/#thisbigintvalue
        // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
        //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
        ReflectApply$LWS$1(BigIntProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_BIG_INT$LWS$1;
        // eslint-disable-next-line no-empty
      } catch (_unused15$LWS) {}
    }
    // Cannot detect brands for Arguments and Error objects.
    return TO_STRING_BRAND_OBJECT$LWS;
  }
  function getBrand$LWS(value$LWS) {
    // Section 20.1.3.6 Object.prototype.toString ( )
    // https://tc39.es/ecma262/#sec-object.prototype.tostring
    if (value$LWS === null) {
      return TO_STRING_BRAND_NULL$LWS;
    }
    if (value$LWS === undefined) {
      return TO_STRING_BRAND_UNDEFINED$LWS;
    }
    // eslint-disable-next-line default-case
    switch (typeof value$LWS) {
      case 'bigint':
        return TO_STRING_BRAND_BIG_INT$LWS$1;
      case 'boolean':
        return TO_STRING_BRAND_BOOLEAN$LWS$1;
      case 'function':
        return TO_STRING_BRAND_FUNCTION$LWS;
      case 'number':
        return TO_STRING_BRAND_NUMBER$LWS$1;
      case 'string':
        return TO_STRING_BRAND_STRING$LWS$1;
      case 'symbol':
        return TO_STRING_BRAND_SYMBOL$LWS$1;
    }
    if (ArrayIsArray$LWS$1(value$LWS)) {
      return TO_STRING_BRAND_ARRAY$LWS;
    }
    return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS$1(ObjectProtoToString$LWS$1, value$LWS, []);
  }
  typeof performance === 'undefined' ? /* istanbul ignore next: unreachable in test env */DateNow$LWS : ReflectApply$LWS$1(FunctionProtoBind$LWS, performance.now, [performance]);
  // Based on Acorn strictDirective() parser utility.
  // Copyright 2012-2022. Released under MIT License.
  // https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js
  function indexOfPragma$LWS(source$LWS, pragma$LWS) {
    let pos$LWS = 0;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
      pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
      const stringLiteralMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS$1(StringProtoSlice$LWS$1, source$LWS, [pos$LWS])]);
      if (stringLiteralMatch$LWS === null) {
        return -1;
      }
      if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
        skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
        const spaceAfterMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
        const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
        const nextChar$LWS = source$LWS[end$LWS];
        if (nextChar$LWS === ';' || nextChar$LWS === '}') {
          return pos$LWS;
        }
        const indexAfterNext$LWS = end$LWS + 1;
        if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === '!' && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === '=' || ReflectApply$LWS$1(RegExpProtoTest$LWS$1, expressionCharRegExp$LWS, [nextChar$LWS]))) {
          return pos$LWS;
        }
      }
      pos$LWS += stringLiteralMatch$LWS[0].length;
      // Skip semicolon, if any.
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
      pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
      if (source$LWS[pos$LWS] === ';') {
        pos$LWS += 1;
      }
    }
  }
  const {
    parse: JSONParse$LWS
  } = JSON;
  function getNearMembraneProxySerializedValue$LWS$1(object$LWS) {
    if (typeof object$LWS === 'object' && object$LWS !== null || typeof object$LWS === 'function') {
      // To extract the serialized value of a blue near-membrane proxy we must
      // perform a two step handshake. First, we trigger the "has" trap for
      // the `LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL` property which
      // must report `false`. Second, we trigger the "get" trap to return the
      // serialized value.
      return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1 in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1];
    }
    return undefined;
  }
  function isNearMembraneProxy$LWS$1(value$LWS) {
    if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
      // To extract the flag value of a blue near-membrane proxy we must
      // perform a two step handshake. First, we trigger the "has" trap for
      // the `LOCKER_NEAR_MEMBRANE_SYMBOL` property which must report `false`.
      // Second, we trigger the "get" trap to return the flag value.
      return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1 in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1] === true;
    }
    return false;
  }
  const SEEN_OBJECTS$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  function cloneBoxedPrimitive$LWS(object$LWS) {
    return ObjectCtor$LWS$1(getNearMembraneProxySerializedValue$LWS$1(object$LWS));
  }
  function cloneMap$LWS(map$LWS, queue$LWS) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // Step 26.1.1: Let copiedList be a new empty List.
    const clone$LWS = new MapCtor$LWS$1();
    // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...
    const entriesIterable$LWS = ReflectApply$LWS$1(MapProtoEntries$LWS$1, map$LWS, []);
    // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:
    let {
      length: queueOffset$LWS
    } = queue$LWS;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const {
        done: done$LWS,
        value: subKeyValuePair$LWS
      } = entriesIterable$LWS.next();
      if (done$LWS) {
        break;
      }
      const {
        0: subKey$LWS,
        1: subValue$LWS
      } = subKeyValuePair$LWS;
      let subCloneKey$LWS;
      // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).
      queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
        subCloneKey$LWS = subClone$LWS;
      }, subKey$LWS];
      // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).
      queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
        ReflectApply$LWS$1(MapProtoSet$LWS$1, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
      }, subValue$LWS];
    }
    return clone$LWS;
  }
  function cloneRegExp$LWS(regexp$LWS) {
    const {
      flags: flags$LWS,
      source: source$LWS
    } = JSONParse$LWS(getNearMembraneProxySerializedValue$LWS$1(regexp$LWS));
    return new RegExpCtor$LWS$1(source$LWS, flags$LWS);
  }
  function cloneSet$LWS(set$LWS, queue$LWS) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // Step 26.2.1: Let copiedList be a new empty List.
    const clone$LWS = new SetCtor$LWS$1();
    // Step 26.2.2: For each entry of value.[[SetData]]...
    const valuesIterable$LWS = ReflectApply$LWS$1(SetProtoValues$LWS$1, set$LWS, []);
    // Step 26.2.3: For each entry of copiedList:
    let {
      length: queueOffset$LWS
    } = queue$LWS;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const {
        done: done$LWS,
        value: subValue$LWS
      } = valuesIterable$LWS.next();
      if (done$LWS) {
        break;
      }
      // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).
      queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
        ReflectApply$LWS$1(SetProtoAdd$LWS$1, clone$LWS, [subCloneValue$LWS]);
      }, subValue$LWS];
    }
    return clone$LWS;
  }
  function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
    // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
    // defined in ECMA262:
    // https://tc39.es/ecma262/#sec-object.keys
    const keys$LWS = ObjectKeys$LWS$1(originalValue$LWS);
    let {
      length: queueOffset$LWS
    } = queue$LWS;
    for (let i$LWS = 0, {
        length: length$LWS
      } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
      // The [[Get]] operation is defined in ECMA262 for ordinary objects,
      // argument objects, integer-indexed exotic objects, module namespace
      // objects, and proxy objects.
      // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
      const key$LWS = keys$LWS[i$LWS];
      const subValue$LWS = originalValue$LWS[key$LWS];
      queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
        // Step 26.4.1.3: Property descriptor attributes are not
        // preserved during deserialization because only keys and
        // values are captured in serialized.[[Properties]].
        cloneValue$LWS[key$LWS] = subCloneValue$LWS;
      }, subValue$LWS];
    }
  }
  // This function is the unguarded internal variant of `partialStructuredClone()`.
  // Any error thrown that is captured by `partialStructuredClone()` is treated as
  // a `DataCloneError`. This function clones blue membrane proxied arrays, plain
  // objects, maps, regexps, sets, and boxed primitives. The following non-membrane
  // proxied objects are set by reference instead of cloning:
  //   ArrayBuffer
  //   BigInt64Array
  //   BigUint64Array
  //   Blob
  //   DataView
  //   Date
  //   DOMException
  //   DOMMatrix
  //   DOMMatrixReadOnly
  //   DOMPoint
  //   DOMPointReadOnly
  //   DOMQuad
  //   DOMRect
  //   DOMRectReadOnly
  //   Error
  //   EvalError
  //   File
  //   FileList
  //   Float32Array
  //   Float64Array
  //   ImageBitMap
  //   ImageData
  //   Int8Array
  //   Int16Array
  //   Int32Array
  //   RangeError
  //   ReferenceError
  //   SyntaxError
  //   TypeError
  //   Uint8Array
  //   Uint8ClampedArray
  //   Uint16Array
  //   Uint32Array
  //   URIError
  //
  // Note:
  // This function performs brand checks using `Object.prototype.toString`. The
  // results can be faked with `Symbol.toStringTag` property values and are a poor
  // substitute for native internal slot checks. However, for our purposes they
  // are perfectly fine and avoid having to repeatedly walk the prototype of proxied
  // values. Cloned values should be passed to native methods, like `postMessage()`,
  // which perform their own validation with internal slot checks.
  function partialStructuredCloneInternal$LWS(value$LWS) {
    // Using a queue instead of recursive function calls avoids call stack limits
    // and enables cloning more complex and deeply nested objects.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
    let result$LWS;
    const queue$LWS = [[subClone$LWS => {
      result$LWS = subClone$LWS;
    }, value$LWS]];
    // eslint-disable-next-line no-labels
    queueLoop: while (queue$LWS.length) {
      // Section 2.7.3 StructuredSerializeInternal:
      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
      // prettier-ignore
      const {
        0: setter$LWS,
        1: originalValue$LWS
      } = ReflectApply$LWS$1(ArrayProtoShift$LWS$1, queue$LWS, []);
      // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String
      if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
        setter$LWS(originalValue$LWS);
        // eslint-disable-next-line no-continue, no-extra-label, no-labels
        continue queueLoop;
      }
      // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.
      if (typeof originalValue$LWS === 'symbol') {
        // Stop cloning and set the original value and defer throwing to
        // native methods.
        setter$LWS(originalValue$LWS);
        // eslint-disable-next-line no-extra-label, no-labels
        break queueLoop;
      }
      // To support circular references check if the original value has been
      // seen. If it has then use the clone associated with its record instead
      // of creating a new clone.
      let cloneValue$LWS = SEEN_OBJECTS$LWS.get(originalValue$LWS);
      if (cloneValue$LWS) {
        setter$LWS(cloneValue$LWS);
        // eslint-disable-next-line no-continue, no-extra-label, no-labels
        continue queueLoop;
      }
      // Perform a brand check on originalValue.
      const brand$LWS = getBrand$LWS(originalValue$LWS);
      // eslint-disable-next-line default-case
      switch (brand$LWS) {
        // Step 19: Otherwise, if value is a platform object...
        case TO_STRING_BRAND_OBJECT$LWS:
          {
            const proto$LWS = ReflectGetPrototypeOf$LWS$1(originalValue$LWS);
            if (proto$LWS === ObjectProto$LWS$1 || proto$LWS === null ||
            // Possible `Object.prototype` from another document.
            ReflectGetPrototypeOf$LWS$1(proto$LWS) === null) {
              cloneValue$LWS = {};
              // Step 19.4: Set deep to true.
              enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
            }
            break;
          }
        // Step 18: Otherwise, if value is an Array exotic object...
        case TO_STRING_BRAND_ARRAY$LWS:
          // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
          // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
          // operation for 'length' because it is a non-configurable property
          // we can access it with the simpler [[Get]]() operation defined
          // in ECMA262.
          // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
          cloneValue$LWS = ArrayCtor$LWS$1(originalValue$LWS.length);
          // Step 18.4: Set deep to true.
          enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          break;
        // Step 15: Otherwise, if value has [[MapData]] internal slot...
        // Step 15.2: Set deep to true.
        case TO_STRING_BRAND_MAP$LWS:
          cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
          break;
        // Step 16: Otherwise, if value has [[SetData]] internal slot...
        // Step 16.2: Set deep to true.
        case TO_STRING_BRAND_SET$LWS:
          cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
          break;
      }
      if (cloneValue$LWS === undefined) {
        // istanbul ignore else
        if (!isNearMembraneProxy$LWS$1(originalValue$LWS)) {
          // Skip cloning non-membrane proxied objects.
          SEEN_OBJECTS$LWS.set(originalValue$LWS, originalValue$LWS);
          setter$LWS(originalValue$LWS);
          // eslint-disable-next-line no-extra-label, no-labels
          continue queueLoop;
        }
        // Cases ordered by a guestimate on frequency of encounter.
        // eslint-disable-next-line default-case
        switch (brand$LWS) {
          // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
          case TO_STRING_BRAND_REG_EXP$LWS:
            cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
            break;
          // Step 7: If value has a [[BooleanData]] internal slot...
          case TO_STRING_BRAND_BOOLEAN$LWS$1:
          // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
          // eslint-disable-next-line no-fallthrough
          case TO_STRING_BRAND_NUMBER$LWS$1:
          // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
          // eslint-disable-next-line no-fallthrough
          case TO_STRING_BRAND_BIG_INT$LWS$1:
          // Step 10: Otherwise, if value has a [[StringData]] internal slot...
          // eslint-disable-next-line no-fallthrough
          case TO_STRING_BRAND_STRING$LWS$1:
            cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
            break;
        }
      }
      // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
      // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'
      if (cloneValue$LWS === undefined) {
        // Stop cloning and set the original value and defer throwing to
        // native methods.
        setter$LWS(originalValue$LWS);
        // eslint-disable-next-line no-extra-label, no-labels
        break queueLoop;
      }
      SEEN_OBJECTS$LWS.set(originalValue$LWS, cloneValue$LWS);
      setter$LWS(cloneValue$LWS);
    }
    return result$LWS;
  }
  function partialStructuredClone$LWS(value$LWS) {
    let result$LWS = value$LWS;
    if (typeof value$LWS === 'object' && value$LWS !== null) {
      try {
        result$LWS = partialStructuredCloneInternal$LWS(value$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused16$LWS) {}
      SEEN_OBJECTS$LWS.clear();
    }
    return result$LWS;
  }
  function shallowCloneArray$LWS(array$LWS) {
    return ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
  }
  function shallowCloneOptions$LWS(options$LWS) {
    const ownKeys$LWS = ReflectOwnKeys$LWS$1(options$LWS);
    const clone$LWS = {
      __proto__: null
    };
    for (let i$LWS = 0, {
        length: length$LWS
      } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = ownKeys$LWS[i$LWS];
      clone$LWS[key$LWS] = options$LWS[key$LWS];
    }
    return clone$LWS;
  }
  const consoleRef$LWS = console;
  const {
    warn: consoleWarnRef$LWS
  } = consoleRef$LWS;
  function consoleWarn$LWS(...args$LWS) {
    ReflectApply$LWS$1(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
  }
  let gaterEnabledFeatures$LWS = [];
  function registerGaterEnabledFeatures$LWS(lockerGaterEnabledFeatures$LWS) {
    if (ArrayIsArray$LWS$1(lockerGaterEnabledFeatures$LWS)) {
      gaterEnabledFeatures$LWS = lockerGaterEnabledFeatures$LWS;
    }
  }
  function isGaterEnabledFeature$LWS(featureName$LWS) {
    return ReflectApply$LWS$1(ArrayProtoIncludes$LWS$1, gaterEnabledFeatures$LWS, [`com.salesforce.locker.${featureName$LWS}`]);
  }
  const trackedLiveTargets$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  function isTargetLive$LWS(target$LWS, targetTraits$LWS = 0 /* TargetTraits.None */) {
    if (targetTraits$LWS & 1 /* TargetTraits.IsArray */ || targetTraits$LWS & 2 /* TargetTraits.IsArrayBufferView */ || targetTraits$LWS & 64 /* TargetTraits.Revoked */ || target$LWS === null || target$LWS === undefined || target$LWS === ObjectProto$LWS$1 || target$LWS === RegExpProto$LWS$1) {
      return false;
    }
    if (typeof target$LWS === 'function') {
      try {
        return trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused17$LWS) {}
      return false;
    }
    if (typeof target$LWS === 'object') {
      try {
        if (trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS)) {
          return true;
        }
        // eslint-disable-next-line no-empty
      } catch (_unused18$LWS) {}
      let constructor$LWS;
      try {
        ({
          constructor: constructor$LWS
        } = target$LWS);
        if (constructor$LWS === ObjectCtor$LWS$1) {
          // If the constructor, own or inherited, points to `Object`
          // then `target` is not likely a prototype object.
          return true;
        }
        // eslint-disable-next-line no-empty
      } catch (_unused19$LWS) {}
      try {
        if (ReflectGetPrototypeOf$LWS$1(target$LWS) === null && (
        // Ensure `target` is not an `Object.prototype` from an iframe.
        typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== target$LWS)) {
          return true;
        }
        // eslint-disable-next-line no-empty
      } catch (_unused20$LWS) {}
      if (targetTraits$LWS === 0 /* TargetTraits.None */) {
        try {
          if (ArrayIsArray$LWS$1(target$LWS)) {
            return true;
          }
        } catch (_unused21$LWS) {
          // The target is a revoked proxy.
          return false;
        }
        if (ArrayBufferIsView$LWS(target$LWS)) {
          return true;
        }
      }
      // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
      // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
      // Step 3: If R does not have an [[OriginalSource]] internal slot, then
      //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
      //     b. Otherwise, throw a TypeError exception.
      try {
        if (ObjectHasOwn$LWS$1(target$LWS, 'lastIndex')) {
          ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, target$LWS, []);
          return true;
        }
        // eslint-disable-next-line no-empty
      } catch (_unused22$LWS) {}
      // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
      // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
      // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
      try {
        if ('byteLength' in target$LWS) {
          ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, target$LWS, []);
          return true;
        }
        // eslint-disable-next-line no-empty
      } catch (_unused23$LWS) {}
    }
    return false;
  }
  function markTargetAsLive$LWS(target$LWS) {
    if ((typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') && !isTargetLive$LWS(target$LWS)) {
      ReflectDefineProperty$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS, {
        __proto__: null,
        value: undefined
      });
    }
    return target$LWS;
  }
  function trackAsLiveTarget$LWS(target$LWS) {
    trackedLiveTargets$LWS.add(target$LWS);
    return target$LWS;
  }
  const NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}-`;
  const NS_TAIL$LWS = '$';
  const STORAGE_NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}[`;
  const STORAGE_NS_TAIL$LWS = ']';
  function getNamespaceMarker$LWS(namespace$LWS) {
    return `${NS_HEAD$LWS}${namespace$LWS}${NS_TAIL$LWS}`;
  }
  function getStorageNamespaceMarker$LWS(namespace$LWS) {
    return `${STORAGE_NS_HEAD$LWS}${namespace$LWS}${STORAGE_NS_TAIL$LWS}`;
  }
  function prependNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return `${getNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
  }
  function prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return `${getStorageNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
  }
  function removeNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    if (typeof key$LWS === 'string') {
      const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
      return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS$1, key$LWS, [marker$LWS.length]) : key$LWS;
    }
    return '';
  }
  function removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    if (typeof key$LWS === 'string') {
      const marker$LWS = getStorageNamespaceMarker$LWS(namespace$LWS);
      return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS$1, key$LWS, [marker$LWS.length]) : key$LWS;
    }
    return '';
  }
  function startsWithNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return typeof key$LWS === 'string' && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [getNamespaceMarker$LWS(namespace$LWS)]);
  }
  function startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return typeof key$LWS === 'string' && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [getStorageNamespaceMarker$LWS(namespace$LWS)]);
  }
  const PromiseCtor$LWS = Promise;
  const {
    catch: PromiseProtoCatch$LWS,
    then: PromiseProtoThen$LWS
  } = PromiseCtor$LWS.prototype;
  const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
  const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
  /*! version: 0.21.7 */

  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const AbortControllerCtor$LWS = AbortController;
  const {
    prototype: AbortControllerProto$LWS
  } = AbortControllerCtor$LWS;
  const {
    abort: AbortControllerProtoAbort$LWS
  } = AbortControllerProto$LWS;
  const AbortControllerProtoSignalGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbortControllerProto$LWS, 'signal');
  const {
    prototype: AttrProto$LWS
  } = Attr;
  const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'name');
  const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'namespaceURI');
  const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'ownerElement');
  const {
    get: AttrProtoValueGetter$LWS,
    set: AttrProtoValueSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, 'value');
  function normalizeNamespacedAttributeName$LWS(attrName$LWS) {
    const href$LWS = 'href';
    // Prevent arbitrary:href from being treated like a valid namespaced href value
    if (ReflectApply$LWS$1(StringProtoEndsWith$LWS, attrName$LWS, [href$LWS]) &&
    // ...But we don't want to match "xlink:href"
    !ReflectApply$LWS$1(StringProtoStartsWith$LWS, attrName$LWS, ['xlink:href'])) {
      return href$LWS;
    }
    return attrName$LWS;
  }
  const rootDocument$LWS = document;
  const {
    prototype: DocumentProto$LWS$1
  } = Document;
  // Used by '@locker/near-membrane/dom'.
  const {
    close: DocumentProtoClose$LWS$1,
    open: DocumentProtoOpen$LWS$1
  } = DocumentProto$LWS$1;
  const {
    createComment: DocumentProtoCreateComment$LWS,
    createElement: DocumentProtoCreateElement$LWS$1,
    createElementNS: DocumentProtoCreateElementNS$LWS,
    getElementById: DocumentProtoGetElementById$LWS
  } = DocumentProto$LWS$1;
  const DocumentProtoBodyGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'body');
  const {
    get: DocumentProtoCookieGetter$LWS,
    set: DocumentProtoCookieSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS$1, 'cookie');
  const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'defaultView');
  const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'documentElement');
  const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'head');
  const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'implementation');
  const {
    prototype: ElementProto$LWS
  } = Element;
  const ElementAriaAttributesToPropertyName$LWS = {
    __proto__: null,
    'aria-activedescendant': 'ariaActiveDescendant',
    'aria-atomic': 'ariaAtomic',
    'aria-autocomplete': 'ariaAutoComplete',
    'aria-busy': 'ariaBusy',
    'aria-checked': 'ariaChecked',
    'aria-colcount': 'ariaColCount',
    'aria-colindex': 'ariaColIndex',
    'aria-colspan': 'ariaColSpan',
    'aria-controls': 'ariaControls',
    'aria-current': 'ariaCurrent',
    'aria-describedby': 'ariaDescribedBy',
    'aria-details': 'ariaDetails',
    'aria-disabled': 'ariaDisabled',
    'aria-errormessage': 'ariaErrorMessage',
    'aria-expanded': 'ariaExpanded',
    'aria-flowto': 'ariaFlowTo',
    'aria-haspopup': 'ariaHasPopup',
    'aria-hidden': 'ariaHidden',
    'aria-invalid': 'ariaInvalid',
    'aria-keyshortcuts': 'ariaKeyShortcuts',
    'aria-label': 'ariaLabel',
    'aria-labelledby': 'ariaLabelledBy',
    'aria-level': 'ariaLevel',
    'aria-live': 'ariaLive',
    'aria-modal': 'ariaModal',
    'aria-multiline': 'ariaMultiLine',
    'aria-multiselectable': 'ariaMultiSelectable',
    'aria-orientation': 'ariaOrientation',
    'aria-owns': 'ariaOwns',
    'aria-placeholder': 'ariaPlaceholder',
    'aria-posinset': 'ariaPosInSet',
    'aria-pressed': 'ariaPressed',
    'aria-readonly': 'ariaReadOnly',
    'aria-relevant': 'ariaRelevant',
    'aria-required': 'ariaRequired',
    'aria-roledescription': 'ariaRoleDescription',
    'aria-rowcount': 'ariaRowCount',
    'aria-rowindex': 'ariaRowIndex',
    'aria-rowspan': 'ariaRowSpan',
    'aria-selected': 'ariaSelected',
    'aria-setsize': 'ariaSetSize',
    'aria-sort': 'ariaSort',
    'aria-valuemax': 'ariaValueMax',
    'aria-valuemin': 'ariaValueMin',
    'aria-valuenow': 'ariaValueNow',
    'aria-valuetext': 'ariaValueText'
  };
  const {
    closest: ElementProtoClosest$LWS,
    getAttribute: ElementProtoGetAttribute$LWS,
    getAttributeNode: ElementProtoGetAttributeNode$LWS,
    getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
    hasAttribute: ElementProtoHasAttribute$LWS,
    querySelector: ElementProtoQuerySelector$LWS,
    querySelectorAll: ElementProtoQuerySelectorAll$LWS,
    removeAttribute: ElementProtoRemoveAttribute$LWS,
    removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
    removeAttributeNS: ElementProtoRemoveAttributeNS$LWS,
    setAttribute: ElementProtoSetAttribute$LWS$1,
    setAttributeNS: ElementProtoSetAttributeNS$LWS,
    toggleAttribute: ElementProtoToggleAttribute$LWS
  } = ElementProto$LWS;
  const {
    get: ElementProtoInnerHTMLGetter$LWS,
    set: ElementProtoInnerHTMLSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'innerHTML');
  const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, 'namespaceURI');
  const {
    get: ElementProtoOuterHTMLGetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'outerHTML');
  const ElementProtoTagNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, 'tagName');
  const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLTemplateElement.prototype, 'content');
  const {
    prototype: NodeProto$LWS$1
  } = Node;
  const {
    appendChild: NodeProtoAppendChild$LWS$1,
    cloneNode: NodeProtoCloneNode$LWS,
    isEqualNode: NodeProtoIsEqualNode$LWS
  } = NodeProto$LWS$1;
  const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'childNodes');
  const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'firstChild');
  const NodeProtoIsConnectedGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'isConnected');
  // Used by '@locker/near-membrane-dom'.
  ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'lastChild');
  const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'nodeName');
  const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'ownerDocument');
  ReflectGetOwnPropertyDescriptor$LWS(NodeProto$LWS$1, 'textContent');

  // Check for the noopener feature being enabled:
  // - noopener
  // - noopener=1
  // - noopener=yes
  const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;
  const rootWindow$LWS$1 = window;
  // These properties are part of the WindowOrGlobalScope mixin and not on
  // Window.prototype.
  // https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope
  const {
    setTimeout: WindowSetTimeout$LWS
  } = rootWindow$LWS$1;
  const {
    clearInterval: WindowClearInterval$LWS,
    decodeURIComponent: WindowDecodeURIComponent$LWS,
    encodeURIComponent: WindowEncodeURIComponent$LWS,
    fetch: WindowFetch$LWS,
    location: rootWindowLocation$LWS,
    setInterval: WindowSetInterval$LWS,
    top: rootWindowTop$LWS
  } = rootWindow$LWS$1;
  const WindowQueueMicrotask$LWS = (() => {
    const {
      queueMicrotask: queueMicrotask$LWS
    } = rootWindow$LWS$1;
    // istanbul ignore else
    if (typeof queueMicrotask$LWS === 'function') {
      return queueMicrotask$LWS;
    }
    // Edge 15 does not support `queueMicrotask()`.
    // https://caniuse.com/mdn-api_queuemicrotask
    // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
    // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    return function queueMicrotask$LWS(callback$LWS) {
      let promise$LWS = PromiseResolve$LWS();
      promise$LWS = ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
      ReflectApply$LWS$1(PromiseProtoCatch$LWS, promise$LWS, [error => WindowSetTimeout$LWS(() => {
        throw error;
      }, 0)]);
    };
  })();
  const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'document');
  const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'frameElement');
  const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'length');
  const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'location');
  function initWindowOpenChildWindow$LWS(win$LWS, url$LWS) {
    // Skip if `url` is an empty string or `undefined` as a blank page will be
    // opened into the targeted browsing context and not navigated away from.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/open#parameters
    if (typeof url$LWS === 'string' && url$LWS !== '') {
      // `WindowDocumentGetter` will throw if `win` is an opaque cross-origin
      // window.
      try {
        const doc$LWS = ReflectApply$LWS$1(WindowDocumentGetter$LWS, win$LWS, []);
        // `win.location` is a non-configurable property so can be accessed
        // directly.
        const {
          location: location$LWS
        } = win$LWS;
        // Check if the `location.href` is an intermediate value different
        // than `url`.
        // `location.href` is a non-configurable property so can be accessed
        // directly.
        if (location$LWS.href !== url$LWS) {
          // Opening and closing `doc` prevents the default browser
          // redirect behavior.
          ReflectApply$LWS$1(DocumentProtoOpen$LWS$1, doc$LWS, []);
          ReflectApply$LWS$1(DocumentProtoClose$LWS$1, doc$LWS, []);
          // `location.replace` is a non-configurable property so can be
          // accessed directly.
          location$LWS.replace(url$LWS);
        }
        // eslint-disable-next-line no-empty
      } catch (_unused$LWS) {}
    }
    return win$LWS;
  }
  function isWindow$LWS(value$LWS) {
    if (typeof value$LWS === 'object' && value$LWS !== null && ObjectHasOwn$LWS$1(value$LWS, 'window') && value$LWS.window === value$LWS) {
      // Slower check that must certainly detect a window object.
      try {
        // window.self getter only works for a window object, otherwise it
        // throws, additionally, this works fine for a detached window as
        // well, which is important since it will guarantee that this check
        // works also for iframes that are disconnected, and could be connected
        // later on, that should not bypass this check. This check is is also
        // equivalent to window.frames, and here is the very simple spec for
        // this getter:
        // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
        ReflectApply$LWS$1(WindowLocationGetter$LWS, value$LWS, []);
        return true;
        // eslint-disable-next-line no-empty
      } catch (_unused2$LWS) {}
    }
    return false;
  }
  function normalizeWindowOpenArguments$LWS(args$LWS) {
    const normalizedArgs$LWS = shallowCloneArray$LWS(args$LWS);
    const {
      length: length$LWS
    } = normalizedArgs$LWS;
    if (length$LWS) {
      const url$LWS = normalizedArgs$LWS[0];
      if (typeof url$LWS !== 'string') {
        normalizedArgs$LWS[0] = url$LWS ? `${url$LWS}` : undefined;
      }
    }
    if (length$LWS > 1) {
      const target$LWS = normalizedArgs$LWS[1];
      if (typeof target$LWS !== 'string') {
        normalizedArgs$LWS[1] = target$LWS ? `${target$LWS}` : undefined;
      }
    }
    if (length$LWS > 2) {
      let features$LWS = normalizedArgs$LWS[2];
      if (typeof features$LWS !== 'string') {
        features$LWS = features$LWS ? `${features$LWS}` : undefined;
      }
      if (features$LWS) {
        // Lowercase the features string because it is case insensitive.
        // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
        let loweredFeatures$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, features$LWS, []);
        // RegExp.prototype[Symbol.replace] resets the lastIndex of global
        // regexp to 0.
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, noopenerRegExp$LWS, [loweredFeatures$LWS])) {
          // Replacing noopener with an enabled state that is supported
          // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
          loweredFeatures$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredFeatures$LWS, [
          // RegExp.prototype[Symbol.replace] resets the lastIndex of
          // global regexp to 0.
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
          noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
        }
        features$LWS = loweredFeatures$LWS;
      }
      normalizedArgs$LWS[2] = features$LWS;
    }
    return normalizedArgs$LWS;
  }

  /* eslint-disable no-underscore-dangle */
  class Validator$LWS {
    constructor(document$LWS, {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      HTMLStyleElement: HTMLStyleElement$LWS
    }) {
      this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement || element$LWS instanceof this._constructors.HTMLStyleElement;
      this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
        ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
        ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
        return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
      };
      this.isSharedElement = element$LWS => element$LWS === ReflectApply$LWS$1(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, this._document, []);
      this._constructors = {
        HTMLLinkElement: HTMLLinkElement$LWS,
        HTMLScriptElement: HTMLScriptElement$LWS,
        HTMLStyleElement: HTMLStyleElement$LWS
      };
      this._document = document$LWS;
      this._templates = {
        left: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ['template']),
        right: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ['template'])
      };
    }
  }
  /* eslint-enable no-underscore-dangle */
  function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
    const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
    const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;
    if (ReflectApply$LWS$1(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
      const leftChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
      const childCount$LWS = leftChildNodes$LWS.length;
      if (childCount$LWS > 0) {
        const rightChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);
        for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
          if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }
  const rootValidator$LWS = new Validator$LWS(rootDocument$LWS, rootWindow$LWS$1);
  const documentToValidatorMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[rootDocument$LWS, rootValidator$LWS]]));
  function getValidator$LWS(document$LWS, globalObject$LWS) {
    // Fast path validator lookup for top level window.
    if (globalObject$LWS === undefined || globalObject$LWS === rootWindow$LWS$1) {
      return rootValidator$LWS;
    }
    // Use the `document` as the key because a window object maintains its identity
    // continuity when its location changes and while the non-configurable document
    // property does not.
    let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);
    if (validator$LWS === undefined) {
      validator$LWS = new Validator$LWS(document$LWS, globalObject$LWS);
      documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
    }
    return validator$LWS;
  }
  const BlobCtor$LWS = Blob;
  const {
    prototype: BlobProto$LWS
  } = BlobCtor$LWS;
  const {
    slice: BlobProtoSlice$LWS
  } = BlobProto$LWS;
  const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, 'size');
  const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, 'type');
  const {
    // We don't cherry-pick the 'userAgent' property from `navigator` here
    // to avoid triggering its getter.
    navigator: navigator$LWS$1,
    navigator: {
      userAgentData: userAgentData$LWS$1
    }
  } = rootWindow$LWS$1;
  // The user-agent client hints API is experimental and subject to change.
  // https://caniuse.com/mdn-api_navigator_useragentdata
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const brands$LWS$1 = userAgentData$LWS$1 == null ? void 0 : userAgentData$LWS$1.brands;
  // Note: Chromium identifies itself as Chrome in its user-agent string.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
  const chromiumUserAgentRegExp$LWS$1 = / (?:Headless)?Chrome\/\d+/;
  const webKitUserAgentRegExp$LWS = /WebKit/i;
  let userAgent$LWS$1;
  function getUserAgent$LWS$1() {
    if (userAgent$LWS$1 === undefined) {
      userAgent$LWS$1 = navigator$LWS$1.userAgent;
    }
    return userAgent$LWS$1;
  }
  const CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS = LOCKER_SERVICE_KEY_LOWERED$LWS;
  // Used by '@locker/near-membrane-dom'.
  const IS_CHROMIUM_BROWSER$LWS$1 =
  // While experimental, `navigator.userAgentData.brands` may be defined as an
  // empty array in headless Chromium based browsers.
  ArrayIsArray$LWS$1(brands$LWS$1) && brands$LWS$1.length ?
  // Use user-agent client hints API if available to avoid deprecation
  // warnings.
  // https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
  // istanbul ignore next: this code is not reachable in the coverage run.
  ReflectApply$LWS$1(ArrayProtoFind$LWS$1, brands$LWS$1, [
  // prettier-ignore
  // istanbul ignore next: this code is not reachable in the coverage run.
  item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined :
  // Fallback to a standard user-agent string sniff.
  ReflectApply$LWS$1(RegExpProtoTest$LWS$1, chromiumUserAgentRegExp$LWS$1, [getUserAgent$LWS$1()]);
  const IS_WEBKIT_BROWSER$LWS = !IS_CHROMIUM_BROWSER$LWS$1 && (
  // istanbul ignore next: this code is not reachable in the coverage run.
  ArrayIsArray$LWS$1(brands$LWS$1) && brands$LWS$1.length ? ReflectApply$LWS$1(ArrayProtoFind$LWS$1, brands$LWS$1, [
  // istanbul ignore next
  item$LWS => {
    const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
    return typeof brand$LWS === 'string' && ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webKitUserAgentRegExp$LWS, [brand$LWS]);
  }]) !== undefined : ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webKitUserAgentRegExp$LWS, [getUserAgent$LWS$1()]));
  const {
    getElementById: DocumentFragmentProtoGetElementById$LWS
  } = DocumentFragment.prototype;

  // Used by '@locker/near-membrane-shared-dom'.
  // The DOMException constructor was exposed in Edge 12 but wasn't invocable
  // until Edge 79. As long as this is used for instanceof checks it should be fine.
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
  const DOMExceptionCtor$LWS$1 = DOMException;
  ObjectLookupOwnGetter$LWS$1(DOMExceptionCtor$LWS$1.prototype, 'code');
  const {
    createDocument: DOMImplementationProtoCreateDocument$LWS
  } = DOMImplementation.prototype;
  const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS$1(DOMTokenList.prototype, 'value');
  const EventCtor$LWS = Event;
  const {
    prototype: EventProto$LWS
  } = EventCtor$LWS;
  const {
    stopPropagation: EventProtoStopPropagation$LWS
  } = EventProto$LWS;
  const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS$1(EventProto$LWS, 'currentTarget');
  const {
    addEventListener: EventTargetProtoAddEventListener$LWS,
    dispatchEvent: EventTargetProtoDispatchEvent$LWS,
    removeEventListener: EventTargetProtoRemoveEventListener$LWS
  } = EventTarget.prototype;
  const {
    prototype: HTMLAnchorElementProto$LWS
  } = HTMLAnchorElement;
  const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElementProto$LWS, 'hostname');
  const {
    get: HTMLAnchorElementProtoHrefGetter$LWS,
    set: HTMLAnchorElementProtoHrefSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElementProto$LWS, 'href');
  const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElementProto$LWS, 'pathname');
  const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElementProto$LWS, 'protocol');
  const HTMLElement$LWS = getUnmaskedFunction$LWS(rootWindow$LWS$1.HTMLElement);
  const {
    prototype: HTMLElementProto$LWS
  } = HTMLElement$LWS;
  // Used by '@locker/near-membrane-dom'.
  ObjectLookupOwnGetter$LWS$1(HTMLElementProto$LWS, 'style');
  const HTMLElementGlobalAttributesToPropertyName$LWS = {
    __proto__: null,
    accesskey: 'accessKey',
    contenteditable: 'contentEditable',
    enterkeyhint: 'enterKeyHint',
    inputmode: 'inputMode',
    tabindex: 'tabIndex'
  };
  const {
    prototype: HTMLIFrameElementProto$LWS
  } = HTMLIFrameElement;
  // Used by '@locker/near-membrane-dom'.
  ObjectLookupOwnGetter$LWS$1(HTMLIFrameElementProto$LWS, 'contentWindow');
  const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'src');
  const HTMLScriptElementCtor$LWS = HTMLScriptElement;
  const {
    prototype: HTMLScriptElementProto$LWS
  } = HTMLScriptElementCtor$LWS;
  const {
    get: HTMLScriptElementProtoSrcGetter$LWS,
    set: HTMLScriptElementProtoSrcSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElementProto$LWS, 'src');
  const NAMESPACE_DEFAULT$LWS = 'default';
  const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
  const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
  const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
  const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS$1(Request.prototype, 'url');
  const ResponseCtor$LWS = Response;
  const ResponseProto$LWS = ResponseCtor$LWS.prototype;
  const ResponseProtoOkGetter$LWS = ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, 'ok');
  ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, 'status');
  ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, 'statusText');
  const {
    text: ResponseProtoText$LWS
  } = ResponseProto$LWS;
  const {
    createObjectURL: URLCreateObjectURL$LWS,
    revokeObjectURL: URLRevokeObjectURL$LWS
  } = URL;
  const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
  const SCRIPT_HOOK_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}`;
  const evaluatedScriptElements$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  const originalScriptPropertyCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const resolvedURLRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function defineScriptAccessorProperty$LWS(script$LWS, propKey$LWS, getter$LWS, setter$LWS) {
    ReflectDefineProperty$LWS$1(script$LWS, propKey$LWS, {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: getter$LWS,
      set: setter$LWS
    });
  }
  function defineScriptEvaluatorProperty$LWS(script$LWS, callback$LWS) {
    if (!ReflectDefineProperty$LWS$1(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
      __proto__: null,
      configurable: true,
      // Create a bound function to obscure the getter source as "[native code]".
      get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
        // Track the script element evaluation to ensure the element
        // is evaluated only once.
        evaluatedScriptElements$LWS.add(script$LWS);
        deleteScriptEvaluatorProperty$LWS(script$LWS);
        const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, script$LWS, []);
        const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
        // We don't need to use something like `WindowLocationGetter()`
        // because the 'location' and 'top' property are non-configurable.
        const context$LWS = {
          [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
          [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
        };
        callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS);
      }, [])
    })) {
      // istanbul ignore next: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
      throw new LockerSecurityError$LWS(`Cannot evaluate ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, script$LWS, [])}`);
    }
  }
  function deleteOriginalScriptProperty$LWS(script$LWS) {
    originalScriptPropertyCache$LWS.delete(script$LWS);
  }
  function deleteScriptEvaluatorProperty$LWS(script$LWS) {
    ReflectDeleteProperty$LWS$1(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
  }
  function getOriginalScriptProperty$LWS(script$LWS) {
    return originalScriptPropertyCache$LWS.get(script$LWS);
  }
  function isScriptEvaluated$LWS(script$LWS) {
    return evaluatedScriptElements$LWS.has(script$LWS);
  }
  function isScriptPropertyEvaluatorHookDefined$LWS(script$LWS) {
    return originalScriptPropertyCache$LWS.has(script$LWS);
  }
  function isScriptURLEvaluatorHookDefined$LWS(script$LWS) {
    return resolvedURLRegistryCache$LWS.has(script$LWS);
  }
  function setOriginalScriptScriptProperty$LWS(script$LWS, scriptProperty$LWS) {
    return originalScriptPropertyCache$LWS.set(script$LWS, scriptProperty$LWS);
  }

  /* eslint-disable no-fallthrough */
  class Token$LWS {
    constructor(tt$LWS, index$LWS, value$LWS = '') {
      this.type = tt$LWS;
      this.value = value$LWS;
      this.index = index$LWS;
    }
  }
  class Tokenizer$LWS {
    constructor() {
      this.currIndex = 0;
      this.source = '';
    }
    getNextToken(currIndex$LWS, source$LWS) {
      this.currIndex = currIndex$LWS;
      this.source = source$LWS;
      // Skip whitespaces and move currIndex
      while (this.isWhitespace(this.currentCharCode())) {
        this.currIndex += 1;
      }
      const ch$LWS = this.currentCharCode();
      switch (ch$LWS) {
        // dot char
        case 46:
          {
            let maybeMemberProp$LWS = '';
            while (!this.isInvalidIdentifierCode(this.nextCharCode())) {
              maybeMemberProp$LWS += this.source[this.currIndex];
            }
            if (maybeMemberProp$LWS === 'location') {
              return new Token$LWS(2 /* TokenType.LOCATION */, this.currIndex);
            }
            return new Token$LWS(4 /* TokenType.MEMBER_PROPERTY */, this.currIndex, maybeMemberProp$LWS);
          }
        // equal char
        case 61:
          {
            const nextCharCode$LWS = this.lookAhead();
            if (this.isWhitespace(nextCharCode$LWS)) {
              return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
            }
            switch (nextCharCode$LWS) {
              // another equal char means equality check
              case 61:
                return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
              default:
                return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
            }
          }
        // asterix sign
        case 42:
        // plus sign
        case 43:
        // minus sign
        case 45:
        // division sign
        case 47:
          {
            // any of the previous chars repeated or followed by an equal is an assignment
            const nextCharCode$LWS = this.lookAhead();
            switch (nextCharCode$LWS) {
              case 42:
              case 43:
              case 45:
              case 61:
                return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
              // `window.location // 1` is not an assignment
              case 47:
                return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
              default:
                return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
            }
          }
        // question mark
        case 63:
          {
            // look for ??= operator
            if (this.nextCharCode() === 63 && this.nextCharCode() === 61) {
              return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
            }
            return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
          }
        // pipe
        case 124:
          {
            // look for ||= operator
            if (this.nextCharCode() === 124 && this.nextCharCode() === 61) {
              return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
            }
            return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
          }
      }
      return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
    }
    getPreviousToken(currIndex$LWS, source$LWS) {
      this.currIndex = currIndex$LWS;
      this.source = source$LWS;
      let buffer$LWS = '';
      while (this.currIndex >= 0) {
        const currCode$LWS = this.currentCharCode();
        if (this.isInvalidIdentifierCode(currCode$LWS)) {
          break;
        }
        buffer$LWS = this.source[this.currIndex] + buffer$LWS;
        this.currIndex -= 1;
      }
      if (buffer$LWS.length > 0) {
        if (buffer$LWS === 'top') {
          return new Token$LWS(6 /* TokenType.TOP */, this.currIndex);
        }
        return new Token$LWS(3 /* TokenType.MEMBER_OBJECT */, this.currIndex, buffer$LWS);
      }
      return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
    }
    currentCharCode() {
      return ReflectApply$LWS$1(StringProtoCharCodeAt$LWS, this.source, [this.currIndex]);
    }
    isInvalidIdentifierCode(charCode$LWS) {
      // #, $, _
      if (charCode$LWS === 35 || charCode$LWS === 36 || charCode$LWS === 95) {
        return false;
      }
      // all numbers
      if (charCode$LWS >= 48 && charCode$LWS <= 57) {
        return false;
      }
      // all uppercase
      if (charCode$LWS >= 65 && charCode$LWS <= 90) {
        return false;
      }
      // all lowercase
      if (charCode$LWS >= 97 && charCode$LWS <= 122) {
        return false;
      }
      return true;
    }
    isWhitespace(charCode$LWS) {
      switch (charCode$LWS) {
        // tab
        // istanbul ignore next: this may be dead code, as code that contains a real tab doesn't pass through this case.
        case 9:
        // new line
        case 10:
        // line tabulation
        case 11:
        // form feed
        case 12:
        // carriage return
        case 13:
        // space
        case 32:
          return true;
        default:
          return false;
      }
    }
    lookAhead() {
      return ReflectApply$LWS$1(StringProtoCharCodeAt$LWS, this.source, [this.currIndex + 1]);
    }
    nextCharCode() {
      return ReflectApply$LWS$1(StringProtoCharCodeAt$LWS, this.source, [++this.currIndex]);
    }
  }
  class Transpiler$LWS {
    // memberProperties must be a safe array.
    constructor(memberProperties$LWS) {
      this.memberProperties = memberProperties$LWS;
      const regexParts$LWS = this.memberProperties.map(prop$LWS => {
        const firstCharCode$LWS = ReflectApply$LWS$1(StringProtoCharCodeAt$LWS, prop$LWS, [0]);
        // REGEX:
        //   [\w] === [a-zA-Z0-9_]
        //   [\s] === Whitespace
        //      1. [\\w\\$\\#]+?\\[['"\`\\w\\s]+?\\]\\. Checks for code in the form of "foo[bar]."
        //      2. ([\\w\\$\\#]+?)\\(['"\`\\w\\s]{0,}\\)\\. Checks for code in the form of "foo(bar)."
        //      3. ([\\w\\$\\#]+?)\\. Check for code in the form of "foobar."
        //   {1,} Matches 1 or more of the top 1-3. All must end in a period.
        //   (?!['"\`]) Ensures that strings are not matched.
        //   Object keys can contain Symbols or other Special Characters. We only deal with [_, $, #].
        if (this.isAlphanumeric(firstCharCode$LWS)) {
          return `(?!['"\`])(([\\w\\$\\#]+?\\[['"\`\\w\\s]+?\\]\\.|([\\w\\$\\#]+?)\\(['"\`\\w\\s]{0,}\\)\\.|([\\w\\$\\#]+?)\\.){1,})${prop$LWS}(?!['"\`])\\b`;
        }
        return `(?!['"\`])(([\\w\\$\\#]+?\\[['"\`\\w\\s]+?\\]\\.|([\\w\\$\\#]+?)\\(['"\`\\w\\s]{0,}\\)\\.|([\\w\\$\\#]+?)\\.){1,})\\${prop$LWS}(?!['"\`])\\b`;
      });
      const regexString$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, regexParts$LWS, ['|']);
      this.memberExprPatt = new RegExpCtor$LWS$1(regexString$LWS, 'g');
      this.tokenizer = new Tokenizer$LWS();
    }
    compile(input$LWS) {
      let compiledOutput$LWS = '';
      let currentIndex$LWS = 0;
      this.memberExprPatt.lastIndex = 0;
      let match$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, this.memberExprPatt, [input$LWS]);
      while (match$LWS) {
        const stringSliceToMachedIndex$LWS = ReflectApply$LWS$1(StringProtoSubstring$LWS, input$LWS, [currentIndex$LWS, match$LWS.index]);
        compiledOutput$LWS += stringSliceToMachedIndex$LWS;
        const expr$LWS = match$LWS[0];
        currentIndex$LWS = match$LWS.index + expr$LWS.length;
        let object$LWS = '';
        let property$LWS = '';
        // Check if the match is the full object, else skip.
        if (this.beginsWithPeriod(input$LWS, match$LWS.index)) {
          compiledOutput$LWS += expr$LWS;
          match$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, this.memberExprPatt, [input$LWS]);
          continue;
        }
        // Loop through the properties and find out which Regex matched
        for (let i$LWS = 0, {
            length: length$LWS
          } = this.memberProperties; i$LWS < length$LWS; i$LWS++) {
          const memberExprObj$LWS = match$LWS[1 + i$LWS * 4];
          if (memberExprObj$LWS) {
            object$LWS = this.trimEndingChar(memberExprObj$LWS);
            property$LWS = this.memberProperties[i$LWS];
            break;
          }
        }
        const propertyIndex$LWS = match$LWS.index + object$LWS.length - 1;
        if (property$LWS === 'location' && this.tokenizer.getPreviousToken(propertyIndex$LWS, input$LWS).type === 6 /* TokenType.TOP */) {
          // rewind index from a.x.top.location to a.x.top
          const beginTopIndex$LWS = propertyIndex$LWS - 4; // `.top`;
          // determine if we're dealing with `top.location` or `x.top.location`;
          const parent$LWS = this.tokenizer.getPreviousToken(beginTopIndex$LWS, input$LWS);
          if (parent$LWS.type === 3 /* TokenType.MEMBER_OBJECT */) {
            const parentObj$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS$1, input$LWS, [match$LWS.index, match$LWS.index + parent$LWS.value.length]);
            compiledOutput$LWS += `${this.replaceMemberObject(parentObj$LWS, '$$locker$$.$$top$$', object$LWS)}.location`;
          } else {
            compiledOutput$LWS += '$$locker$$.$$top$$.location';
          }
        } else {
          const nextToken$LWS = this.tokenizer.getNextToken(currentIndex$LWS, input$LWS);
          switch (nextToken$LWS.type) {
            // istanbul ignore next: there are currently no occurences of new Token(TokenType.EOF, ...)
            case 1 /* TokenType.EOF */:
            case 4 /* TokenType.MEMBER_PROPERTY */:
            case 5 /* TokenType.ROW */:
              {
                compiledOutput$LWS += this.replaceMemberObject(object$LWS, property$LWS, expr$LWS);
                break;
              }
            case 2 /* TokenType.LOCATION */:
              {
                if (property$LWS === 'top') {
                  const parent$LWS = this.tokenizer.getPreviousToken(propertyIndex$LWS, input$LWS);
                  if (parent$LWS.type === 3 /* TokenType.MEMBER_OBJECT */) {
                    compiledOutput$LWS += `${this.replaceMemberObject(parent$LWS.value, '$$locker$$.$$top$$', expr$LWS)}`;
                  }
                  break;
                }
              }
            case 0 /* TokenType.ASSIGN */:
              {
                compiledOutput$LWS += `${this.replaceMemberObject(object$LWS, '$$locker$$', object$LWS)}.${property$LWS}`;
                break;
              }
          }
        }
        match$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, this.memberExprPatt, [input$LWS]);
      }
      if (currentIndex$LWS < input$LWS.length) {
        compiledOutput$LWS += ReflectApply$LWS$1(StringProtoSubstring$LWS, input$LWS, [currentIndex$LWS, input$LWS.length]);
      }
      return compiledOutput$LWS;
    }
    beginsWithPeriod(input$LWS, matchIndex$LWS) {
      return input$LWS[matchIndex$LWS - 1] === '.';
    }
    isAlphanumeric(code$LWS) {
      if (code$LWS > 47 && code$LWS < 58 || code$LWS > 64 && code$LWS < 91 || code$LWS > 96 && code$LWS < 123) {
        return true;
      }
      return false;
    }
    trimEndingChar(input$LWS) {
      return ReflectApply$LWS$1(StringProtoSlice$LWS$1, input$LWS, [0, -1]);
    }
    replaceMemberObject(object$LWS, replaceWith$LWS, expression$LWS) {
      return `(${object$LWS} === globalThis || ${object$LWS} === document ? ${replaceWith$LWS} : ${expression$LWS})`;
    }
  }
  const documentPattern$LWS = 'document';
  const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
  const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
  const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
  // While fully qualified member expression access can be unambiguously detected,
  // ie. window.location or window.top, bare-word references to location and top
  // cannot. This means that code containing the fully qualified member expressions
  // can have all occurrences replaced by transforms and given special names controlled
  // by LWS in Aura. This process will also result in the program knowing that it
  // applied a given transform, which it can then use to populate a context names
  // list to be used in the declaration assignment code injected into wrapped Aura
  // component code. Because the unqualified member expressions cannot be unambiguously
  // detected, there is no way for the program to know that, eg. location.search was
  // used in the Aura component code and subsequently transformed, which means it
  // cannot be relied upon to when populating a context names list to be used in
  // the declaration assignment code. As a result, location and top must be universally
  // and explicitly included in the context object, and universally and explicitly
  // included in the context names list.
  const UNIVERSAL_CONTEXT_NAMES$LWS = [UNCOMPILED_LOCATION_NAME$LWS, UNCOMPILED_TOP_NAME$LWS, 'location', 'top'];
  const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
  const locationReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
  const sandboxEvalContextNameRegExp$LWS = new RegExpCtor$LWS$1(`(?:^|\\W)${toRegExpEscapedString$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
  const webpackRequireNameRegExp$LWS = new RegExpCtor$LWS$1(toRegExpEscapedIdentifierName$LWS(WEBPACK_REQUIRE_NAME$LWS));
  const windowTopReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, 'top');
  const windowTopReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, 'top');
  function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
    // An assignment operator is defined by
    // https://tc39.es/ecma262/#prod-AssignmentOperator
    // as one of the following:
    //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
    return new RegExpCtor$LWS$1(`\\b(?:${objectPattern$LWS})\\.${key$LWS}\\b(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
  }
  function compileSourceText$LWS(sourceText$LWS) {
    // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
    // we sniff the source text to see if it is present, and in that case we
    // don't proceed with the string replacement.
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
      return sourceText$LWS;
    }
    let locationRegExp$LWS;
    let topRegExp$LWS;
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webpackRequireNameRegExp$LWS, [sourceText$LWS])) {
      locationRegExp$LWS = locationReferencesWithWebpackRegExp$LWS;
      topRegExp$LWS = windowTopReferencesWithWebpackRegExp$LWS;
    } else {
      locationRegExp$LWS = locationReferencesRegExp$LWS;
      topRegExp$LWS = windowTopReferencesRegExp$LWS;
    }
    // Input `sourceText` is non-compiled, so `window.location` returns `null`
    // inside the detached iframe sandbox. Our compiler solves this problem by
    // transforming the red `location` reference into a blue `location` reference.
    // The solution below emulates what our compiler does, but using a simple
    // string replacement.
    sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [locationRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS]);
    // In non-compiled source text `window.top` is null when evaluated in a
    // sandbox. We perform a naive transformation to replace references of
    // `window.top` to use our internal sandbox helpers.
    sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [topRegExp$LWS, () => UNCOMPILED_TOP_NAME$LWS]);
    return sourceText$LWS;
  }
  function generateContextAssignmentCodeFromContextNames$LWS(names$LWS) {
    return `const {${ReflectApply$LWS$1(ArrayProtoToString$LWS$1, names$LWS, [])}}=${SANDBOX_EVAL_CONTEXT_NAME$LWS}`;
  }
  function transformSourceText$LWS(sourceText$LWS) {
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
      return sourceText$LWS;
    }
    const code$LWS = compileSourceText$LWS(sourceText$LWS);
    const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(UNIVERSAL_CONTEXT_NAMES$LWS)};`;
    const pragmaIndex$LWS = indexOfPragma$LWS(code$LWS, 'use strict');
    if (pragmaIndex$LWS === -1) {
      return prefix$LWS + code$LWS;
    }
    // The "use strict" pragma, including quotes, is 12 characters long.
    let afterPragmaIndex$LWS = pragmaIndex$LWS + 12;
    // istanbul ignore else
    if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ';') {
      // Move index after the semicolon.
      afterPragmaIndex$LWS += 1;
    }
    return ReflectApply$LWS$1(StringProtoSlice$LWS$1, code$LWS, [0, afterPragmaIndex$LWS]) + prefix$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS$1, code$LWS, [afterPragmaIndex$LWS]);
  }
  const {
    key: StorageProtoKey$LWS,
    getItem: StorageProtoGetItem$LWS,
    removeItem: StorageProtoRemoveItem$LWS,
    setItem: StorageProtoSetItem$LWS
  } = Storage.prototype;
  ReflectGetOwnPropertyDescriptor$LWS(SVGScriptElement.prototype, 'href');

  // This has to be done 1-by-1 because putting a full file ignore in this file
  // will result in dist/index.mjs.js containing the directive and subsequently being
  // ignored.
  // istanbul ignore next
  const XhrCtor$LWS = XMLHttpRequest;
  const {
    prototype: XhrProto$LWS
  } = XhrCtor$LWS;
  const {
    abort: XhrProtoAbort$LWS,
    open: XhrProtoOpen$LWS,
    send: XhrProtoSend$LWS
  } = XhrProto$LWS;
  const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, 'responseText');
  const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, 'status');
  ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials');
  /*! version: 0.21.7 */

  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar'];
  const validMimeTypeRegExp$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;
  function isMIMETypeAllowed$LWS(mimeType$LWS) {
    // W-4896359 Avoid MIME types which try to escape using special characters:
    // Allow only alphanumeric, '-', '+', and '.' characters.
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, validMimeTypeRegExp$LWS, [mimeType$LWS])) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
        if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, mimeType$LWS, [ALLOWED_MIME_TYPES$LWS[i$LWS]])) {
          return true;
        }
      }
    }
    return false;
  }
  const DISALLOWED_ENDPOINTS_LIST$LWS = ['/aura', '/webruntime'];
  const TRUSTED_DOMAINS_REG_EXP$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/;
  const URL_SCHEMES_LIST$LWS = toSafeArray$LWS$1(['about:', 'http:', 'https:']);
  const newlinesAndTabsRegExp$LWS = /[\u2028\u2029\n\r\t]/g;
  const normalizerAnchor$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, rootDocument$LWS, ['a']);
  // @TODO: W-7302311 Make paths and domains configurable.
  function isValidURL$LWS(parsedURL$LWS) {
    const loweredPathname$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, parsedURL$LWS.pathname, []);
    for (let i$LWS = 0, {
        length: length$LWS
      } = DISALLOWED_ENDPOINTS_LIST$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (ReflectApply$LWS$1(StringProtoEndsWith$LWS, loweredPathname$LWS, [DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, loweredPathname$LWS, [`${DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]}/`])) {
        return false;
      }
    }
    return true;
  }
  function isValidURLScheme$LWS(url$LWS) {
    ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
    return URL_SCHEMES_LIST$LWS.includes(ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []));
  }
  function parseURL$LWS(url$LWS) {
    const normalizedURL$LWS = sanitizeURLForElement$LWS(url$LWS);
    return {
      normalizedURL: normalizedURL$LWS,
      pathname: WindowDecodeURIComponent$LWS(ReflectApply$LWS$1(HTMLAnchorElementProtoPathnameGetter$LWS, normalizerAnchor$LWS, []))
    };
  }
  function resolveURL$LWS(url$LWS) {
    ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
    return ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
  }
  function sanitizeURLForElement$LWS(url$LWS) {
    return resolveURL$LWS(sanitizeURLString$LWS(url$LWS));
  }
  function sanitizeURLString$LWS(urlString$LWS) {
    return urlString$LWS === '' ? urlString$LWS : ReflectApply$LWS$1(StringProtoReplace$LWS, urlString$LWS, [newlinesAndTabsRegExp$LWS, '']);
  }
  /*! version: 0.21.7 */

  const DEFAULT_URL_SCHEMES = ['http:', 'https:'];
  const EXTENDED_URL_SCHEMES = ['http:', 'https:', 'mailto:'];
  const TRUSTED_DOMAINS = TRUSTED_DOMAINS_REG_EXP$LWS;
  /**
   * Basic URL Scheme checking utility.
   * Checks for http: and https: url schemes.
   * @param {String} url
   * @return {Boolean}
   */
  function isValidURLScheme(url, schemes = DEFAULT_URL_SCHEMES) {
    const normalized = document.createElement('a');
    normalized.href = url;
    return schemes.includes(normalized.protocol);
  }

  /**
   * Sanitizes a URL string . Will prevent:
   * - usage of UTF-8 control characters. Update BLOCKED constant to support more
   * - usage of \n, \t in url strings
   * @param {String} urlString
   * @returns {String}
   */
  function sanitizeURLString(urlString) {
    const BLOCKED = /[\u2029\u2028\n\r\t]/g;

    // false, '', undefined, null
    if (!urlString) {
      return urlString;
    }
    if (typeof urlString !== 'string') {
      throw new TypeError('URL argument is not a string');
    }
    return urlString.replace(BLOCKED, '');
  }

  /**
   * Sanitizes for a DOM element. Typical use would be when wanting to sanitize for
   * an href or src attribute of an element or window.open
   * @param {*} url
   */
  function sanitizeURLForElement(url) {
    const normalized = document.createElement('a');
    normalized.href = url;
    return sanitizeURLString(normalized.href);
  }

  /**
   * Sanitizes request URL!
   * @param {*} url
   */
  function sanitizeURLForRequests(url) {
    const normalizer = document.createElement('a');
    normalizer.setAttribute('href', url);

    // Order of operations are important!
    let pathname = normalizer.pathname;
    pathname = decodeURIComponent(pathname);
    pathname = pathname.toLowerCase();
    if (!isValidURL$LWS({
      pathname
    })) {
      throw new error(`Request URL cannot be made to Aura framework internal API endpoints ${url}!`);
    }
    return normalizer.getAttribute('href');
  }
  function isValidAttributeName(raw, name, prototype, caseInsensitiveAttributes) {
    if (typeof name !== 'string') {
      return false;
    }
    const lcName = name.toLowerCase();
    const tagName = raw.tagName && raw.tagName.toUpperCase();

    // Reason: [W-4210397] Locker does not allow setting custom HTTP headers.
    if (tagName === 'META' && lcName === 'http-equiv') {
      return false;
    }

    // Always allow names with the form a-b.* (e.g. data-foo, x-foo, ng-repeat, etc)
    if (name.indexOf('-') >= 0) {
      return true;
    }
    if (name in caseInsensitiveAttributes) {
      return true;
    }
    if (raw instanceof SVGElement) {
      return true;
    }
    if (name in prototype) {
      return true;
    }

    // Special case Label element's 'for' attribute. It called 'htmlFor' on prototype but
    // needs to be addressable as 'for' via accessors like .attributes/getAttribute()/setAtribute()
    if (tagName === 'LABEL' && lcName === 'for') {
      return true;
    }

    // Special case Meta element's custom 'property' attribute. It used by the Open Graph protocol.
    if (tagName === 'META' && lcName === 'property') {
      return true;
    }
    return false;
  }

  // SVG TAGS
  // taken from DOMPurifier source code
  var svgTags = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];

  // HTML TAGS SECTION
  // must be kept in sync with https://git.soma.salesforce.com/aura/aura/blob/master/aura-resources/src/main/resources/javascript/aura/component/HtmlComponent.js
  var htmlTags = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];

  // ATTRIBUTES
  var attrs = ['aria-activedescendant', 'aria-atomic', 'aria-autocomplete', 'aria-busy', 'aria-checked', 'aria-controls', 'aria-describedby', 'aria-disabled', 'aria-readonly', 'aria-dropeffect', 'aria-expanded', 'aria-flowto', 'aria-grabbed', 'aria-haspopup', 'aria-hidden', 'aria-disabled', 'aria-invalid', 'aria-label', 'aria-labelledby', 'aria-level', 'aria-live', 'aria-multiline', 'aria-multiselectable', 'aria-orientation', 'aria-owns', 'aria-posinset', 'aria-pressed', 'aria-readonly', 'aria-relevant', 'aria-required', 'aria-selected', 'aria-setsize', 'aria-sort', 'aria-valuemax', 'aria-valuemin', 'aria-valuenow', 'aria-valuetext', 'role', 'target'];

  // cache DOMPurify instances to avoid reparsing configs
  // improves performance of DOMPurify.sanitize for repeated usage with same config
  const instances = new WeakMap();

  /**
   * use global DOMPurify if provided as global
   *  defaults to package dependency otherwise
   */
  function getSanitizerForConfig(config) {
    let sanitizer = instances.get(config);
    if (sanitizer) {
      return sanitizer;
    }
    sanitizer = DOMPurify(window);
    sanitizer.setConfig(config);
    if (config.hooks) {
      Object.keys(config.hooks).forEach(key => {
        sanitizer.addHook(key, config.hooks[key]);
      });
    }
    instances.set(config, sanitizer);
    return sanitizer;
  }

  // floating element used for purification of strings in Locker
  // create a dummy floating element that stores text if document is not found
  const htmlTemplate = document.createElement('template');
  const normalizerAnchor = document.createElement('a');

  // DOMPurify preset configurations
  // configuration objects are also used as keys in the WeakMap to retrieve a DOMPurify instance

  // precompile a list of all allowed tags
  const allTags = ArrayMerge(svgTags, htmlTags);
  function uponSanitizeAttribute(node, data) {
    const nodeName = node.nodeName.toUpperCase();
    if (nodeName === 'USE' && ['href', 'xlink:href'].includes(data.attrName)) {
      // eslint-disable-next-line no-use-before-define
      data.attrValue = sanitizeHrefAttribute(data.attrValue);
    }
    return data;
  }

  // generic, sanitizer attempts in place sanitization and returns node
  const RETURN_NODE_ALL_IN_PLACE = {
    ADD_ATTR: attrs,
    ALLOWED_TAGS: allTags.concat('#document-fragment'),
    IN_PLACE: true,
    hooks: {
      uponSanitizeAttribute
    }
  };

  // use only svg tags, sanitizer returns a document fragment
  const RETURN_NODE_SVG = {
    ADD_ATTR: attrs,
    ALLOWED_TAGS: svgTags,
    SANITIZE_DOM: false,
    RETURN_DOM_FRAGMENT: true,
    hooks: {
      uponSanitizeAttribute
    }
  };

  // use only tags allowed for blob and file
  const RETURN_STRING_BLOB_HTML = {
    ADD_ATTR: attrs,
    ALLOWED_TAGS: allTags.filter(t => !['iframe'].includes(t)),
    SANITIZE_DOM: false,
    hooks: {
      uponSanitizeAttribute
    }
  };

  /**
   * Sanitize a string.
   * Uses internal Locker configuration.
   * Uses a template floating element to avoid https://github.com/cure53/DOMPurify/issues/190.
   * @param {String} input
   */
  function sanitizeDefault(input) {
    htmlTemplate.innerHTML = asString(input);
    const sanitizer = getSanitizerForConfig(RETURN_NODE_ALL_IN_PLACE);
    sanitizer.sanitize(htmlTemplate.content);
    return htmlTemplate.innerHTML;
  }
  const queue = new Set();
  const urlReplacer = /[^a-z0-9]+/gi;
  const urlSchemes = ['http:', 'https:'];

  // sanitize a str representing an href SVG attribute value
  function sanitizeHrefAttribute(str) {
    if (!str) {
      return str;
    }
    str = asString(str);
    if (str.startsWith('#')) {
      return str;
    }
    normalizerAnchor.href = str;
    if (!urlSchemes.includes(normalizerAnchor.protocol)) {
      return '';
    }
    const {
      0: requestedUrl,
      1: requestedFragment
    } = normalizerAnchor.href.split('#');
    const url = requestedUrl.toLowerCase().replace(urlReplacer, '');
    const internalId = requestedFragment ? `${url}_${requestedFragment.replace(urlReplacer, '')}` : '';
    let container = document.getElementById(url);
    if (!container) {
      container = document.createElement('div');
      container.setAttribute('style', 'display:none');
      container.setAttribute('id', url);
      document.body.appendChild(container);
      queue.add(url);
      const xhr = new XMLHttpRequest();
      xhr.onload = () => {
        if (xhr.status === 200) {
          // eslint-disable-next-line no-use-before-define
          const fragment = sanitizeSvgTextReturnDOM(xhr.responseText);
          if (requestedFragment) {
            const el = fragment.getElementById(requestedFragment);
            if (el) {
              el.setAttribute('id', internalId);
            }
          }
          container.appendChild(fragment);
          queue.delete(url);
        }
      };
      xhr.open('GET', requestedUrl);
      xhr.send();
    } else if (container && internalId) {
      const updater = () => {
        // if we use the same href multiple times we should check we parsed the ids
        let el = container.querySelector(`#${internalId}`);
        if (!el) {
          try {
            el = container.querySelector(`#${requestedFragment}`);
            el.setAttribute('id', internalId);
          } catch (e) {
            // catch all malformed CSS3 selectors
            // getElementById not available on Node
            // cannot use document.getElementById because there might be multiple containers having the same ids for svg elements
          }
        }
      };
      if (queue.has(url)) {
        // wait for request to finish, then update content
        const interval = setInterval(() => {
          if (!queue.has(url)) {
            updater();
            clearInterval(interval);
          }
        }, 50);
      } else {
        updater();
      }
    }
    return requestedFragment ? `#${internalId}` : `#${url}`;
  }
  function sanitizeSvgInnerHTML(el, input) {
    const closestSvg = el.closest('svg');
    const container = closestSvg ? closestSvg.cloneNode(false) : document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    container.appendChild(el.ownerDocument.createComment(''));
    const replacedOuterHTML = container.outerHTML.replace('<!---->', asString(input));
    // eslint-disable-next-line no-use-before-define
    const fragment = sanitizeSvgTextReturnDOM(replacedOuterHTML);
    return fragment.firstChild.innerHTML;
  }
  function sanitizeSvgTextReturnDOM(input) {
    const sanitizer = getSanitizerForConfig(RETURN_NODE_SVG);
    return sanitizer.sanitize(input);
  }

  /**
   * This module owns the Locker API Options
   */

  const LATEST_API_VERSION = 999;

  /**
   * Here we declare all the API options and their default values
   */
  const apiOptionsDefaults = {
    W6043924_rejectImportExpressions: true,
    W5885703_domClobberingNameId: true,
    W6081125_windowOpenNoopener: false,
    // W-6689206
    W6247122_execCommand_insertHTML: true,
    W7175026_auraGetCallbackLockerBypass: true
  };

  /**
   * Returns a frozen object with all of the API options with overrides (if any).
   * @param {Object} apiOptionsOverride
   */
  function getAPIOptions(apiOptionsOverride) {
    const apiOptions = assign(create$1(null), apiOptionsDefaults, apiOptionsOverride);
    return freeze(apiOptions);
  }

  /**
   * Returns the major version number of apiVersion value as a positive integer.
   * Returns LATEST_API_VERSION for 'latest', '', undefined or null.
   * Supports version numbers like '1.1', '1.1.1', '1.1a' and returns 1 in those cases.
   * Throws an exception for values that can't be parsed to a major version number,
   * like 'x' or {} or negative numbers.
   * @param {Number|String} apiVersion
   */
  function getMajorVersionNumber(apiVersion) {
    if (apiVersion === 'latest' || apiVersion === '' || apiVersion === undefined || apiVersion === null) {
      return LATEST_API_VERSION;
    }
    const majorVerNum = parseInt(apiVersion, 10);
    if (Number.isNaN(majorVerNum) || majorVerNum < 0) {
      throw error(`Invalid API version number: ${apiVersion}`);
    }
    return majorVerNum;
  }

  /**
   * Returns an object with override options given an API version.
   * References:
   *  Currently available API Versions: https://sfdc.co/kyg0p
   *  Upcoming releases API Versions: https://sfdc.co/uVVqi
   * @param {Number|String} apiVersion
   */
  function getAPIOptionsOverride(apiVersion) {
    const apiVersionMajor = getMajorVersionNumber(apiVersion);
    const apiOptions = {
      W6043924_rejectImportExpressions: false,
      W5885703_domClobberingNameId: false,
      W6081125_windowOpenNoopener: false,
      W6247122_execCommand_insertHTML: false,
      W7175026_auraGetCallbackLockerBypass: false
    };
    if (apiVersionMajor >= 47) {
      assign(apiOptions, {
        W6043924_rejectImportExpressions: true,
        W5885703_domClobberingNameId: true,
        W6081125_windowOpenNoopener: false // W-6689206
      });
    }

    if (apiVersionMajor >= 48) {
      apiOptions.W6247122_execCommand_insertHTML = true;
    }
    if (apiVersionMajor >= 49) {
      apiOptions.W7175026_auraGetCallbackLockerBypass = true;
    }
    return freeze(apiOptions);
  }

  /*!
   * Copyright (C) 2021 salesforce.com, inc.
   */
  const OBSERVABILITY_NAMESPACE$LWS = 'LIGHTNING.locker.service';
  let o11yGetInstrumentation$LWS;
  function injectO11yDependency$LWS(getInstrumentationFromO11y$LWS) {
    o11yGetInstrumentation$LWS = getInstrumentationFromO11y$LWS;
  }
  function getInstrumentation$LWS(name$LWS = OBSERVABILITY_NAMESPACE$LWS) {
    return o11yGetInstrumentation$LWS == null ? void 0 : o11yGetInstrumentation$LWS(name$LWS);
  }
  /*! version: 0.21.7 */

  function isKey(key) {
    // Key is detected by duck typing.
    return typeof key === 'object' && typeof key.namespace === 'string';
  }

  // Keyed objects can only have one owner. We prevent "null" and "undefined"
  // keys by guarding all set operations.
  const keychain = new WeakMap();
  // Map to store <key> to <Weakmap of <raw> to <Secure> pairs>, this is the primary cache
  const rawToSecurePrimaryCacheByKey = new Map();
  // Map to store <key> to <Map of <raw> to <Secure> pairs>, will be used for raw objects that cannot be stored in a WeakMap, this is the secondary cache
  const rawToSecureSecondaryCacheByKey = new Map();
  const secureToRaw = new WeakMap();
  const objectToKeyedData = new WeakMap();
  const opaqueSecure = new WeakSet();
  const secureProxy = new WeakSet();
  const filteringProxy = new WeakSet();
  const secureFunction = new WeakSet();
  function getKey(thing) {
    return keychain.get(thing);
  }
  function isOpaque(st) {
    return opaqueSecure.has(st);
  }
  function setKey(thing, key) {
    if (!thing) {
      return;
    }
    if (!key) {
      throw new Error('Setting an empty key is prohibited.');
    }
    const hasKey = keychain.get(thing);
    if (hasKey === undefined) {
      keychain.set(thing, key);
    } else if (hasKey === key) ;else {
      // Prevent keyed objects from being keyed again.
      throw new Error('Re-setting of key is prohibited.');
    }
  }
  function trust$1(from, thing) {
    if (from) {
      const key = keychain.get(from);
      if (key) {
        setKey(thing, key);
      }
    }
  }
  function hasAccess(from, to) {
    return keychain.get(from) === keychain.get(to);
  }
  function verifyAccess(from, to, skipOpaque) {
    const fromKey = keychain.get(from);
    const toKey = keychain.get(to);
    if (fromKey !== toKey || skipOpaque && isOpaque(to)) {
      throw new Error(`Access denied: ${JSON.stringify({
        from: fromKey,
        to: toKey
      })}`);
    }
  }
  function hasRef(st) {
    return secureToRaw.has(st);
  }
  function getRef(st, key, skipOpaque) {
    const toKey = keychain.get(st);
    if (toKey !== key || skipOpaque && opaqueSecure.has(st)) {
      throw new Error(`Access denied: ${JSON.stringify({
        from: key,
        to: toKey
      })}`);
    }
    return secureToRaw.get(st);
  }
  function setRef(st, raw, key, isOpaque) {
    if (!st) {
      throw new Error('Setting an empty reference is prohibited.');
    }
    if (!key) {
      throw new Error('Setting an empty key is prohibited.');
    }
    setKey(st, key);
    secureToRaw.set(st, raw);
    if (isOpaque) {
      opaqueSecure.add(st);
    }
  }
  function getData(object, key) {
    const keyedData = objectToKeyedData.get(object);
    return keyedData ? keyedData.get(key) : undefined;
  }
  function setData(object, key, data) {
    let keyedData = objectToKeyedData.get(object);
    if (!keyedData) {
      keyedData = new WeakMap();
      objectToKeyedData.set(object, keyedData);
    }
    keyedData.set(key, data);
  }
  function registerProxy(st) {
    secureProxy.add(st);
  }
  function isProxy(st) {
    return secureProxy.has(st);
  }
  function registerFilteringProxy(st) {
    filteringProxy.add(st);
  }
  function isFilteringProxy(st) {
    return filteringProxy.has(st);
  }
  function registerSecureFunction(st) {
    secureFunction.add(st);
  }
  function isSecureFunction(st) {
    return secureFunction.has(st);
  }
  function unwrap$1(from, st) {
    if (!st) {
      return st;
    }
    const key = keychain.get(from);
    let ref;
    if (isArray(st)) {
      // Only getRef on "secure" arrays
      if (secureToRaw.get(st)) {
        // Secure array - reconcile modifications to the filtered clone with the actual array
        ref = getRef(st, key);
        const originalLength = ref.length;
        let insertIndex = 0;
        for (let n = 0; n < st.length; n++) {
          // Find the next available location that corresponds to the filtered projection of the array
          while (insertIndex < originalLength && getKey(ref[insertIndex]) !== key) {
            insertIndex++;
          }
          ref[insertIndex++] = unwrap$1(from, st[n]);
        }
      } else {
        ref = [];
      }
    } else {
      ref = getRef(st, key);
    }
    return ref;
  }
  function addToCache(raw, st, key) {
    if (!raw) {
      throw new Error('Caching an empty reference is prohibited.');
    }
    if (!key) {
      throw new Error('Caching with an empty key is prohibited.');
    }
    let rawToSecurePrimary = rawToSecurePrimaryCacheByKey.get(key);
    let rawToSecureSecondary;
    if (!rawToSecurePrimary) {
      rawToSecurePrimary = new WeakMap();
      rawToSecurePrimaryCacheByKey.set(key, rawToSecurePrimary);
    }
    try {
      rawToSecurePrimary.set(raw, st);
    } catch (e) {
      /**
       * If caching raw object fails in a weakmap,
       * then create a secondary cache implemented using a Map(which is more fault tolerant).
       */
      rawToSecureSecondary = rawToSecureSecondaryCacheByKey.get(key);
      if (!rawToSecureSecondary) {
        // Created on demand
        rawToSecureSecondary = new Map();
        rawToSecureSecondaryCacheByKey.set(key, rawToSecureSecondary);
      }
      rawToSecureSecondary.set(raw, st);
    }
  }
  function getFromCache(raw, key) {
    const rawToSecurePrimaryCache = rawToSecurePrimaryCacheByKey.get(key);
    if (rawToSecurePrimaryCache) {
      let secureThing = rawToSecurePrimaryCache.get(raw);
      // If raw object was cached in primary WeakMap and we have used the secondary cache, look there
      if (!secureThing && rawToSecureSecondaryCacheByKey.size > 0) {
        const rawToSecureSecondary = rawToSecureSecondaryCacheByKey.get(key);
        secureThing = rawToSecureSecondary && rawToSecureSecondary.get(raw);
      }
      return secureThing;
    }
    return undefined;
  }
  function getRawThis(so) {
    const raw = getRef(so, getKey(so));
    if (!raw) {
      throw new Error('Blocked attempt to invoke secure method with altered this!');
    }
    return raw;
  }
  function getRaw$1(value) {
    if (isProxy(value)) {
      const key = getKey(value);
      const ref = getRef(value, key);
      value = ref;
    }
    return value;
  }
  function getRawArray(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      result.push(getRaw$1(arr[i]));
    }
    return result;
  }
  const defaultKey = {
    namespace: 'default'
  };
  const realmRec = {};
  let isInitialized = false;
  function init(options) {
    if (isInitialized) {
      return;
    }

    // Browser support is the default for all compartments.
    realmRec.isBrowser = options.isBrowser !== false;
    realmRec.shouldFreeze = options.shouldFreeze;

    /**
     * The unsafe* variables hold precious values that must not escape
     * to untrusted code. When eval is invoked via unsafeEval, this is
     * a call to the indirect eval function, not the direct eval operator.
     */
    realmRec.unsafeGlobal = options.unsafeGlobal;
    realmRec.unsafeEval = options.unsafeGlobal.eval;
    realmRec.unsafeFunction = options.unsafeGlobal.Function;
    realmRec.apiOptions = getAPIOptions(options.apiOptions);
    if (realmRec.shouldFreeze) {
      realmRec.notFrozenIntrinsicNames = options.notFrozenIntrinsicNames;
      const intrinsics = getIntrinsics(realmRec);
      const eagerFreezeIntrinsics = assign({}, intrinsics);
      if (isArray(realmRec.notFrozenIntrinsicNames)) {
        realmRec.notFrozenIntrinsicNames.forEach(name => delete eagerFreezeIntrinsics[name]);
      }
      realmRec.intrinsics = intrinsics;
      realmRec.eagerFreezeIntrinsics = eagerFreezeIntrinsics;
    }

    // None of these values can change after initialization.
    freeze(realmRec);
    installPolyfills(realmRec);
    repairAccessors(realmRec);
    repairFunctions(realmRec);
    if (realmRec.shouldFreeze) {
      repairDataProperties(realmRec);
      freezeIntrinsics(realmRec);
    }
    isInitialized = true;
  }
  function getEnv$1(key) {
    const sandbox = getSandbox(key, realmRec);
    return sandbox.globalObject;
  }

  /**
   * Evaluates a string using secure eval rather than eval.
   * Sanitizes the input string and attaches a sourceURL so the
   * result can be easily found in browser debugging tools.
   */
  function evaluate(src, key, sourceURL) {
    const sandbox = getSandbox(key, realmRec);

    // Sanitize the URL
    if (sourceURL) {
      sourceURL = sanitizeURLForElement(sourceURL);
      src += `\n//# sourceURL=${sourceURL}`;
    }
    const instrumentation = getInstrumentation$LWS();
    try {
      const evalResult = sandbox.evalEvaluator(src);
      instrumentation == null || instrumentation.incrementCounter == null || instrumentation.incrementCounter('legacy.evaluate', 1, false);
      return evalResult;
    } catch (e) {
      instrumentation == null || instrumentation.incrementCounter == null || instrumentation.incrementCounter('legacy.evaluate', 1, true);
      throw new error(e.message || 'Evaluation error', e, severity.QUIET);
    }
  }
  let customElementHook$1;
  function registerCustomElementHook(hook) {
    customElementHook$1 = hook;
  }
  let windowAddPropertiesHook;
  function registerWindowAddPropertiesHook(hook) {
    windowAddPropertiesHook = hook;
  }
  let navigatorAddPropertiesHook$1;
  function registerNavigatorAddPropertiesHook(hook) {
    navigatorAddPropertiesHook$1 = hook;
  }

  /**
   * Returns a merged and frozen options object.
   */
  function createOptions(...options) {
    const opts = {};
    fastArrayForEach(options, item => assign(opts, item));
    return freeze(opts);
  }
  const DEFAULT = createOptions({});
  const FUNCTION = createOptions({
    type: 'function'
  });
  const EVENT = createOptions({
    type: '@event'
  });
  const CTOR = createOptions({
    type: '@ctor'
  });
  const RAW = createOptions({
    type: '@raw'
  });
  const SKIP_OPAQUE = createOptions({
    skipOpaque: true
  });
  const FORCE_OPAQUE = createOptions({
    forceOpaque: true
  });
  const ASCENDING = createOptions({
    traverse: 'parentNode',
    traverseAlt: 'host'
  });
  const SKIP_OPAQUE_ASCENDING = createOptions(SKIP_OPAQUE, ASCENDING);
  const TRUST_RETURN_VALUE = createOptions({
    trustReturnValue: true
  });
  const IGNORE_NON_EXISTING = createOptions({
    ignoreNonExisting: true
  });

  // @ToDo: #761 Convert `writable` to `readOnly`
  const READ_ONLY_PROPERTY = createOptions({
    writable: false
  });
  const READ_ONLY_PROPERTY_FORCE_OPAQUE = createOptions(READ_ONLY_PROPERTY, FORCE_OPAQUE);
  const RAW_ARGS = createOptions({
    rawArguments: true
  });
  const RAW_ARGS_DEEP = createOptions({
    rawArgumentsDeep: true
  });
  const FUNCTION_RAW_ARGS = createOptions(FUNCTION, RAW_ARGS);
  const FUNCTION_RAW_ARGS_DEEP = createOptions(FUNCTION, RAW_ARGS_DEEP);
  const FUNCTION_TRUST_RETURN_VALUE = createOptions(FUNCTION, TRUST_RETURN_VALUE);
  var assert = {
    block: fn => fn(),
    isTrue: (condition, message) => {
      if (!condition) {
        throw new TypeError(`Assertion failed: ${message}`);
      }
    },
    isFalse: (condition, message) => {
      if (condition) {
        throw new TypeError(`Assertion failed: ${message}`);
      }
    },
    invariant: (condition, message) => {
      if (!condition) {
        throw new TypeError(`Invariant violation: ${message}`);
      }
    },
    fail: message => {
      throw new TypeError(message);
    }
  };

  /* eslint-enable import/no-cycle */

  /**
   * Unwrap a value to allow raw access in system mode
   * This method returns:
   *  a. an unfiltering proxy if the indexed value is a plain object or array
   *  b. an unwrapped value if the value represents a secure wrapped object
   *  c. a SecureFunction is the value represents a function
   *  d. Everything else will be filtered
   */
  function unwrapValue(st, originalValue) {
    if (!originalValue) {
      return originalValue;
    }
    // Call lwcUnwrap() to access the underlying raw value
    const value = lwcUnwrap(originalValue);
    let unfilteredValue;
    if (isArray(value) || isPlainObject(value)) {
      // If an object or array is nested inside a data proxy, they will need to be rewrapped
      // FilteringProxy and ArrayProxy is covered by this check
      unfilteredValue = getUnfilteringDataProxy(getKey(st), originalValue);
    } else if (typeof value === 'function') {
      // Functions from sandbox cannot be handed over to system, they will be converted to a SecureFunction
      const secureFunction = filterEverything(st, value);
      // If function does not need to be converted, return the function as is. Eg: Object, Array
      if (secureFunction === value) {
        return value;
      }
      // Return a wrapper function to system mode.
      unfilteredValue = function (...args) {
        // When system mode invokes the wrapper function, locker will invoke the secure function
        // This ensures arguments from system mode are filtered, return value is unwrapped and
        // sent back to system mode
        return unwrapValue(st, secureFunction.call(st, ...args));
      };
    } else if (isProxy(value)) {
      // If value is a wrapped object, use st's key to unwrap the value.
      unfilteredValue = unwrap$1(st, value);
    } else {
      // Protect anything else that we don't know about.
      // Call lwcUnwrap to catch things like SecureWindow that can be wrapped in a data proxy
      unfilteredValue = filterEverything(st, lwcUnwrap(value));
    }
    return unfilteredValue;
  }

  /**
   * An unwrapDescriptor will be give to system mode
   * Any access of value will need to be unwrapped
   * Any mutation of value will need to be filtered
   * @param {*} st secure thing that owns the descriptor
   * @param {*} descriptor
   */
  function getUnwrapDescriptor(st, descriptor) {
    if (!descriptor) {
      return descriptor;
    }
    // If data descriptor
    if ('value' in descriptor) {
      const {
        value
      } = descriptor;
      if (typeof value === 'function') {
        descriptor.value = function (...args) {
          return unwrapValue(st, value.call(st, filterArguments(st, args)));
        };
      } else {
        descriptor.value = unwrapValue(st, value);
      }
    } else {
      const {
        get,
        set
      } = descriptor;
      // accessor descriptor
      if (get) {
        descriptor.get = function () {
          return unwrapValue(st, get.call(st));
        };
      }
      if (set) {
        descriptor.set = function (newValue) {
          return set.call(st, filterEverything(st, newValue));
        };
      }
    }
    return descriptor;
  }

  /* eslint-enable import/no-cycle */

  /**
   * Class to handle the unfiltering of any read/write operations on an array
   * Behavior:
   *  1. Reading values by index will provide:
   *    a. an unfiltering proxy if the indexed value is a plain object or array
   *    b. an unwrapped value if the value represents a secure wrapped object
   *    c. a SecureFunction is the value represents a function
   *    d. Everything else will be filtered
   *  2. Settings value by index will filter the provided value with the real target's key
   *    and set the filtered value on the real target
   *  3. Accessing descriptor will result in a unwrapping descriptor
   *  4. Setting a prototype of the value is not allowed
   *
   * Caveat: A shadow target is required to adhere to proxy invariants. The shadow target prevents
   * from leaking prototype information of the real target. One common scenario is when a target has
   * a non-configurable property descriptor, the getOwnPropertyDescriptor() has the return the original
   * descriptor of the target. In such a case, not using a shadowTarget will result is leaking the
   * descriptor locker wants to protect.
   */
  /* eslint-disable  class-methods-use-this */
  class UnfilteringProxyHandlerForArray {
    constructor(target) {
      this.target = target;
    }
    get(shadowTarget, property) {
      property = asPropertyName(property);
      const {
        target
      } = this;
      const value = target[property];
      if (typeof property === 'number') {
        return unwrapValue(target, value);
      }
      return value;
    }
    set(shadowTarget, property, value) {
      const {
        target
      } = this;
      target[property] = filterEverything(target, value);
      return true;
    }
    deleteProperty(shadowTarget, property) {
      deleteProperty(this.target, property);
      return true;
    }
    has(shadowTarget, property) {
      return property in this.target;
    }
    ownKeys() {
      return ownKeys(this.target);
    }
    isExtensible() {
      return isExtensible(this.target);
    }
    setPrototypeOf() {
      throw new error('System mode should not attempt to change prototype of data proxy');
    }
    getPrototypeOf() {
      return getPrototypeOf(this.target);
    }
    getOwnPropertyDescriptor(shadowTarget, property) {
      // If it is a non-configurable descriptor and its already defined on the shadowTarget
      const shadowTargetDescriptor = getOwnPropertyDescriptor(shadowTarget, property);
      if (shadowTargetDescriptor && !shadowTargetDescriptor.configurable) {
        return shadowTargetDescriptor;
      }
      const {
        target
      } = this;
      const originalDescriptor = getOwnPropertyDescriptor(target, property);
      if (!originalDescriptor) {
        return originalDescriptor;
      }
      if (property === 'length') {
        return originalDescriptor;
      }
      // Wrap the descriptor
      const unwrapDescriptor = getUnwrapDescriptor(target, originalDescriptor);
      // To adhere to proxy invariants, if the original descriptor is non-configurable,
      // define a non-configurable unwrap descriptor on the shadow target
      if (!originalDescriptor.configurable) {
        defineProperty(shadowTarget, property, unwrapDescriptor);
      }
      return unwrapDescriptor;
    }
    preventExtensions() {
      return preventExtensions(this.target);
    }
    defineProperty(shadowTarget, key, descriptor) {
      return defineProperty(this.target, key, descriptor);
    }
  }
  /* eslint-enable  class-methods-use-this */

  /* eslint-enable import/no-cycle */

  /**
   * Class to handle the unfiltering of any read/write operations on a plain old javascript object(pojo)
   * Behavior:
   *  1. Accessing object property value will provide:
   *    a. an unfiltering proxy if the value is a plain object or array
   *    b. an unwrapped value if the value represents a secure wrapped object
   *    c. a SecureFunction is the value represents a function
   *    d. Everything else will be filtered
   *  2. Settings value for a property will
   *    a. filter the provided value with the real target's key
   *    b. set the filtered value on the real target
   *  3. Accessing descriptor will result in a unwrapping descriptor
   *  4. Setting a prototype of the value is not allowed
   *
   * Caveat: A shadow target is required to adhere to proxy invariants. The shadow target prevents
   * from leaking prototype information of the real target. One common scenario is when a target has
   * a non-configurable property descriptor, the getOwnPropertyDescriptor() has the return the original
   * descriptor of the target. In such a case, not using a shadowTarget will result is leaking the
   * descriptor locker wants to protect.
   */
  /* eslint-disable  class-methods-use-this */
  class UnfilteringProxyHandlerForObject {
    constructor(target) {
      this.target = target;
    }
    get(shadowTarget, property) {
      const target = this.target;
      const value = target[property];
      return unwrapValue(target, value);
    }
    set(shadowTarget, property, value) {
      const target = this.target;
      target[property] = filterEverything(target, value);
      return true;
    }
    deleteProperty(shadowTarget, property) {
      deleteProperty(this.target, property);
      return true;
    }
    has(shadowTarget, property) {
      return property in this.target;
    }
    ownKeys() {
      return ownKeys(this.target);
    }
    isExtensible() {
      return isExtensible(this.target);
    }
    setPrototypeOf() {
      throw new error('System mode should not attempt to change prototype of data proxy');
    }
    getPrototypeOf() {
      return getPrototypeOf(this.target);
    }
    getOwnPropertyDescriptor(shadowTarget, property) {
      // If it is a non-configurable descriptor and its already defined on the shadowTarget
      const shadowTargetDescriptor = getOwnPropertyDescriptor(shadowTarget, property);
      if (shadowTargetDescriptor && !shadowTargetDescriptor.configurable) {
        return shadowTargetDescriptor;
      }
      const target = this.target;
      const originalDescriptor = getOwnPropertyDescriptor(target, property);
      if (!originalDescriptor) {
        return originalDescriptor;
      }
      // Wrap the descriptor
      const unwrapDescriptor = getUnwrapDescriptor(target, originalDescriptor);
      // To adhere to proxy invariants
      if (!originalDescriptor.configurable) {
        defineProperty(shadowTarget, property, unwrapDescriptor);
      }
      return unwrapDescriptor;
    }
    preventExtensions() {
      return preventExtensions(this.target);
    }
    defineProperty(shadowTarget, key, descriptor) {
      return defineProperty(this.target, key, descriptor);
    }
  }
  /* eslint-enable  class-methods-use-this */

  /* eslint-enable import/no-cycle */

  const cachedUnfilteringProxy = new WeakMap();
  const proxyToValueMap = new WeakMap();
  function registerUnfilteringDataProxy(proxy, value) {
    proxyToValueMap.set(proxy, value);
  }
  function isUnfilteringDataProxy(proxy) {
    return proxyToValueMap.has(proxy);
  }
  function getDataProxy(proxy) {
    return proxyToValueMap.get(proxy);
  }

  /**
   * Provide a unfiltering proxy for a value that can be used in system mode
   * The value originates from a sandbox owned by the secure thing
   * @param {*} fromKey locker key of the secure thing that wants to send value to system mode
   * @param {*} value value being unwrapped
   */
  function getUnfilteringDataProxy(fromKey, value) {
    if (!value) {
      return value;
    }
    assert.invariant(fromKey, 'Trying to unfilter a value without a key');

    // Handle only plain objects or arrays that were created by the secure thing
    if (!isArray(value) && !isPlainObject(value)) {
      // Throw in non-production mode
      assert.fail('Attempting to unfilter a value that is neither an array nor a plain object');
      // Do nothing in production mode
      return value;
    }
    let unfilteringProxy = cachedUnfilteringProxy.get(value);
    if (unfilteringProxy) {
      return unfilteringProxy;
    }
    if (!getKey(value)) {
      // If value has not already been keyed, propagate the key to the value
      setKey(value, fromKey);
    }

    // Use a shadow target to avoid breaking proxy invariants
    const shadowTarget = isArray(value) ? [] : {};
    unfilteringProxy = new Proxy(shadowTarget, isArray(value) ? new UnfilteringProxyHandlerForArray(value) : new UnfilteringProxyHandlerForObject(value));
    // Key the unfilteringProxy to the secure thing's namespace
    setKey(unfilteringProxy, fromKey);
    cachedUnfilteringProxy.set(value, unfilteringProxy);
    registerUnfilteringDataProxy(unfilteringProxy, value);
    return unfilteringProxy;
  }

  /* eslint-enable import/no-cycle */

  function isCustomElement(tagName) {
    return tagName.indexOf('-') > 0;
  }
  let lwcUnwrap = value => value;
  let lwcGetComponentDef = () => undefined;
  let lwcGetComponentConstructor = () => undefined;
  let lwcIsNodeFromTemplate = () => false;
  function registerLWCAPI(api) {
    if (api) {
      if (api.lwcUnwrap) {
        lwcUnwrap = api.lwcUnwrap;
      }
      if (api.lwcGetComponentDef) {
        lwcGetComponentDef = api.lwcGetComponentDef;
      }
      if (api.lwcGetComponentConstructor) {
        lwcGetComponentConstructor = api.lwcGetComponentConstructor;
      }
      if (api.lwcIsNodeFromTemplate) {
        lwcIsNodeFromTemplate = api.lwcIsNodeFromTemplate;
      }
    }
  }

  /**
   * Add additional properties for custom elements
   * @param {*} el DOM element
   * @param {*} prototype Represents the psuedo protototype that will be used to create wrapped element
   * @param {*} tagNameSpecificConfig Temporary holder of tag specific config
   */
  function customElementHook(el, prototype, tagNameSpecificConfig) {
    assert.invariant(isCustomElement(asString(el.tagName)), 'Cannot call custom element hook on a non custom element');
    const methodOptions = {
      unfilterEverything: function (args) {
        const st = this;
        return deepUnfilterMethodArguments(st, [], args);
      }
    };
    const elComponentConstructor = lwcGetComponentConstructor(el);
    if (elComponentConstructor) {
      const elComponentMethods = lwcGetComponentDef(elComponentConstructor).methods;
      if (elComponentMethods) {
        ObjectKeys(elComponentMethods).forEach(method => {
          tagNameSpecificConfig[method] = createFilteredMethodStateless(method, prototype, methodOptions);
        });
      }
      const elComponentProps = lwcGetComponentDef(elComponentConstructor).props;
      if (elComponentProps) {
        const elComponentPropsNames = ObjectKeys(elComponentProps);
        fastArrayForEach(elComponentPropsNames, prop => {
          // id and name properties are overridden in SecureElement for domClobbering
          if (prop !== 'id' && prop !== 'name') {
            tagNameSpecificConfig[prop] = {
              enumerable: true,
              get() {
                // When the secure parent is accessing a value on the child element
                const key = getKey(this);
                const raw = getRef(this, key);
                const value = raw[prop];
                return filter(key, value);
              },
              set(newValue) {
                // When the secure parent is setting a value on the child component
                const key = getKey(this);
                const raw = getRef(this, key);
                // Deep unfilter the value and let the setHook() filter the value at the destination
                raw[prop] = deepUnfilter(key, [], [newValue])[0];
              }
            };
          }
        });
      }
    }
  }

  /**
   * Was node created by lwc?
   * Will return true for all nodes in an LWC component's template and shadowRoot nodes of LWC components
   * @param {Node} node node to check
   */
  function isAnLWCNode(node) {
    assert.invariant(node, 'Checking an undefined value to be node');
    if (lwcIsNodeFromTemplate(node) || isShadowRoot(node) && lwcIsNodeFromTemplate(node.host)) {
      return true;
    }
    return false;
  }

  /**
   * Is an LWC Data proxy
   * The value could be a raw data proxy from the reactive membrane
   * or it could be an unfiltering proxy wrapping a raw data proxy
   * or it could be filtering proxy wrapping an unfiltering proxy
   * @param {*} value
   */
  function isDataProxy(value) {
    assert.invariant(value, 'Checking an undefined value to be data proxy');
    if (value !== lwcUnwrap(value)) {
      return true;
    }
    if (isUnfilteringDataProxy(getRaw$1(value))) {
      return true;
    }
    return false;
  }

  /**
   * Determine the host element for a given node and the path to the host
   * @param {Node} node The node being accessed
   */
  function getHost(node) {
    if (!node) {
      return node;
    }
    // Traverse up until we have reached the shadowRoot of the node
    // or document(this is the case when the given node is host element of an interop component)
    while (node && !isShadowRoot(node)) {
      node = node.parentNode;
    }
    return node ? node.host : node;
  }

  /**
   * Get the locker key for a given host element's component class
   * Note: Not using a weak map here to cache this information locally because that would be slower
   * asking LWC. LWC does a Symbol property lookup directly on the element.
   * lookup to get the information.
   * @param {HTMLElement} el
   */
  function getKeyFromComponentConstructor(el) {
    const elComponentConstructor = lwcGetComponentConstructor(el);
    return getKey(elComponentConstructor);
  }

  /**
   * Can the given node be accessed with this key
   * @param {Object} key locker key of the thing trying to access the node
   * @param {Node} node
   * @return Boolean
   */
  function isAccessibleLWCNode(key, node) {
    if (!key) {
      throw new TypeError(`Unexpected value receved for key: ${key}`);
    }
    // Check if the node was created by LWC, this is a fast symbol look up by LWC
    if (!isAnLWCNode(node)) {
      return false;
    }

    // Find the host in whose template the node was declared
    const host = getHost(node);
    if (!host) {
      return false;
    }
    const hostComponentKey = getKeyFromComponentConstructor(host);
    // If the host is an instance of a lockerized component class
    if (hostComponentKey) {
      // Check if accessor key is same as node's key
      return hostComponentKey === key;
    }
    return false;
  }
  const secureLightningElementRegistry = new WeakMap();
  let LightningElement = NaN;
  function registerLightningElement(clazz) {
    LightningElement = clazz;
  }
  function getLightningElement() {
    return LightningElement;
  }
  function registerSecureLightningElementForKey(key, SecureLightningElement) {
    secureLightningElementRegistry.set(key, SecureLightningElement);
  }
  function getSecureLightningElementForKey(key) {
    return secureLightningElementRegistry.get(key);
  }

  /**
   * Return a prototype which looks like an Object
   * Create prototype to allow basic object operations like hasOwnProperty etc
   */
  function getObjectLikeProto() {
    const props = getOwnPropertyDescriptors(Object.prototype);
    // Do not want to leak access to the raw Object constructor
    delete props.constructor;
    // To keep it configurable in any extensions of this prototype
    // Note: This does no affect the original Object.prototype
    props.toString.configurable = true;
    const emptyProto = create$1(null, props);
    return emptyProto;
  }
  function isSecureLightningElement(Ctor, key) {
    let current = Ctor;
    const SecureLightningElement = getSecureLightningElementForKey(key);
    const LightningElement = getLightningElement();
    do {
      if (SecureLightningElement === current || LightningElement === current) {
        return true;
      }
    } while (current = Object.getPrototypeOf(current));
    return false;
  }

  // 1 wrapped template per key, 1 per key to isolate the prototype
  const WRAPPED_TEMPLATE_BY_KEY = new Map();
  function getWrappedTemplatePrototype(template) {
    const wrappedTemplatePrototype = create$1(getObjectLikeProto(), {
      toString: {
        value: function () {
          const template = getRawThis(this);
          return `SecureTemplate: ${template}{ key: ${JSON.stringify(getKey(this))} }`;
        }
      },
      dispatchEvent: {
        value: function (event) {
          const template = getRawThis(this);
          const rawEvent = getRaw$1(event);
          return template.dispatchEvent(rawEvent);
        }
      },
      localName: {
        value: null
      },
      namespaceURI: {
        value: null
      },
      nodeValue: {
        value: null
      },
      nextElementSibling: {
        value: null
      },
      nextSibling: {
        value: null
      },
      parentNode: {
        value: null
      },
      parentElement: {
        value: null
      },
      prefix: {
        value: undefined
      },
      previousElementSibling: {
        value: null
      },
      previousSibling: {
        value: null
      },
      querySelector: {
        value: function (selector) {
          const template = getRawThis(this);
          const node = template.querySelector(selector);
          return filterEverything(this, node);
        }
      },
      querySelectorAll: {
        value: function (selector) {
          const template = getRawThis(this);
          const rawNodeList = template.querySelectorAll(selector);
          return filterEverything(this, rawNodeList);
        }
      }
    });
    defineProperties(wrappedTemplatePrototype, {
      addEventListener: createAddEventListenerDescriptorStateless(),
      // @TODO: RJ - This is a copy/paste of pieces of SecureEventTarget.addEventTargetMethodsStateless
      // It should be refactored into a reusable function. Separate PR for that to minimize change
      removeEventListener: {
        writable: true,
        value: function (type, listener, options) {
          const raw = getRawThis(this);
          const sCallback = getFromCache(listener, getKey(this));
          raw.removeEventListener(type, sCallback, options);
        }
      }
    });
    const config = {};
    const metadataPrototypes = metadataViewSecureTemplate['prototypes'];
    const supportedInterfaces = ObjectKeys(metadataPrototypes);
    fastArrayForEach(supportedInterfaces, name => {
      const metadataPrototype = metadataPrototypes[name];
      for (const property in metadataPrototype) {
        addPrototypeMethodsAndPropertiesStatelessHelper(property, metadataPrototype, undefined, wrappedTemplatePrototype, template, config);
      }
    });
    defineProperties(wrappedTemplatePrototype, config);
    freeze(wrappedTemplatePrototype);
    return wrappedTemplatePrototype;
  }
  function SecureTemplate(template, key) {
    assert.invariant(isObject(key), 'Cannot invoke SecureTemplate wrapper without a valid key');
    assert.invariant(isObject(template), 'Expected template to be an object');
    let o = getFromCache(template, key);
    if (o) {
      return o;
    }
    assert.invariant(WRAPPED_TEMPLATE_BY_KEY, 'Expected to receive a map for caching prototypes');
    let wrappedTemplatePrototype = WRAPPED_TEMPLATE_BY_KEY.get(key);
    if (!wrappedTemplatePrototype) {
      wrappedTemplatePrototype = getWrappedTemplatePrototype(template);
      WRAPPED_TEMPLATE_BY_KEY.set(key, wrappedTemplatePrototype);
    }
    o = create$1(wrappedTemplatePrototype);
    setRef(o, template, key);
    addToCache(template, o, key);
    registerProxy(o);
    return o;
  }

  /**
   * this should return a secure value
   * @param {*} cmp component instance who is accessing the value
   * @param {*} rawValue unwrapped value
   */
  function getFilteredValue(cmp, rawValue) {
    return filterEverything(cmp, rawValue);
  }

  /**
   * This method accept a value from a lockerized component and provides system mode with raw access.
   * All public properties and methods of an LWC custom element get processed by this method.
   * 1. If the value returned is a data proxy(@api, @track) that is its own,
   *    we create an unfiltering proxy and return that
   * 2. if the value returned is a data proxy that it received from another component,
   *    we return the unfiltering proxy underneath the wrapped value
   * 3. If the value returned is a plain object or array, return a deep copy with unwrapped values
   * 4. If the value is a distorted value from system mode, unwrap it
   * @param {*} cmp component
   * @param {*} filteredValue wrapped value
   */
  function getUnwrappedValue(cmp, filteredValue) {
    if (filteredValue) {
      // If the value being returned by the component is a data proxy
      // Early escape hatch for data proxy. Because the data proxy behaves like a plain object/array,
      // locker needs to act early and unwrap it in the right shape.
      // deepUnfilterMethodArguments() works fine for simple arrays/objects, but looses the data proxy behavior
      if (isDataProxy(filteredValue)) {
        // If the data proxy was received from a different locker
        if (isProxy(filteredValue)) {
          // Unwrap the filtering proxy
          return unwrap$1(cmp, filteredValue);
        }
        return getUnfilteringDataProxy(getKey(cmp), filteredValue);
      }
      if (isArray(filteredValue)) {
        // If the value is a plain array that belongs to this locker
        return deepUnfilterMethodArguments(cmp, [], filteredValue);
      }
      if (isPlainObject(filteredValue)) {
        // If the value is a plain object that belongs to this locker
        return deepUnfilterMethodArguments(cmp, {}, filteredValue);
      }
      if (getKey(filteredValue)) {
        return unwrap$1(cmp, filteredValue);
      }
    }
    return filteredValue;
  }
  const LightningElementPropDescriptorMap = {};
  function getRawPropertyDescriptor(LightningElementPrototype, propName) {
    let descriptor = LightningElementPropDescriptorMap[propName];
    if (descriptor) {
      return descriptor;
    }
    descriptor = LightningElementPropDescriptorMap[propName] = getOwnPropertyDescriptor(LightningElementPrototype, propName);
    return descriptor;
  }

  // Hooks to be used by LWC
  function generateInstanceHooks(st) {
    return {
      callHook: function (cmp, fn, args) {
        if (isArray(args)) {
          args = args.map(rawValue => getFilteredValue(st, rawValue));
        }
        const filteredResult = fn.apply(st, args);
        return getUnwrappedValue(st, filteredResult);
      },
      setHook: function (cmp, prop, rawValue) {
        st[prop] = getFilteredValue(st, rawValue);
      },
      getHook: function (cmp, prop) {
        return getUnwrappedValue(st, st[prop]);
      }
    };
  }
  // End of hooks

  const lwcElementProtoPropNames = [
  // Global Properties:
  'dir', 'id', 'accessKey', 'title', 'lang', 'hidden', 'draggable', 'tabIndex',
  // ARIA Attributes:
  'ariaAutoComplete', 'ariaChecked', 'ariaCurrent', 'ariaDisabled', 'ariaExpanded', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaLabel', 'ariaLevel', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaPressed', 'ariaReadOnly', 'ariaRequired', 'ariaSelected', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'ariaLive', 'ariaRelevant', 'ariaAtomic', 'ariaBusy', 'ariaActiveDescendant', 'ariaControls', 'ariaDescribedBy', 'ariaFlowTo', 'ariaLabelledBy', 'ariaOwns', 'ariaPosInSet', 'ariaSetSize', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaDetails', 'ariaErrorMessage', 'ariaKeyShortcuts', 'ariaModal', 'ariaPlaceholder', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'role',
  // Lightning Component Properties:
  'accessKeyLabel',
  // 'attachShadow', (Not available to end users!)
  'addEventListener', 'blur', 'classList', 'className', 'contentEditable', 'dataset', 'dispatchEvent', 'dropzone', 'getAttribute', 'getAttributeNS', 'getBoundingClientRect', 'getElementsByClassName', 'getElementsByTagName', 'inputMode', 'isContentEditable', 'offsetHeight', 'offsetLeft', 'offsetParent', 'offsetTop', 'offsetWidth', 'querySelector', 'querySelectorAll', 'refs', 'removeAttributeNS', 'removeAttribute', 'removeEventListener', 'render',
  // 'root', (Deprecated. Previous name for template!)
  'setAttribute', 'setAttributeNS',
  // 'shadowRoot', (@TODO: W-5527917)
  // 'slot', (Experimental property. Not supported by all browsers. LWC throws error on access!) [https://developer.mozilla.org/en-US/docs/Web/API/Element/slot]
  'spellcheck', 'style', 'template', 'toString', 'translate'];
  function SecureLightningElementFactory(LightningElement, key) {
    let o = getFromCache(LightningElement, key);
    if (o) {
      return o;
    }
    o = SecureLightningElementFactory.getWrappedLightningElement(LightningElement, key);
    setRef(o, LightningElement, key);
    addToCache(LightningElement, o, key);
    freeze(o);
    registerSecureLightningElementForKey(key, o);
    return o;
  }
  SecureLightningElementFactory.getWrappedLightningElement = function (LightningElement, lockerKey) {
    function getWrappedDescriptor(rawDescriptor) {
      const {
        value,
        get,
        set,
        enumerable,
        configurable,
        writable
      } = rawDescriptor;
      function wrappedMethod() {
        const args = filterArguments(this, arguments, RAW_ARGS);
        const rawResult = value.apply(this, args);
        return getFilteredValue(this, rawResult);
      }
      if (rawDescriptor.hasOwnProperty('value')) {
        // Wrap if value is a function
        if (typeof value === 'function') {
          return {
            value: wrappedMethod,
            enumerable,
            writable,
            configurable
          };
        }
        // else return a getter descriptor for static values
        return {
          get() {
            return getFilteredValue(this, value);
          },
          writable,
          enumerable,
          configurable
        };
      }
      // getter and setter
      return {
        get() {
          return getFilteredValue(this, get.call(this));
        },
        set(filteredValue) {
          if (set) {
            set.call(this, getUnwrappedValue(this, filteredValue));
          }
        },
        enumerable,
        configurable
      };
    }
    function SecureLightningElement() {
      if (this instanceof SecureLightningElement) {
        LightningElement.prototype.constructor.call(this, generateInstanceHooks(this));

        /**
         *  `this` represents the user mode instance. No need to wrap this object or protect it
         * `pseudoInstance` is used as an instance we are trying to protect.
         * If this instance ever crosses from one locker to another, a filtering proxy will be placed
         * around this and there is no risk of leaking.
         */
        const pseudoInstance = create$1(null, {
          toString: {
            value: function () {
              return LightningElement.prototype.toString.call(this);
            }
          }
        });
        freeze(pseudoInstance);
        setRef(this, pseudoInstance, lockerKey);
        registerProxy(this);
      } else {
        return SecureLightningElement;
      }
    }

    // eslint-disable-next-line no-underscore-dangle
    SecureLightningElement.__circular__ = true;
    const SecureLElementPrototype = SecureLightningElement.prototype = getObjectLikeProto();
    const LElementPrototype = LightningElement.prototype;

    // Special properties
    defineProperties(SecureLElementPrototype, {
      toString: {
        value: function () {
          return `SecureLightningElement ${LElementPrototype.toString.call(this)}{ key: ${JSON.stringify(lockerKey)} }`;
        }
      },
      template: {
        enumerable: true,
        get: function () {
          const {
            get
          } = getRawPropertyDescriptor(LElementPrototype, 'template');
          const rawValue = get.call(this);
          return SecureTemplate(rawValue, lockerKey);
        }
      },
      ownerDocument: {
        enumerable: true,
        get: function () {
          const {
            get
          } = getRawPropertyDescriptor(LElementPrototype, 'ownerDocument');
          const rawValue = get.call(this);
          return SecureDocument(rawValue, lockerKey);
        }
      }
    });
    fastArrayForEach(['querySelector', 'querySelectorAll', 'getElementsByTagName', 'getElementsByClassName'], method => {
      defineProperty(SecureLElementPrototype, method, {
        enumerable: true,
        value: function (arg) {
          const {
            value
          } = getRawPropertyDescriptor(LElementPrototype, method);
          const result = value.call(this, arg);
          return getFilteredValue(this, result);
        }
      });
    });
    fastArrayForEach(lwcElementProtoPropNames, propName => {
      if (!SecureLElementPrototype.hasOwnProperty(propName) && LElementPrototype.hasOwnProperty(propName)) {
        const originalDescriptor = getRawPropertyDescriptor(LElementPrototype, propName);
        const wrappedDescriptor = getWrappedDescriptor(originalDescriptor);
        defineProperty(SecureLElementPrototype, propName, wrappedDescriptor);
      }
    });
    freeze(SecureLightningElement);
    freeze(SecureLElementPrototype);
    return SecureLightningElement;
  };
  function SecureLWC(lwc, key) {
    let o = getFromCache(lwc, key);
    if (o) {
      return o;
    }

    // this is the first time we get a reference to the LightningElement
    // register it as early as possible
    const LightningElement = lwc['LightningElement'];
    registerLightningElement(LightningElement);
    o = create$1(null, {
      LightningElement: {
        enumerable: true,
        value: SecureLightningElementFactory(LightningElement, key)
      },
      /**
       * freezeTemplate() accepts a Template function and returns void.
       * In principle, it freezes the entire object, although in the short-term it may just log console warnings.
       */
      freezeTemplate: {
        enumerable: true,
        value: lwc['freezeTemplate']
      },
      /**
       * parseFragment() accepts html template string and returns an HTML fragment
       * It is used to re-use static elements that don't change across re-renders.
       */
      parseFragment: {
        enumerable: true,
        value: lwc['parseFragment']
      },
      /**
       * parseSVGFragment() accepts html template string and returns an HTML fragment
       * Same as `parseFragment` but only for SVG elements
       */
      parseSVGFragment: {
        enumerable: true,
        value: lwc['parseSVGFragment']
      },
      readonly: {
        enumerable: true,
        value: obj => lwc['readonly'](obj)
      },
      // *** start EXCEPTION: 'registerTemplate', 'registerComponent', 'registerDecorators' are not secure
      // methods and cannot be exposed to the user. By extension, SecureLWC also cannot be exposed to the user.
      registerTemplate: {
        enumerable: true,
        value: lwc['registerTemplate']
      },
      /**
       * registerComponent() accepts a Component class and returns the same back.
       * It is important for the engine to register the Component class without distortions
       * (identity of what the user provided component class has to be the same as what engine gets)
       */
      registerComponent: {
        enumerable: true,
        value: lwc['registerComponent']
      },
      /**
       * registerDecorators() accepts a Component class and its decorator metadata.
       * The method processes the component metadata and decorates the class to handle the decorator properties
       */
      registerDecorators: {
        enumerable: true,
        value: lwc['registerDecorators']
      },
      // *** end EXCEPTION
      sanitizeAttribute: {
        enumerable: true,
        value() {
          const tag = arguments[0];
          const attrName = arguments[2];
          const attrValue = arguments[3];
          if (tag.toLowerCase() === 'use' && ['xlink:href', 'href'].includes(attrName)) {
            return sanitizeHrefAttribute(attrValue);
          }
          return attrValue;
        }
      }
    });
    freeze(o);
    setRef(o, lwc, key);
    addToCache(lwc, o, key);
    return o;
  }

  /**
   * Create a wrapped library
   * @param {Object} lib Library being imported
   * @param {Object} key Locker key of the module importing the library
   * @param {Boolean} requireLocker Should the library being imported be lockeried
   */
  function SecureLib(lib, fromKey, toKey) {
    if (isPrimitive(lib)) {
      return lib;
    }
    let o = getFromCache(lib, toKey);
    if (o) {
      return o;
    }
    o = create$1(getObjectLikeProto(), {
      toString: {
        value: function () {
          return `SecureLib: ${lib}{ key: ${JSON.stringify(toKey)} }`;
        }
      }
    });
    ObjectEntries(lib).forEach(([property, item]) => {
      if (isPrimitive(item)) {
        o[property] = item;
      } else if (typeof item === 'function') {
        if (item.prototype instanceof Event) {
          // only Platform events created in non-lockerized libs will be caught by this condition
          // @TODO: add support for importing lockerized libs that expose events
          const secureEventCtorDescriptor = createFilteredConstructor(o, lib, property, SecureCustomEventFactory, toKey);
          defineProperty(o, property, secureEventCtorDescriptor);
        } else if (isSecureLightningElement(item, fromKey)) {
          o[property] = item;
        } else {
          o[property] = SecureFunction(item, fromKey, toKey);
        }
      } else if (typeof item === 'object') {
        o[property] = SecureFunction(item, fromKey, toKey);
      } else {
        addPropertyIfSupported(o, lib, property);
      }
    });
    setRef(o, lib, toKey);
    addToCache(lib, o, toKey);
    registerProxy(o);
    return seal(o);
  }

  /* eslint-disable no-use-before-define */

  function SecureObject(thing, key) {
    let o = getFromCache(thing, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureObject: ${thing}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    setRef(o, thing, key, true);
    addToCache(thing, o, key);
    registerProxy(o);
    return seal(o);
  }

  /* eslint-enable import/no-cycle */

  const convertOptions = {
    useNewSecureFunction: true
  };
  function getPropertyValues(obj) {
    return ObjectValues(getOwnPropertyDescriptors(obj)).map(desc => desc.value);
  }

  /**
   * List of unfiltered objects.
   */
  // @TODO: W-5529670 augment the list of unfiltered types for performance.
  const allowedObjects$1 = [
  // Function, // unsafe
  Object, Array, Function.prototype, ...getPropertyValues(Function.prototype), Object.prototype, ...getPropertyValues(Object.prototype), Array.prototype];
  function isObjectAllowed(obj) {
    // Key is detected by duck typing.
    return allowedObjects$1.includes(obj);
  }

  /**
   * Ensure a value from the source graph is converted to the
   * destination graph.
   */
  function convert(value, fromKey, toKey) {
    assert.invariant(isKey(fromKey), `Convert() requires a source key: ${stringify(fromKey)}`);
    assert.invariant(isKey(toKey), `Convert() requires a destination key: ${stringify(toKey)}`);
    assert.invariant(fromKey !== toKey, `Convert() requires two different keys: ${stringify(fromKey)} to ${stringify(toKey)}`);
    if (isPrimitive(value) || isObjectAllowed(value)) {
      // Do not proxy primitives.
      return value;
    }
    if (hasRef(value)) {
      // 1. The value is a secure proxy.
      const raw = getRef(value, fromKey);
      const rawKey = getKey(raw);
      if (rawKey === toKey) {
        // 1a. The raw object belongs to the destination graph.
        return raw;
      }
      // 1b. Create (or reuse) a secure proxy in the destination graph.
      return toKey === defaultKey ? deepUnfilter(fromKey, [], [value])[0] : filter(toKey, value, convertOptions);
    }

    // 2. The value is not a proxy.
    const valueKey = getKey(value);
    if (!valueKey) {
      // 2a. The value has no key, it's new to the membrane.
      // It can only come from the source graph.
      // Assign it to the source graph.
      setKey(value, fromKey);
    }
    // 2b. Create a secure proxy in the destination graph.
    return toKey === defaultKey ? deepUnfilter(fromKey, [], [value])[0] : filter(toKey, value, convertOptions);
  }

  /**
   * Ensure all values in an array (an argument list)
   * are converted to the destination namespace.
   */
  function convertArgs(args, fromKey, toKey) {
    return args.map(arg => convert(arg, fromKey, toKey));
  }
  function convertDescriptor(desc, fromKey, toKey) {
    if (desc) {
      if ('value' in desc) {
        desc.value = convert(desc.value, fromKey, toKey);
      } else {
        const {
          get,
          set
        } = desc;
        if (get) {
          desc.get = convert(get, fromKey, toKey);
        }
        if (set) {
          desc.set = convert(set, fromKey, toKey);
        }
      }
    }
    return desc;
  }

  /* eslint-enable import/no-cycle */

  function createShadowTarget(raw) {
    switch (typeof raw) {
      case 'function':
        return function () {};
      case 'object':
        return isArray(raw) ? [] : {};
      default:
        throw new TypeError('Unsupported proxy target type.');
    }
  }
  function lockShadow(shadow, raw, fromKey, toKey) {
    const props = ownKeys(shadow);
    fastArrayForEach(props, prop => {
      if (!has(shadow, prop)) {
        const desc = getOwnPropertyDescriptor(raw, prop);
        const wrapped = convertDescriptor(desc, fromKey, toKey);
        defineProperty(shadow, prop, wrapped);
      }
    });
  }

  /**
   * A generic handler with support for:
   * - filtered function invocation
   * - filtered constructor invocation
   * - read only filtered prototype
   * - read only filtered properties
   * - expando for new properties (unfiltered)
   * Decisions:
   * - raw properties have authority over expandos
   */
  class SecureFunctionHandler {
    constructor(raw, fromKey, toKey) {
      // The raw value to proxy.
      this.raw = raw;
      // The raw value's object graph.
      this.fromKey = fromKey;
      // The proxy's object graph.
      this.toKey = toKey;
    }
    apply(_shadow, thisArg, args) {
      // Both 'this' and arguments are filtered from the graph where the
      // proxy beling sto the graph where the function was originally defined.
      thisArg = convert(thisArg, this.toKey, this.fromKey);
      args = convertArgs(args, this.toKey, this.fromKey);
      // Always try to invoke raw as a function.
      const value = apply(this.raw, thisArg, args);
      return convert(value, this.fromKey, this.toKey);
    }
    construct(_shadow, args, newTarget) {
      args = convertArgs(args, this.toKey, this.fromKey);
      newTarget = convert(newTarget, this.toKey, this.fromKey);
      // Always try to invoke raw as a constructor.
      const value = construct(this.raw, args, newTarget);
      return convert(value, this.fromKey, this.toKey);
    }
    defineProperty(shadow, prop, desc) {
      // Always invoke raw first.
      if (has(this.raw, prop)) {
        // Only set data properties on the raw object.
        if ('value' in desc) {
          // Only set existing data properties on the raw object.
          const descriptor = getOwnPropertyDescriptor(this.raw, prop);
          if ('value' in descriptor && descriptor.writable) {
            // Prevent changes to configuration of data properties.
            descriptor.value = desc.value;
            return defineProperty(this.raw, prop, descriptor);
          }
        }
        throw new TypeError(`Cannot redefine property '${prop}' of ${this.raw}`);
      }
      // Expando is unfiltered.
      return defineProperty(shadow, prop, desc);
    }
    deleteProperty(shadow, prop) {
      // Check on shadow first.
      if (shadow.hasOwnProperty(prop)) {
        // Expando is unfiltered.
        return deleteProperty(shadow, prop);
      }
      // Never delete a property raw on the raw object.
      // Behave as if the raw object is frozen.
      throw new TypeError(`Cannot delete property '${prop}' of ${this.raw}`);
    }
    get(shadow, prop, receiver) {
      if (prop === '__proto__') {
        return getPrototypeOf(receiver);
      }
      // Always invoke raw first.
      if (has(this.raw, prop)) {
        // Always filter the results returned by the raw object.
        const value = get(this.raw, prop, receiver);
        return convert(value, this.fromKey, this.toKey);
      }
      // Expando is unfiltered.
      return get(shadow, prop, receiver);
    }
    getOwnPropertyDescriptor(shadow, prop) {
      // Always invoke raw first.
      const desc = getOwnPropertyDescriptor(this.raw, prop);
      if (!desc) {
        return getOwnPropertyDescriptor(shadow, prop);
      }
      const wrapped = convertDescriptor(desc, this.fromKey, this.toKey);
      if (!desc.configurable) {
        // Proxy invariant: non-configurable properties must exist on target.
        // If descriptor of raw property is non-configurable,
        // define the property on the shadow using the wrapped descriptor.
        defineProperty(shadow, prop, wrapped);
      }
      return wrapped;
    }

    /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */
    getPrototypeOf(_shadow) {
      return convert(getPrototypeOf(this.raw), this.fromKey, this.toKey);
    }
    has(shadow, prop) {
      if (!isExtensible(shadow)) {
        // If shadow isn't extensible, it's because raw isn't,
        // and all properties have already been copied.
        return shadow.hasOwnProperty(prop);
      }
      return has(this.raw, prop) || shadow.hasOwnProperty(prop);
    }
    isExtensible(shadow) {
      const extensibleShadow = isExtensible(shadow);
      if (!extensibleShadow) {
        // Proxy invariant: must report non-extensibility of target.
        // If shadow isn't extensible, we must report it.
        return extensibleShadow;
      }
      const extensible = isExtensible(this.raw);
      if (!extensible) {
        // Proxy invariant: to report non-extensibility, target must be non-extensibile.
        lockShadow(shadow, this.raw, this.fromKey, this.toKey);
        preventExtensions(shadow);
      }
      return extensible;
    }
    ownKeys(shadow) {
      if (!isExtensible(shadow)) {
        // If shadow isn't extensible, it's because raw isn't,
        // and all properties have already been copied.
        return ownKeys(shadow);
      }
      // Must remove duplicates between raw and shadow.
      return ArrayMerge(ownKeys(this.raw), ownKeys(shadow));
    }
    preventExtensions(shadow) {
      if (isExtensible(shadow)) {
        // Never freeze or change the extensibility of raw objects.
        // Proxy invariant: can't report non-extensibility of extensible target.
        // Making shadow non-extensible prevents the addition of any
        // non-configurable property of raw which appears at a later stage.
        lockShadow(shadow, this.raw, this.fromKey, this.toKey);
      }
      return preventExtensions(shadow);
    }
    set(shadow, prop, value, receiver) {
      // Always invoke raw first.
      if (has(this.raw, prop)) {
        value = convert(value, this.toKey, this.fromKey);
        return set(this.raw, prop, value, receiver);
      }
      // If raw doesn't have the property, define it on shadow.
      // Expando is unfiltered.
      return set(shadow, prop, value, receiver);
    }
    setPrototypeOf(_shadow, proto) {
      // Never change the prototype of a raw object.
      // Behave as if the raw object is frozen.
      if (proto === getPrototypeOf(this.raw)) {
        // No failure if no change if value, even if property is non-configurable.
        return true;
      }
      throw new TypeError(`Cannot set the prototyope of ${this.raw}`);
    }
  }
  function SecureFunction(raw, fromKey, toKey) {
    assert.invariant(isKey(fromKey), `SecureFunction() requires a raw toKey: ${stringify(fromKey)}`);
    assert.invariant(isKey(toKey), `SecureFunction() requires a destination toKey: ${stringify(toKey)}`);
    assert.invariant(fromKey !== toKey, `SecureFunction() requires two different keys: ${stringify(fromKey)} to ${stringify(toKey)}`);
    const shadow = createShadowTarget(raw);
    const handler = new SecureFunctionHandler(raw, fromKey, toKey);
    return new Proxy(shadow, handler);
  }
  const isImport = /import/i;
  const linkRelGetter = getOwnPropertyDescriptor(HTMLLinkElement.prototype, 'rel').get;
  const secureRelList = {
    get(target, property) {
      const targetValue = get(target, property);
      if (typeof targetValue === 'function') {
        return function (...args) {
          if (isImport.test(args.join(' '))) {
            warn("SecureLinkElement does not allow setting 'rel' property to 'import' value.");
            return undefined;
          }
          return target[property](...args);
        };
      }
      return targetValue;
    },
    set(target, property, value) {
      if (property === 'length') {
        target[property] = value;
      } else if (property === 'value') {
        if (!isImport.test(value)) {
          target[property] = value;
        }
      }
      return true;
    }
  };
  function createDescriptorMethods(method, indexOfValue, indexOfName, isNode) {
    return {
      value: function () {
        if (isNode) {
          const rawNodeAttr = getRawThis(arguments[indexOfValue]);
          if (rawNodeAttr.name === 'rel' && isImport.test(rawNodeAttr.value)) {
            warn("SecureLinkElement does not allow setting 'rel' property to 'import' value.");
            return undefined;
          }
          return method.apply(this, arguments);
        }
        if (arguments[indexOfName] === 'rel' && isImport.test(arguments[indexOfValue])) {
          warn("SecureLinkElement does not allow setting 'rel' property to 'import' value.");
          return undefined;
        }
        return method.apply(this, arguments);
      }
    };
  }
  function createDescriptors$2(prototype) {
    const {
      setAttribute,
      setAttributeNS,
      setAttributeNode,
      setAttributeNodeNS
    } = prototype;
    return {
      rel: {
        enumerable: true,
        get: function () {
          const raw = getRawThis(this);
          return linkRelGetter.call(raw);
        },
        set: function (value) {
          value = asString(value);
          if (isImport.test(value)) {
            warn("SecureLinkElement does not allow setting 'rel' property to 'import' value.");
            return;
          }
          const raw = getRawThis(this);
          raw.rel = value;
        }
      },
      relList: {
        get: function () {
          const raw = getRawThis(this);
          const key = getKey(raw);
          const {
            relList
          } = raw;
          let relListProxy = getFromCache(relList, key);
          if (!relListProxy) {
            relListProxy = new Proxy(relList, secureRelList);
            addToCache(relList, relListProxy, key);
            registerProxy(relListProxy);
          }
          return relListProxy;
        },
        set: function (relList) {
          const raw = getRawThis(this);
          if (relList instanceof DOMTokenList) {
            if (isImport.test(relList.value)) {
              warn("SecureLinkElement does not allow setting 'rel' property to 'import' value.");
              return undefined;
            }
            return raw['setAttribute']('rel', relList.value);
          }
          relList = asString(relList);
          if (isImport.test(relList)) {
            warn("SecureLinkElement does not allow setting 'rel' property to 'import' value.");
            return undefined;
          }
          return raw['setAttribute']('rel', relList);
        }
      },
      setAttribute: createDescriptorMethods(setAttribute, 1, 0, false),
      setAttributeNS: createDescriptorMethods(setAttributeNS, 2, 1, false),
      setAttributeNode: createDescriptorMethods(setAttributeNode, 0, undefined, true),
      setAttributeNodeNS: createDescriptorMethods(setAttributeNodeNS, 0, undefined, true)
    };
  }
  const isAttrBlocked = attr => ['xlink:href', 'href'].includes(attr);
  function createDescriptor$1(method, valIndex, isNode) {
    return {
      value() {
        const attr = arguments[valIndex];
        if (attr) {
          if (isNode) {
            // attr.name is readonly and we do not need to guard
            attr.value = isAttrBlocked(attr.name) ? sanitizeHrefAttribute(attr.value) : attr.value;
          } else {
            const attrName = asString(arguments[valIndex - 1]);
            arguments[valIndex - 1] = attrName;
            arguments[valIndex] = isAttrBlocked(attrName) ? sanitizeHrefAttribute(attr) : attr;
          }
        }
        return method.apply(this, arguments);
      }
    };
  }
  function SecureSVGURIReference(el) {
    return {
      baseVal: {
        get() {
          return el.href && el.href.baseVal;
        },
        set(value) {
          if (el.href) {
            el.href.baseVal = sanitizeHrefAttribute(value);
          }
          return true;
        }
      },
      animVal: {
        get() {
          return el.href && el.href.animVal;
        },
        set() {
          return true;
        }
      },
      toString: {
        value() {
          return `SecureSVGURIReference: ${el}`;
        }
      }
    };
  }
  function createDescriptors$1(prototype, el) {
    const {
      setAttribute,
      setAttributeNode,
      setAttributeNS,
      setAttributeNodeNS
    } = prototype;
    const href = Object.create(null);
    defineProperties(href, SecureSVGURIReference(el));
    return {
      setAttribute: createDescriptor$1(setAttribute, 1, false),
      setAttributeNS: createDescriptor$1(setAttributeNS, 2, false),
      setAttributeNode: createDescriptor$1(setAttributeNode, 0, true),
      setAttributeNodeNS: createDescriptor$1(setAttributeNodeNS, 0, true),
      href: {
        enumerable: true,
        configurable: true,
        get() {
          return href;
        },
        set() {
          return true;
        }
      }
    };
  }
  const isAttrValueBlocked = attr => ['xlink:href', 'href'].includes(attr);
  const isAttrNameBlocked = attrName => ['attributeName', 'attributename'].includes(attrName);
  const getWarnMsg = (aName, aVal) => `SecureSVGSetElement does not allow setting the value ${aVal} on ${aName}`;
  const isNameValPairBlocked = (aName, aVal) => isAttrNameBlocked(aName) && isAttrValueBlocked(aVal);
  function createDescriptor(method, valIndex, isNode) {
    return {
      value() {
        const attr = isNode ? arguments[valIndex] : asString(arguments[valIndex]);
        const attrNameStr = asString(arguments[valIndex - 1]);
        if (attr) {
          const {
            name,
            value
          } = isNode ? {
            name: attr.name,
            value: attr.value
          } : {
            name: attrNameStr,
            value: attr
          };
          const shouldBlock = isNameValPairBlocked(name, value);
          if (shouldBlock) {
            warn(getWarnMsg(name, value));
            return '';
          }
        }
        return method.apply(this, arguments);
      }
    };
  }
  function createDescriptors(prototype) {
    const {
      setAttribute,
      setAttributeNode,
      setAttributeNS,
      setAttributeNodeNS
    } = prototype;
    return {
      setAttribute: createDescriptor(setAttribute, 1, false),
      setAttributeNS: createDescriptor(setAttributeNS, 2, false),
      setAttributeNode: createDescriptor(setAttributeNode, 0, true),
      setAttributeNodeNS: createDescriptor(setAttributeNodeNS, 0, true)
    };
  }
  var Attr$1 = {
    name: DEFAULT,
    namespaceURI: DEFAULT,
    localName: DEFAULT,
    prefix: DEFAULT,
    ownerElement: DEFAULT,
    specified: DEFAULT,
    value: DEFAULT
  };
  var CharacterData = {
    after: FUNCTION,
    appendData: FUNCTION,
    before: FUNCTION,
    data: DEFAULT,
    deleteData: FUNCTION,
    insertData: FUNCTION,
    length: DEFAULT,
    nextElementSibling: SKIP_OPAQUE,
    previousElementSibling: SKIP_OPAQUE,
    remove: FUNCTION,
    replaceData: FUNCTION,
    replaceWith: FUNCTION,
    substringData: FUNCTION
  };
  var DocumentFragment$1 = {
    childElementCount: DEFAULT,
    children: DEFAULT,
    firstElementChild: SKIP_OPAQUE,
    getElementById: FUNCTION,
    lastElementChild: SKIP_OPAQUE,
    querySelector: FUNCTION,
    querySelectorAll: FUNCTION
  };
  var DocumentType$1 = {
    after: FUNCTION,
    before: FUNCTION,
    name: READ_ONLY_PROPERTY,
    publicId: READ_ONLY_PROPERTY,
    remove: FUNCTION,
    replaceWith: FUNCTION,
    systemId: READ_ONLY_PROPERTY
  };
  var Element$1 = {
    animate: FUNCTION,
    attributes: DEFAULT,
    children: DEFAULT,
    classList: DEFAULT,
    className: DEFAULT,
    clientHeight: DEFAULT,
    clientLeft: DEFAULT,
    clientTop: DEFAULT,
    clientWidth: DEFAULT,
    closest: FUNCTION,
    firstElementChild: SKIP_OPAQUE,
    getAttribute: FUNCTION,
    getAttributeNS: FUNCTION,
    getAttributeNode: FUNCTION,
    getAttributeNodeNS: FUNCTION,
    getBoundingClientRect: FUNCTION,
    getClientRects: FUNCTION,
    getDestinationInsertionPoints: FUNCTION,
    // getElementsByClassName: FUNCTION, // Custom descriptor
    // getElementsByTagName: FUNCTION, // Custom descriptor
    // getElementsByTagNameNS: FUNCTION, // Custom descriptor
    hasAttribute: FUNCTION,
    hasAttributeNS: FUNCTION,
    hasAttributes: FUNCTION,
    id: DEFAULT,
    innerHTML: DEFAULT,
    insertAdjacentElement: FUNCTION,
    insertAdjacentHTML: FUNCTION,
    insertAdjacentText: FUNCTION,
    lastElementChild: SKIP_OPAQUE,
    localName: DEFAULT,
    matches: FUNCTION,
    namespaceURI: DEFAULT,
    nextElementSibling: SKIP_OPAQUE,
    onbeforecopy: EVENT,
    onbeforecut: EVENT,
    onbeforepaste: EVENT,
    oncopy: EVENT,
    oncut: EVENT,
    onpaste: EVENT,
    onsearch: EVENT,
    onselectstart: EVENT,
    onwebkitfullscreenchange: EVENT,
    onwebkitfullscreenerror: EVENT,
    onwheel: EVENT,
    outerHTML: DEFAULT,
    prefix: DEFAULT,
    previousElementSibling: SKIP_OPAQUE,
    // querySelector: FUNCTION, // Custom descriptor
    // querySelectorAll: FUNCTION, // Custom descriptor
    remove: FUNCTION,
    removeAttribute: FUNCTION,
    removeAttributeNS: FUNCTION,
    removeAttributeNode: FUNCTION,
    requestPointerLock: FUNCTION,
    scrollHeight: DEFAULT,
    scrollIntoView: FUNCTION,
    scrollIntoViewIfNeeded: FUNCTION,
    scrollLeft: DEFAULT,
    scrollTop: DEFAULT,
    scrollWidth: DEFAULT,
    setAttribute: FUNCTION,
    setAttributeNS: FUNCTION,
    setAttributeNode: FUNCTION,
    setAttributeNodeNS: FUNCTION,
    tagName: DEFAULT
  };
  var EventTarget$1 = {
    addEventListener: FUNCTION,
    dispatchEvent: FUNCTION,
    removeEventListener: FUNCTION
  };
  var HTMLAnchorElement$1 = {
    charset: DEFAULT,
    coords: DEFAULT,
    download: DEFAULT,
    hash: DEFAULT,
    host: DEFAULT,
    hostname: DEFAULT,
    href: DEFAULT,
    hreflang: DEFAULT,
    name: DEFAULT,
    origin: DEFAULT,
    password: DEFAULT,
    pathname: DEFAULT,
    ping: DEFAULT,
    port: DEFAULT,
    protocol: DEFAULT,
    referrerPolicy: DEFAULT,
    rel: DEFAULT,
    rev: DEFAULT,
    search: DEFAULT,
    shape: DEFAULT,
    target: DEFAULT,
    text: DEFAULT,
    type: DEFAULT,
    username: DEFAULT
  };
  var HTMLAreaElement$1 = {
    alt: DEFAULT,
    coords: DEFAULT,
    hash: DEFAULT,
    host: DEFAULT,
    hostname: DEFAULT,
    href: DEFAULT,
    noHref: DEFAULT,
    origin: DEFAULT,
    password: DEFAULT,
    pathname: DEFAULT,
    ping: DEFAULT,
    port: DEFAULT,
    protocol: DEFAULT,
    referrerPolicy: DEFAULT,
    search: DEFAULT,
    shape: DEFAULT,
    target: DEFAULT,
    username: DEFAULT
  };
  var HTMLAudioElement$1 = {};
  var HTMLBaseElement$1 = {
    href: DEFAULT,
    target: DEFAULT
  };
  var HTMLButtonElement$1 = {
    autofocus: DEFAULT,
    checkValidity: FUNCTION,
    disabled: DEFAULT,
    form: DEFAULT,
    formAction: DEFAULT,
    formEnctype: DEFAULT,
    formMethod: DEFAULT,
    formNoValidate: DEFAULT,
    formTarget: DEFAULT,
    labels: DEFAULT,
    name: DEFAULT,
    reportValidity: FUNCTION,
    setCustomValidity: FUNCTION,
    type: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    value: DEFAULT,
    willValidate: DEFAULT
  };
  var HTMLCanvasElement$1 = {
    captureStream: FUNCTION,
    getContext: FUNCTION,
    height: DEFAULT,
    toBlob: FUNCTION,
    toDataURL: FUNCTION,
    width: DEFAULT
  };
  var HTMLDetailsElement$1 = {
    open: DEFAULT
  };
  var HTMLElement$1 = {
    accessKey: DEFAULT,
    assignedSlot: DEFAULT,
    blur: FUNCTION,
    click: FUNCTION,
    contentEditable: DEFAULT,
    dataset: DEFAULT,
    dir: DEFAULT,
    draggable: DEFAULT,
    focus: FUNCTION,
    hidden: DEFAULT,
    innerText: DEFAULT,
    isContentEditable: DEFAULT,
    lang: DEFAULT,
    offsetHeight: DEFAULT,
    offsetLeft: DEFAULT,
    offsetParent: DEFAULT,
    offsetTop: DEFAULT,
    offsetWidth: DEFAULT,
    onabort: EVENT,
    onautocomplete: EVENT,
    onautocompleteerror: EVENT,
    onblur: EVENT,
    oncancel: EVENT,
    oncanplay: EVENT,
    oncanplaythrough: EVENT,
    onchange: EVENT,
    onclick: EVENT,
    onclose: EVENT,
    oncontextmenu: EVENT,
    oncuechange: EVENT,
    ondblclick: EVENT,
    ondrag: EVENT,
    ondragend: EVENT,
    ondragenter: EVENT,
    ondragleave: EVENT,
    ondragover: EVENT,
    ondragstart: EVENT,
    ondrop: EVENT,
    ondurationchange: EVENT,
    onemptied: EVENT,
    onended: EVENT,
    onerror: EVENT,
    onfocus: EVENT,
    oninput: EVENT,
    oninvalid: EVENT,
    onkeydown: EVENT,
    onkeypress: EVENT,
    onkeyup: EVENT,
    onload: EVENT,
    onloadeddata: EVENT,
    onloadedmetadata: EVENT,
    onloadstart: EVENT,
    onmousedown: EVENT,
    onmouseenter: EVENT,
    onmouseleave: EVENT,
    onmousemove: EVENT,
    onmouseout: EVENT,
    onmouseover: EVENT,
    onmouseup: EVENT,
    onmousewheel: EVENT,
    onpause: EVENT,
    onplay: EVENT,
    onplaying: EVENT,
    onprogress: EVENT,
    onratechange: EVENT,
    onreset: EVENT,
    onresize: EVENT,
    onscroll: EVENT,
    onseeked: EVENT,
    onseeking: EVENT,
    onselect: EVENT,
    onshow: EVENT,
    onstalled: EVENT,
    onsubmit: EVENT,
    onsuspend: EVENT,
    ontimeupdate: EVENT,
    ontoggle: EVENT,
    ontouchcancel: EVENT,
    ontouchend: EVENT,
    ontouchmove: EVENT,
    ontouchstart: EVENT,
    onvolumechange: EVENT,
    onwaiting: EVENT,
    outerText: DEFAULT,
    slot: DEFAULT,
    spellcheck: DEFAULT,
    style: DEFAULT,
    tabIndex: DEFAULT,
    title: DEFAULT,
    translate: DEFAULT,
    webkitdropzone: DEFAULT
  };
  var HTMLEmbedElement$1 = {
    align: DEFAULT,
    getSVGDocument: FUNCTION,
    height: DEFAULT,
    name: DEFAULT,
    src: DEFAULT,
    type: DEFAULT,
    width: DEFAULT
  };
  var HTMLFieldSetElement$1 = {
    checkValidity: FUNCTION,
    disabled: DEFAULT,
    elements: DEFAULT,
    form: DEFAULT,
    name: DEFAULT,
    reportValidity: FUNCTION,
    setCustomValidity: FUNCTION,
    type: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    willValidate: DEFAULT
  };
  var HTMLFormElement$1 = {
    acceptCharset: DEFAULT,
    action: DEFAULT,
    autocomplete: DEFAULT,
    checkValidity: FUNCTION,
    elements: DEFAULT,
    encoding: DEFAULT,
    enctype: DEFAULT,
    length: DEFAULT,
    method: DEFAULT,
    name: DEFAULT,
    noValidate: DEFAULT,
    reportValidity: FUNCTION,
    requestAutocomplete: FUNCTION,
    reset: FUNCTION,
    submit: FUNCTION,
    target: DEFAULT
  };
  var HTMLIFrameElement$1 = {
    align: DEFAULT,
    allowFullscreen: DEFAULT,
    frameBorder: DEFAULT,
    height: DEFAULT,
    longDesc: DEFAULT,
    marginHeight: DEFAULT,
    marginWidth: DEFAULT,
    name: DEFAULT,
    referrerPolicy: DEFAULT,
    scrolling: DEFAULT,
    src: DEFAULT,
    width: DEFAULT
  };
  var HTMLImageElement$1 = {
    align: DEFAULT,
    alt: DEFAULT,
    border: DEFAULT,
    complete: DEFAULT,
    crossOrigin: DEFAULT,
    currentSrc: DEFAULT,
    height: DEFAULT,
    hspace: DEFAULT,
    isMap: DEFAULT,
    longDesc: DEFAULT,
    lowsrc: DEFAULT,
    name: DEFAULT,
    naturalHeight: DEFAULT,
    naturalWidth: DEFAULT,
    referrerPolicy: DEFAULT,
    sizes: DEFAULT,
    src: DEFAULT,
    srcset: DEFAULT,
    useMap: DEFAULT,
    vspace: DEFAULT,
    width: DEFAULT,
    x: DEFAULT,
    y: DEFAULT
  };
  var HTMLInputElement$1 = {
    accept: DEFAULT,
    align: DEFAULT,
    alt: DEFAULT,
    autocapitalize: DEFAULT,
    autocomplete: DEFAULT,
    autocorrect: DEFAULT,
    autofocus: DEFAULT,
    checkValidity: FUNCTION,
    checked: DEFAULT,
    defaultChecked: DEFAULT,
    defaultValue: DEFAULT,
    dirName: DEFAULT,
    disabled: DEFAULT,
    files: DEFAULT,
    form: DEFAULT,
    formAction: DEFAULT,
    formEnctype: DEFAULT,
    formMethod: DEFAULT,
    formNoValidate: DEFAULT,
    formTarget: DEFAULT,
    height: DEFAULT,
    incremental: DEFAULT,
    indeterminate: DEFAULT,
    labels: DEFAULT,
    list: DEFAULT,
    max: DEFAULT,
    maxLength: DEFAULT,
    min: DEFAULT,
    minLength: DEFAULT,
    multiple: DEFAULT,
    name: DEFAULT,
    pattern: DEFAULT,
    placeholder: DEFAULT,
    readOnly: DEFAULT,
    reportValidity: FUNCTION,
    required: DEFAULT,
    results: DEFAULT,
    select: FUNCTION,
    selectionDirection: DEFAULT,
    selectionEnd: DEFAULT,
    selectionStart: DEFAULT,
    setCustomValidity: FUNCTION,
    setRangeText: FUNCTION,
    setSelectionRange: FUNCTION,
    size: DEFAULT,
    src: DEFAULT,
    step: DEFAULT,
    stepDown: FUNCTION,
    stepUp: FUNCTION,
    type: DEFAULT,
    useMap: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    value: DEFAULT,
    valueAsDate: DEFAULT,
    valueAsNumber: DEFAULT,
    webkitEntries: DEFAULT,
    webkitdirectory: DEFAULT,
    width: DEFAULT,
    willValidate: DEFAULT,
    'x-moz-errormessage': DEFAULT
  };
  var HTMLLIElement$1 = {
    type: DEFAULT,
    value: DEFAULT
  };
  var HTMLLabelElement$1 = {
    control: DEFAULT,
    form: DEFAULT,
    htmlFor: DEFAULT
  };
  var HTMLLinkElement$1 = {
    as: DEFAULT,
    charset: DEFAULT,
    crossOrigin: DEFAULT,
    disabled: DEFAULT,
    href: DEFAULT,
    hreflang: DEFAULT,
    import: DEFAULT,
    integrity: DEFAULT,
    media: DEFAULT,
    rel: DEFAULT,
    relList: DEFAULT,
    rev: DEFAULT,
    sheet: DEFAULT,
    sizes: DEFAULT,
    target: DEFAULT,
    type: DEFAULT
  };
  var HTMLMapElement$1 = {
    areas: DEFAULT,
    name: DEFAULT
  };
  var HTMLMediaElement$1 = {
    HAVE_CURRENT_DATA: DEFAULT,
    HAVE_ENOUGH_DATA: DEFAULT,
    HAVE_FUTURE_DATA: DEFAULT,
    HAVE_METADATA: DEFAULT,
    HAVE_NOTHING: DEFAULT,
    NETWORK_EMPTY: DEFAULT,
    NETWORK_IDLE: DEFAULT,
    NETWORK_LOADING: DEFAULT,
    NETWORK_NO_SOURCE: DEFAULT,
    addTextTrack: FUNCTION,
    autoplay: DEFAULT,
    buffered: DEFAULT,
    canPlayType: FUNCTION,
    controls: DEFAULT,
    crossOrigin: DEFAULT,
    currentSrc: DEFAULT,
    currentTime: DEFAULT,
    defaultMuted: DEFAULT,
    defaultPlaybackRate: DEFAULT,
    disableRemotePlayback: DEFAULT,
    duration: DEFAULT,
    ended: DEFAULT,
    error: DEFAULT,
    load: FUNCTION,
    loop: DEFAULT,
    mediaKeys: DEFAULT,
    muted: DEFAULT,
    networkState: DEFAULT,
    onencrypted: EVENT,
    pause: FUNCTION,
    paused: DEFAULT,
    play: FUNCTION,
    playbackRate: DEFAULT,
    played: DEFAULT,
    preload: DEFAULT,
    readyState: DEFAULT,
    seekable: DEFAULT,
    seeking: DEFAULT,
    setMediaKeys: FUNCTION,
    setSinkId: FUNCTION,
    sinkId: DEFAULT,
    src: DEFAULT,
    srcObject: DEFAULT,
    textTracks: DEFAULT,
    volume: DEFAULT,
    webkitAudioDecodedByteCount: DEFAULT,
    webkitVideoDecodedByteCount: DEFAULT
  };
  var HTMLMetaElement$1 = {
    content: DEFAULT,
    httpEquiv: DEFAULT,
    name: DEFAULT,
    scheme: DEFAULT
  };
  var HTMLMeterElement$1 = {
    high: DEFAULT,
    labels: DEFAULT,
    low: DEFAULT,
    max: DEFAULT,
    min: DEFAULT,
    optimum: DEFAULT,
    value: DEFAULT
  };
  var HTMLModElement$1 = {
    cite: DEFAULT,
    dateTime: DEFAULT
  };
  var HTMLOListElement$1 = {
    compact: DEFAULT,
    reversed: DEFAULT,
    start: DEFAULT,
    type: DEFAULT
  };
  var HTMLObjectElement$1 = {
    align: DEFAULT,
    archive: DEFAULT,
    border: DEFAULT,
    checkValidity: FUNCTION,
    code: DEFAULT,
    codeBase: DEFAULT,
    codeType: DEFAULT,
    contentDocument: DEFAULT,
    data: DEFAULT,
    declare: DEFAULT,
    form: DEFAULT,
    getSVGDocument: FUNCTION,
    height: DEFAULT,
    hspace: DEFAULT,
    name: DEFAULT,
    reportValidity: FUNCTION,
    setCustomValidity: FUNCTION,
    standby: DEFAULT,
    type: DEFAULT,
    useMap: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    vspace: DEFAULT,
    width: DEFAULT,
    willValidate: DEFAULT
  };
  var HTMLOptGroupElement$1 = {
    disabled: DEFAULT,
    label: DEFAULT
  };
  var HTMLOptionElement$1 = {
    defaultSelected: DEFAULT,
    disabled: DEFAULT,
    form: DEFAULT,
    index: DEFAULT,
    label: DEFAULT,
    selected: DEFAULT,
    text: DEFAULT,
    value: DEFAULT
  };
  var HTMLOutputElement$1 = {
    checkValidity: FUNCTION,
    defaultValue: DEFAULT,
    form: DEFAULT,
    htmlFor: DEFAULT,
    labels: DEFAULT,
    name: DEFAULT,
    reportValidity: FUNCTION,
    setCustomValidity: FUNCTION,
    type: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    value: DEFAULT,
    willValidate: DEFAULT
  };
  var HTMLParamElement$1 = {
    name: DEFAULT,
    type: DEFAULT,
    value: DEFAULT,
    valueType: DEFAULT
  };
  var HTMLProgressElement$1 = {
    labels: DEFAULT,
    max: DEFAULT,
    position: DEFAULT,
    value: DEFAULT
  };
  var HTMLQuoteElement$1 = {
    cite: DEFAULT
  };
  var HTMLScriptElement$1 = {
    src: DEFAULT,
    type: DEFAULT
  };
  var HTMLSelectElement$1 = {
    add: FUNCTION,
    autofocus: DEFAULT,
    checkValidity: FUNCTION,
    disabled: DEFAULT,
    form: DEFAULT,
    item: FUNCTION,
    labels: DEFAULT,
    length: DEFAULT,
    multiple: DEFAULT,
    name: DEFAULT,
    namedItem: FUNCTION,
    options: DEFAULT,
    remove: FUNCTION,
    reportValidity: FUNCTION,
    required: DEFAULT,
    selectedIndex: DEFAULT,
    selectedOptions: DEFAULT,
    setCustomValidity: FUNCTION,
    size: DEFAULT,
    type: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    value: DEFAULT,
    willValidate: DEFAULT
  };
  var HTMLSlotElement$1 = {
    assignedElements: FUNCTION,
    assignedNodes: FUNCTION,
    name: DEFAULT
  };
  var HTMLSourceElement$1 = {
    media: DEFAULT,
    sizes: DEFAULT,
    src: DEFAULT,
    srcset: DEFAULT,
    type: DEFAULT
  };
  var HTMLTableCellElement$1 = {
    abbr: DEFAULT,
    align: DEFAULT,
    axis: DEFAULT,
    bgColor: DEFAULT,
    cellIndex: DEFAULT,
    ch: DEFAULT,
    chOff: DEFAULT,
    colSpan: DEFAULT,
    headers: DEFAULT,
    height: DEFAULT,
    noWrap: DEFAULT,
    rowSpan: DEFAULT,
    scope: DEFAULT,
    vAlign: DEFAULT,
    width: DEFAULT
  };
  var HTMLTableElement$1 = {
    caption: DEFAULT,
    tHead: SKIP_OPAQUE,
    tFoot: SKIP_OPAQUE,
    tBodies: DEFAULT,
    createTHead: FUNCTION_TRUST_RETURN_VALUE,
    deleteTHead: FUNCTION,
    createTFoot: FUNCTION_TRUST_RETURN_VALUE,
    deleteTFoot: FUNCTION,
    createCaption: FUNCTION_TRUST_RETURN_VALUE,
    deleteCaption: FUNCTION,
    rows: DEFAULT,
    insertRow: FUNCTION_TRUST_RETURN_VALUE,
    deleteRow: FUNCTION,
    width: DEFAULT
  };
  var HTMLTableRowElement$1 = {
    cells: DEFAULT,
    rowIndex: DEFAULT,
    sectionRowIndex: DEFAULT,
    insertCell: FUNCTION_TRUST_RETURN_VALUE,
    deleteCell: FUNCTION
  };
  var HTMLTableSectionElement$1 = {
    rows: DEFAULT,
    insertRow: FUNCTION_TRUST_RETURN_VALUE,
    deleteRow: FUNCTION
  };
  var HTMLTemplateElement$1 = {
    content: DEFAULT
  };
  var HTMLTextAreaElement$1 = {
    autocapitalize: DEFAULT,
    autofocus: DEFAULT,
    checkValidity: FUNCTION,
    cols: DEFAULT,
    defaultValue: DEFAULT,
    dirName: DEFAULT,
    disabled: DEFAULT,
    form: DEFAULT,
    labels: DEFAULT,
    maxLength: DEFAULT,
    minLength: DEFAULT,
    name: DEFAULT,
    placeholder: DEFAULT,
    readOnly: DEFAULT,
    reportValidity: FUNCTION,
    required: DEFAULT,
    rows: DEFAULT,
    select: FUNCTION,
    selectionDirection: DEFAULT,
    selectionEnd: DEFAULT,
    selectionStart: DEFAULT,
    setCustomValidity: FUNCTION,
    setRangeText: FUNCTION,
    setSelectionRange: FUNCTION,
    textLength: DEFAULT,
    type: DEFAULT,
    validationMessage: DEFAULT,
    validity: DEFAULT,
    value: DEFAULT,
    willValidate: DEFAULT,
    wrap: DEFAULT
  };
  var HTMLTrackElement$1 = {
    ERROR: DEFAULT,
    LOADED: DEFAULT,
    LOADING: DEFAULT,
    NONE: DEFAULT,
    default: DEFAULT,
    kind: DEFAULT,
    label: DEFAULT,
    readyState: DEFAULT,
    src: DEFAULT,
    srclang: DEFAULT,
    track: DEFAULT
  };
  var HTMLUnknownElement = {};
  var HTMLVideoElement$1 = {
    height: DEFAULT,
    poster: DEFAULT,
    videoHeight: DEFAULT,
    videoWidth: DEFAULT,
    width: DEFAULT
  };
  var Node$1 = {
    ATTRIBUTE_NODE: DEFAULT,
    CDATA_SECTION_NODE: DEFAULT,
    COMMENT_NODE: DEFAULT,
    DOCUMENT_FRAGMENT_NODE: DEFAULT,
    DOCUMENT_NODE: DEFAULT,
    DOCUMENT_POSITION_CONTAINED_BY: DEFAULT,
    DOCUMENT_POSITION_CONTAINS: DEFAULT,
    DOCUMENT_POSITION_DISCONNECTED: DEFAULT,
    DOCUMENT_POSITION_FOLLOWING: DEFAULT,
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: DEFAULT,
    DOCUMENT_POSITION_PRECEDING: DEFAULT,
    DOCUMENT_TYPE_NODE: DEFAULT,
    ELEMENT_NODE: DEFAULT,
    ENTITY_NODE: DEFAULT,
    ENTITY_REFERENCE_NODE: DEFAULT,
    NOTATION_NODE: DEFAULT,
    PROCESSING_INSTRUCTION_NODE: DEFAULT,
    TEXT_NODE: DEFAULT,
    appendChild: FUNCTION,
    baseURI: READ_ONLY_PROPERTY,
    childNodes: READ_ONLY_PROPERTY,
    cloneNode: FUNCTION,
    compareDocumentPosition: FUNCTION_RAW_ARGS,
    contains: FUNCTION_RAW_ARGS,
    firstChild: SKIP_OPAQUE,
    getRootNode: FUNCTION,
    hasChildNodes: FUNCTION,
    insertBefore: FUNCTION,
    isDefaultNamespace: FUNCTION,
    isConnected: READ_ONLY_PROPERTY,
    isEqualNode: FUNCTION_RAW_ARGS,
    isSameNode: FUNCTION_RAW_ARGS,
    lastChild: SKIP_OPAQUE,
    // localName (NULL!) Obsolete: https://developer.mozilla.org/en-US/docs/Web/API/Node/localName
    lookupNamespaceURI: FUNCTION,
    lookupPrefix: FUNCTION,
    // namespaceURI (NULL!) Obsolete: https://developer.mozilla.org/en-US/docs/Web/API/Node/namespaceURI
    nextSibling: SKIP_OPAQUE,
    nodeName: READ_ONLY_PROPERTY,
    nodeType: READ_ONLY_PROPERTY,
    nodeValue: DEFAULT,
    normalize: FUNCTION,
    ownerDocument: READ_ONLY_PROPERTY,
    parentElement: SKIP_OPAQUE,
    parentNode: SKIP_OPAQUE,
    previousSibling: SKIP_OPAQUE,
    removeChild: FUNCTION,
    replaceChild: FUNCTION,
    textContent: DEFAULT
  };
  var SVGAngle$1 = {
    unitType: DEFAULT,
    value: DEFAULT,
    valueInSpecifiedUnits: DEFAULT,
    valueAsString: DEFAULT,
    newValueSpecifiedUnits: FUNCTION,
    convertToSpecifiedUnits: FUNCTION
  };
  var SVGAnimatedAngle$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedBoolean$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedEnumeration$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedInteger$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedLength$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedLengthList$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedNumber$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedNumberList$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedPreserveAspectRatio$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedRect$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedString$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimatedTransformList$1 = {
    baseVal: DEFAULT,
    animVal: DEFAULT
  };
  var SVGAnimationElement$1 = {
    targetElement: SKIP_OPAQUE,
    getCurrentTime: FUNCTION,
    getSimpleDuration: FUNCTION
  };
  var SVGCircleElement$1 = {
    cx: DEFAULT,
    cy: DEFAULT,
    r: DEFAULT
  };
  var SVGClipPathElement$1 = {
    clipPathUnits: DEFAULT
  };
  var SVGElement$1 = {
    blur: FUNCTION,
    dataset: DEFAULT,
    focus: FUNCTION,
    getBBox: FUNCTION,
    ownerSVGElement: SKIP_OPAQUE,
    onabort: EVENT,
    onblur: EVENT,
    oncancel: EVENT,
    oncanplay: EVENT,
    oncanplaythrough: EVENT,
    onchange: EVENT,
    onclick: EVENT,
    onclose: EVENT,
    oncontextmenu: EVENT,
    oncuechange: EVENT,
    ondblclick: EVENT,
    ondrag: EVENT,
    ondragend: EVENT,
    ondragenter: EVENT,
    ondragleave: EVENT,
    ondragover: EVENT,
    ondragstart: EVENT,
    ondrop: EVENT,
    ondurationchange: EVENT,
    onemptied: EVENT,
    onended: EVENT,
    onerror: EVENT,
    onfocus: EVENT,
    oninput: EVENT,
    oninvalid: EVENT,
    onkeydown: EVENT,
    onkeypress: EVENT,
    onkeyup: EVENT,
    onload: EVENT,
    onloadeddata: EVENT,
    onloadedmetadata: EVENT,
    onloadstart: EVENT,
    onmousedown: EVENT,
    onmouseenter: EVENT,
    onmouseleave: EVENT,
    onmousemove: EVENT,
    onmouseout: EVENT,
    onmouseover: EVENT,
    onmouseup: EVENT,
    onmousewheel: EVENT,
    onpause: EVENT,
    onplay: EVENT,
    onplaying: EVENT,
    onprogress: EVENT,
    onratechange: EVENT,
    onreset: EVENT,
    onresize: EVENT,
    onscroll: EVENT,
    onseeked: EVENT,
    onseeking: EVENT,
    onselect: EVENT,
    onshow: EVENT,
    onstalled: EVENT,
    onsubmit: EVENT,
    onsuspend: EVENT,
    ontimeupdate: EVENT,
    ontoggle: EVENT,
    ontouchcancel: EVENT,
    ontouchend: EVENT,
    ontouchmove: EVENT,
    ontouchstart: EVENT,
    onvolumechange: EVENT,
    onwaiting: EVENT,
    style: DEFAULT,
    tabIndex: DEFAULT,
    viewportElement: SKIP_OPAQUE
  };
  var SVGEllipseElement$1 = {
    cx: DEFAULT,
    cy: DEFAULT,
    rx: DEFAULT,
    ry: DEFAULT
  };
  var SVGFilterElement$1 = {
    filterUnits: DEFAULT,
    primitiveUnits: DEFAULT,
    x: DEFAULT,
    y: DEFAULT,
    width: DEFAULT,
    height: DEFAULT,
    filterResX: DEFAULT,
    fitlerResY: DEFAULT
  };
  var SVGForeignObjectElement$1 = {
    height: DEFAULT,
    width: DEFAULT,
    x: DEFAULT,
    y: DEFAULT
  };
  var SVGGeometryElement$1 = {
    pathLength: DEFAULT,
    isPointInFill: FUNCTION,
    isPointInStroke: FUNCTION,
    getTotalLength: FUNCTION,
    getPointAtLength: FUNCTION
  };
  var SVGGradientElement$1 = {
    gradientUnits: DEFAULT,
    gradientTransform: DEFAULT,
    spreadMethod: DEFAULT
  };
  var SVGGraphicsElement$1 = {
    transform: DEFAULT,
    getBBox: FUNCTION,
    getCTM: FUNCTION,
    getScreenCTM: FUNCTION
  };
  var SVGImageElement$1 = {
    x: DEFAULT,
    y: DEFAULT,
    width: DEFAULT,
    height: DEFAULT,
    preserveAspectRatio: DEFAULT,
    crossOrigin: DEFAULT
  };
  var SVGLength$1 = {
    SVG_LENGTHTYPE_UNKNOWN: DEFAULT,
    SVG_LENGTHTYPE_NUMBER: DEFAULT,
    SVG_LENGTHTYPE_PERCENTAGE: DEFAULT,
    SVG_LENGTHTYPE_EMS: DEFAULT,
    SVG_LENGTHTYPE_EXS: DEFAULT,
    SVG_LENGTHTYPE_PX: DEFAULT,
    SVG_LENGTHTYPE_CM: DEFAULT,
    SVG_LENGTHTYPE_MM: DEFAULT,
    SVG_LENGTHTYPE_IN: DEFAULT,
    SVG_LENGTHTYPE_PT: DEFAULT,
    SVG_LENGTHTYPE_PC: DEFAULT,
    unitType: DEFAULT,
    value: DEFAULT,
    valueInSpecifiedUnits: DEFAULT,
    valueAsString: DEFAULT,
    newValueSpecifiedUnits: FUNCTION,
    convertToSpecifiedUnits: FUNCTION
  };
  var SVGLengthList$1 = {
    numberOfItem: DEFAULT,
    clear: FUNCTION,
    initialize: FUNCTION,
    getItem: SKIP_OPAQUE,
    insertItemBefore: FUNCTION,
    replaceItem: FUNCTION,
    removeItem: SKIP_OPAQUE,
    appendItem: FUNCTION
  };
  var SVGLineElement$1 = {
    x1: DEFAULT,
    x2: DEFAULT,
    y1: DEFAULT,
    y2: DEFAULT
  };
  var SVGLinearGradientElement$1 = {
    x1: DEFAULT,
    x2: DEFAULT,
    y1: DEFAULT,
    y2: DEFAULT
  };
  var SVGMaskElement$1 = {
    height: DEFAULT,
    maskContentUnits: DEFAULT,
    maskUnits: DEFAULT,
    width: DEFAULT,
    x: DEFAULT,
    y: DEFAULT
  };
  var SVGNumber$1 = {
    value: DEFAULT
  };
  var SVGNumberList$1 = {
    appendItem: FUNCTION,
    clear: FUNCTION,
    getItem: SKIP_OPAQUE,
    initialize: FUNCTION,
    insertItemBefore: FUNCTION,
    numberOfItem: DEFAULT,
    removeItem: SKIP_OPAQUE,
    replaceItem: FUNCTION
  };
  var SVGPatternElement$1 = {
    x: DEFAULT,
    y: DEFAULT,
    width: DEFAULT,
    height: DEFAULT,
    patternUnits: DEFAULT,
    patternContentUnits: DEFAULT,
    patternTransform: DEFAULT
  };
  var SVGPreserveAspectRatio$1 = {
    align: DEFAULT,
    meetOrSlice: DEFAULT,
    SVG_PRESERVEASPECTRATIO_UNKNOWN: DEFAULT,
    SVG_PRESERVEASPECTRATIO_NONE: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMINYMIN: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMIDYMIN: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMAXYMIN: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMINYMID: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMIDYMID: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMAXYMID: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMINYMAX: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMIDYMAX: DEFAULT,
    SVG_PRESERVEASPECTRATIO_XMAXYMAX: DEFAULT,
    SVG_MEETORSLICE_UNKNOWN: DEFAULT,
    SVG_MEETORSLICE_MEET: DEFAULT,
    SVG_MEETORSLICE_SLICE: DEFAULT
  };
  var SVGRadialGradientElement$1 = {
    cx: DEFAULT,
    cy: DEFAULT,
    r: DEFAULT,
    fx: DEFAULT,
    fy: DEFAULT
  };
  var SVGRect$1 = {
    x: DEFAULT,
    y: DEFAULT,
    width: DEFAULT,
    height: DEFAULT
  };
  var SVGRectElement$1 = {
    x: DEFAULT,
    y: DEFAULT,
    width: DEFAULT,
    height: DEFAULT,
    rx: DEFAULT,
    ry: DEFAULT
  };
  var SVGSVGElement$1 = {
    animationsPaused: FUNCTION,
    checkIntersection: FUNCTION,
    checkEnclosure: FUNCTION,
    contentScriptType: DEFAULT,
    contentStyleType: DEFAULT,
    createSVGAngle: FUNCTION,
    createSVGLength: FUNCTION,
    createSVGMatrix: FUNCTION,
    createSVGNumber: FUNCTION,
    createSVGPoint: FUNCTION,
    createSVGRect: FUNCTION,
    createSVGTransform: FUNCTION,
    createSVGTransformFromMatrix: FUNCTION,
    currentScale: DEFAULT,
    currentTranslate: DEFAULT,
    currentView: DEFAULT,
    forceRedraw: FUNCTION,
    height: DEFAULT,
    pauseAnimations: FUNCTION,
    pixelUnitToMillimeterX: DEFAULT,
    pixelUnitToMillimeterY: DEFAULT,
    getCurrentTime: FUNCTION,
    getEnclosureList: FUNCTION,
    getElementById: FUNCTION,
    getIntersectionList: FUNCTION,
    screenPixelToMillimeterX: DEFAULT,
    screenPixelToMillimeterY: DEFAULT,
    setCurrentTime: FUNCTION,
    suspendRedraw: FUNCTION,
    unpauseAnimations: FUNCTION,
    unsuspendRedraw: FUNCTION,
    unsuspendRedrawAll: FUNCTION,
    useCurrentView: DEFAULT,
    viewport: DEFAULT,
    width: DEFAULT,
    x: DEFAULT,
    y: DEFAULT
  };
  var SVGScriptElement$1 = {
    crossOrigin: DEFAULT,
    type: DEFAULT
  };
  var SVGStopElement$1 = {
    offset: DEFAULT
  };
  var SVGStringList$1 = {
    numberOfItem: DEFAULT,
    clear: FUNCTION,
    initialize: FUNCTION,
    getItem: SKIP_OPAQUE,
    insertItemBefore: FUNCTION,
    replaceItem: FUNCTION,
    removeItem: SKIP_OPAQUE,
    appendItem: FUNCTION
  };
  var SVGStyleElement$1 = {
    type: DEFAULT,
    media: DEFAULT,
    title: DEFAULT
  };
  var SVGTextContentElement$1 = {
    LENGTHADJUST_UNKNOWN: DEFAULT,
    LENGTHADJUST_SPACING: DEFAULT,
    LENGTHADJUST_SPACINGANDGLYPHS: DEFAULT,
    textLength: DEFAULT,
    lengthAdjust: DEFAULT,
    getNumberOfChars: FUNCTION,
    getComputedTextLength: FUNCTION,
    getSubStringLength: FUNCTION,
    getStartPositionOfChar: FUNCTION,
    getEndPositionOfChar: FUNCTION,
    getExtentOfChar: FUNCTION,
    getRotationOfChar: FUNCTION,
    getCharNumAtPosition: FUNCTION
  };
  var SVGTextPositioningElement$1 = {
    x: DEFAULT,
    y: DEFAULT,
    dx: DEFAULT,
    dy: DEFAULT,
    rotate: DEFAULT
  };
  var SVGTransform$1 = {
    SVG_TRANSFORM_UNKNOWN: DEFAULT,
    SVG_TRANSFORM_MATRIX: DEFAULT,
    SVG_TRANSFORM_TRANSLATE: DEFAULT,
    SVG_TRANSFORM_SCALE: DEFAULT,
    SVG_TRANSFORM_ROTATE: DEFAULT,
    SVG_TRANSFORM_SKEWX: DEFAULT,
    SVG_TRANSFORM_SKEWY: DEFAULT,
    type: DEFAULT,
    angle: DEFAULT,
    matrix: DEFAULT,
    setMatrix: FUNCTION,
    setTranslate: FUNCTION,
    setScale: FUNCTION,
    setRotate: FUNCTION,
    setSkewX: FUNCTION,
    setSkewY: FUNCTION
  };
  var SVGTransformList$1 = {
    numberOfItem: DEFAULT,
    clear: FUNCTION,
    initialize: FUNCTION,
    getItem: SKIP_OPAQUE,
    insertItemBefore: FUNCTION,
    replaceItem: FUNCTION,
    removeItem: SKIP_OPAQUE,
    appendItem: FUNCTION,
    createSVGTransformFromMatrix: FUNCTION,
    consolidate: FUNCTION
  };
  var SVGURIReference = {
    href: DEFAULT
  };
  var SVGUseElement$1 = {
    x: DEFAULT,
    y: DEFAULT,
    width: DEFAULT,
    height: DEFAULT,
    instanceRoot: DEFAULT,
    animatedInstanceRoot: DEFAULT
  };
  var SVGViewElement$1 = {
    viewTarget: DEFAULT
  };
  var Text$1 = {
    assignedSlot: DEFAULT,
    isElementContentWhitespace: DEFAULT,
    replaceWholeText: FUNCTION,
    splitText: FUNCTION,
    wholeText: DEFAULT
  };
  var metadataView$3 = {
    prototypes: {
      Attr: Attr$1,
      CharacterData,
      DocumentFragment: DocumentFragment$1,
      DocumentType: DocumentType$1,
      Element: Element$1,
      EventTarget: EventTarget$1,
      HTMLAnchorElement: HTMLAnchorElement$1,
      HTMLAreaElement: HTMLAreaElement$1,
      HTMLAudioElement: HTMLAudioElement$1,
      HTMLBaseElement: HTMLBaseElement$1,
      HTMLButtonElement: HTMLButtonElement$1,
      HTMLCanvasElement: HTMLCanvasElement$1,
      HTMLDetailsElement: HTMLDetailsElement$1,
      HTMLElement: HTMLElement$1,
      HTMLEmbedElement: HTMLEmbedElement$1,
      HTMLFieldSetElement: HTMLFieldSetElement$1,
      HTMLFormElement: HTMLFormElement$1,
      HTMLIFrameElement: HTMLIFrameElement$1,
      HTMLImageElement: HTMLImageElement$1,
      HTMLInputElement: HTMLInputElement$1,
      HTMLLIElement: HTMLLIElement$1,
      HTMLLabelElement: HTMLLabelElement$1,
      HTMLLinkElement: HTMLLinkElement$1,
      HTMLMapElement: HTMLMapElement$1,
      HTMLMediaElement: HTMLMediaElement$1,
      HTMLMetaElement: HTMLMetaElement$1,
      HTMLMeterElement: HTMLMeterElement$1,
      HTMLModElement: HTMLModElement$1,
      HTMLOListElement: HTMLOListElement$1,
      HTMLObjectElement: HTMLObjectElement$1,
      HTMLOptGroupElement: HTMLOptGroupElement$1,
      HTMLOptionElement: HTMLOptionElement$1,
      HTMLOutputElement: HTMLOutputElement$1,
      HTMLParamElement: HTMLParamElement$1,
      HTMLProgressElement: HTMLProgressElement$1,
      HTMLQuoteElement: HTMLQuoteElement$1,
      HTMLScriptElement: HTMLScriptElement$1,
      HTMLSelectElement: HTMLSelectElement$1,
      HTMLSlotElement: HTMLSlotElement$1,
      HTMLSourceElement: HTMLSourceElement$1,
      HTMLTableCellElement: HTMLTableCellElement$1,
      HTMLTableElement: HTMLTableElement$1,
      HTMLTableRowElement: HTMLTableRowElement$1,
      HTMLTableSectionElement: HTMLTableSectionElement$1,
      HTMLTemplateElement: HTMLTemplateElement$1,
      HTMLTextAreaElement: HTMLTextAreaElement$1,
      HTMLTrackElement: HTMLTrackElement$1,
      HTMLUnknownElement,
      HTMLVideoElement: HTMLVideoElement$1,
      Node: Node$1,
      SVGAngle: SVGAngle$1,
      SVGAnimatedAngle: SVGAnimatedAngle$1,
      SVGAnimatedBoolean: SVGAnimatedBoolean$1,
      SVGAnimatedEnumeration: SVGAnimatedEnumeration$1,
      SVGAnimatedInteger: SVGAnimatedInteger$1,
      SVGAnimatedLength: SVGAnimatedLength$1,
      SVGAnimatedLengthList: SVGAnimatedLengthList$1,
      SVGAnimatedNumber: SVGAnimatedNumber$1,
      SVGAnimatedNumberList: SVGAnimatedNumberList$1,
      SVGAnimatedPreserveAspectRatio: SVGAnimatedPreserveAspectRatio$1,
      SVGAnimatedRect: SVGAnimatedRect$1,
      SVGAnimatedString: SVGAnimatedString$1,
      SVGAnimatedTransformList: SVGAnimatedTransformList$1,
      SVGAnimationElement: SVGAnimationElement$1,
      SVGCircleElement: SVGCircleElement$1,
      SVGClipPathElement: SVGClipPathElement$1,
      SVGElement: SVGElement$1,
      SVGEllipseElement: SVGEllipseElement$1,
      SVGFilterElement: SVGFilterElement$1,
      SVGForeignObjectElement: SVGForeignObjectElement$1,
      SVGGeometryElement: SVGGeometryElement$1,
      SVGGradientElement: SVGGradientElement$1,
      SVGGraphicsElement: SVGGraphicsElement$1,
      SVGImageElement: SVGImageElement$1,
      SVGLength: SVGLength$1,
      SVGLengthList: SVGLengthList$1,
      SVGLineElement: SVGLineElement$1,
      SVGLinearGradientElement: SVGLinearGradientElement$1,
      SVGMaskElement: SVGMaskElement$1,
      SVGNumber: SVGNumber$1,
      SVGNumberList: SVGNumberList$1,
      SVGPatternElement: SVGPatternElement$1,
      SVGPreserveAspectRatio: SVGPreserveAspectRatio$1,
      SVGRadialGradientElement: SVGRadialGradientElement$1,
      SVGRect: SVGRect$1,
      SVGRectElement: SVGRectElement$1,
      SVGSVGElement: SVGSVGElement$1,
      SVGScriptElement: SVGScriptElement$1,
      SVGStopElement: SVGStopElement$1,
      SVGStringList: SVGStringList$1,
      SVGStyleElement: SVGStyleElement$1,
      SVGTextContentElement: SVGTextContentElement$1,
      SVGTextPositioningElement: SVGTextPositioningElement$1,
      SVGTransform: SVGTransform$1,
      SVGTransformList: SVGTransformList$1,
      SVGURIReference,
      SVGUseElement: SVGUseElement$1,
      SVGViewElement: SVGViewElement$1,
      Text: Text$1
    }
  };

  /* eslint-enable import/no-cycle */

  function SecureDocumentType(documentType, key) {
    return SecureElement(documentType, key);
  }
  SecureDocumentType.setOverrides = function (descriptors) {
    descriptors.toString = {
      value: function () {
        const key = getKey(this);
        const raw = getRawThis(this);
        return `SecureDocumentType: ${raw} { key: ${stringify(key)} }`;
      }
    };
    descriptors[Symbol.toStringTag] = {
      configurable: true,
      value: 'DocumentType'
    };
    descriptors[Symbol.unscopables] = {
      configurable: true,
      enumerable: true,
      value: {
        __proto__: null,
        after: true,
        before: true,
        remove: true,
        replaceWith: true
      },
      writable: true
    };
  };
  SecureDocumentType.toString = function () {
    return 'SecureDocumentType() { [native code] }';
  };

  /* eslint-enable import/no-cycle */

  const CALLBACK_ERROR = `Failed to execute 'addEventListener' on 'EventTarget': The callback provided as parameter 2 is not an object.`;
  const KEY_EVENTS = {
    keydown: true,
    keyup: true,
    keypress: true
  };
  setPrototypeOf(KEY_EVENTS, null);
  function getWrappedEvent(e, key) {
    if (!e) {
      return e;
    }
    // If e is a wrapped event
    if (isProxy(e)) {
      // Wrapped with the required key, then nothing to do further
      if (getKey(e) === key) {
        return e;
      }
      assert.fail(`Received a wrapped event(key: ${getKey(e)}) from a different locker(key: ${key})`);
      // If the browser is calling your listener, then you have access to the event
      e = getRawThis(e);
    }
    return SecureDOMEvent(e, key);
  }
  function createSecureListener(st, listener, key) {
    // If the listener is a function, we need to ignore any
    // handleEvent property set on it.
    if (typeof listener === 'function') {
      return function (e) {
        verifyAccess(st, listener, true);
        const se = isObject(e) ? getWrappedEvent(e, key) : e;
        listener.call(st, se);
      };
    }
    if (typeof listener === 'object') {
      // capture the pointer to prevent shape-shifting
      const handleEvent = listener.handleEvent;
      if (typeof handleEvent === 'function') {
        return function (e) {
          verifyAccess(st, listener, true);
          const se = isObject(e) ? getWrappedEvent(e, key) : e;
          handleEvent.call(listener, se);
        };
      }
    }
    return undefined;
  }
  function getSecureListener(st, listener, key) {
    let sListener = getFromCache(listener, key);
    if (!sListener) {
      sListener = createSecureListener(st, listener, key);
      addToCache(listener, sListener, key);
      setKey(listener, key);
    }
    return sListener;
  }
  function createAddEventListenerDescriptor(st, el, key) {
    return {
      writable: true,
      value: function (event, listener, useCapture) {
        if (!listener) {
          return; // by spec, missing callback argument does not throw,
          // just ignores it.
        }

        if (Object(listener) !== listener) {
          throw new TypeError(CALLBACK_ERROR);
        }
        const sListener = getSecureListener(st, listener, key);
        el.addEventListener(event, sListener, useCapture);
      }
    };
  }
  function addEventTargetMethods(st, raw, key) {
    defineProperties(st, {
      addEventListener: createAddEventListenerDescriptor(st, raw, key),
      dispatchEvent: createFilteredMethod(st, raw, 'dispatchEvent', RAW_ARGS),
      // removeEventListener() is special in that we do not want to
      // unfilter/unwrap the listener argument or it will not match what
      // was actually wired up originally
      removeEventListener: {
        writable: true,
        value: function (type, listener, options) {
          const sCallback = getFromCache(listener, key);
          raw.removeEventListener(type, sCallback, options);
        }
      }
    });
  }
  function createAddEventListenerDescriptorStateless() {
    return {
      value: function (event, listener, useCapture) {
        if (!listener) {
          return; // by spec, missing callback argument does not throw,
          // just ignores it.
        }

        if (Object(listener) !== listener) {
          throw new TypeError(CALLBACK_ERROR);
        }
        const so = this;
        const el = getRawThis(so);
        const key = getKey(so);
        const sListener = getSecureListener(so, listener, key);
        el.addEventListener(event, sListener, useCapture);
      }
    };
  }
  function createEventTargetMethodsStateless(config, prototype) {
    config['addEventListener'] = createAddEventListenerDescriptorStateless();
    config['dispatchEvent'] = createFilteredMethodStateless('dispatchEvent', prototype, RAW_ARGS);

    // removeEventListener() is special in that we do not want to
    // unfilter/unwrap the listener argument or it will not match what
    // was actually wired up originally
    config['removeEventListener'] = {
      value: function (type, listener, options) {
        const raw = getRawThis(this);
        const sCallback = getFromCache(listener, getKey(this));
        raw.removeEventListener(type, sCallback, options);
      }
    };
  }

  /* eslint-enable import/no-cycle */

  function SecureIFrameContentWindow(w, key) {
    const cached = getFromCache(w, key);
    if (cached) {
      return cached;
    }
    const sms = SecureMessageEventSource(w, key);
    defineProperty(sms, 'toString', {
      value: function () {
        return `SecureIFrameContentWindow: ${w}{ key: ${JSON.stringify(key)} }`;
      }
    });
    addPropertyIfSupported(sms, w, 'parent');
    addMethodIfSupported(sms, w, 'focus');
    addPropertyIfSupported(sms, w, 'opener');
    addPropertyIfSupported(sms, w, 'closed', READ_ONLY_PROPERTY);
    setRef(sms, w, key);
    addToCache(w, sms, key);
    registerProxy(sms);
    return sms;
  }

  /* eslint-enable import/no-cycle */

  const iframeSrcGetter = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'src').get;
  const SecureIFrameElement = {
    addMethodsAndProperties: function (prototype) {
      defineProperties(prototype, {
        // Standard HTMLElement methods
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#Methods
        blur: createFilteredMethodStateless('blur', prototype),
        focus: createFilteredMethodStateless('focus', prototype),
        contentWindow: {
          get: function () {
            const raw = getRawThis(this);
            return raw.contentWindow ? SecureIFrameContentWindow(raw.contentWindow, getKey(this)) : raw.contentWindow;
          }
        },
        // W-4437391 Window access via encoded path segments.
        src: {
          get: function () {
            const raw = getRawThis(this);
            return iframeSrcGetter.call(raw);
          },
          set: function (url) {
            const urlString = sanitizeURLForElement(url);
            if (urlString.length > 0) {
              if (!isValidURLScheme(urlString)) {
                warn('SecureIframeElement.src supports http://, https:// schemes and relative urls.');
              } else {
                const raw = getRawThis(this);
                raw.src = urlString;
              }
            }
          }
        }
      });

      // Standard list of iframe's properties from:
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement
      // Note: Ignoring 'contentDocument', 'sandbox' and 'srcdoc' from the list above.
      fastArrayForEach(['height', 'width'], name => defineProperty(prototype, name, createFilteredPropertyStateless(name, prototype)));
    }
  };

  /* eslint-enable import/no-cycle */

  function SecureScriptElement() {}
  SecureScriptElement.setOverrides = function (elementOverrides, prototype) {
    function getAttributeName(name) {
      const lowercasedName = name.toLowerCase();
      switch (lowercasedName) {
        case 'src':
          return 'data-locker-src';
        case 'href':
          return 'data-locker-href';
        default:
          return name;
      }
    }
    function isAttributeAllowed(name) {
      // null, undefined, ''
      // allow a passthrough of these values
      if (!name) {
        return true;
      }
      return name.toLowerCase() !== 'xlink:href';
    }
    elementOverrides['src'] = {
      enumerable: true,
      get: function () {
        return this.getAttribute.apply(this, ['src']);
      },
      set: function (value) {
        this.setAttribute.apply(this, ['src', value]);
      }
    };
    const orignalGetAttribute = prototype.getAttribute;
    elementOverrides['getAttribute'] = {
      value: function (name) {
        return orignalGetAttribute.apply(this, [getAttributeName(name)]);
      }
    };
    const orignalSetAttribute = prototype.setAttribute;
    elementOverrides['setAttribute'] = {
      value: function (name, value) {
        if (isAttributeAllowed(name)) {
          orignalSetAttribute.apply(this, [getAttributeName(name), value]);
        }
      }
    };
    const orignalGetAttributeNS = prototype.getAttributeNS;
    elementOverrides['getAttributeNS'] = {
      value: function (ns, name) {
        return orignalGetAttributeNS.apply(this, [ns, getAttributeName(name)]);
      }
    };
    const orignalSetAttributeNS = prototype.setAttributeNS;
    elementOverrides['setAttributeNS'] = {
      value: function (ns, name, value) {
        if (isAttributeAllowed(name)) {
          orignalSetAttributeNS.apply(this, [ns, getAttributeName(name), value]);
        }
      }
    };
    const orignalGetAttributeNode = prototype.getAttributeNode;
    elementOverrides['getAttributeNode'] = {
      value: function (name) {
        return orignalGetAttributeNode.apply(this, [getAttributeName(name)]);
      }
    };
    const orignalGetAttributeNodeNS = prototype.getAttributeNodeNS;
    elementOverrides['getAttributeNodeNS'] = {
      value: function (ns, name) {
        return orignalGetAttributeNodeNS.apply(this, [ns, getAttributeName(name)]);
      }
    };
    const orignalSetAttributeNode = prototype.setAttributeNode;
    elementOverrides['setAttributeNode'] = {
      value: function (attr) {
        let raw = unwrap$1(this, attr);
        if (!raw) {
          // this will allow the browser to throw TypeError using native error messages
          orignalGetAttributeNode.call(this, raw);
        }

        /* We are interested in the value of the given attribute but we want
              to avoid executing any getters so we will clone it and attach it
              to a floating element which is not going to be a script tag.
              According to https://dev.w3.org/html5/spec-preview/the-script-element.html section 14
              some browsers may initiate fetching the script before it has been
              added to the DOM. Not using a script tag will prevent that. */
        const clone = raw.cloneNode();
        const normalizer = document.createElement('span');
        normalizer.setAttributeNode(clone);
        const attrNode = normalizer.attributes[0];
        switch (attrNode.name) {
          case 'xlink:href':
            {
              return undefined;
            }
          case 'src':
          case 'href':
            {
              raw = document.createAttribute(getAttributeName(attrNode.name));
              raw.value = attrNode.value;
              break;
            }
        }
        addToCache(raw, attr, getKey(attr));
        const replacedAttr = orignalSetAttributeNode.call(this, raw);
        return filterEverything(this, replacedAttr);
      }
    };
    elementOverrides['attributes'] = createFilteredPropertyStateless('attributes', prototype, {
      writable: false,
      afterGetCallback: function (attributes) {
        if (!attributes) {
          return attributes;
        }
        // Secure attributes
        const secureAttributes = [];
        const raw = getRawThis(this);
        for (let i = 0; i < attributes.length; i++) {
          const attribute = attributes[i];

          // Only add supported attributes
          if (isValidAttributeName(raw, attribute.name, prototype)) {
            let attributeName = attribute.name;
            if (attribute.name === 'src') {
              continue;
            }
            if (attribute.name === 'data-locker-src') {
              attributeName = 'src';
            }
            if (attribute.name === 'data-locker-href') {
              attributeName = 'href';
            }
            secureAttributes.push({
              name: attributeName,
              value: filterEverything(this, attribute.value)
            });
          }
        }
        return secureAttributes;
      }
    });
  };
  SecureScriptElement.run = function (st, parent = document.head) {
    const src = st.getAttribute('src');
    const href = st.getAttribute('href');
    const scriptUrl = src || href;
    if (!scriptUrl) {
      return;
    }
    const el = getRawThis(st);
    parent.appendChild(el);
    if (href && !(el instanceof SVGScriptElement)) {
      return;
    }

    // Get source using XHR and secure it using
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      const key = getKey(st);
      if (xhr.status === 200) {
        const code = xhr.responseText;
        try {
          evaluate(code, key, scriptUrl);
          el.dispatchEvent(new Event('load'));
        } catch (e) {
          warn(`Failed to load script at ${scriptUrl}: ${e.message}`);
          el.dispatchEvent(new Event('error'));
        }
      }
      // DCHASMAN TODO W-2837800 Add in error handling for 404's etc
    };

    xhr.open('GET', scriptUrl, true);

    // send credentials only when performing CORS requests
    // @TODO: this should be revisited once Locker has a proper configuration mechanism
    const normalized = document.createElement('a');
    normalized.href = scriptUrl;
    if (normalized.hostname.match(TRUSTED_DOMAINS)) {
      xhr.withCredentials = true;
    }
    xhr.send();
  };

  /* eslint-enable import/no-cycle */

  // Remove when SecureElement is refactored to use sandbox
  let shouldFreeze;
  let W5885703_domClobberingNameId;
  function setElementRealm(realmRec) {
    shouldFreeze = realmRec.shouldFreeze;
    W5885703_domClobberingNameId = realmRec.apiOptions.W5885703_domClobberingNameId;
  }
  function cloneFiltered(el, st) {
    const root = el.cloneNode(false);
    function cloneChildren(parent, parentClone) {
      const childNodes = parent.childNodes;
      const key = getKey(st);
      for (let i = 0; i < childNodes.length; i++) {
        const child = childNodes[i];
        if (hasAccess(st, child) || child.nodeType === Node.TEXT_NODE || isAccessibleLWCNode(key, child)) {
          const childClone = child.cloneNode(false);
          parentClone.appendChild(childClone);
          trust$1(st, childClone);
          cloneChildren(child, childClone);
        }
      }
    }
    cloneChildren(el, root);
    return root;
  }
  function runIfRunnable(st, parent) {
    if (st instanceof HTMLScriptElement || st instanceof SVGScriptElement) {
      st.type = asString(st.type);
      if (st.type === 'text/json') {
        return false;
      }
      SecureScriptElement.run(st, parent);
      return true;
    }
    return false;
  }
  function trustChildNodesRecursive(node, key) {
    const children = node.childNodes;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      setKey(child, key);
      trustChildNodesRecursive(child, key);
    }
  }
  function trustChildNodes(from, node) {
    const key = getKey(from);
    if (key) {
      const currentNode = node instanceof HTMLTemplateElement ? node.content : node;
      trustChildNodesRecursive(currentNode, key);
    }
  }
  const KEY_TO_PROTOTYPES = typeof Map !== 'undefined' ? new Map() : undefined;
  function propertyIsSupported(target, property) {
    // If the SecureElement prototype does not have the property directly on it then this
    // is an attempt to get a property that we do not support
    return ObjectHasOwnProperty(getPrototypeOf(target), property);
  }
  function SecureElement(el, key) {
    let o = getFromCache(el, key);
    if (o) {
      return o;
    }

    // A secure element can have multiple forms, this block allows us to apply
    // some polymorphic behavior to SecureElement depending on the tagName
    let tagName = el.tagName && el.tagName.toUpperCase();
    switch (tagName) {
      case 'FRAME':
        throw new error('The deprecated FRAME element is not supported in LockerService!');
      // no default
    }

    // SecureElement is it then!

    // Lazily create and cache tag name specific prototype
    switch (el.nodeType) {
      case Node.TEXT_NODE:
        tagName = '#text';
        break;
      case Node.DOCUMENT_FRAGMENT_NODE:
        tagName = '#fragment';
        break;
      case Node.DOCUMENT_TYPE_NODE:
        tagName = '#document-type';
        break;
      case Node.ATTRIBUTE_NODE:
        tagName = 'Attr';
        break;
      case Node.COMMENT_NODE:
        tagName = '#comment';
        break;
      // no default
    }

    // Segregate prototypes by their locker
    let prototypes = KEY_TO_PROTOTYPES.get(key);
    if (!prototypes) {
      prototypes = new Map();
      KEY_TO_PROTOTYPES.set(key, prototypes);
    }
    let prototypeInfo = prototypes.get(tagName);
    if (!prototypeInfo) {
      const basePrototype = getPrototypeOf(el);
      const expandoCapturingHandler = {
        get: function (target, property) {
          // Deyan: TODO W-4808252, is this fine? custom element
          if (property in basePrototype || property in target) {
            // if (property in basePrototype) {
            return property in target ? target[property] : undefined;
          }

          // Expando - retrieve it from a private locker scoped object
          const raw = getRef(target, key);
          const data = getData(raw, key);
          return data ? data[property] : undefined;
        },
        set: function (target, property, value) {
          // Deyan: TODO W-4808252, is this fine? custom element
          if (property in basePrototype || property in target) {
            // if (property in basePrototype) {
            if (!propertyIsSupported(target, property)) {
              warn(`SecureElement does not allow access to ${property}`);
              // setters on proxy trap must return true or throw
              return true;
            }
            target[property] = value;
            return true;
          }

          // Expando - store it from a private locker scoped object
          const raw = getRef(target, key);

          // SELECT elements allow options to be specified in array assignment style
          if (raw instanceof HTMLSelectElement && !Number.isNaN(Number(property))) {
            const rawOption = getRef(value, key);
            raw[property] = rawOption;
            return value;
          }
          let data = getData(raw, key);
          if (!data) {
            data = {};
            setData(raw, key, data);
          }
          data[property] = value;
          return true;
        },
        has: function (target, property) {
          if (property in basePrototype) {
            return true;
          }
          const raw = getRef(target, key);
          const data = getData(raw, key);
          return !!data && property in data;
        },
        deleteProperty: function (target, property) {
          const raw = getRef(target, key);
          const data = getData(raw, key);
          if (data && property in data) {
            return delete data[property];
          }
          return delete target[property];
        },
        ownKeys: function (target) {
          const raw = getRef(target, key);
          const data = getData(raw, key);
          let result = ownKeys(raw);
          if (data) {
            const set = new Set(result);
            const keys = ownKeys(data);
            for (let i = 0; i < keys.length; i++) {
              set.add(keys[i]);
            }
            result = [];
            set.forEach(value => {
              result.push(value);
            });
          }
          return result;
        },
        getOwnPropertyDescriptor: function (target, property) {
          let desc = getOwnPropertyDescriptor(target, property);
          if (!desc) {
            const raw = getRef(target, key);
            const data = getData(raw, key);
            desc = data ? getOwnPropertyDescriptor(data, property) : undefined;
          }
          return desc;
        },
        getPrototypeOf: function () {
          if (shouldFreeze && !isFrozen(basePrototype)) {
            deepFreeze(basePrototype);
          }
          return basePrototype;
        },
        setPrototypeOf: function () {
          throw new Error(`Illegal attempt to set the prototype of: ${basePrototype}`);
        }
      };

      // "class", "id", etc global attributes are special because they do not directly correspond to any property
      const caseInsensitiveAttributes = {
        class: true,
        contextmenu: true,
        dropzone: true,
        id: true,
        role: true
      };
      const prototype = function () {
        function SecureElementPrototype() {}
        SecureElementPrototype.prototype['tagName'] = tagName;
        const sep = new SecureElementPrototype();
        sep.constructor = function () {
          throw new TypeError('Illegal constructor');
        };
        return sep;
      }();

      // Allow React to register spies on input nodes
      // See inputValueTracking.js
      // https://github.com/facebook/react/blob/master/packages/react-dom/src/client/inputValueTracking.js
      fastArrayForEach(['checked', 'value'], prop => {
        let elementProto = {};
        // @TODO: W-5143278 bug on lwc, remove try catch after bug is fixed
        try {
          elementProto = el.constructor.prototype;
        } catch (e) {
          elementProto = lwcUnwrap(el).constructor.prototype;
        }
        // End TODO: W-5143278
        const descriptor = getOwnPropertyDescriptor(elementProto, prop);
        if (descriptor) {
          defineProperty(prototype.constructor.prototype, prop, {
            configurable: descriptor.configurable,
            enumerable: true,
            get: function () {
              const rawEl = getRawThis(this);
              return filterEverything(this, rawEl[prop]);
            },
            set: function (value) {
              const rawEl = getRawThis(this);
              rawEl[prop] = filterEverything(this, value);
            }
          });
        }
      });

      // Override standard methods and properties derived from Node interface
      SecureElement.addStandardNodeMethodAndPropertyOverrides(prototype);
      // Override standard methods and properties derived from Element interface
      if (el instanceof Element) {
        SecureElement.addStandardElementMethodAndPropertyOverrides(prototype, caseInsensitiveAttributes, key);
      }
      const prototypicalInstance = create$1(prototype);
      setRef(prototypicalInstance, el, key);
      if (tagName === 'IFRAME') {
        SecureIFrameElement.addMethodsAndProperties(prototype);
      }
      let tagNameSpecificConfig = addPrototypeMethodsAndPropertiesStateless(metadataView$3, prototypicalInstance, prototype);

      // Conditionally add things that not all Node types support
      if ('attributes' in el) {
        tagNameSpecificConfig['attributes'] = createFilteredPropertyStateless('attributes', prototype, {
          writable: false,
          afterGetCallback: function (attributes) {
            if (!attributes) {
              return attributes;
            }
            return createProxyForNamedNodeMap(attributes, key, prototype, caseInsensitiveAttributes);
          }
        });
      }
      if ('innerText' in el) {
        tagNameSpecificConfig['innerText'] = {
          get: function () {
            /*
             * innerText changes it's return value based on style and whether the element is live in
             * the DOM or not. This implementation does not account for that and simply returns the
             * innerText of the cloned node. This may cause subtle differences, such as missing newlines,
             * from the original implementation.
             *
             * https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#Differences_from_innerText
             */
            const rawEl = getRawThis(this);
            const filtered = cloneFiltered(rawEl, o);
            const ret = filtered.innerText;
            return ret;
          },
          set: function (value) {
            const raw = getRawThis(this);
            if (isSharedElement(raw)) {
              throw new error(`SecureElement.innerText cannot be used with ${raw.tagName} elements!`);
            }
            raw.innerText = value;
            trustChildNodes(this, raw);
          }
        };
      }
      if ('innerHTML' in el) {
        tagNameSpecificConfig['innerHTML'] = {
          get: function () {
            return cloneFiltered(getRawThis(this), o).innerHTML;
          },
          set: function (value) {
            const raw = getRawThis(this);
            // Do not allow innerHTML on shared elements (body/head)
            if (isSharedElement(raw)) {
              throw new error(`SecureElement.innerHTML cannot be used with ${raw.tagName} elements!`);
            }
            raw.innerHTML = raw instanceof SVGElement ? sanitizeSvgInnerHTML(raw, value) : sanitizeDefault(value);
            trustChildNodes(this, raw);
          }
        };
      }
      if (tagName === 'TEMPLATE') {
        tagNameSpecificConfig['content'] = {
          get: function () {
            const raw = getRawThis(this);
            const documentFragment = raw.content;
            return SecureElement(documentFragment, getKey(this));
          },
          set: function (value) {
            return value;
          }
        };
      }
      // Reason: W-3564204 Web Components HTML imports only supported in Chrome.
      if (tagName === 'LINK') {
        const descriptors = createDescriptors$2(prototype);
        tagNameSpecificConfig = assign(tagNameSpecificConfig, descriptors);
      }

      // special handling for Text.splitText() instead of creating a new secure wrapper
      if (tagName === '#text' && 'splitText' in el) {
        tagNameSpecificConfig['splitText'] = {
          value: function (index) {
            const raw = getRawThis(this);
            const newNode = raw.splitText(index);
            const fromKey = getKey(raw);
            if (fromKey) {
              setKey(newNode, fromKey);
            }
            return SecureElement(newNode, getKey(this));
          }
        };
      }
      if ('outerHTML' in el) {
        tagNameSpecificConfig['outerHTML'] = {
          get: function () {
            return cloneFiltered(getRawThis(this), o).outerHTML;
          },
          set: function (value) {
            const raw = getRawThis(this);
            // Do not allow on shared elements (body/head)
            if (isSharedElement(raw)) {
              throw new error(`SecureElement.outerHTML cannot be used with ${raw.tagName} elements!`);
            }
            const parent = raw.parentElement;

            // As per specifications, throw when there is no parent
            if (!parent) {
              throw new DOMException(`Failed to set the 'outerHTML' property on ${raw.tagName}: This element has no parent node.`);
            }

            // Setting outerHTML on an element removes it from the document tree.
            // It returns no handle to trust the new elements. Here we create the
            // elements in a fragment then insert them in their proper location.
            const template = document.createElement('template');
            template.innerHTML = sanitizeDefault(value);
            const content = template.content;
            trustChildNodes(this, content);
            while (content.childNodes.length > 0) {
              const node = content.childNodes[0];
              parent.insertBefore(node, raw);
            }
            parent.removeChild(raw);
          }
        };
      }

      // special handling for Text.splitText() instead of creating a new secure wrapper
      if (tagName === '#text' && 'splitText' in el) {
        tagNameSpecificConfig['splitText'] = {
          value: function (index) {
            const raw = getRawThis(this);
            const newNode = raw.splitText(index);
            const fromKey = getKey(raw);
            if (fromKey) {
              setKey(newNode, fromKey);
            }
            return SecureElement(newNode, getKey(this));
          }
        };
      }

      // special handle insertRow since it may automatically also insert a <tbody> element that
      // also needs to be keyed.
      if ('insertRow' in el && el instanceof HTMLTableElement) {
        tagNameSpecificConfig['insertRow'] = {
          value: function (index) {
            function getFirstTBody(table) {
              for (let i = 0; i < table.childNodes.length; i++) {
                const node = table.childNodes[i];
                if (node instanceof HTMLTableSectionElement) {
                  return node;
                }
              }
              return undefined;
            }
            const raw = getRawThis(this);
            const tbodyExists = !!getFirstTBody(raw);
            const newRow = raw.insertRow(index);
            trust$1(this, newRow);
            if (!tbodyExists) {
              // a new tbody element has also been inserted, key that too.
              const tbody = getFirstTBody(raw);
              trust$1(this, tbody);
            }
            return SecureElement(newRow, getKey(this));
          }
        };
      }
      createEventTargetMethodsStateless(tagNameSpecificConfig, prototype);
      if (tagName === '#document-type') {
        SecureDocumentType.setOverrides(tagNameSpecificConfig, prototype);
      }
      if (tagName === 'SCRIPT') {
        SecureScriptElement.setOverrides(tagNameSpecificConfig, prototype);
      }
      if (tagName === 'USE') {
        assign(tagNameSpecificConfig, createDescriptors$1(prototype, el));
      }
      if (tagName === 'SET') {
        assign(tagNameSpecificConfig, createDescriptors(prototype));
      }

      // Custom Element with properties
      // an Attr object does not have a tagName
      if (tagName && isCustomElement(tagName) && customElementHook$1) {
        customElementHook$1(el, prototype, tagNameSpecificConfig);
      }
      if (!ObjectHasOwnProperty(tagNameSpecificConfig, 'toString')) {
        tagNameSpecificConfig.toString = {
          value: function () {
            const e = getRawThis(this);
            return `SecureElement: ${e}{ key: ${JSON.stringify(getKey(this))} }`;
          }
        };
      }
      defineProperties(prototype, tagNameSpecificConfig);
      for (const propertyName in tagNameSpecificConfig) {
        if (ObjectHasOwnProperty(tagNameSpecificConfig, propertyName)) {
          const descriptor = tagNameSpecificConfig[propertyName];
          if (ObjectHasOwnProperty(descriptor, 'value')) {
            const {
              value
            } = descriptor;
            if (typeof value === 'function') {
              maskToString(value, propertyName);
            }
          }
        }
      }

      // Build case insensitive index for attribute validation
      fastArrayForEach(getOwnPropertyNames(prototype), k => {
        const lower = k.toLowerCase();
        if (lower !== k) {
          caseInsensitiveAttributes[lower] = true;
        }
      });
      prototypeInfo = {
        prototype: prototype,
        expandoCapturingHandler: expandoCapturingHandler
      };
      prototypes.set(tagName, prototypeInfo);
    }

    /*
     * Additional checks for <object> and <embed> tag, restrict access to browser navigation and
     * browser interaction APIs
     * https://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS1EFE2EDA-026D-4d14-864E-79DFD56F87C6.html#WS5b3ccc516d4fbf351e63e3d118a9b90204-7c5b
     */
    if (tagName === 'OBJECT' || tagName === 'EMBED') {
      el.setAttribute('allowNetworking', 'none');
    }
    o = create$1(prototypeInfo.prototype);
    if (prototypeInfo.expandoCapturingHandler) {
      setRef(o, el, key);
      o = new Proxy(o, prototypeInfo.expandoCapturingHandler);
    }
    setRef(o, el, key);
    addToCache(el, o, key);
    registerProxy(o);
    return o;
  }
  SecureElement.addStandardNodeMethodAndPropertyOverrides = function (prototype) {
    const descriptors = {
      appendChild: {
        writable: true,
        value(child) {
          const e = getRawThis(this);
          if (!runIfRunnable(child, e)) {
            e.appendChild(getRef(child, getKey(this), true));
          }
          return child;
        }
      },
      replaceChild: {
        writable: true,
        value(newChild, oldChild) {
          const e = getRawThis(this);
          if (!runIfRunnable(newChild, e)) {
            const k = getKey(this);
            e.replaceChild(getRef(newChild, k, true), getRef(oldChild, k, true));
          }
          return oldChild;
        }
      },
      insertBefore: {
        writable: true,
        value(newNode, referenceNode) {
          const e = getRawThis(this);
          if (!runIfRunnable(newNode, e)) {
            const k = getKey(this);
            e.insertBefore(getRef(newNode, k, true), referenceNode ? getRef(referenceNode, k, true) : null);
          }
          return newNode;
        }
      },
      removeChild: createFilteredMethodStateless('removeChild', prototype, createOptions(RAW_ARGS, {
        beforeCallback: function (child) {
          // Verify that the passed in child is not opaque!
          verifyAccess(this, child, true);
        }
      })),
      cloneNode: {
        writable: true,
        value(deep) {
          function copyKeys(from, to) {
            // Copy keys from the original to the cloned tree
            const fromKey = getKey(from);
            if (fromKey) {
              setKey(to, fromKey);
            }
            const toChildren = to.childNodes;
            const fromChildren = from.childNodes;
            const toLength = toChildren.length;
            const fromLength = fromChildren.length;
            for (let i = 0; i < toLength && i < fromLength; i++) {
              copyKeys(fromChildren[i], toChildren[i]);
            }
          }
          const e = getRawThis(this);
          const root = e.cloneNode(deep);

          // Maintain the same ownership in the cloned subtree
          copyKeys(e, root);
          return SecureElement(root, getKey(this));
        }
      },
      textContent: {
        get() {
          return cloneFiltered(getRawThis(this), this).textContent;
        },
        set(value) {
          const raw = getRawThis(this);
          if (isSharedElement(raw)) {
            throw new error(`SecureElement.textContent cannot be used with ${raw.tagName} elements!`);
          }
          raw.textContent = value;
          trustChildNodes(this, raw);
        }
      },
      hasChildNodes: {
        value() {
          const raw = getRawThis(this);
          // If this is a shared element, delegate the call to the shared element, no need to check for access
          if (isSharedElement(raw)) {
            return raw.hasChildNodes();
          }
          const childNodes = raw.childNodes;
          const key = getKey(this);
          for (let i = 0; i < childNodes.length; i++) {
            if (hasAccess(this, childNodes[i]) || isAccessibleLWCNode(key, childNodes[i])) {
              return true;
            }
          }
          return false;
        }
      }
    };
    defineProperties(prototype, descriptors);
    for (const propertyName in descriptors) {
      if (ObjectHasOwnProperty(descriptors, propertyName)) {
        const descriptor = descriptors[propertyName];
        if (ObjectHasOwnProperty(descriptor, 'value')) {
          const {
            value
          } = descriptor;
          if (typeof value === 'function') {
            maskToString(value, propertyName);
          }
        }
      }
    }
  };
  SecureElement.addStandardElementMethodAndPropertyOverrides = function (prototype, caseInsensitiveAttributes, key) {
    const descriptors = {
      querySelector: {
        writable: true,
        value: function (selector) {
          const raw = getRawThis(this);
          return SecureElement.secureQuerySelector(raw, getKey(this), selector);
        }
      },
      insertAdjacentHTML: {
        writable: true,
        value: function (position, text) {
          const raw = getRawThis(this);

          // Do not allow insertAdjacentHTML on shared elements (body/head)
          if (isSharedElement(raw)) {
            throw new error(`SecureElement.insertAdjacentHTML cannot be used with ${raw.tagName} elements!`);
          }
          let parent;
          if (position === 'afterbegin' || position === 'beforeend') ;else if (position === 'beforebegin' || position === 'afterend') {
            // Prevent writing outside secure node.
            parent = raw.parentNode;
            verifyAccess(this, parent, true);
          } else {
            throw new error("SecureElement.insertAdjacentHTML requires position 'beforeBegin', 'afterBegin', 'beforeEnd', or 'afterEnd'.");
          }
          raw.insertAdjacentHTML(position, sanitizeDefault(text));
          trustChildNodes(this, parent || raw);
        }
      },
      name: {
        configurable: true,
        enumerable: true,
        get() {
          const raw = getRawThis(this);
          return raw.name;
        },
        set(value) {
          value = asString(value);
          if (W5885703_domClobberingNameId && !SecureElement.isValidAttributeValue('name', value)) {
            warn(`SecureElement does not allow setting name attribute to ${value}`);
            return;
          }
          const raw = getRawThis(this);
          raw.name = value;
        }
      },
      id: {
        configurable: true,
        enumerable: true,
        get() {
          const raw = getRawThis(this);
          return raw.id;
        },
        set(value) {
          value = asString(value);
          if (W5885703_domClobberingNameId && !SecureElement.isValidAttributeValue('id', value)) {
            warn(`SecureElement does not allow setting id attribute to ${value}`);
            return;
          }
          const raw = getRawThis(this);
          raw.id = value;
        }
      },
      getAttribute: SecureElement.createGetAttributeAccessMethodConfig('getAttribute', prototype, caseInsensitiveAttributes, null, undefined, key),
      getAttributeNS: SecureElement.createGetAttributeAccessMethodConfig('getAttributeNS', prototype, caseInsensitiveAttributes, null, true, key),
      getAttributeNode: SecureElement.createGetAttributeAccessMethodConfig('getAttributeNode', prototype, caseInsensitiveAttributes, null, undefined, key),
      getAttributeNodeNS: SecureElement.createGetAttributeAccessMethodConfig('getAttributeNodeNS', prototype, caseInsensitiveAttributes, null, true, key),
      setAttribute: SecureElement.createSetAttributeAccessMethodConfig('setAttribute', prototype, caseInsensitiveAttributes, undefined, undefined),
      setAttributeNS: SecureElement.createSetAttributeAccessMethodConfig('setAttributeNS', prototype, caseInsensitiveAttributes, undefined, true),
      setAttributeNode: SecureElement.createSetAttributeAccessNodeMethodConfig('setAttributeNode', prototype, caseInsensitiveAttributes, undefined),
      setAttributeNodeNS: SecureElement.createSetAttributeAccessNodeMethodConfig('setAttributeNodeNS', prototype, caseInsensitiveAttributes, undefined),
      removeAttributeNode: SecureElement.createRemoveAttributeNodeAccessNodeMethodConfig('removeAttributeNode', prototype, caseInsensitiveAttributes, undefined, key)
    };
    defineProperties(prototype, descriptors);
    for (const propertyName in descriptors) {
      if (ObjectHasOwnProperty(descriptors, propertyName)) {
        const descriptor = descriptors[propertyName];
        if (ObjectHasOwnProperty(descriptor, 'value')) {
          const {
            value
          } = descriptor;
          if (typeof value === 'function') {
            maskToString(value, propertyName);
          }
        }
      }
    }
    fastArrayForEach(['getElementsByClassName', 'getElementsByTagName', 'getElementsByTagNameNS', 'querySelectorAll'], methodName => {
      defineProperty(prototype, methodName, {
        configurable: false,
        enumerable: false,
        writable: true,
        value: maskToString(function (...args) {
          const raw = getRawThis(this);
          const rawReturnedValue = raw[methodName](...args);
          return filterEverything(this, rawReturnedValue);
        }, methodName)
      });
    });
  };
  SecureElement.createGetAttributeAccessMethodConfig = function (methodName, prototype, caseInsensitiveAttributes, invalidAttributeReturnValue, namespaced, key) {
    return {
      writable: true,
      value: function () {
        let name;
        let args;
        if (namespaced) {
          name = asString(arguments[1]);
          args = [arguments[0], name];
        } else {
          name = asString(arguments[0]);
          args = [name];
        }
        const raw = getRawThis(this);
        if (!isValidAttributeName(raw, name, prototype, caseInsensitiveAttributes)) {
          warn(`${this} does not allow getting the ${name} attribute, ignoring!`);
          return invalidAttributeReturnValue;
        }
        const ret = raw[methodName](...args);
        return ret instanceof Node ? SecureElement(ret, key) : ret;
      }
    };
  };
  SecureElement.createSetAttributeAccessMethodConfig = function (methodName, prototype, caseInsensitiveAttributes, invalidAttributeReturnValue, namespaced) {
    return {
      writable: true,
      value: function () {
        let name;
        let value;
        let args;
        if (namespaced) {
          name = arguments[1] === null ? arguments[1] : asString(arguments[1]);
          value = asString(arguments[2]);
          args = [arguments[0], name, value];
        } else {
          name = arguments[0] === null ? arguments[0] : asString(arguments[0]);
          value = asString(arguments[1]);
          args = [name, value];
        }
        const raw = getRawThis(this);
        if (!isValidAttributeName(raw, name, prototype, caseInsensitiveAttributes)) {
          warn(`${this} does not allow setting the ${name} attribute, ignoring!`);
          return invalidAttributeReturnValue;
        }
        if (W5885703_domClobberingNameId && !SecureElement.isValidAttributeValue(name, value)) {
          warn(`${this} does not allow setting the ${name} attribue to ${value}, ignoring!`);
          return invalidAttributeReturnValue;
        }
        args = filterArguments(this, args, {
          rawArguments: true
        });
        return raw[methodName](...args);
      }
    };
  };
  SecureElement.createSetAttributeAccessNodeMethodConfig = function (methodName, prototype, caseInsensitiveAttributes, invalidAttributeReturnValue) {
    return {
      writable: true,
      value: function () {
        const raw = getRawThis(this);
        const rawAttribute = isProxy(arguments[0]) ? getRawThis(arguments[0]) : arguments[0];
        const name = asString(rawAttribute.name);
        const value = asString(rawAttribute.value);
        if (!isValidAttributeName(raw, name, prototype, caseInsensitiveAttributes)) {
          warn(`${this} does not allow setting the ${name} attribute, ignoring!`);
          return invalidAttributeReturnValue;
        }
        if (W5885703_domClobberingNameId && !SecureElement.isValidAttributeValue(name, value)) {
          warn(`${this} does not allow setting the ${name} attribue to ${value}, ignoring!`);
          return invalidAttributeReturnValue;
        }
        const args = filterArguments(this, arguments, {
          rawArguments: true
        });
        return raw[methodName](...args);
      }
    };
  };
  SecureElement.createRemoveAttributeNodeAccessNodeMethodConfig = function (methodName) {
    return {
      writable: true,
      value: function () {
        const raw = getRawThis(this);
        const args = isProxy(arguments[0]) ? getRawThis(arguments[0]) : arguments[0];
        return raw[methodName](args);
      }
    };
  };

  // As per the spec, a new empty registry is used when creating a template
  // contents owner document, so we use that as our parent document to
  // ensure nothing s inherited.
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  const templateElement = document.createElement('template');
  const documentElement = templateElement.content.ownerDocument;
  const formElement = document.createElement('form');
  SecureElement.isValidAttributeValue = function (name, value) {
    if ((name === 'id' || name === 'name') && (value in documentElement || value in formElement)) {
      return false;
    }
    return true;
  };
  SecureElement.secureQuerySelector = function (el, key, selector) {
    const rawAll = el.querySelectorAll(selector);
    for (let n = 0; n < rawAll.length; n++) {
      const raw = rawAll[n];
      const rawKey = getKey(raw);
      if (rawKey === key || isSharedElement(raw) || isAccessibleLWCNode(key, raw)) {
        return SecureElement(raw, key);
      }
    }
    return null;
  };

  /* eslint-enable import/no-cycle */

  const keyToConstructor$6 = new WeakMap();
  function SecureTouchWrapper(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    const constructor = keyToConstructor$6.get(key);
    assert.invariant(constructor, 'Touch is not defined!');
    const proto = constructor.prototype;
    o = create$1(proto, {
      target: {
        configurable: true,
        enumerable: true,
        get: () => SecureElement(raw.target, key)
      }
    });
    fastArrayForEach(['altitudeAngle', 'azimuthAngle', 'clientX', 'clientY', 'force', 'identifier', 'pageX', 'pageY', 'radiusX', 'radiusY', 'rotationAngle', 'screenX', 'screenY', 'touchType'], property => addPropertyIfSupported(o, raw, property));
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureTouch(win, key) {
    class Touch {
      constructor(touchInit) {
        if (touchInit && touchInit.target && isProxy(touchInit.target)) {
          touchInit.target = getRef(touchInit.target, key);
        }
        const touchInstance = new win.Touch(touchInit);
        // eslint-disable-next-line no-constructor-return
        return SecureTouchWrapper(touchInstance, key);
      }
    }
    defineProperty(Touch.prototype, Symbol.toStringTag, {
      configurable: true,
      value: 'Touch'
    });
    keyToConstructor$6.set(key, Touch);
    return Touch;
  }

  /* eslint-enable import/no-cycle */

  const keyToConstructor$5 = new WeakMap();
  function createSecureListProxy(proto, raw, key) {
    const handler = {
      has(target, prop) {
        return isPositiveInteger(prop) || has(proto, prop);
      },
      get(target, prop) {
        return isPositiveInteger(prop) ? SecureTouchWrapper(raw[prop], key) : proto[prop];
      }
    };
    return new Proxy({}, handler);
  }

  /**
   * Wraps a TouchList in a proxy.
   * @param {Object} [raw] TouchList: represents a list of contact points on a touch surface.
   */
  function SecureTouchListWrapper(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    const constructor = keyToConstructor$5.get(key);
    assert.invariant(constructor, 'TouchList is not defined!');
    const proto = constructor.prototype;
    const proxy = createSecureListProxy(proto, raw, key);
    o = create$1(proxy, {
      item: {
        configurable: true,
        enumerable: true,
        writable: true,
        value: index => {
          const item = raw.item(index);
          return item ? SecureTouchWrapper(raw.item(index), key) : undefined;
        }
      },
      length: {
        configurable: true,
        enumerable: true,
        get: () => raw.length
      }
    });
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureTouchList(win, key) {
    class TouchList {
      constructor() {
        throw new TypeError('Illegal constructor');
      }
    }
    defineProperty(TouchList.prototype, Symbol.toStringTag, {
      configurable: true,
      value: 'TouchList'
    });
    keyToConstructor$5.set(key, TouchList);
    return TouchList;
  }

  /* eslint-enable import/no-cycle */

  const keyToConstructor$4 = new WeakMap();
  function defensiveHas(object, prop) {
    try {
      return has(object, prop);
    } catch (e) {
      return false;
    }
  }
  function SecureMessageEventSource(raw, key) {
    if (!raw) {
      return undefined;
    }
    const cached = getFromCache(raw, key);
    if (cached) {
      return cached;
    }
    const st = create$1(null);
    if (defensiveHas(raw, 'postMessage')) {
      defineProperty(st, 'postMessage', createFilteredMethod(st, raw, 'postMessage', RAW_ARGS_DEEP));
    }
    fastArrayForEach(['close', 'start'], prop => {
      if (defensiveHas(raw, prop)) {
        defineProperty(st, prop, createFilteredMethod(st, raw, prop));
      }
    });
    fastArrayForEach(['onmessage', 'onmessageerror'], prop => {
      if (defensiveHas(raw, prop)) {
        defineProperty(st, prop, createFilteredProperty(st, raw, prop));
      }
    });
    setKey(st, key);
    addToCache(raw, st, key);
    return st;
  }
  function SecureDOMEvent(event, key) {
    assert.invariant(event, 'Wrapping an undefined event is prohibited.');
    let o = getFromCache(event, key);
    if (o) {
      return o;
    }
    if (typeof TouchEvent !== 'undefined' && event instanceof TouchEvent) {
      const constructor = keyToConstructor$4.get(key);
      const proto = constructor.prototype;
      assert.invariant(proto, 'TouchEvent.prototype is not defined!');
      o = create$1(proto, {});
    } else {
      o = create$1(null, {
        toString: {
          value: function () {
            return `SecureDOMEvent: ${event}{ key: ${JSON.stringify(key)} }`;
          }
        }
      });
    }
    const DOMEventSecureDescriptors = {
      // Events properties that are DOM Elements were compiled from
      // https://developer.mozilla.org/en-US/docs/Web/Events
      target: createFilteredProperty(o, event, 'target', SKIP_OPAQUE_ASCENDING),
      currentTarget: createFilteredProperty(o, event, 'currentTarget'),
      initEvent: createFilteredMethod(o, event, 'initEvent'),
      // Aliasing target as srcElement, which still meet specs and circumvent any potential
      // discrepancy in the way prototypes are patched.
      srcElement: createFilteredProperty(o, event, 'target', SKIP_OPAQUE_ASCENDING),
      // Touch Events are special on their own:
      // https://developer.mozilla.org/en-US/docs/Web/API/Touch
      touches: SecureDOMEvent.filterTouchesDescriptor(o, event, 'touches', key),
      targetTouches: SecureDOMEvent.filterTouchesDescriptor(o, event, 'targetTouches', key),
      changedTouches: SecureDOMEvent.filterTouchesDescriptor(o, event, 'changedTouches', key),
      source: {
        enumerable: true,
        get() {
          if (event.source === window) {
            return getEnv$1(key);
          }
          return SecureMessageEventSource(event.source, key);
        }
      },
      view: {
        get: function () {
          const key = getKey(o);
          const swin = getEnv$1(key);
          const win = getRef(swin, key);
          return win === event.view ? swin : undefined;
        }
      }
    };
    fastArrayForEach(['preventDefault', 'stopImmediatePropagation', 'stopPropagation'], method => addMethodIfSupported(o, event, method));

    // non-standard properties and aliases
    fastArrayForEach(['relatedTarget', 'explicitOriginalTarget', 'originalTarget'], property => addPropertyIfSupported(o, event, property));

    // re-exposing externals
    // @TODO: we might need to include non-enumerables
    for (const name in event) {
      if (!(name in o)) {
        // every DOM event has a different shape, we apply filters when possible,
        // and bypass when no secure filter is found.
        defineProperty(o, name, DOMEventSecureDescriptors[name] || createFilteredProperty(o, event, name));
      }
    }
    setRef(o, event, key);
    addToCache(event, o, key);
    registerProxy(o);
    return o;
  }
  SecureDOMEvent.filterTouchesDescriptor = function (se, event, propName, key) {
    let valueOverride;
    // descriptor to produce a new collection of touches where the target of each
    // touch is a secure element
    return {
      get: function () {
        if (valueOverride) {
          return valueOverride;
        }
        const touches = event[propName];
        if (!touches) {
          return touches;
        }
        return SecureTouchListWrapper(touches, key);
      },
      set: function (value) {
        valueOverride = value;
      }
    };
  };
  function SecureTouchEvent(win, key) {
    class TouchEvent {
      constructor(typeArg, touchEventInit) {
        ['changedTouches', 'targetTouches', 'touches'].forEach(prop => {
          const touchList = touchEventInit[prop];
          if (touchList) {
            for (let i = 0; i < touchList.length; i++) {
              if (touchList[i] && isProxy(touchList[i])) {
                touchEventInit[prop][i] = getRef(touchList[i], key);
              }
            }
          }
        });
        const touchEventInstance = new win.TouchEvent(typeArg, touchEventInit);
        // eslint-disable-next-line no-constructor-return
        return SecureDOMEvent(touchEventInstance, key);
      }
    }
    defineProperty(TouchEvent.prototype, Symbol.toStringTag, {
      writable: false,
      enumerable: false,
      configurable: true,
      value: 'TouchEvent'
    });
    keyToConstructor$4.set(key, TouchEvent);
    return TouchEvent;
  }

  /* eslint-enable import/no-cycle */

  function getFiltered(raw, key, nodeIsAccessible) {
    const filtered = [];
    for (let n = 0, length = raw.length; n < length; n++) {
      const value = raw[n];
      if (nodeIsAccessible(value, key)) {
        filtered.push(value);
      }
    }
    return filtered;
  }
  function getFilteredByIndex(raw, key, index, nodeIsAccessible) {
    const {
      length
    } = raw;
    if (index < length) {
      let filteredIndex = -1;
      for (let n = 0; n < length; n++) {
        const value = raw[n];
        if (nodeIsAccessible(value, key) && ++filteredIndex === index) {
          return filterNode(key, value);
        }
      }
    }
    return undefined;
  }
  function getFilteredCount(raw, key, nodeIsAccessible) {
    let filteredCount = 0;
    for (let n = 0, length = raw.length; n < length; n++) {
      const value = raw[n];
      if (nodeIsAccessible(value, key)) {
        filteredCount++;
      }
    }
    return filteredCount;
  }

  /**
   * Proxy handler for NodeList and HTMLCollection
   */
  class SecureNodeListProxyHandler {
    constructor(target, key, nodeIsAccessible) {
      this.target = target;
      this.key = key;
      this.nodeIsAccessible = nodeIsAccessible;
    }
    get(shadowTarget, property) {
      property = asPropertyName(property);
      const {
        target: raw,
        key,
        nodeIsAccessible
      } = this;
      if (typeof property === 'number') {
        return getFilteredByIndex(raw, key, property, nodeIsAccessible);
      }
      switch (property) {
        case 'forEach':
          return (callback, thisArg) => {
            const secureCallback = filterFunction(key, callback);
            const secureThisArg = filter(key, thisArg);
            raw.forEach(secureCallback, secureThisArg);
            return filterNodeList(key, raw);
          };
        case 'hasOwnProperty':
          return property => {
            const {
              target: raw
            } = this;
            if (ObjectHasOwnProperty(raw, property)) {
              property = asPropertyName(property);
              if (typeof property === 'number') {
                const filtered = getFilteredByIndex(raw, this.key, property, this.nodeIsAccessible);
                return filtered !== undefined;
              }
              return true;
            }
            return false;
          };
        case 'item':
          return index => {
            const maybeIndex = asPropertyName(index);
            if (typeof maybeIndex === 'number') {
              return getFilteredByIndex(raw, key, maybeIndex, nodeIsAccessible);
            }
            return undefined;
          };
        case 'length':
          return getFilteredCount(raw, key, nodeIsAccessible);
        case 'namedItem':
          return name => {
            const value = raw.namedItem(name);
            return value ? filterObject(key, value) : value;
          };
        case 'toJSON':
          return () => {
            const filtered = getFiltered(raw, key, nodeIsAccessible);
            return stringify(filtered);
          };
        case 'toString':
        case Symbol.toStringTag:
          {
            const toStringTag = `SecureNodeList: ${asString(raw)}{ key: ${stringify(key)} }`;
            if (property === Symbol.toStringTag) {
              return toStringTag;
            }
            return () => toStringTag;
          }
        case Symbol.iterator:
          {
            const filtered = getFiltered(raw, key, nodeIsAccessible);
            return () => {
              let nextIndex = -1;
              return {
                next() {
                  if (++nextIndex < filtered.length) {
                    const value = filtered[nextIndex];
                    return {
                      value: value ? filterNode(key, value) : value,
                      done: false
                    };
                  }
                  return {
                    done: true
                  };
                }
              };
            };
          }
        default:
          {
            warn(`Unsupported ${asString(raw)} method: ${asString(property)}. Returning undefined`);
            return undefined;
          }
      }
    }
    has(shadowTarget, property) {
      property = asPropertyName(property);
      const {
        target: raw
      } = this;
      if (property in raw) {
        if (typeof property === 'number' && ObjectHasOwnProperty(raw, property)) {
          const filtered = getFilteredByIndex(raw, this.key, property, this.nodeIsAccessible);
          return filtered !== undefined;
        }
        return true;
      }
      return false;
    }
  }

  /**
   *  The default access check function for a node
   */
  const defaultNodeIsAccessible = (node, toKey) => getKey(node) === toKey || isSharedElement(node) || isAccessibleLWCNode(toKey, node);

  /**
   * Create a wrapper for a NodeList
   * Currently this wrapper handles both NodeList and HTMLCollection.
   * @param {NodeList | HTMLCollection} raw nodelist to wrap
   * @param {object} toKey locker key for the destination trying to access the nodelist
   * @param {function} nodeIsAccessibleOverride Override the default access check function to determine if a node can be allowed accessed
   */
  function SecureNodeList(raw, toKey, nodeIsAccessibleOverride) {
    const shadowTarget = create$1(getPrototypeOf(raw));
    setRef(shadowTarget, raw, toKey);
    const proxy = new Proxy(shadowTarget, new SecureNodeListProxyHandler(raw, toKey, typeof nodeIsAccessibleOverride === 'function' ? nodeIsAccessibleOverride : defaultNodeIsAccessible));
    setRef(proxy, raw, toKey);
    registerProxy(proxy);
    return proxy;
  }
  var CanvasRenderingContext2D$1 = {
    addHitRegion: FUNCTION,
    arc: FUNCTION,
    arcTo: FUNCTION,
    beginPath: FUNCTION,
    bezierCurveTo: FUNCTION,
    canvas: READ_ONLY_PROPERTY,
    clearHitRegions: FUNCTION,
    clearRect: FUNCTION,
    clip: FUNCTION,
    closePath: FUNCTION,
    createImageData: FUNCTION,
    createLinearGradient: FUNCTION,
    createPattern: FUNCTION_RAW_ARGS,
    createRadialGradient: FUNCTION,
    currentTransform: RAW,
    direction: DEFAULT,
    drawFocusIfNeeded: FUNCTION_RAW_ARGS,
    drawImage: FUNCTION_RAW_ARGS,
    ellipse: FUNCTION,
    fill: FUNCTION_RAW_ARGS,
    fillRect: FUNCTION,
    fillStyle: DEFAULT,
    fillText: FUNCTION,
    font: DEFAULT,
    getImageData: FUNCTION,
    getLineDash: FUNCTION,
    getTransform: FUNCTION,
    globalAlpha: DEFAULT,
    globalCompositeOperation: DEFAULT,
    imageSmoothingEnabled: DEFAULT,
    isPointInPath: FUNCTION,
    isPointInStroke: FUNCTION,
    lineCap: DEFAULT,
    lineDashOffset: DEFAULT,
    lineJoin: DEFAULT,
    lineTo: FUNCTION,
    lineWidth: DEFAULT,
    measureText: FUNCTION,
    miterLimit: DEFAULT,
    moveTo: FUNCTION,
    putImageData: FUNCTION_RAW_ARGS,
    quadraticCurveTo: FUNCTION,
    rect: FUNCTION,
    removeHitRegion: FUNCTION,
    restore: FUNCTION,
    resetTransform: FUNCTION,
    rotate: FUNCTION,
    save: FUNCTION,
    scale: FUNCTION,
    setLineDash: FUNCTION,
    setTransform: FUNCTION,
    scrollPathIntoView: FUNCTION_RAW_ARGS,
    shadowBlur: DEFAULT,
    shadowColor: DEFAULT,
    shadowOffsetX: DEFAULT,
    shadowOffsetY: DEFAULT,
    stroke: FUNCTION_RAW_ARGS,
    strokeRect: FUNCTION,
    strokeStyle: DEFAULT,
    strokeText: FUNCTION,
    textAlign: DEFAULT,
    textBaseline: DEFAULT,
    transform: FUNCTION,
    translate: FUNCTION
  };
  var metadataView$2 = {
    prototypes: {
      CanvasRenderingContext2D: CanvasRenderingContext2D$1
    }
  };

  /* eslint-enable import/no-cycle */

  function SecureCanvasRenderingContext2D(ctx, key) {
    let o = getFromCache(ctx, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureCanvasRenderingContext2D: ${ctx}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    addPrototypeMethodsAndProperties(metadataView$2, o, ctx, key);
    setRef(o, ctx, key);
    addToCache(ctx, o, key);
    registerProxy(o);
    return o;
  }

  /* eslint-disable no-use-before-define */
  /* eslint-enable import/no-cycle */

  let filterTypeHook$1;
  function registerFilterTypeHook(hook) {
    filterTypeHook$1 = hook;
  }
  let deepUnfilteringTypeHook$1;
  function registerDeepUnfilteringTypeHook(hook) {
    deepUnfilteringTypeHook$1 = hook;
  }
  let isUnfilteredTypeHook$1;
  function registerIsUnfilteredTypeHook(hook) {
    isUnfilteredTypeHook$1 = hook;
  }

  // @TODO: W-5505278 Move add/create to LockerFactory

  function filterFunction(key, raw, options = DEFAULT) {
    const cached = getFromCache(raw, key);
    if (cached) {
      return cached;
    }

    // Handle already proxied things
    const rawKey = getKey(raw);
    const belongsToLocker = rawKey === key;
    if (isProxy(raw)) {
      // - If !belongsToLocker then this is a jump from one locker to another - we just need to unwrap and then reproxy based on the target locker's perspective
      // otherwise just return the proxy (do not proxy a proxy).
      // - Bypass unwrapping and refiltering for SecureFunction so arguments and 'this' are filtered against the
      // Locker where the function was originally defined.
      return belongsToLocker || isSecureFunction(raw) ? raw : filterFunction(key, getRef(raw, rawKey), options);
    }
    if (!rawKey) {
      const defaultKey$1 = options.defaultKey ? options.defaultKey : defaultKey;
      setKey(raw, defaultKey$1);
    }

    // Set useNewSecureFunction to true to use the new SecureFunction Proxy instead of the legacy FilteringProxy
    const {
      useNewSecureFunction
    } = options;

    // wrapping functions to guarantee that they run in system mode but their
    // returned value complies with user-mode.
    const swallowed = useNewSecureFunction ? SecureFunction(raw, rawKey, key) : function SecureFunction() {
      // @TODO: rawKey could be undefined when SecureFunction is created.
      const rawKey = getKey(raw);
      // special unfiltering logic to unwrap Proxies passed back to origin.
      // this could potentially be folded into filterArguments with an option set if needed.
      const filteredArgs = [];
      for (let i = 0; i < arguments.length; i++) {
        let arg = arguments[i];
        if (isFilteringProxy(arg)) {
          const unfilteredProxy = getRef(arg, getKey(arg));
          const unfilteredKey = getKey(unfilteredProxy);
          arg = unfilteredKey === rawKey ? unfilteredProxy : filter(key, arg);
        } else {
          arg = filter(key, arg);
        }
        filteredArgs[i] = arg;
      }
      let self = filter(key, this);
      if (isFilteringProxy(self) && getKey(self) === key) {
        self = getRef(self, key);
      }
      if (hasRef(self)) {
        const ref = getRef(self, key);
        if (isPromise(ref)) {
          self = ref;
        }
      }
      const fnReturnedValue = raw.apply(self, filteredArgs);
      return filter(key, fnReturnedValue, options);
    };
    setRef(swallowed, raw, key);
    addToCache(raw, swallowed, key);
    registerProxy(swallowed);
    registerSecureFunction(swallowed);
    return swallowed;
  }
  function filterNode(key, raw, options = DEFAULT) {
    const cached = getFromCache(raw, key);
    if (cached) {
      return cached;
    }

    // Handle already proxied things
    const rawKey = getKey(raw);
    const belongsToLocker = rawKey === key;
    if (isProxy(raw)) {
      // - If !belongsToLocker then this is a jump from one locker to another - we just need to unwrap and then reproxy based on the target locker's perspective
      // otherwise just return the proxy (do not proxy a proxy).
      return belongsToLocker ? raw : filterNode(key, getRef(raw, rawKey), options);
    }
    if (filterTypeHook$1) {
      const swallowed = filterTypeHook$1(raw, key, belongsToLocker);
      if (swallowed) {
        return raw === swallowed ? raw : swallowed;
      }
    }
    if (belongsToLocker || isSharedElement(raw)) {
      return SecureElement(raw, key);
    }
    if (options === DEFAULT) {
      return SecureObject(raw, key);
    }
    // REASON: W-3158233 SecureElement.attributes emulate a NamedNodeMap.
    if ((raw instanceof Attr || options.forceOpaque) && !rawKey) {
      const defaultKey$1 = options.defaultKey ? options.defaultKey : defaultKey;
      setKey(raw, defaultKey$1);
      return filterObject(key, raw);
    }
    addToCache(raw, options.defaultValue, key);
    return options.defaultValue;
  }
  function filterNodeList(key, raw) {
    const cached = getFromCache(raw, key);
    if (cached) {
      return cached;
    }

    // Handle already proxied things
    if (isProxy(raw)) {
      const rawKey = getKey(raw);
      const belongsToLocker = rawKey === key;

      // - If !belongsToLocker then this is a jump from one locker to another - we just need to unwrap and then reproxy based on the target locker's perspective
      // otherwise just return the proxy (do not proxy a proxy).
      return belongsToLocker ? raw : filterNodeList(key, getRef(raw, rawKey));
    }
    return SecureNodeList(raw, key);
  }
  function filterObject(key, raw, options = DEFAULT) {
    const cached = getFromCache(raw, key);
    if (cached) {
      return cached;
    }

    // Handle already proxied things
    const rawKey = getKey(raw);
    const belongsToLocker = rawKey === key;
    const defaultKey$1 = options.defaultKey ? options.defaultKey : defaultKey;
    // Set useNewSecureFunction to true to use the new SecureFunction Proxy instead of the legacy FilteringProxy
    const {
      useNewSecureFunction
    } = options;
    if (isProxy(raw)) {
      // - If !belongsToLocker then this is a jump from one locker to another - we just need to unwrap and then reproxy based on the target locker's perspective
      // otherwise just return the proxy (do not proxy a proxy).
      return belongsToLocker ? raw : filterObject(key, getRef(raw, rawKey), options);
    }
    let swallowed;
    let mutated = false;
    if (raw === window) {
      return getEnv$1(key);
    }
    if (raw === document) {
      return getEnv$1(key).document;
    }
    if (raw === window.location) {
      return getEnv$1(key).location;
    }
    if (isArray(raw)) {
      if (!belongsToLocker) {
        if (!rawKey) {
          // Array that was created in this locker or system mode but not yet keyed - key it now
          setKey(raw, defaultKey$1);
          return filterObject(key, raw, options);
        }
        swallowed = createProxyForArrayObjects(raw, key);
        setRef(swallowed, raw, key);
        addToCache(raw, swallowed, key);
        mutated = true;
      }
    } else if (isNodeList(raw)) {
      swallowed = SecureNodeList(raw, key);
      mutated = true;
    } else {
      assert.invariant(key, 'A secure object should always have a key.');
      if (filterTypeHook$1) {
        swallowed = filterTypeHook$1(raw, key, belongsToLocker);
      }
      if (swallowed) {
        mutated = raw !== swallowed;
      } else if (isNode(raw)) {
        return filterNode(key, raw, options);
      } else if (raw instanceof Event) {
        swallowed = SecureDOMEvent(raw, key);
        mutated = true;
      } else if (raw instanceof CanvasRenderingContext2D) {
        swallowed = SecureCanvasRenderingContext2D(raw, key);
        mutated = true;
      } else if (isUnfilteredType(raw, key)) {
        // return raw for unfiltered types
        mutated = false;
      } else {
        if (!belongsToLocker) {
          if (!rawKey) {
            // Object that was created in this locker or in system mode and not yet keyed - key it now
            setKey(raw, defaultKey$1);
            return filterObject(key, raw, options);
          }
          if (useNewSecureFunction) {
            swallowed = SecureFunction(raw, rawKey, key);
            setRef(swallowed, raw, key);
            addToCache(raw, swallowed, key);
          } else {
            swallowed = createFilteringProxy(raw, key);
          }
          mutated = true;
        }
      }
    }
    return mutated ? swallowed : raw;
  }

  /**
   * List of unfiltered objects.
   */
  // @TODO: W-5529670 augment the list of unfiltered types for performance.
  const allowedObjects = [
  // Function, // unsafe
  Object, Array, Function.prototype, Object.prototype, Array.prototype];

  /**
   * @deprecated Use filter() instead.
   */
  function filterEverything(st, raw, options) {
    if (raw === undefined || raw === null) {
      return raw;
    }
    // This detection of primitives is performant, even with the apparent string creation.
    // Benchmarks show that Object(raw) !== raw is 10x slower.
    switch (typeof raw) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'symbol':
        return raw;
      case 'function':
        if (allowedObjects.includes(raw)) {
          return raw;
        }
        return filterFunction(getKey(st), raw, options);
      case 'object':
        if (allowedObjects.includes(raw)) {
          return raw;
        }
        return filterObject(getKey(st), raw, options);
      default:
        throw new TypeError(`type not supported ${raw}`);
    }
  }

  /**
   * Filter the given raw object with the accessors key and provide a filtered view.
   * Best used when the type of "raw" is not known
   * @param st Represents the accessor who is trying to access "raw"
   * @param raw The raw object that we are trying to filter
   * @param options
   * @returns {*}
   */
  function filter(key, raw, options) {
    if (raw === undefined || raw === null) {
      return raw;
    }
    // This detection of primitives is performant, even with the apparent string creation.
    // Benchmarks show that Object(raw) !== raw is 10x slower.
    switch (typeof raw) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'symbol':
        return raw;
      case 'function':
        if (allowedObjects.includes(raw)) {
          return raw;
        }
        return filterFunction(key, raw, options);
      case 'object':
        if (allowedObjects.includes(raw)) {
          return raw;
        }
        return filterObject(key, raw, options);
      default:
        throw new TypeError(`type not supported ${raw}`);
    }
  }
  function filterArguments(st, args, options = DEFAULT) {
    args = ArraySlice(args);
    if (options.beforeCallback) {
      options.beforeCallback.apply(st, args);
    }
    if (options.unfilterEverything) {
      return options.unfilterEverything.call(st, args);
    }

    // For backwards compatibility, rawArgumentsDeep is a new option and it has to be
    // evaluated after unfilterEverything and before rawArguments. W-5833730
    if (options.rawArgumentsDeep) {
      return deepUnfilter(getKey(st), [], args);
    }
    const {
      rawArguments
    } = options;
    for (let n = 0; n < args.length; n++) {
      const value = args[n];
      if (value) {
        if (rawArguments && typeof value === 'object') {
          args[n] = isArray(value) ? getRawArray(value) : getRaw$1(value);
        } else {
          args[n] = filterEverything(st, value, options);
        }
      }
    }
    return args;
  }

  // @TODO: W-5529670
  const allowedConstructors = [Object, Array];
  const filteringProxyHandler = freeze({
    get(target, property) {
      const raw = getRef(target, getKey(target));
      const value = raw[property];
      if (!value) {
        return value;
      }
      if (property === 'constructor' && allowedConstructors.includes(value)) {
        return value;
      }
      return filterEverything(target, value);
    },
    set(target, property, value) {
      const raw = getRef(target, getKey(target));
      const filteredValue = value ? filterEverything(target, value) : value;
      raw[property] = filteredValue;
      return true;
    },
    // These are all direct pass through methods to preserve the shape etc of the delegate

    getPrototypeOf(target) {
      const raw = getRef(target, getKey(target));
      return getPrototypeOf(raw);
    },
    setPrototypeOf(target, prototype) {
      const raw = getRef(target, getKey(target));
      return setPrototypeOf(raw, prototype);
    },
    has(target, property) {
      const raw = getRef(target, getKey(target));
      return property in raw;
    },
    defineProperty(target, property, descriptor) {
      const raw = getRef(target, getKey(target));
      defineProperty(raw, property, descriptor);
      return true;
    },
    deleteProperty(target, property) {
      const raw = getRef(target, getKey(target));
      delete target[property];
      delete raw[property];
      return true;
    },
    ownKeys(target) {
      const raw = getRef(target, getKey(target));
      return ownKeys(raw);
    },
    getOwnPropertyDescriptor(target, property) {
      // If the property is non-writable and non-configurable, there is nothing to do.
      const targetDescriptor = getOwnPropertyDescriptor(target, property);
      if (targetDescriptor && !targetDescriptor.configurable && !targetDescriptor.writable) {
        return targetDescriptor;
      }

      // Always get the descriptor of the raw object.
      const raw = getRef(target, getKey(target));
      const rawDescriptor = getOwnPropertyDescriptor(raw, property);
      if (rawDescriptor) {
        // Always filter the descriptor value.
        if (rawDescriptor.hasOwnProperty('value')) {
          rawDescriptor.value = filterEverything(target, rawDescriptor.value);
        }

        // Always remove from the surrogate (and redefine if necessary).
        if (targetDescriptor) {
          deleteProperty(target, property);
        }

        // Use the surrogate to preserve invariants.
        // Only non-configurable properties are verified against the target.
        if (!rawDescriptor.configurable) {
          defineProperty(target, property, rawDescriptor);
        }
      } else if (targetDescriptor) {
        // Update the surrogate when the property is no longer on raw.
        deleteProperty(target, property);
      }
      return rawDescriptor;
    },
    isExtensible(target) {
      const raw = getRef(target, getKey(target));
      return isExtensible(raw);
    },
    preventExtensions(target) {
      const raw = getRef(target, getKey(target));
      return preventExtensions(raw);
    }
  });
  function createFilteringProxy(raw, key) {
    // Use a direct proxy on raw to a proxy on {} to avoid the Proxy invariants for non-writable, non-configurable properties
    const surrogate = create$1(getPrototypeOf(raw));
    setRef(surrogate, raw, key);
    const rawKey = getKey(raw);
    if (!rawKey) {
      // This is a newly created plain old js object - stamp it with the key
      setKey(raw, key);
    }
    const swallowed = new Proxy(surrogate, filteringProxyHandler);
    registerProxy(swallowed);

    // DCHASMAN TODO We should be able to remove this (replaced with ls.setKey()) in the next phase of proxy work where we remove unfilterEverything() as something that is done all the time
    setRef(swallowed, raw, key);
    addToCache(raw, swallowed, key);
    registerFilteringProxy(swallowed);
    return swallowed;
  }

  // We cache 1 array proxy per key
  const KEY_TO_ARRAY_HANDLER = new Map();
  function getFilteredArray(st, raw, key) {
    const filtered = [];
    // @TODO: RJ, we are missing named(non-integer) properties, changing this for loop to for..in should fix it
    for (let n = 0; n < raw.length; n++) {
      const value = raw[n];
      let validEntry = false;
      if (!value ||
      // Array can contain undefined/null/false/0 such falsy values
      getKey(value) === key // Value has been keyed and belongs to this locker
      ) {
        validEntry = true;
      } else {
        const filteredValue = filterEverything(st, value, {
          defaultKey: key
        });
        if (filteredValue && !isOpaque(filteredValue)) {
          validEntry = true;
        }
      }
      if (validEntry) {
        // Store the raw index and value in an object
        filtered.push({
          rawIndex: n,
          rawValue: value
        });
      }
    }
    const symbolLiveObjectDesc = getOwnPropertyDescriptor(raw, SYMBOL_LIVE_OBJECT$LWS);
    if (symbolLiveObjectDesc) {
      setPrototypeOf(symbolLiveObjectDesc, null);
      if (symbolLiveObjectDesc.configurable === false) {
        defineProperty(filtered, SYMBOL_LIVE_OBJECT$LWS, symbolLiveObjectDesc);
      }
    }
    return filtered;
  }
  function getArrayProxyHandler(key) {
    function getFromFiltered(so, filtered, index) {
      // Numeric indexing into array
      const value = filtered[index] ? filtered[index]['rawValue'] : filtered[index];
      return value ? filterEverything(so, value) : value;
    }
    function getFilteredValues(so, filtered) {
      // Gather values from the filtered array
      const ret = [];
      filtered.forEach(item => {
        const value = item['rawValue'];
        ret.push(value ? filterEverything(so, value) : value);
      });
      return ret;
    }
    let handler = KEY_TO_ARRAY_HANDLER.get(key);
    if (!handler) {
      handler = {
        getPrototypeOf: function (target) {
          return getPrototypeOf(target);
        },
        setPrototypeOf: function (target, newProto) {
          return setPrototypeOf(target, newProto);
        },
        isExtensible: function (target) {
          return isExtensible(target);
        },
        preventExtensions: function (target) {
          preventExtensions(target);
          return getFromCache(target, key);
        },
        getOwnPropertyDescriptor: function (target, property) {
          const raw = target;
          const filtered = getFilteredArray(handler, raw, key);
          if (property === 'length') {
            const distortedDescriptor = ObjectCreate(null);
            const originalDescriptor = getOwnPropertyDescriptor(raw, property);
            distortedDescriptor.configurable = originalDescriptor.configurable;
            distortedDescriptor.enumerable = originalDescriptor.enumerable;
            distortedDescriptor.value = filtered.length;
            distortedDescriptor.writable = originalDescriptor.writable;
            return distortedDescriptor;
          }
          if (property === SYMBOL_LIVE_OBJECT$LWS) {
            return getOwnPropertyDescriptor(raw, property);
          }
          if (property in filtered) {
            return getOwnPropertyDescriptor(raw, filtered[property]['rawIndex']);
          }
          return undefined;
        },
        defineProperty: function (target, property, descriptor) {
          const raw = target;
          defineProperty(raw, property, descriptor);
          return true;
        },
        get: function (target, property) {
          const raw = target;
          const filtered = getFilteredArray(handler, raw, key);
          let ret;
          if (property === 'constructor' && allowedConstructors.includes(raw[property])) {
            return raw[property];
          }
          property = asPropertyName(property);
          if (typeof property === 'number') {
            ret = getFromFiltered(handler, filtered, property);
          } else {
            switch (property) {
              case 'length':
                ret = filtered.length;
                break;
              case 'pop':
                ret = function () {
                  if (filtered.length > 0) {
                    // Get the filtered value by index to return
                    const itemValue = getFromFiltered(handler, filtered, filtered.length - 1);
                    // Get raw index and update the raw array
                    const itemToRemove = filtered.pop();
                    raw.splice(itemToRemove['rawIndex'], 1);
                    return itemValue;
                  }
                  return undefined;
                };
                break;
              case 'push':
                ret = function () {
                  if (arguments.length === 0) {
                    return filtered.length;
                  }
                  for (let i = 0; i < arguments.length; i++) {
                    raw.push(filterEverything(handler, arguments[i]));
                  }
                  return filtered.length + arguments.length;
                };
                break;
              case 'reverse':
                ret = function () {
                  raw.reverse();
                  return getFromCache(raw, key);
                };
                break;
              case 'shift':
                ret = function () {
                  if (filtered.length > 0) {
                    // Get the filtered value by index to return
                    const itemValue = getFromFiltered(handler, filtered, 0);
                    // Get raw index and update the raw array
                    const itemToRemove = filtered.shift();
                    raw.splice(itemToRemove['rawIndex'], 1);
                    return itemValue;
                  }
                  return undefined;
                };
                break;
              case 'sort':
                ret = function (compareFunction) {
                  if (arguments.length > 0) {
                    raw.sort(filterEverything(handler, compareFunction));
                  } else {
                    raw.sort();
                  }
                  return getFromCache(raw, key);
                };
                break;
              case 'splice':
                ret = function (start, deleteCount) {
                  let positionToInsert = raw.length; // By default insert at the end of raw
                  const itemsToRemove = filtered.splice(start, deleteCount);
                  // If there are items to remove
                  if (itemsToRemove.length > 0) {
                    // Get position to insert the new items if there are any
                    positionToInsert = itemsToRemove[0]['rawIndex'];
                    // Remove from raw
                    for (let i = 0; i < itemsToRemove.length; i++) {
                      const itemToRemove = itemsToRemove[i];
                      // Remove from raw
                      raw.splice(itemToRemove['rawIndex'] - i, 1); // Since we are removing elements from raw, account for index adjustment
                    }
                  } else {
                    // Not deleting anything but inserting
                    if (start >= 0 && start < filtered.length) {
                      positionToInsert = filtered[start]['rawIndex'];
                    } else if (start >= filtered.length) {
                      // If position is bigger than filtered's last index, insert at end of raw
                      positionToInsert = raw.length;
                    } else {
                      // If start is a negative
                      // If trying to insert at the beginning of filtered array
                      if (filtered.length + start <= 0) {
                        positionToInsert = filtered.length > 0 ? filtered[0]['rawIndex'] : raw.length;
                      } else {
                        // Else inserting in the middle of filtered array, get index of element in raw array
                        positionToInsert = filtered[filtered.length + start]['rawIndex'];
                      }
                    }
                  }
                  // If there are items to be inserted
                  const newItems = [];
                  if (arguments.length > 2) {
                    for (let j = 2; j < arguments.length; j++) {
                      newItems.push(filterEverything(handler, arguments[j]));
                    }
                  }
                  if (newItems.length > 0) {
                    raw.splice.apply(raw, [positionToInsert, 0].concat(newItems));
                  }
                  return getFilteredValues(handler, itemsToRemove);
                };
                break;
              case 'unshift':
                ret = function () {
                  if (arguments.length === 0) {
                    return filtered.length;
                  }
                  const newItems = [];
                  for (let i = 0; i < arguments.length; i++) {
                    newItems.push(filterEverything(handler, arguments[i]));
                  }
                  raw.splice.apply(raw, [0, 0].concat(newItems));
                  return filtered.length + newItems.length;
                };
                break;
              case 'concat':
              case 'indexOf':
              case 'join':
              case 'lastIndexOf':
              case 'slice':
                ret = function () {
                  const filteredValues = getFilteredValues(handler, filtered);
                  return filteredValues[property].apply(filteredValues, arguments);
                };
                break;
              // For the iteration handlers, secure the callback function and invoke the method on filtered array
              case 'every':
              case 'filter':
              case 'forEach':
              case 'map':
              case 'reduce':
              case 'reduceRight':
              case 'some':
                ret = function () {
                  if (arguments.length > 0) {
                    const secureCallback = filterEverything(handler, arguments[0]);
                    arguments[0] = secureCallback;
                  }
                  const filteredValues = getFilteredValues(handler, filtered);
                  return filteredValues[property].apply(filteredValues, arguments);
                };
                break;
              case 'toString':
                ret = function () {
                  const filteredValues = getFilteredValues(handler, filtered);
                  return filteredValues.toString();
                };
                break;
              case Symbol.iterator:
                ret = function () {
                  let nextIndex = 0;
                  return {
                    next: function () {
                      if (nextIndex < filtered.length) {
                        const value = filtered[nextIndex]['rawValue'];
                        nextIndex++;
                        return {
                          value: value ? filterEverything(handler, value) : value,
                          done: false
                        };
                      }
                      return {
                        done: true
                      };
                    }
                  };
                };
                break;
              case Symbol.isConcatSpreadable:
                ret = raw[Symbol.isConcatSpreadable];
                break;
              default:
                if (raw[property]) {
                  // If trying to use array like an associative array
                  ret = filterEverything(handler, raw[property]);
                } else {
                  warn(`Unsupported ${asString(raw)} method: ${asString(property)}. Returning undefined`);
                  return undefined;
                }
            }
          }
          return ret;
        },
        set: function (target, property, value) {
          const raw = target;
          // Setting numerical indexes, number has to be positive integer, else its treated as an associative array key
          const coercedProperty = Number(property);
          if (!Number.isNaN(coercedProperty) && Number.isInteger(coercedProperty) && coercedProperty >= 0) {
            // Refilter raw to recreate the index mapping between raw and filtered value
            const filtered = getFilteredArray(handler, raw, key);
            // If we are replacing existing index
            if (filtered[property]) {
              raw[filtered[property]['rawIndex']] = filterEverything(handler, value);
              return true;
            }
            // Adding values at a random numerical index greater than length
            const filteredLength = filtered.length;
            const newItems = [];
            for (let i = 0; i < property - filtered.length; i++) {
              newItems.push(undefined);
            }
            newItems.push(value);
            // Find the position in raw where we have to insert the new items
            // If filtered is empty, insert at beginning of raw
            // else, find the rawIndex of last filtered element and insert one after
            const positionToInsert = filteredLength ? filtered[filteredLength - 1]['rawIndex'] + 1 : 0;
            raw.splice.apply(raw, [positionToInsert, 0].concat(newItems));
            return true;
          }
          // Trying to use it like an associative array
          raw[property] = filterEverything(handler, value);
          return true;
        },
        has: function (target, property) {
          const raw = target;
          const filtered = getFilteredArray(handler, raw, key);
          return property in filtered;
        },
        ownKeys: function (target) {
          const raw = target;
          const filtered = getFilteredArray(handler, raw, key);
          return ownKeys(filtered);
        },
        deleteProperty: function (target, property) {
          const raw = target;
          const coercedProperty = Number(property);
          // If property is a numerical index(0 or positive integer)
          if (!Number.isNaN(coercedProperty) && Number.isInteger(coercedProperty) && coercedProperty >= 0) {
            const filtered = getFilteredArray(handler, raw, key);
            if (filtered[property]) {
              delete raw[filtered[property]['rawIndex']];
            }
          } else {
            const value = raw[property];
            // If value was set by using the array like an associative array
            if (value) {
              // Check if we have access
              const rawValue = getRef(value, key);
              if (rawValue) {
                delete raw[property];
              }
            }
          }
          return true;
        }
        // Not handling "apply" and "construct" trap and letting the underlying raw handle apply and throw the error
      };

      setKey(handler, key);
      KEY_TO_ARRAY_HANDLER.set(key, handler);
      freeze(handler);
    }
    return handler;
  }
  function createProxyForArrayObjects(raw, key) {
    if (!isArray(raw)) {
      warn('Illegal usage of createProxyForArrayObjects');
      return createFilteringProxy(raw, key);
    }
    // Not using a surrogate for array proxy because we want to support for..in
    // style of looping on arrays. Having a fake surrogate does not allow for
    // correct looping. Mitigating this risk by handling all traps for Proxy.
    const proxy = new Proxy(raw, getArrayProxyHandler(key));
    setKey(proxy, key);
    registerProxy(proxy);
    return proxy;
  }
  const KEY_TO_NAMED_NODE_MAP_HANLDER = typeof Map !== 'undefined' ? new Map() : undefined;
  function getFilteredNamedNodeMap(raw, key, prototype, caseInsensitiveAttributes) {
    const filtered = {};
    for (let n = 0, i = 0; n < raw.length; n++) {
      const value = raw[n];
      if (isValidAttributeName(raw, value.name, prototype, caseInsensitiveAttributes)) {
        filtered[i++] = value;
      }
    }
    return filtered;
  }
  function getNamedNodeMapProxyHandler(key, prototype, caseInsensitiveAttributes) {
    function getFromFiltered(so, filtered, index) {
      const value = filtered[index];
      return value ? filterEverything(so, value, {
        defaultKey: key
      }) : value;
    }
    let handler = KEY_TO_NAMED_NODE_MAP_HANLDER.get(key);
    if (!handler) {
      handler = {
        get: function (target, property) {
          property = asPropertyName(property);
          const raw = getRef(target, key);
          const filtered = getFilteredNamedNodeMap(raw, key, prototype, caseInsensitiveAttributes);
          if (typeof property === 'number') {
            return getFromFiltered(handler, filtered, property);
          }
          switch (property) {
            case 'length':
              return ObjectKeys(filtered).length;
            case 'item':
              return function (index) {
                return getFromFiltered(handler, filtered, index);
              };
            case 'getNamedItem':
              return function (name) {
                for (const val in filtered) {
                  if (name === filtered[val].name) {
                    return filterEverything(handler, filtered[val], {
                      defaultKey: key
                    });
                  }
                }
                return null;
              };
            case 'setNamedItem':
              return function (attribute) {
                if (!isValidAttributeName(raw, attribute.name, prototype, caseInsensitiveAttributes)) {
                  warn(`${this} does not allow getting/setting the ${attribute.name.toLowerCase()} attribute, ignoring!`);
                  return undefined;
                }
                // it may not be possible to get here from another Locker so the access check may be unnecessary
                // keep to error on the safe side
                verifyAccess(attribute, target);
                if (isProxy(attribute)) {
                  attribute = getRef(attribute, key);
                }
                return filterEverything(handler, raw['setNamedItem'](attribute), {
                  defaultKey: key
                });
              };
            case 'removeNamedItem':
              return function (name) {
                if (!isValidAttributeName(raw, name, prototype, caseInsensitiveAttributes)) {
                  warn(`${this} does not allow removing the ${name.toLowerCase()} attribute, ignoring!`);
                  return undefined;
                }
                return filterEverything(handler, raw['removeNamedItem'](name), {
                  defaultKey: key
                });
              };
            case 'getNamedItemNS':
              return function (namespace, localName) {
                for (const val in filtered) {
                  if (namespace === filtered[val].namespaceURI && localName === filtered[val].localName) {
                    return filterEverything(handler, filtered[val], {
                      defaultKey: key
                    });
                  }
                }
                return null;
              };
            case 'setNamedItemNS':
              return function (attribute) {
                if (!isValidAttributeName(raw, attribute.name, prototype, caseInsensitiveAttributes)) {
                  warn(`${this} does not allow getting/setting the ${attribute.name.toLowerCase()} attribute, ignoring!`);
                  return undefined;
                }
                verifyAccess(attribute, target);
                if (isProxy(attribute)) {
                  attribute = getRef(attribute, key);
                }
                return filterEverything(handler, raw['setNamedItemNS'](attribute), {
                  defaultKey: key
                });
              };
            case 'removeNamedItemNS':
              return function (namespace, localName) {
                if (!isValidAttributeName(raw, localName, prototype, caseInsensitiveAttributes)) {
                  warn(`${this} does not allow removing the ${localName.toLowerCase()} attribute, ignoring!`);
                  return undefined;
                }
                return filterEverything(handler, raw['removeNamedItemNS'](namespace, localName), {
                  defaultKey: key
                });
              };
            case 'toJSON':
              return () => stringify(filtered);
            case 'toString':
              return () => raw.toString();
            case Symbol.iterator:
              return function () {
                let nextIndex = 0;
                return {
                  next: function () {
                    if (nextIndex < filtered.length) {
                      const value = filtered[nextIndex];
                      nextIndex++;
                      return {
                        value: value ? filterEverything(handler, value) : value,
                        done: false
                      };
                    }
                    return {
                      done: true
                    };
                  }
                };
              };
            case Symbol.toStringTag:
              return raw.toString();
            default:
              warn(`Unsupported ${asString(raw)} method: ${asString(property)}. Returning undefined`);
              return undefined;
          }
        },
        has: function (target, property) {
          const raw = getRef(target, key);
          const filtered = getFilteredNamedNodeMap(handler, raw, key, prototype);
          return property in filtered;
        }
      };
      setKey(handler, key);
      KEY_TO_NAMED_NODE_MAP_HANLDER.set(key, handler);
      freeze(handler);
    }
    return handler;
  }
  function createProxyForNamedNodeMap(raw, key, prototype, caseInsensitiveAttributes) {
    const surrogate = create$1(getPrototypeOf(raw));
    setRef(surrogate, raw, key);
    const proxy = new Proxy(surrogate, getNamedNodeMapProxyHandler(key, prototype, caseInsensitiveAttributes));
    setKey(proxy, key);
    registerProxy(proxy);
    return proxy;
  }
  function createFilteredConstructor(st, raw, propName, factory, key, options = DEFAULT) {
    if (!factory || !key) {
      warn('No Factory or key provided.');
      return undefined;
    }
    if (!(propName in raw)) {
      if (options.ignoreNonExisting) {
        return undefined;
      }
      throw new error(`Underlying raw object ${raw} does not support constructor: ${propName}`);
    }
    return {
      enumerable: true,
      writable: true,
      value: factory(raw[propName], key)
    };
  }
  function createFilteredMethod(st, raw, methodName, options = DEFAULT) {
    // Do not expose properties that the raw object does not actually support
    if (!(methodName in raw)) {
      if (options.ignoreNonExisting) {
        return undefined;
      }
      throw new error(`Underlying raw object ${raw} does not support method: ${methodName}`);
    }
    return {
      configurable: false,
      enumerable: true,
      writable: true,
      value: maskToString(function () {
        const filteredArgs = filterArguments(st, arguments, options);
        let fnReturnedValue = raw[methodName](...filteredArgs);
        if (options.afterCallback) {
          fnReturnedValue = options.afterCallback(fnReturnedValue);
        }
        return filterEverything(st, fnReturnedValue, options);
      }, raw[methodName])
    };
  }
  function createFilteredMethodStateless(methodName, prototype, options = DEFAULT) {
    if (!prototype) {
      throw new Error('createFilteredMethodStateless() called without prototype');
    }
    return {
      configurable: false,
      enumerable: true,
      writable: true,
      value: maskToString(function () {
        const st = this;
        const raw = getRawThis(st);
        const filteredArgs = filterArguments(st, arguments, options);
        let fnReturnedValue = raw[methodName].apply(raw, filteredArgs);
        if (options.afterCallback) {
          fnReturnedValue = options.afterCallback.call(st, fnReturnedValue);
        }
        if (options.trustReturnValue) {
          trust$1(st, fnReturnedValue);
        }
        return filterEverything(st, fnReturnedValue, options);
      }, methodName)
    };
  }
  function createFilteredProperty(st, raw, propertyName, options = DEFAULT) {
    // Do not expose properties that the raw object does not actually support.
    if (!(propertyName in raw)) {
      if (options.ignoreNonExisting) {
        return undefined;
      }
      throw new error(`Underlying raw object ${raw} does not support property: ${propertyName}`);
    }
    const descriptor = {
      enumerable: true
    };
    descriptor.get = function () {
      let value = raw[propertyName];

      // Continue from the current object until we find an accessible object.
      if (options.skipOpaque) {
        // skipping opaque elements and traverse up the dom tree, eg: event.target
        const traverse = options.traverse || propertyName;
        const traverseAlt = options.traverseAlt;
        const key = getKey(st);
        while (value) {
          if (hasAccess(st, value) || isSharedElement(value) || isAccessibleLWCNode(key, value)) {
            break;
          }
          const nextValue = value[traverse];
          value = nextValue === null && traverseAlt ? value[traverseAlt] : nextValue;
        }
      }
      if (options.afterGetCallback) {
        // The caller wants to handle the property value
        return options.afterGetCallback(value);
      }
      return filterEverything(st, value, options);
    };
    if (options.writable !== false) {
      descriptor.set = function (value) {
        if (options.beforeSetCallback) {
          value = options.beforeSetCallback(value);
        }
        raw[propertyName] = filterEverything(st, value);
        if (options.afterSetCallback) {
          options.afterSetCallback();
        }
      };
    }
    return descriptor;
  }
  function createFilteredPropertyStateless(propertyName, prototype, options = DEFAULT) {
    if (!prototype) {
      throw new Error('createFilteredPropertyStateless() called without prototype');
    }
    const descriptor = {
      enumerable: true
    };
    descriptor.get = function () {
      const st = this;
      const raw = getRawThis(st);
      const key = getKey(st);
      let value = raw[propertyName];

      // Continue from the current object until we find an accessible object.
      if (options.skipOpaque) {
        while (value) {
          const hasAccess$1 = hasAccess(st, value);
          if (hasAccess$1 || value === document.body || value === document.head || value === document.documentElement || value === document || isAccessibleLWCNode(key, value)) {
            break;
          }
          value = value[propertyName];
        }
      }
      if (options.afterGetCallback) {
        // The caller wants to handle the property value
        return options.afterGetCallback.call(st, value);
      }
      return filterEverything(st, value, options);
    };
    if (options.writable !== false) {
      descriptor.set = function (value) {
        const st = this;
        const key = getKey(st);
        const raw = getRef(st, key);
        if (options.beforeSetCallback) {
          value = options.beforeSetCallback.call(st, value);
        }
        raw[propertyName] = filterEverything(st, value);
        if (options.afterSetCallback) {
          options.afterSetCallback.call(st);
        }
      };
    }
    return descriptor;
  }
  function addIfSupported(behavior, st, element, name, options = DEFAULT) {
    options = createOptions(options, IGNORE_NON_EXISTING);
    const prop = behavior(st, element, name, options);
    if (prop) {
      defineProperty(st, name, prop);
    }
  }
  function addPropertyIfSupported(st, raw, name, options) {
    addIfSupported(createFilteredProperty, st, raw, name, options);
  }
  function addMethodIfSupported(st, raw, name, options) {
    addIfSupported(createFilteredMethod, st, raw, name, options);
  }

  // Return the set of interfaces supported by the object in order of most specific to least specific
  function getSupportedInterfaces(o) {
    const interfaces = [];
    if (o instanceof Window) {
      interfaces.push('Window', 'EventTarget');
    } else if (o instanceof Document) {
      if (o instanceof HTMLDocument) {
        interfaces.push('HTMLDocument');
      }
      interfaces.push('Document', 'Node', 'EventTarget');
    } else if (o instanceof DocumentFragment) {
      interfaces.push('Node', 'EventTarget', 'DocumentFragment');
    } else if (o instanceof DocumentType) {
      interfaces.push('DocumentType', 'Node', 'EventTarget');
    } else if (o instanceof DOMImplementation) {
      interfaces.push('DOMImplementation');
    } else if (o instanceof Element) {
      if (o instanceof HTMLElement) {
        // Look for all HTMLElement subtypes
        if (o instanceof HTMLAnchorElement) {
          interfaces.push('HTMLAnchorElement');
        } else if (o instanceof HTMLAreaElement) {
          interfaces.push('HTMLAreaElement');
        } else if (o instanceof HTMLMediaElement) {
          if (o instanceof HTMLAudioElement) {
            interfaces.push('HTMLAudioElement');
          } else if (o instanceof HTMLVideoElement) {
            interfaces.push('HTMLVideoElement');
          }
          interfaces.push('HTMLMediaElement');
        } else if (o instanceof HTMLBaseElement) {
          interfaces.push('HTMLBaseElement');
        } else if (o instanceof HTMLButtonElement) {
          interfaces.push('HTMLButtonElement');
        } else if (o instanceof HTMLCanvasElement) {
          interfaces.push('HTMLCanvasElement');
        } else if (o instanceof HTMLTableColElement) {
          interfaces.push('HTMLTableColElement');
        } else if (o instanceof HTMLTableRowElement) {
          interfaces.push('HTMLTableRowElement');
        } else if (o instanceof HTMLModElement) {
          interfaces.push('HTMLModElement');
        } else if (typeof HTMLDetailsElement !== 'undefined' && o instanceof HTMLDetailsElement) {
          interfaces.push('HTMLDetailsElement');
        } else if (o instanceof HTMLEmbedElement) {
          interfaces.push('HTMLEmbedElement');
        } else if (o instanceof HTMLFieldSetElement) {
          interfaces.push('HTMLFieldSetElement');
        } else if (o instanceof HTMLFormElement) {
          interfaces.push('HTMLFormElement');
        } else if (o instanceof HTMLIFrameElement) {
          interfaces.push('HTMLIFrameElement');
        } else if (o instanceof HTMLImageElement) {
          interfaces.push('HTMLImageElement');
        } else if (o instanceof HTMLInputElement) {
          interfaces.push('HTMLInputElement');
        } else if (o instanceof HTMLLabelElement) {
          interfaces.push('HTMLLabelElement');
        } else if (o instanceof HTMLLIElement) {
          interfaces.push('HTMLLIElement');
        } else if (o instanceof HTMLLinkElement) {
          interfaces.push('HTMLLinkElement');
        } else if (o instanceof HTMLMapElement) {
          interfaces.push('HTMLMapElement');
        } else if (o instanceof HTMLMetaElement) {
          interfaces.push('HTMLMetaElement');
        } else if (typeof HTMLMeterElement !== 'undefined' && o instanceof HTMLMeterElement) {
          interfaces.push('HTMLMeterElement');
        } else if (o instanceof HTMLObjectElement) {
          interfaces.push('HTMLObjectElement');
        } else if (o instanceof HTMLOListElement) {
          interfaces.push('HTMLOListElement');
        } else if (o instanceof HTMLOptGroupElement) {
          interfaces.push('HTMLOptGroupElement');
        } else if (o instanceof HTMLOptionElement) {
          interfaces.push('HTMLOptionElement');
        } else if (typeof HTMLOutputElement !== 'undefined' && o instanceof HTMLOutputElement) {
          interfaces.push('HTMLOutputElement');
        } else if (o instanceof HTMLParamElement) {
          interfaces.push('HTMLParamElement');
        } else if (o instanceof HTMLProgressElement) {
          interfaces.push('HTMLProgressElement');
        } else if (o instanceof HTMLQuoteElement) {
          interfaces.push('HTMLQuoteElement');
        } else if (o instanceof HTMLScriptElement) {
          interfaces.push('HTMLScriptElement');
        } else if (o instanceof HTMLSelectElement) {
          interfaces.push('HTMLSelectElement');
        } else if (typeof HTMLSlotElement !== 'undefined' && o instanceof HTMLSlotElement) {
          interfaces.push('HTMLSlotElement');
        } else if (o instanceof HTMLSourceElement) {
          interfaces.push('HTMLSourceElement');
        } else if (o instanceof HTMLTableCellElement) {
          interfaces.push('HTMLTableCellElement');
        } else if (o instanceof HTMLTableElement) {
          interfaces.push('HTMLTableElement');
        } else if (typeof HTMLTemplateElement !== 'undefined' && o instanceof HTMLTemplateElement) {
          interfaces.push('HTMLTemplateElement');
        } else if (o instanceof HTMLTextAreaElement) {
          interfaces.push('HTMLTextAreaElement');
        } else if (o instanceof HTMLTrackElement) {
          interfaces.push('HTMLTrackElement');
        }
        if (o instanceof HTMLTableSectionElement) {
          interfaces.push('HTMLTableSectionElement');
        }
        interfaces.push('HTMLElement');
      } else if (o instanceof SVGElement) {
        if (o instanceof SVGSVGElement) {
          interfaces.push('SVGSVGElement');
        } else if (o instanceof SVGAngle) {
          interfaces.push('SVGAngle');
        } else if (o instanceof SVGCircleElement) {
          interfaces.push('SVGCircleElement');
        } else if (o instanceof SVGClipPathElement) {
          interfaces.push('SVGClipPathElement');
        } else if (o instanceof SVGDefsElement) {
          interfaces.push('SVGGraphicsElement');
        } else if (o instanceof SVGEllipseElement) {
          interfaces.push('SVGEllipseElement');
        } else if (o instanceof SVGFilterElement) {
          interfaces.push('SVGFilterElement');
        } else if (o instanceof SVGForeignObjectElement) {
          interfaces.push('SVGForeignObjectElement');
        } else if (o instanceof SVGImageElement) {
          interfaces.push('SVGImageElement');
        } else if (o instanceof SVGLength) {
          interfaces.push('SVGLength');
        } else if (o instanceof SVGLengthList) {
          interfaces.push('SVGLengthList');
        } else if (o instanceof SVGLineElement) {
          interfaces.push('SVGLineElement');
        } else if (o instanceof SVGLinearGradientElement) {
          interfaces.push('SVGLinearGradientElement');
        } else if (o instanceof SVGMaskElement) {
          interfaces.push('SVGMaskElement');
        } else if (o instanceof SVGNumber) {
          interfaces.push('SVGNumber');
        } else if (o instanceof SVGNumberList) {
          interfaces.push('SVGNumberList');
        } else if (o instanceof SVGPatternElement) {
          interfaces.push('SVGPatternElement');
        } else if (o instanceof SVGPreserveAspectRatio) {
          interfaces.push('SVGPreserveAspectRatio');
        } else if (o instanceof SVGRadialGradientElement) {
          interfaces.push('SVGRadialGradientElement');
        } else if (o instanceof SVGRect) {
          interfaces.push('SVGRect');
        } else if (o instanceof SVGRectElement) {
          interfaces.push('SVGRectElement');
        } else if (o instanceof SVGScriptElement) {
          interfaces.push('SVGScriptElement');
        } else if (o instanceof SVGStopElement) {
          interfaces.push('SVGStopElement');
        } else if (o instanceof SVGStringList) {
          interfaces.push('SVGStringList');
        } else if (o instanceof SVGStyleElement) {
          interfaces.push('SVGStyleElement');
        } else if (o instanceof SVGTransform) {
          interfaces.push('SVGTransform');
        } else if (o instanceof SVGTransformList) {
          interfaces.push('SVGTransformList');
        } else if (o instanceof SVGUseElement) {
          interfaces.push('SVGUseElement');
          interfaces.push('SVGURIReference');
        } else if (o instanceof SVGViewElement) {
          interfaces.push('SVGViewElement');
        } else if (o instanceof SVGAnimatedAngle) {
          interfaces.push('SVGAnimatedAngle');
        } else if (o instanceof SVGAnimatedBoolean) {
          interfaces.push('SVGAnimatedBoolean');
        } else if (o instanceof SVGAnimatedEnumeration) {
          interfaces.push('SVGAnimatedEnumeration');
        } else if (o instanceof SVGAnimatedInteger) {
          interfaces.push('SVGAnimatedInteger');
        } else if (o instanceof SVGAnimatedLength) {
          interfaces.push('SVGAnimatedLength');
        } else if (o instanceof SVGAnimatedLengthList) {
          interfaces.push('SVGAnimatedLengthList');
        } else if (o instanceof SVGAnimatedNumber) {
          interfaces.push('SVGAnimatedNumber');
        } else if (o instanceof SVGAnimatedNumberList) {
          interfaces.push('SVGAnimatedNumberList');
        } else if (o instanceof SVGAnimatedPreserveAspectRatio) {
          interfaces.push('SVGAnimatedPreserveAspectRatio');
        } else if (o instanceof SVGAnimatedRect) {
          interfaces.push('SVGAnimatedRect');
        } else if (o instanceof SVGAnimatedString) {
          interfaces.push('SVGAnimatedString');
        } else if (o instanceof SVGAnimatedTransformList) {
          interfaces.push('SVGAnimatedTransformList');
        }

        // below may be implemented by multiple types
        if (o instanceof SVGTextContentElement) {
          interfaces.push('SVGTextContentElement');
        }
        if (typeof SVGAnimationElement !== 'undefined' && o instanceof SVGAnimationElement) {
          interfaces.push('SVGAnimationElement');
        }
        if (o instanceof SVGGradientElement) {
          interfaces.push('SVGGradientElement');
        }
        if (typeof SVGGraphicsElement !== 'undefined' && o instanceof SVGGraphicsElement) {
          interfaces.push('SVGGraphicsElement');
        }
        if (typeof SVGGeometryElement !== 'undefined' && o instanceof SVGGeometryElement) {
          interfaces.push('SVGGeometryElement');
        }
        if (o instanceof SVGTextPositioningElement) {
          interfaces.push('SVGTextPositioningElement');
        }
        interfaces.push('SVGElement');
      }
      interfaces.push('Element', 'Node', 'EventTarget');
    } else if (o instanceof Text) {
      interfaces.push('Text', 'CharacterData', 'Node');
    } else if (o instanceof Comment) {
      interfaces.push('CharacterData', 'Node');
    } else if (o instanceof Attr) {
      interfaces.push('Attr', 'Node', 'EventTarget');
    } else if (o instanceof CanvasRenderingContext2D) {
      interfaces.push('CanvasRenderingContext2D');
    } else if (typeof RTCPeerConnection !== 'undefined' && o instanceof RTCPeerConnection) {
      interfaces.push('RTCPeerConnection');
    }
    return interfaces;
  }
  function addPrototypeMethodsAndProperties(metadata, so, raw, key) {
    let prototype;
    function worker(name) {
      let valueOverride;
      if (!(name in so) && name in raw) {
        const options = prototype[name];
        if (options.type === 'function') {
          addMethodIfSupported(so, raw, name, options);
        } else if (options.type === '@raw') {
          defineProperty(so, name, {
            // Does not currently secure proxy the actual class
            get: function () {
              return valueOverride || raw[name];
            },
            set: function (value) {
              valueOverride = value;
            }
          });
        } else if (options.type === '@ctor') {
          defineProperty(so, name, {
            get: function () {
              return valueOverride || function () {
                const cls = raw[name];
                const args = ArraySlice(arguments);
                let result;
                if (typeof cls === 'function') {
                  // Function.prototype.bind.apply is being used to invoke the constructor and to pass all the arguments provided by the caller
                  // @TODO: Switch to ES6 when available https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
                  const ctor = Function.prototype.bind.apply(cls, [null].concat(args));
                  result = new ctor();
                } else {
                  // For browsers that use a constructor that's not a function, invoke the constructor directly.
                  // For example, on Mobile Safari window["Audio"] returns an object called AudioConstructor
                  // Passing the args as an array is the closest we got to passing the arguments.
                  result = new cls(args);
                }
                trust$1(so, result);
                return filterEverything(so, result);
              };
            },
            set: function (value) {
              valueOverride = value;
            }
          });
        } else if (options.type === '@event') {
          defineProperty(so, name, {
            get: function () {
              return filterEverything(so, raw[name]);
            },
            set: function (callback) {
              raw[name] = function (e) {
                if (callback) {
                  callback.call(so, e && SecureDOMEvent(e, key));
                }
              };
            }
          });
        } else {
          // Properties
          const descriptor = createFilteredProperty(so, raw, name, options);
          if (descriptor) {
            defineProperty(so, name, descriptor);
          }
        }
      }
    }
    const supportedInterfaces = getSupportedInterfaces(raw);
    const prototypes = metadata['prototypes'];
    fastArrayForEach(supportedInterfaces, name => {
      prototype = prototypes[name];
      ObjectKeys(prototype).forEach(worker);
    });
  }

  // Closure factory
  function addPrototypeMethodsAndPropertiesStatelessHelper(name, prototype, prototypicalInstance, prototypeForValidation, rawPrototypicalInstance, config) {
    let descriptor;
    let valueOverride;
    if (!prototypeForValidation.hasOwnProperty(name) && name in rawPrototypicalInstance) {
      const options = prototype[name];
      if (options.type === 'function') {
        descriptor = createFilteredMethodStateless(name, prototypeForValidation, options);
      } else if (options.type === '@raw') {
        descriptor = {
          // Does not currently secure proxy the actual class
          get: function () {
            if (valueOverride) {
              return valueOverride;
            }
            const raw = getRawThis(this);
            return raw[name];
          },
          set: function (value) {
            valueOverride = value;
          }
        };
      } else if (options.type === '@ctor') {
        descriptor = {
          get: valueOverride || function () {
            return function () {
              const so = this;
              const raw = getRawThis(so);
              const cls = raw[name];

              // @TODO: Switch to ES6 when available https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
              const ctor = Function.prototype.bind.apply(cls, [null].concat(ArraySlice(arguments)));
              const result = new ctor();
              trust$1(so, result);
              return filterEverything(so, result);
            };
          },
          set: function (value) {
            valueOverride = value;
          }
        };
      } else if (options.type === '@event') {
        descriptor = {
          get: function () {
            return filterEverything(this, getRawThis(this)[name]);
          },
          set: function (callback) {
            const raw = getRawThis(this);

            // Insure that we pick up the current proxy for the raw object
            let key = getKey(raw);
            // Shared elements like <body> and <head> are not tied to specific namespaces.
            // Every namespace has a secure wrapper for these elements
            if (!key && isSharedElement(raw)) {
              // Obtain the key of the secure wrapper
              key = getKey(this);
            }
            const o = getFromCache(raw, key);
            raw[name] = function (e) {
              if (callback) {
                callback.call(o, e && SecureDOMEvent(e, key));
              }
            };
          }
        };
      } else {
        // Properties
        descriptor = createFilteredPropertyStateless(name, prototypeForValidation, options);
      }
    }
    if (descriptor) {
      config[name] = descriptor;
    }
  }
  function addPrototypeMethodsAndPropertiesStateless(metadata, prototypicalInstance, prototypeForValidation) {
    const rawPrototypicalInstance = getRawThis(prototypicalInstance);
    let prototype;
    const config = {};
    const supportedInterfaces = getSupportedInterfaces(rawPrototypicalInstance);
    const prototypes = metadata['prototypes'];
    fastArrayForEach(supportedInterfaces, name => {
      prototype = prototypes[name];
      for (const property in prototype) {
        addPrototypeMethodsAndPropertiesStatelessHelper(property, prototype, prototypicalInstance, prototypeForValidation, rawPrototypicalInstance, config);
      }
    });
    return config;
  }
  function getUnfilteredTypes() {
    const ret = [];
    const unfilteredTypesMeta = ['File', 'FileList', 'CSSStyleDeclaration', 'TimeRanges', 'Date', 'MessagePort', 'MessageChannel', 'MessageEvent', 'FormData', 'ValidityState', 'Crypto', 'DOMTokenList', 'ArrayBuffer', 'Blob'];
    fastArrayForEach(unfilteredTypesMeta, unfilteredType => {
      if (typeof window[unfilteredType] !== 'undefined') {
        ret.push(window[unfilteredType]);
      }
    });
    return ret;
  }
  const unfilteredTypes = getUnfilteredTypes();
  function isUnfilteredType(raw, key) {
    for (let n = 0; n < unfilteredTypes.length; n++) {
      if (raw instanceof unfilteredTypes[n]) {
        return true;
      }
    }

    // Do not filter ArrayBufferView types. https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView
    if (raw && raw.buffer instanceof ArrayBuffer && raw.byteLength !== undefined) {
      return true;
    }
    if (isUnfilteredTypeHook$1 && isUnfilteredTypeHook$1(raw, key)) {
      return true;
    }
    return false;
  }
  function addUnfilteredPropertyIfSupported(st, raw, name) {
    if (raw[name]) {
      const config = {
        enumerable: true,
        value: raw[name],
        writable: true
      };
      defineProperty(st, name, config);
    }
  }

  /**
   * @deprecated
   */
  function deepUnfilterMethodArguments(st, baseObject, members) {
    // The locker key of the secure thing from where the members originated
    const fromKey = getKey(st);
    for (const property in members) {
      const value = members[property];
      let rawValue = deepUnfilteringTypeHook$1 ? deepUnfilteringTypeHook$1(fromKey, value) : value;
      // If the hooks failed to unfilter the value, do the deep copy, unwrapping one item at a time
      if (rawValue === value) {
        if (isArray(value)) {
          rawValue = deepUnfilterMethodArguments(st, [], value);
        } else if (isPlainObject(value)) {
          rawValue = deepUnfilterMethodArguments(st, {}, value);
        } else if (typeof value !== 'function') {
          if (value) {
            const key = getKey(value);
            if (key) {
              rawValue = getRef(value, key) || value;
            }
          }
          // If value is a plain object, we need to deep unfilter
          if (isPlainObject(value)) {
            rawValue = deepUnfilterMethodArguments(st, {}, value);
          }
        } else {
          // For everything else we are not sure how to provide raw access, filter the value
          rawValue = filterEverything(st, value, {
            defaultKey: fromKey
          });
        }
      }
      baseObject[property] = rawValue;
    }
    return baseObject;
  }

  /**
   * Traverse all entries in the baseObject to unwrap any secure wrappers and wrap any functions as
   * SecureFunction. This ensures any non-Lockerized handlers of the event do not choke on the secure
   * wrappers, but any callbacks back into the original Locker have their arguments properly filtered.
   */
  function deepUnfilter(key, baseObject, members) {
    for (const property in members) {
      const value = members[property];
      let rawValue = deepUnfilteringTypeHook$1 ? deepUnfilteringTypeHook$1(key, value) : value;
      // If the hooks failed to unfilter the value, do the deep copy, unwrapping one item at a time
      if (rawValue === value) {
        if (isArray(value)) {
          rawValue = deepUnfilter(key, [], value);
        } else if (isPlainObject(value)) {
          rawValue = deepUnfilter(key, {}, value);
        } else if (typeof value !== 'function') {
          if (value) {
            const key = getKey(value);
            if (key) {
              rawValue = getRef(value, key) || value;
            }
          }
          // If value is a plain object, we need to deep unfilter
          if (isPlainObject(value)) {
            rawValue = deepUnfilter(key, {}, value);
          }
        } else {
          // For everything else we are not sure how to provide raw access, filter the value
          rawValue = filter(key, value, {
            defaultKey: key
          });
        }
      }
      baseObject[property] = rawValue;
    }
    return baseObject;
  }
  function SecureCustomEventFactory(CustomEventCtor, key) {
    assert.invariant(CustomEventCtor !== undefined, 'CustomEvent constructor is undefined');
    assert.invariant(key !== undefined, 'key is undefined');
    let SecureCustomEvent = getFromCache(CustomEventCtor, key);
    if (SecureCustomEvent) {
      return SecureCustomEvent;
    }
    SecureCustomEvent = function (...args) {
      // Because the event is being constructed, the sandbox will be used as the accessor
      const filteredArguments = deepUnfilterMethodArguments(getEnv$1(key), [], args);
      const event = new CustomEventCtor(...filteredArguments);
      return SecureDOMEvent(event, key);
    };
    addToCache(CustomEventCtor, SecureCustomEvent, key);
    setRef(SecureCustomEvent, CustomEventCtor, key);
    return SecureCustomEvent;
  }
  function SecureRTCPeerConnection(raw, key) {
    const SecureConstructor = function SecureConstructor(configuration) {
      const rtc = new raw(configuration);
      const o = create$1(null, {
        toString: {
          value: function () {
            return `SecureRTCPeerConnection: ${rtc}{ key: ${JSON.stringify(key)} }`;
          }
        }
      });
      setRef(o, rtc, key);
      // Reference to the original event target functions
      const originalAddEventListener = rtc['addEventListener'];
      const originalDispatchEvent = rtc['dispatchEvent'];
      const originalRemoveEventListener = rtc['removeEventListener'];
      // Override the event target functions to handled wrapped arguments
      defineProperties(rtc, {
        addEventListener: {
          writable: true,
          value: function (event, callback, useCapture) {
            if (!callback) {
              return;
            }
            let sCallback = getFromCache(callback, key);
            if (!sCallback) {
              sCallback = function (e) {
                verifyAccess(o, callback, true);
                const se = e && SecureDOMEvent(e, key);
                callback.call(o, se);
              };
              addToCache(callback, sCallback, key);
              setKey(callback, key);
            }
            originalAddEventListener.call(rtc, event, sCallback, useCapture);
          }
        },
        dispatchEvent: {
          enumerable: true,
          writable: true,
          value: function () {
            const filteredArgs = filterArguments(o, arguments, RAW_ARGS);
            const fnReturnedValue = originalDispatchEvent.apply(rtc, filteredArgs);
            return filterEverything(o, fnReturnedValue, RAW_ARGS);
          }
        },
        removeEventListener: {
          writable: true,
          value: function (type, listener, removeOption) {
            const sCallback = getFromCache(listener, key);
            originalRemoveEventListener.call(rtc, type, sCallback, removeOption);
          }
        }
      });
      return rtc;
    };
    SecureConstructor.prototype = raw.prototype;
    return SecureConstructor;
  }
  function SecureNavigator(navigator, key) {
    let o = getFromCache(navigator, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureNavigator: ${navigator}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    fastArrayForEach(['appCodeName', 'appName', 'appVersion', 'cookieEnabled', 'geolocation', 'language', 'onLine', 'platform', 'product', 'userAgent'], name => addPropertyIfSupported(o, navigator, name));
    if (navigatorAddPropertiesHook$1) {
      navigatorAddPropertiesHook$1(o, navigator, key);
    }
    setRef(o, navigator, key);
    addToCache(navigator, o, key);
    registerProxy(o);
    return o;
  }
  const keyToConstructor$3 = new WeakMap();
  function SecureDOMImplementationWrapper(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    const constructor = keyToConstructor$3.get(key);
    assert.invariant(constructor, 'DOMImplementation is not defined!');
    const proto = constructor.prototype;
    o = create$1(proto);
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureDOMImplementation(win, key) {
    if (keyToConstructor$3.has(key)) {
      return keyToConstructor$3.get(key);
    }
    const {
      prototype
    } = win.DOMImplementation;
    const orignalCreateDocument = prototype.createDocument;
    const originalCreateDocumentType = prototype.createDocumentType;
    const orignalCreateHTMLDocument = prototype.createHTMLDocument;
    class DOMImplementation {
      constructor() {
        throw new TypeError('Illegal constructor');
      }
    }
    defineProperties(DOMImplementation.prototype, {
      createDocumentType: {
        configurable: true,
        enumerable: true,
        value: function () {
          const key = getKey(this);
          const raw = getRef(this, key);
          const rawDocumentType = apply(originalCreateDocumentType, raw, arguments);
          return SecureDocumentType(rawDocumentType, key);
        }
      },
      createDocument: {
        configurable: true,
        enumerable: true,
        value: function () {
          const key = getKey(this);
          const raw = getRef(this, key);

          // Let the native `createDocument()` method handle throwing an error
          // when not enough arguments are provided.
          if (arguments.length < 2) {
            return apply(orignalCreateDocument, raw, arguments);
          }

          // The default value for the `documentType` parameter is `null`.
          // https://dom.spec.whatwg.org/#dom-domimplementation-createdocument-namespace-qualifiedname-doctype-doctype
          const {
            0: namespaceURI,
            1: qualifiedName,
            2: documentType = null
          } = arguments;
          const rawDocumentType = isProxy(documentType) ? getRef(documentType, key) : documentType;

          // Return the unsecured result until we can properly work through the
          // security implications.
          return apply(orignalCreateDocument, raw, [namespaceURI, qualifiedName, rawDocumentType]);
        }
      },
      createHTMLDocument: {
        configurable: true,
        enumerable: true,
        value: function () {
          const raw = getRawThis(this);

          // Return the unsecured result until we can properly work through the
          // security implications and the handling of "shared" nodes.
          return apply(orignalCreateHTMLDocument, raw, arguments);
        }
      },
      hasFeature: {
        configurable: true,
        enumerable: true,
        value: function () {
          return true;
        }
      },
      toString: {
        configurable: true,
        enumerable: true,
        value: function () {
          const key = getKey(this);
          const raw = getRef(this, key);
          return `SecureDOMImplemenation: ${raw} { key: ${stringify(key)} }`;
        }
      },
      [Symbol.toStringTag]: {
        configurable: true,
        value: 'DOMImplementation'
      }
    });
    keyToConstructor$3.set(key, DOMImplementation);
    return DOMImplementation;
  }
  SecureDOMImplementation.toString = function () {
    return 'SecureDOMImplementation() { [native code] }';
  };
  const statics = {
    END_TO_END: READ_ONLY_PROPERTY,
    END_TO_START: READ_ONLY_PROPERTY,
    START_TO_END: READ_ONLY_PROPERTY,
    START_TO_START: READ_ONLY_PROPERTY
  };
  var RangeMetadata = {
    END_TO_END: READ_ONLY_PROPERTY,
    END_TO_START: READ_ONLY_PROPERTY,
    START_TO_END: READ_ONLY_PROPERTY,
    START_TO_START: READ_ONLY_PROPERTY,
    cloneContents: FUNCTION_RAW_ARGS,
    cloneRange: FUNCTION_RAW_ARGS,
    collapse: FUNCTION_RAW_ARGS,
    collapsed: READ_ONLY_PROPERTY,
    commonAncestorContainer: READ_ONLY_PROPERTY,
    compareBoundaryPoints: FUNCTION_RAW_ARGS,
    comparePoint: FUNCTION_RAW_ARGS,
    // createContextualFragment: FUNCTION, // Custom descriptor
    deleteContents: FUNCTION_RAW_ARGS,
    detach: FUNCTION_RAW_ARGS,
    endContainer: READ_ONLY_PROPERTY,
    endOffset: READ_ONLY_PROPERTY,
    expand: FUNCTION_RAW_ARGS,
    extractContents: FUNCTION_RAW_ARGS,
    getBoundingClientRect: FUNCTION_RAW_ARGS,
    getClientRects: FUNCTION_RAW_ARGS,
    insertNode: FUNCTION_RAW_ARGS,
    intersectsNode: FUNCTION_RAW_ARGS,
    isPointInRange: FUNCTION_RAW_ARGS,
    selectNode: FUNCTION_RAW_ARGS,
    selectNodeContents: FUNCTION_RAW_ARGS,
    setEnd: FUNCTION_RAW_ARGS,
    setEndAfter: FUNCTION_RAW_ARGS,
    setEndBefore: FUNCTION_RAW_ARGS,
    setStart: FUNCTION_RAW_ARGS,
    setStartAfter: FUNCTION_RAW_ARGS,
    setStartBefore: FUNCTION_RAW_ARGS,
    startContainer: READ_ONLY_PROPERTY,
    startOffset: READ_ONLY_PROPERTY,
    surroundContents: FUNCTION_RAW_ARGS
  };
  const keyToConstructor$2 = new WeakMap();
  function SecureRangeWrapper(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    const constructor = keyToConstructor$2.get(key);
    assert.invariant(constructor, 'Range is not defined!');
    o = create$1(constructor.prototype);
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureRange(rawWin, key) {
    if (keyToConstructor$2.has(key)) {
      return keyToConstructor$2.get(key);
    }
    class Range {
      constructor() {
        const rawRange = rawWin.document.createRange();
        setKey(rawRange, key);
        // eslint-disable-next-line no-constructor-return
        return SecureRangeWrapper(rawRange, key);
      }
    }
    const protoDescriptors = {};
    const staticDescriptors = {};
    for (const property in RangeMetadata) {
      addPrototypeMethodsAndPropertiesStatelessHelper(property, RangeMetadata, undefined, Range.prototype, rawWin.Range.prototype, protoDescriptors);
    }
    for (const property in statics) {
      addPrototypeMethodsAndPropertiesStatelessHelper(property, statics, undefined, Range, rawWin.Range, staticDescriptors);
    }
    protoDescriptors.createContextualFragment = {
      configurable: true,
      enumerable: true,
      value: function (tagString) {
        const key = getKey(this);
        const raw = getRef(this, key);
        const rawFragment = raw.createContextualFragment(sanitizeDefault(tagString));
        setKey(rawFragment, key);
        trustChildNodes(this, rawFragment);
        return SecureElement(rawFragment, key);
      },
      writable: true
    };
    defineProperties(Range.prototype, protoDescriptors);
    defineProperties(Range, staticDescriptors);
    maskToString(Range, rawWin.Range);
    keyToConstructor$2.set(key, Range);
    setRef(Range, rawWin.Range, key);
    addToCache(rawWin.Range, Range, key);
    registerProxy(Range);
    return Range;
  }
  var SelectionMetadata = {
    anchorNode: READ_ONLY_PROPERTY,
    anchorOffset: READ_ONLY_PROPERTY,
    baseNode: READ_ONLY_PROPERTY,
    baseOffset: READ_ONLY_PROPERTY,
    extentNode: READ_ONLY_PROPERTY,
    extentOffset: READ_ONLY_PROPERTY,
    focusNode: READ_ONLY_PROPERTY,
    focusOffset: READ_ONLY_PROPERTY,
    isCollapsed: READ_ONLY_PROPERTY,
    rangeCount: READ_ONLY_PROPERTY,
    type: READ_ONLY_PROPERTY,
    addRange: FUNCTION_RAW_ARGS,
    collapse: FUNCTION_RAW_ARGS,
    collapseToEnd: FUNCTION,
    collapseToStart: FUNCTION,
    containsNode: FUNCTION_RAW_ARGS,
    deleteFromDocument: FUNCTION,
    empty: FUNCTION,
    extend: FUNCTION_RAW_ARGS,
    // getRangeAt: FUNCTION, // Custom descriptor
    modify: FUNCTION,
    removeAllRanges: FUNCTION,
    removeRange: FUNCTION_RAW_ARGS,
    selectAllChildren: FUNCTION_RAW_ARGS,
    setBaseAndExtent: FUNCTION_RAW_ARGS,
    setPosition: FUNCTION_RAW_ARGS,
    toString: FUNCTION
  };
  const keyToConstructor$1 = new WeakMap();
  function SecureSelectionWrapper(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    const constructor = keyToConstructor$1.get(key);
    assert.invariant(constructor, 'Selection is not defined!');
    o = create$1(constructor.prototype);
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureSelection(rawWin, key) {
    if (keyToConstructor$1.has(key)) {
      return keyToConstructor$1.get(key);
    }
    class Selection {
      constructor() {
        throw new TypeError('Illegal constructor');
      }
    }
    const protoDescriptors = {};
    for (const property in SelectionMetadata) {
      addPrototypeMethodsAndPropertiesStatelessHelper(property, SelectionMetadata, undefined, Selection.prototype, rawWin.Selection.prototype, protoDescriptors);
    }
    protoDescriptors.getRangeAt = {
      configurable: true,
      enumerable: true,
      value: function (index) {
        const key = getKey(this);
        const raw = getRef(this, key);
        const rawRange = raw.getRangeAt(index);
        setKey(rawRange, key);
        return SecureRangeWrapper(rawRange, key);
      },
      writable: true
    };
    defineProperties(Selection.prototype, protoDescriptors);
    maskToString(Selection, rawWin.Selection);
    keyToConstructor$1.set(key, Selection);
    setRef(Selection, rawWin.Selection, key);
    addToCache(rawWin.Selection, Selection, key);
    registerProxy(Selection);
    return Selection;
  }
  var Document$1 = {
    URL: DEFAULT,
    activeElement: DEFAULT,
    adoptNode: FUNCTION,
    anchors: DEFAULT,
    applets: DEFAULT,
    body: DEFAULT,
    caretRangeFromPoint: FUNCTION,
    characterSet: DEFAULT,
    charset: DEFAULT,
    childElementCount: DEFAULT,
    children: DEFAULT,
    close: FUNCTION,
    compatMode: DEFAULT,
    contentType: DEFAULT,
    cookie: DEFAULT,
    createAttribute: FUNCTION,
    createAttributeNS: FUNCTION,
    createCDATASection: FUNCTION,
    createComment: FUNCTION,
    // createDocumentFragment: FUNCTION, // Custom descriptor
    createElement: FUNCTION,
    createElementNS: FUNCTION,
    createEvent: FUNCTION,
    createExpression: FUNCTION,
    createNSResolver: FUNCTION,
    createNodeIterator: FUNCTION,
    createProcessingInstruction: FUNCTION,
    // createRange: FUNCTION, // Custom descriptor
    createTextNode: FUNCTION,
    createTreeWalker: FUNCTION_RAW_ARGS,
    defaultView: DEFAULT,
    designMode: DEFAULT,
    dir: DEFAULT,
    doctype: DEFAULT,
    documentElement: DEFAULT,
    documentURI: DEFAULT,
    // SecureDocument does not allow setting domain property.
    // domain: DEFAULT,
    elementFromPoint: FUNCTION,
    elementsFromPoint: FUNCTION,
    embeds: DEFAULT,
    evaluate: FUNCTION,
    // execCommand: // Custom descriptor
    exitPointerLock: FUNCTION,
    firstElementChild: DEFAULT,
    fonts: DEFAULT,
    forms: DEFAULT,
    // getElementById: FUNCTION, // Custom descriptor
    // getElementsByClassName: FUNCTION, // Custom descriptor
    // getElementsByName: FUNCTION, // Custom descriptor
    // getElementsByTagName: FUNCTION, // Custom descriptor
    // getElementsByTagNameNS: FUNCTION, // Custom descriptor
    // getSelection: FUNCTION, // Custom descriptor
    hasFocus: FUNCTION,
    head: DEFAULT,
    hidden: DEFAULT,
    images: DEFAULT,
    implementation: DEFAULT,
    importNode: FUNCTION,
    inputEncoding: DEFAULT,
    lastElementChild: DEFAULT,
    lastModified: DEFAULT,
    links: DEFAULT,
    onabort: EVENT,
    onautocomplete: EVENT,
    onautocompleteerror: EVENT,
    onbeforecopy: EVENT,
    onbeforecut: EVENT,
    onbeforepaste: EVENT,
    onblur: EVENT,
    oncancel: EVENT,
    oncanplay: EVENT,
    oncanplaythrough: EVENT,
    onchange: EVENT,
    onclick: EVENT,
    onclose: EVENT,
    oncontextmenu: EVENT,
    oncopy: EVENT,
    oncuechange: EVENT,
    oncut: EVENT,
    ondblclick: EVENT,
    ondrag: EVENT,
    ondragend: EVENT,
    ondragenter: EVENT,
    ondragleave: EVENT,
    ondragover: EVENT,
    ondragstart: EVENT,
    ondrop: EVENT,
    ondurationchange: EVENT,
    onemptied: EVENT,
    onended: EVENT,
    onerror: EVENT,
    onfocus: EVENT,
    oninput: EVENT,
    oninvalid: EVENT,
    onkeydown: EVENT,
    onkeypress: EVENT,
    onkeyup: EVENT,
    onload: EVENT,
    onloadeddata: EVENT,
    onloadedmetadata: EVENT,
    onloadstart: EVENT,
    onmousedown: EVENT,
    onmouseenter: EVENT,
    onmouseleave: EVENT,
    onmousemove: EVENT,
    onmouseout: EVENT,
    onmouseover: EVENT,
    onmouseup: EVENT,
    onmousewheel: EVENT,
    onpaste: EVENT,
    onpause: EVENT,
    onplay: EVENT,
    onplaying: EVENT,
    onpointerlockchange: EVENT,
    onpointerlockerror: EVENT,
    onprogress: EVENT,
    onratechange: EVENT,
    onreadystatechange: EVENT,
    onreset: EVENT,
    onresize: EVENT,
    onscroll: EVENT,
    onsearch: EVENT,
    onseeked: EVENT,
    onseeking: EVENT,
    onselect: EVENT,
    onselectionchange: EVENT,
    onselectstart: EVENT,
    onshow: EVENT,
    onstalled: EVENT,
    onsubmit: EVENT,
    onsuspend: EVENT,
    ontimeupdate: EVENT,
    ontoggle: EVENT,
    ontouchcancel: EVENT,
    ontouchend: EVENT,
    ontouchmove: EVENT,
    ontouchstart: EVENT,
    onvolumechange: EVENT,
    onwaiting: EVENT,
    onwebkitfullscreenchange: EVENT,
    onwebkitfullscreenerror: EVENT,
    onwheel: EVENT,
    open: FUNCTION,
    origin: DEFAULT,
    plugins: DEFAULT,
    pointerLockElement: DEFAULT,
    preferredStylesheetSet: DEFAULT,
    queryCommandEnabled: FUNCTION,
    queryCommandIndeterm: FUNCTION,
    queryCommandState: FUNCTION,
    queryCommandSupported: FUNCTION,
    queryCommandValue: FUNCTION,
    // querySelector: FUNCTION, // Custom descriptor
    // querySelectorAll: FUNCTION, // Custom descriptor
    readyState: DEFAULT,
    referrer: DEFAULT,
    registerElement: FUNCTION,
    rootElement: DEFAULT,
    scripts: DEFAULT,
    scrollingElement: DEFAULT,
    selectedStylesheetSet: DEFAULT,
    styleSheets: DEFAULT,
    title: DEFAULT,
    visibilityState: DEFAULT,
    webkitCancelFullScreen: FUNCTION,
    webkitCurrentFullScreenElement: DEFAULT,
    webkitExitFullscreen: FUNCTION,
    webkitFullscreenElement: DEFAULT,
    webkitFullscreenEnabled: DEFAULT,
    webkitHidden: DEFAULT,
    webkitIsFullScreen: DEFAULT,
    webkitVisibilityState: DEFAULT,
    // Blocked on purpose because of security risk
    // write: FUNCTION,
    // writeln: FUNCTION,
    xmlEncoding: DEFAULT,
    xmlStandalone: DEFAULT,
    xmlVersion: DEFAULT
  };
  var HTMLDocument$1 = {
    // Defined on Instance
    location: DEFAULT,
    // Defined on Proto
    fgColor: DEFAULT,
    linkColor: DEFAULT,
    vlinkColor: DEFAULT,
    alinkColor: DEFAULT,
    bgColor: DEFAULT,
    clear: FUNCTION,
    captureEvents: FUNCTION,
    releaseEvents: FUNCTION
  };
  var metadataView$1 = {
    prototypes: {
      Document: Document$1,
      EventTarget: EventTarget$1,
      HTMLDocument: HTMLDocument$1,
      Node: Node$1
    }
  };

  // Node access checker function for queries originating from document, excludes nodes from shadow dom
  const nodeIsAccessible = (node, toKey) => {
    if (!node) {
      return false;
    }
    return isSharedElement(node) || getKey(node) === toKey && !isAnLWCNode(node);
  };
  let W6247122_execCommand_insertHTML;
  function setDocumentRealm(realmRec) {
    W6247122_execCommand_insertHTML = realmRec.apiOptions.W6247122_execCommand_insertHTML;
  }
  function SecureDocument(doc, key) {
    let o = getFromCache(doc, key);
    if (o) {
      return o;
    }

    // create prototype to allow instanceof checks against document
    const prototype = function prototype() {};
    freeze(prototype);
    const descriptors = {
      toString: {
        value: function () {
          return `SecureDocument: ${doc}{ key: ${JSON.stringify(key)} }`;
        }
      },
      createAttribute: {
        value: function (name) {
          const att = doc.createAttribute(name);
          setKey(att, key);
          return SecureElement(att, key);
        }
      },
      createAttributeNS: {
        value: function (namespace, name) {
          const att = doc.createAttributeNS(namespace, name);
          setKey(att, key);
          return SecureElement(att, key);
        }
      },
      createElement: {
        value: function (tag) {
          const el = doc.createElement(tag);
          setKey(el, key);
          return SecureElement(el, key);
        }
      },
      createElementNS: {
        value: function (namespace, tag) {
          const el = doc.createElementNS(namespace, tag);
          setKey(el, key);
          return SecureElement(el, key);
        }
      },
      createDocumentFragment: {
        value: function () {
          const el = doc.createDocumentFragment();
          setKey(el, key);
          return SecureElement(el, key);
        }
      },
      createRange: {
        configurable: true,
        enumerable: true,
        value: function () {
          const rawRange = doc.createRange();
          setKey(rawRange, key);
          return SecureRangeWrapper(rawRange, key);
        },
        writable: true
      },
      createTextNode: {
        value: function (text) {
          const el = doc.createTextNode(text);
          setKey(el, key);
          return SecureElement(el, key);
        }
      },
      createComment: {
        value: function (data) {
          const el = doc.createComment(data);
          setKey(el, key);
          return SecureElement(el, key);
        }
      },
      domain: {
        get: function () {
          return doc.domain;
        },
        set: function () {
          throw new Error('SecureDocument does not allow setting domain property.');
        }
      },
      querySelector: {
        enumerable: true,
        writable: true,
        value: function (selector) {
          const rawAll = doc.querySelectorAll(selector);
          for (let n = 0, rawLength = rawAll.length; n < rawLength; n++) {
            const raw = rawAll[n];
            if (nodeIsAccessible(raw, key)) {
              return SecureElement(raw, key);
            }
          }
          return null;
        }
      },
      getElementById: {
        enumerable: true,
        writable: true,
        value: function (id) {
          const raw = doc.getElementById(id);
          if (nodeIsAccessible(raw, key)) {
            return SecureElement(raw, key);
          }
          return null;
        }
      },
      getSelection: {
        configurable: true,
        enumerable: true,
        value: function () {
          const rawSelection = doc.getSelection();
          setKey(rawSelection, key);
          return SecureSelectionWrapper(rawSelection, key);
        },
        writable: true
      },
      execCommand: {
        value: function (command, showUI, value) {
          command = asString(command);
          if (command === 'insertHTML' && W6247122_execCommand_insertHTML) {
            value = sanitizeDefault(value);
          }
          return doc.execCommand(command, showUI, value);
        }
      }
    };
    o = create$1(prototype, descriptors);
    for (const propertyName in descriptors) {
      if (ObjectHasOwnProperty(descriptors, propertyName)) {
        const descriptor = descriptors[propertyName];
        if (ObjectHasOwnProperty(descriptor, 'value')) {
          const {
            value
          } = descriptor;
          if (typeof value === 'function') {
            maskToString(value, propertyName);
          }
        }
      }
    }
    fastArrayForEach(['getElementsByClassName', 'getElementsByName', 'getElementsByTagName', 'getElementsByTagNameNS', 'querySelectorAll'], methodName => {
      if (methodName in doc) {
        defineProperty(o, methodName, {
          configurable: false,
          enumerable: true,
          writable: true,
          value: maskToString(function () {
            const raw = doc[methodName](...arguments);
            return SecureNodeList(raw, key, nodeIsAccessible);
          }, methodName)
        });
      }
    });
    addEventTargetMethods(o, doc, key);
    function getCookieNSKey() {
      return `LSKey-${key['namespace']}$`;
    }
    function getFormerCookieNSKey() {
      return `LSKey[${key['namespace']}]`;
    }
    function expireCookieNSKey(keyValue) {
      const cookieKey = keyValue.includes('=') ? `${keyValue.split('=')[0]}=` : keyValue;
      document.cookie = `${cookieKey}; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
    }
    defineProperties(o, {
      cookie: {
        get: function () {
          const fullCookie = doc.cookie;
          const entries = fullCookie.split('; ');
          const cookieNSKey = getCookieNSKey();
          const formerCookieNSKey = getFormerCookieNSKey();
          const nsKeyLength = cookieNSKey.length;
          const cookiesNSFiltered = [];
          const keysNSFiltered = [];
          for (let i = 0, len = entries.length; i < len; i += 1) {
            const cookie = entries[i];
            const cookieNSFiltered = cookie.trim().substring(nsKeyLength);
            const keyNSFiltered = cookieNSFiltered.split('=')[0];
            if (cookie.startsWith(formerCookieNSKey)) {
              if (keysNSFiltered.includes(keyNSFiltered)) {
                expireCookieNSKey(cookie);
              } else {
                cookiesNSFiltered.push(cookieNSFiltered);
                keysNSFiltered.push(keyNSFiltered);
              }
            } else if (cookie.startsWith(cookieNSKey)) {
              if (keysNSFiltered.includes(keyNSFiltered)) {
                const index = keysNSFiltered.indexOf(keyNSFiltered);
                expireCookieNSKey(`${formerCookieNSKey}${cookieNSFiltered}`);
                cookiesNSFiltered[index] = cookieNSFiltered;
              } else {
                cookiesNSFiltered.push(cookieNSFiltered);
                keysNSFiltered.push(keyNSFiltered);
              }
            }
          }
          return cookiesNSFiltered.join('; ');
        },
        set: function (cookie) {
          const chunks = asString(cookie).split(';');
          const entry = chunks[0].split('=');
          const key = entry[0];
          entry[0] = `${getCookieNSKey()}${key}`;

          // Remove old prefixed cookies with the same key.
          const fullCookies = doc.cookie;
          const formerCookieNSKey = getFormerCookieNSKey();
          if (fullCookies.includes(formerCookieNSKey)) {
            const cookies = fullCookies.split('; ');
            for (let i = 0, cookiesLength = cookies.length; i < cookiesLength; i++) {
              const cookieItem = cookies[i];
              if (cookieItem.startsWith(formerCookieNSKey)) {
                const cookieKey = cookies[i].split('=')[0];
                const cookieKeyFiltered = cookieKey.substring(formerCookieNSKey.length);
                if (cookieKeyFiltered === key) {
                  expireCookieNSKey(cookieItem);
                }
              }
            }
          }
          chunks[0] = entry.join('=');
          const newCookie = chunks.join(';');
          doc.cookie = newCookie;
        }
      },
      implementation: {
        configurable: true,
        enumerable: true,
        get: () => SecureDOMImplementationWrapper(doc.implementation, key)
      }
    });
    addPrototypeMethodsAndProperties(metadataView$1, o, doc, key);
    setRef(o, doc, key);
    addToCache(doc, o, key);
    registerProxy(o);
    return o;
  }
  SecureDocument.toString = function () {
    return 'SecureDocument() { [native code] }';
  };
  function getSupportedSchemesErrorMessage(method, object, schemes) {
    const csvSchemes = (schemes || DEFAULT_URL_SCHEMES).join(', ');
    return `${object}.${method} supports ${csvSchemes} schemes and relative urls.`;
  }

  /**
   * Creates a confirmation dialog to ask the user if they would like to navigate away from
   * the current domain. This is in an effort to prevent phishing attacks, e.g. salesforce.com -> saelsforce.com
   *
   * @param currentURL current location else, use window.location.href
   * @param targetURL location to check against current location
   */
  function confirmLocationChange(currentURL, targetURL) {
    const c = document.createElement('a');
    const t = document.createElement('a');
    c.href = currentURL;
    t.href = targetURL;
    const isSameLocation = c.protocol === t.protocol && c.hostname === t.hostname;
    if (!isSameLocation) {
      // @TODO: W-5757872 Breaking customers. Redirection warning needs to respect OrgPreference.
      // return continue(`You are exiting ${c.hostname}. Continue?`);
      warn(`You are exiting ${c.hostname}.`);
      // @TODO: Should we return false?
    }

    return true;
  }
  function SecureLocation(loc, key) {
    let o = getFromCache(loc, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return loc.href;
        }
      },
      href: {
        get: function () {
          return loc.href;
        },
        set: function (href) {
          href = sanitizeURLForElement(href);
          if (!isValidURLScheme(href, EXTENDED_URL_SCHEMES)) {
            throw new error(getSupportedSchemesErrorMessage('href', 'SecureLocation', EXTENDED_URL_SCHEMES));
          }
          if (confirmLocationChange(loc.href, href)) {
            loc.href = href;
          }
          return true;
        }
      },
      protocol: {
        get: function () {
          return loc.protocol;
        },
        set: function (protocol) {
          protocol = String(protocol);
          if (!isValidURLScheme(protocol)) {
            throw new error(getSupportedSchemesErrorMessage('protocol', 'SecureLocation'));
          }
          loc.protocol = protocol;
          return true;
        }
      }
    });
    fastArrayForEach(['host', 'hostname'], property => {
      defineProperty(o, property, {
        get: function () {
          return loc[property];
        },
        set: function (val) {
          val = String(val);
          if (confirmLocationChange(loc.href, `${loc.protocol}//${val}`)) {
            loc[property] = val;
          }
          return true;
        }
      });
    });
    fastArrayForEach(['pathname', 'search', 'hash', 'username', 'password', 'origin', 'port'], property => addPropertyIfSupported(o, loc, property));
    fastArrayForEach(['replace', 'assign'], method => {
      defineProperty(o, method, {
        writable: true,
        enumerable: true,
        value(url) {
          url = sanitizeURLForElement(url);
          if (!isValidURLScheme(url)) {
            throw new error(getSupportedSchemesErrorMessage(method, 'SecureLocation'));
          }
          if (confirmLocationChange(loc.href, url)) {
            loc[method](url);
          }
        }
      });
    });
    addMethodIfSupported(o, loc, 'reload');
    setRef(o, loc, key);
    addToCache(loc, o, key);
    registerProxy(o);
    return o;
  }
  function SecureMutationObserver(key) {
    function filterRecords(st, records) {
      const filtered = [];
      records.forEach(record => {
        const {
          target
        } = record;
        if (hasAccess(st, target) || isSharedElement(target) || isAccessibleLWCNode(key, target)) {
          filtered.push(filterEverything(st, record));
        }
      });
      return filtered;
    }

    // Create a new closure constructor for new MutationObserver() syntax support that captures the key
    return function (callback) {
      const o = create$1(null);
      const observer = new MutationObserver(records => {
        const filtered = filterRecords(o, records);
        if (filtered.length > 0) {
          callback(filtered);
        }
      });
      defineProperties(o, {
        toString: {
          value: function () {
            return `SecureMutationObserver: ${observer} { key: ${JSON.stringify(key)} }`;
          }
        },
        observe: createFilteredMethod(o, observer, 'observe', RAW_ARGS),
        disconnect: createFilteredMethod(o, observer, 'disconnect'),
        takeRecords: {
          writable: true,
          value: function () {
            return filterRecords(o, observer['takeRecords']());
          }
        }
      });
      setRef(o, observer, key);
      return freeze(o);
    };
  }
  function SecureNotification(key) {
    // Create a new closure constructor for new Notification() syntax support that captures the key
    return function (title, options) {
      const notification = new Notification(title, options);
      const o = create$1(null, {
        toString: {
          value: function () {
            return `SecureNotification: ${notification} { key: ${JSON.stringify(key)} }`;
          }
        }
      });

      // Properties
      fastArrayForEach(['actions', 'badge', 'body', 'data', 'dir', 'lang', 'tag', 'icon', 'image', 'requireInteraction', 'silent', 'timestamp', 'title', 'vibrate', 'noscreen', 'renotify', 'sound', 'sticky'], name => addPropertyIfSupported(o, notification, name));

      // Event handlers
      fastArrayForEach(['onclick', 'onerror'], name => defineProperty(o, name, {
        set: function (callback) {
          notification[name] = function (e) {
            callback.call(o, e && SecureDOMEvent(e, key));
          };
        }
      }));
      defineProperties(o, {
        close: createFilteredMethod(o, notification, 'close')
      });
      addEventTargetMethods(o, notification, key);
      setRef(o, notification, key);
      return freeze(o);
    };
  }
  function SecureStorage(storage, type, key) {
    let o = getFromCache(storage, key);
    if (o) {
      return o;
    }

    // Read existing key to synthetic key index from storage
    const stringizedKey = JSON.stringify(key);
    const nextSyntheticKey = `LSSNextSynthtic:${type}`;
    const storedIndexKey = `LSSIndex:${type}${stringizedKey}`;
    let nameToSyntheticRaw;
    try {
      nameToSyntheticRaw = storage.getItem(storedIndexKey);
    } catch (e) {
      // There is a bug in google chrome where localStorage becomes inaccessible.
      // Don't fast fail and break all applications. Defer the exception throwing to when the app actually uses localStorage
    }
    let nameToSynthetic = nameToSyntheticRaw ? JSON.parse(nameToSyntheticRaw) : {};
    function persistSyntheticNameIndex() {
      // Persist the nameToSynthetic index
      const stringizedIndex = JSON.stringify(nameToSynthetic);
      storage.setItem(storedIndexKey, stringizedIndex);
    }
    function getSynthetic(name) {
      let synthetic = nameToSynthetic[name];
      if (!synthetic) {
        const nextSynthticRaw = storage.getItem(nextSyntheticKey);
        let nextSynthetic = nextSynthticRaw ? Number(nextSynthticRaw) : 1;
        synthetic = nextSynthetic++;

        // Persist the next synthetic counter
        storage.setItem(nextSyntheticKey, nextSynthetic);
        nameToSynthetic[name] = synthetic;
        persistSyntheticNameIndex();
      }
      return synthetic;
    }
    function forgetSynthetic(name) {
      const synthetic = getSynthetic(name);
      if (synthetic) {
        delete nameToSynthetic[name];
        persistSyntheticNameIndex();
      }
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureStorage: ${type} { key: ${JSON.stringify(key)} }`;
        }
      },
      length: {
        get: function () {
          return ObjectKeys(nameToSynthetic).length;
        }
      },
      getItem: {
        value: function (name) {
          const synthetic = getSynthetic(name);
          return synthetic ? storage.getItem(synthetic) : null;
        }
      },
      setItem: {
        value: function (name, value) {
          const synthetic = getSynthetic(name);
          storage.setItem(synthetic, value);
        }
      },
      removeItem: {
        value: function (name) {
          const syntheticKey = getSynthetic(name);
          if (syntheticKey) {
            storage.removeItem(syntheticKey);
            forgetSynthetic(name);
          }
        }
      },
      key: {
        value: function (index) {
          return ObjectKeys(nameToSynthetic)[index];
        }
      },
      clear: {
        value: function () {
          ObjectKeys(nameToSynthetic).forEach(name => {
            const syntheticKey = getSynthetic(name);
            storage.removeItem(syntheticKey);
          });

          // Forget all synthetic
          nameToSynthetic = {};
          storage.removeItem(storedIndexKey);
        }
      }
    });
    setRef(o, storage, key);
    addToCache(storage, o, key);
    registerProxy(o);
    return o;
  }

  // For URL, we only need to tame one static method. That method is on the

  const keyToConstructor = new WeakMap();
  const BlobTypeGetter = getOwnPropertyDescriptor(Blob.prototype, 'type').get;
  const BlobSliceValue = getOwnPropertyDescriptor(Blob.prototype, 'slice').value;
  const BlobSizeGetter = getOwnPropertyDescriptor(Blob.prototype, 'size').get;
  const HTML_MIME_TYPES = ['text/html', 'image/svg+xml', 'text/xml'];
  function SecureURLWrapper(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    const constructor = keyToConstructor.get(key);
    assert.invariant(constructor, 'URL is not defined!');
    const proto = constructor.prototype;

    // We're assigning enumerable own properties to the `o` URL instance here which is different
    // than native URL instances that rely on property getters on the `URL.prototype`.
    o = create$1(proto, {
      toString: {
        value: () => raw.toString()
      },
      toJSON: {
        value: () => raw.toJSON()
      }
    });
    fastArrayForEach(['hash', 'host', 'hostname', 'href', 'origin', 'password', 'pathname', 'port', 'protocol', 'search', 'searchParams', 'username'], property => addPropertyIfSupported(o, raw, property));
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureURL(win, key) {
    if (keyToConstructor.has(key)) {
      return keyToConstructor.get(key);
    }
    const {
      isEqualDomString
    } = getValidator$LWS(win.document, win);
    class URL {
      constructor(...args) {
        const urlInstance = new win.URL(...args);
        // eslint-disable-next-line no-constructor-return
        return SecureURLWrapper(urlInstance, key);
      }
      static createObjectURL(object) {
        // create a URL first using the native APIs
        // this will ensure native validation against undefined and other non-accepted types
        const {
          createObjectURL,
          revokeObjectURL
        } = win.URL;
        let outUrl = createObjectURL(object);
        const type = BlobTypeGetter.call(object).toLowerCase();
        if (HTML_MIME_TYPES.includes(type)) {
          const normalizedBlob = BlobSliceValue.call(object, 0, BlobSizeGetter.call(object), `${type};charset=utf-8`);
          revokeObjectURL(outUrl);
          outUrl = createObjectURL(normalizedBlob);
          const xhr = new XMLHttpRequest();
          xhr.open('GET', outUrl, false);
          xhr.send();
          const sanitizer = getSanitizerForConfig(RETURN_STRING_BLOB_HTML);
          const sanitized = sanitizer.sanitize(xhr.responseText);
          if (!isEqualDomString(xhr.responseText, sanitized)) {
            revokeObjectURL(outUrl);
            throw new TypeError(`Locker: Cannot "createObjectURL" using a unsecure ${object}!`);
          }
          return outUrl;
        }
        if (type === '' || isMIMETypeAllowed$LWS(type)) {
          return outUrl;
        }
        revokeObjectURL(outUrl);
        throw new error('Unsupported MIME type.');
      }
      static revokeObjectURL(objectURL) {
        return win.URL.revokeObjectURL(objectURL);
      }
    }
    defineProperty(URL.prototype, Symbol.toStringTag, {
      configurable: true,
      value: 'URL'
    });
    keyToConstructor.set(key, URL);
    return URL;
  }
  function sanitizeHistoryStateArguments(args) {
    // args = [state, title, [, url]]
    // where state is an object and url could be string or URL object
    if (args.length > 2 && args[2] !== null && args[2] !== undefined) {
      args[2] = sanitizeURLForRequests(args[2]);
    }
    if (args.length > 0) {
      args[0] = getRaw$1(args[0]);
    }
    return args;
  }
  function SecureHistory(raw, key) {
    let o = getFromCache(raw, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: () => `SecureHistory: ${raw} { key: ${JSON.stringify(key)} }`
      },
      pushState: {
        value() {
          return apply(raw.pushState, raw, sanitizeHistoryStateArguments(arguments));
        }
      },
      replaceState: {
        value() {
          return apply(raw.replaceState, raw, sanitizeHistoryStateArguments(arguments));
        }
      }
    });
    fastArrayForEach(['back', 'forward', 'go'], method => addMethodIfSupported(o, raw, method));
    fastArrayForEach(['length', 'state', 'scrollRestoration'], property => addPropertyIfSupported(o, raw, property));
    setRef(o, raw, key);
    addToCache(raw, o, key);
    registerProxy(o);
    return o;
  }
  function SecureXMLHttpRequest(key) {
    // Create a new closure constructor for new XHMLHttpRequest() syntax support that captures the key
    return function () {
      const xhr = new XMLHttpRequest();
      const o = create$1(null, {
        toString: {
          value: function () {
            return `SecureXMLHttpRequest: ${xhr} { key: ${JSON.stringify(key)} }`;
          }
        }
      });

      // Properties
      fastArrayForEach(['readyState', 'status', 'statusText', 'response', 'responseType', 'responseText', 'responseURL', 'timeout', 'withCredentials', 'upload', 'UNSENT', 'OPENED', 'HEADERS_RECEIVED', 'LOADING', 'DONE'], name => addPropertyIfSupported(o, xhr, name));
      addPropertyIfSupported(o, xhr, 'responseXML', {
        afterGetCallback: function (value) {
          return value;
        }
      });

      // Event handlers
      fastArrayForEach(['onloadstart', 'onprogress', 'onabort', 'onerror', 'onload', 'ontimeout', 'onloadend', 'onreadystatechange'], name => defineProperty(o, name, {
        set: function (callback) {
          xhr[name] = function (e) {
            callback.call(o, e && SecureDOMEvent(e, key));
          };
        }
      }));
      defineProperties(o, {
        abort: createFilteredMethod(o, xhr, 'abort'),
        addEventListener: createAddEventListenerDescriptor(o, xhr, key),
        open: {
          enumerable: true,
          writable: true,
          value: function () {
            if (arguments[1]) {
              arguments[1] = sanitizeURLForRequests(arguments[1]);
            }
            return xhr.open(...arguments);
          }
        },
        send: createFilteredMethod(o, xhr, 'send'),
        getAllResponseHeaders: createFilteredMethod(o, xhr, 'getAllResponseHeaders'),
        getResponseHeader: createFilteredMethod(o, xhr, 'getResponseHeader'),
        setRequestHeader: createFilteredMethod(o, xhr, 'setRequestHeader'),
        overrideMimeType: createFilteredMethod(o, xhr, 'overrideMimeType')
      });
      setRef(o, xhr, key);
      return freeze(o);
    };
  }
  var Window$1 = {
    AnalyserNode: CTOR,
    AnimationEvent: CTOR,
    AppBannerPromptResult: CTOR,
    ApplicationCache: FUNCTION,
    ApplicationCacheErrorEvent: CTOR,
    Attr: RAW,
    Audio: CTOR,
    AudioBuffer: CTOR,
    AudioBufferSourceNode: CTOR,
    AudioContext: CTOR,
    AudioDestinationNode: CTOR,
    AudioListener: FUNCTION,
    AudioNode: FUNCTION,
    AudioParam: FUNCTION,
    AudioProcessingEvent: CTOR,
    AutocompleteErrorEvent: CTOR,
    BarProp: FUNCTION,
    BatteryManager: FUNCTION,
    BeforeInstallPromptEvent: CTOR,
    BeforeUnloadEvent: FUNCTION,
    BiquadFilterNode: CTOR,
    BlobEvent: CTOR,
    CDATASection: FUNCTION,
    // CSS: FUNCTION, // Custom descriptor
    CSSFontFaceRule: FUNCTION,
    CSSGroupingRule: FUNCTION,
    CSSImportRule: FUNCTION,
    CSSKeyframeRule: FUNCTION,
    CSSKeyframesRule: FUNCTION,
    CSSMediaRule: FUNCTION,
    CSSNamespaceRule: FUNCTION,
    CSSPageRule: FUNCTION,
    CSSRule: FUNCTION,
    CSSRuleList: FUNCTION,
    CSSStyleDeclaration: FUNCTION,
    CSSStyleRule: FUNCTION,
    CSSStyleSheet: CTOR,
    CSSSupportsRule: FUNCTION,
    CSSViewportRule: CTOR,
    CanvasCaptureMediaStreamTrack: FUNCTION,
    CanvasGradient: FUNCTION,
    CanvasPattern: FUNCTION,
    CanvasRenderingContext2D: RAW,
    ChannelMergerNode: CTOR,
    ChannelSplitterNode: CTOR,
    CharacterData: FUNCTION,
    ClientRect: FUNCTION,
    ClientRectList: FUNCTION,
    ClipboardEvent: CTOR,
    CloseEvent: CTOR,
    Comment: CTOR,
    CompositionEvent: CTOR,
    ConvolverNode: CTOR,
    Credential: FUNCTION,
    CredentialsContainer: FUNCTION,
    Crypto: FUNCTION,
    CryptoKey: FUNCTION,
    DOMError: CTOR,
    DOMException: CTOR,
    DOMImplementation: FUNCTION,
    // DOMParser: RAW, // Custom descriptor
    DOMStringList: FUNCTION,
    DOMStringMap: FUNCTION,
    DOMTokenList: FUNCTION,
    DataTransfer: CTOR,
    DataTransferItem: FUNCTION,
    DataTransferItemList: FUNCTION,
    DelayNode: CTOR,
    DeviceMotionEvent: CTOR,
    DeviceOrientationEvent: CTOR,
    Document: CTOR,
    DocumentFragment: CTOR,
    DocumentType: FUNCTION,
    DragEvent: CTOR,
    DynamicsCompressorNode: CTOR,
    ES6Promise: DEFAULT,
    Element: RAW,
    ErrorEvent: CTOR,
    Event: CTOR,
    EventSource: CTOR,
    EventTarget: RAW,
    FederatedCredential: CTOR,
    FileError: FUNCTION,
    FileList: RAW,
    FileReader: RAW,
    FocusEvent: CTOR,
    FontFace: CTOR,
    GainNode: CTOR,
    HTMLAllCollection: FUNCTION,
    HTMLAnchorElement: RAW,
    HTMLAreaElement: RAW,
    HTMLAudioElement: RAW,
    HTMLBRElement: RAW,
    HTMLBaseElement: RAW,
    HTMLBodyElement: RAW,
    HTMLButtonElement: RAW,
    HTMLCanvasElement: RAW,
    HTMLCollection: RAW,
    HTMLContentElement: RAW,
    HTMLDListElement: RAW,
    HTMLDataListElement: RAW,
    HTMLDetailsElement: RAW,
    HTMLDialogElement: RAW,
    HTMLDirectoryElement: RAW,
    HTMLDivElement: RAW,
    HTMLDocument: FUNCTION,
    HTMLElement: RAW,
    HTMLEmbedElement: RAW,
    HTMLFieldSetElement: RAW,
    HTMLFontElement: RAW,
    HTMLFormControlsCollection: FUNCTION,
    HTMLFormElement: RAW,
    HTMLFrameElement: RAW,
    HTMLFrameSetElement: RAW,
    HTMLHRElement: RAW,
    HTMLHeadElement: RAW,
    HTMLHeadingElement: RAW,
    HTMLHtmlElement: RAW,
    HTMLIFrameElement: RAW,
    HTMLImageElement: RAW,
    HTMLInputElement: RAW,
    HTMLKeygenElement: RAW,
    HTMLLIElement: RAW,
    HTMLLabelElement: RAW,
    HTMLLegendElement: RAW,
    HTMLLinkElement: RAW,
    HTMLMapElement: RAW,
    HTMLMarqueeElement: RAW,
    HTMLMediaElement: RAW,
    HTMLMenuElement: RAW,
    HTMLMetaElement: RAW,
    HTMLMeterElement: RAW,
    HTMLModElement: RAW,
    HTMLOListElement: RAW,
    HTMLObjectElement: RAW,
    HTMLOptGroupElement: RAW,
    HTMLOptionElement: RAW,
    HTMLOptionsCollection: RAW,
    HTMLOutputElement: RAW,
    HTMLParagraphElement: RAW,
    HTMLParamElement: RAW,
    HTMLPictureElement: RAW,
    HTMLPreElement: RAW,
    HTMLProgressElement: RAW,
    HTMLQuoteElement: RAW,
    HTMLScriptElement: RAW,
    HTMLSelectElement: RAW,
    HTMLShadowElement: RAW,
    HTMLSlotElement: RAW,
    HTMLSourceElement: RAW,
    HTMLSpanElement: RAW,
    HTMLStyleElement: RAW,
    HTMLTableCaptionElement: RAW,
    HTMLTableCellElement: RAW,
    HTMLTableColElement: RAW,
    HTMLTableElement: RAW,
    HTMLTableRowElement: RAW,
    HTMLTableSectionElement: RAW,
    HTMLTemplateElement: RAW,
    HTMLTextAreaElement: RAW,
    HTMLTitleElement: RAW,
    HTMLTrackElement: RAW,
    HTMLUListElement: RAW,
    HTMLUnknownElement: RAW,
    HTMLVideoElement: RAW,
    HashChangeEvent: CTOR,
    IdleDeadline: FUNCTION,
    Image: CTOR,
    ImageBitmap: FUNCTION,
    ImageData: CTOR,
    Infinity: DEFAULT,
    InputDeviceCapabilities: CTOR,
    KeyboardEvent: CTOR,
    Location: FUNCTION,
    MIDIAccess: FUNCTION,
    MIDIConnectionEvent: CTOR,
    MIDIInput: FUNCTION,
    MIDIInputMap: FUNCTION,
    MIDIMessageEvent: CTOR,
    MIDIOutput: FUNCTION,
    MIDIOutputMap: FUNCTION,
    MIDIPort: FUNCTION,
    MediaDevices: DEFAULT,
    MediaElementAudioSourceNode: CTOR,
    MediaEncryptedEvent: CTOR,
    MediaError: FUNCTION,
    MediaKeyMessageEvent: CTOR,
    MediaKeySession: FUNCTION,
    MediaKeyStatusMap: FUNCTION,
    MediaKeySystemAccess: FUNCTION,
    MediaKeys: FUNCTION,
    MediaList: FUNCTION,
    MediaQueryList: FUNCTION,
    MediaQueryListEvent: CTOR,
    MediaRecorder: CTOR,
    MediaSource: FUNCTION,
    MediaStreamAudioDestinationNode: CTOR,
    MediaStreamAudioSourceNode: CTOR,
    MediaStreamEvent: CTOR,
    MediaStreamTrack: FUNCTION,
    MessageChannel: RAW,
    MessageEvent: RAW,
    MessagePort: RAW,
    MimeType: FUNCTION,
    MimeTypeArray: FUNCTION,
    MutationObserver: CTOR,
    MutationRecord: FUNCTION,
    MouseEvent: CTOR,
    NaN: DEFAULT,
    NamedNodeMap: FUNCTION,
    Navigator: FUNCTION,
    Node: RAW,
    NodeFilter: FUNCTION,
    NodeIterator: FUNCTION,
    NodeList: FUNCTION,
    OfflineAudioCompletionEvent: CTOR,
    OfflineAudioContext: CTOR,
    Option: CTOR,
    OscillatorNode: CTOR,
    PERSISTENT: DEFAULT,
    PageTransitionEvent: CTOR,
    PasswordCredential: CTOR,
    Path2D: CTOR,
    Performance: RAW,
    PerformanceEntry: FUNCTION,
    PerformanceMark: FUNCTION,
    PerformanceMeasure: FUNCTION,
    PerformanceNavigation: FUNCTION,
    PerformanceResourceTiming: FUNCTION,
    PerformanceTiming: FUNCTION,
    PeriodicWave: CTOR,
    PopStateEvent: CTOR,
    Presentation: FUNCTION,
    PresentationAvailability: FUNCTION,
    PresentationConnection: FUNCTION,
    PresentationConnectionAvailableEvent: CTOR,
    PresentationConnectionCloseEvent: CTOR,
    PresentationRequest: CTOR,
    ProcessingInstruction: FUNCTION,
    ProgressEvent: CTOR,
    PromiseRejectionEvent: CTOR,
    RTCCertificate: FUNCTION,
    RTCIceCandidate: CTOR,
    RTCSessionDescription: CTOR,
    RadioNodeList: FUNCTION,
    // Range: // Custom descriptor
    ReadableByteStream: FUNCTION,
    ReadableStream: CTOR,
    Request: CTOR,
    Response: CTOR,
    // Selection: CTOR, // Custom descriptor
    SVGAElement: FUNCTION,
    SVGAngle: FUNCTION,
    SVGAnimateElement: FUNCTION,
    SVGAnimateMotionElement: FUNCTION,
    SVGAnimateTransformElement: FUNCTION,
    SVGAnimatedAngle: FUNCTION,
    SVGAnimatedBoolean: FUNCTION,
    SVGAnimatedEnumeration: FUNCTION,
    SVGAnimatedInteger: FUNCTION,
    SVGAnimatedLength: FUNCTION,
    SVGAnimatedLengthList: FUNCTION,
    SVGAnimatedNumber: FUNCTION,
    SVGAnimatedNumberList: FUNCTION,
    SVGAnimatedPreserveAspectRatio: FUNCTION,
    SVGAnimatedRect: FUNCTION,
    SVGAnimatedString: FUNCTION,
    SVGAnimatedTransformList: FUNCTION,
    SVGAnimationElement: RAW,
    SVGCircleElement: RAW,
    SVGClipPathElement: RAW,
    SVGComponentTransferFunctionElement: RAW,
    SVGCursorElement: RAW,
    SVGDefsElement: RAW,
    SVGDescElement: RAW,
    SVGDiscardElement: RAW,
    SVGElement: RAW,
    SVGEllipseElement: RAW,
    SVGFEBlendElement: RAW,
    SVGFEColorMatrixElement: RAW,
    SVGFEComponentTransferElement: RAW,
    SVGFECompositeElement: RAW,
    SVGFEConvolveMatrixElement: RAW,
    SVGFEDiffuseLightingElement: RAW,
    SVGFEDisplacementMapElement: RAW,
    SVGFEDistantLightElement: RAW,
    SVGFEDropShadowElement: RAW,
    SVGFEFloodElement: RAW,
    SVGFEFuncAElement: RAW,
    SVGFEFuncBElement: RAW,
    SVGFEFuncGElement: RAW,
    SVGFEFuncRElement: RAW,
    SVGFEGaussianBlurElement: RAW,
    SVGFEImageElement: RAW,
    SVGFEMergeElement: RAW,
    SVGFEMergeNodeElement: RAW,
    SVGFEMorphologyElement: RAW,
    SVGFEOffsetElement: RAW,
    SVGFEPointLightElement: RAW,
    SVGFESpecularLightingElement: RAW,
    SVGFESpotLightElement: RAW,
    SVGFETileElement: RAW,
    SVGFETurbulenceElement: RAW,
    SVGFilterElement: RAW,
    SVGForeignObjectElement: RAW,
    SVGGElement: RAW,
    SVGGeometryElement: RAW,
    SVGGradientElement: RAW,
    SVGGraphicsElement: RAW,
    SVGImageElement: RAW,
    SVGLength: FUNCTION,
    SVGLengthList: FUNCTION,
    SVGLineElement: RAW,
    SVGLinearGradientElement: RAW,
    SVGMPathElement: RAW,
    SVGMarkerElement: RAW,
    SVGMaskElement: RAW,
    SVGMatrix: RAW,
    SVGMetadataElement: RAW,
    SVGNumber: FUNCTION,
    SVGNumberList: FUNCTION,
    SVGPathElement: RAW,
    SVGPatternElement: RAW,
    SVGPoint: FUNCTION,
    SVGPointList: FUNCTION,
    SVGPolygonElement: RAW,
    SVGPolylineElement: RAW,
    SVGPreserveAspectRatio: FUNCTION,
    SVGRadialGradientElement: RAW,
    SVGRect: FUNCTION,
    SVGRectElement: RAW,
    SVGSVGElement: RAW,
    SVGScriptElement: RAW,
    SVGSetElement: RAW,
    SVGStopElement: RAW,
    SVGStringList: FUNCTION,
    SVGStyleElement: RAW,
    SVGSwitchElement: RAW,
    SVGSymbolElement: RAW,
    SVGTSpanElement: RAW,
    SVGTextContentElement: RAW,
    SVGTextElement: RAW,
    SVGTextPathElement: RAW,
    SVGTextPositioningElement: RAW,
    SVGTitleElement: RAW,
    SVGTransform: FUNCTION,
    SVGTransformList: FUNCTION,
    SVGUnitTypes: FUNCTION,
    SVGUseElement: RAW,
    SVGViewElement: RAW,
    SVGViewSpec: FUNCTION,
    SVGZoomEvent: CTOR,
    Screen: FUNCTION,
    ScreenOrientation: FUNCTION,
    SecurityPolicyViolationEvent: CTOR,
    Selection: FUNCTION,
    SourceBuffer: FUNCTION,
    SourceBufferList: FUNCTION,
    SpeechSynthesisEvent: CTOR,
    SpeechSynthesisUtterance: CTOR,
    StyleSheet: FUNCTION,
    StyleSheetList: FUNCTION,
    SubtleCrypto: FUNCTION,
    TEMPORARY: DEFAULT,
    Text: CTOR,
    TextDecoder: CTOR,
    TextEncoder: RAW,
    TextEvent: FUNCTION,
    TextMetrics: FUNCTION,
    TextTrack: FUNCTION,
    TextTrackCue: FUNCTION,
    TextTrackCueList: FUNCTION,
    TextTrackList: FUNCTION,
    TimeRanges: RAW,
    Touch: FUNCTION,
    TouchEvent: CTOR,
    TouchList: FUNCTION,
    TrackEvent: CTOR,
    TransitionEvent: CTOR,
    TreeWalker: FUNCTION,
    UIEvent: CTOR,
    // Replaced by SecureURL
    // URL: RAW,
    URLSearchParams: CTOR,
    VTTCue: CTOR,
    ValidityState: FUNCTION,
    WaveShaperNode: CTOR,
    WebGLActiveInfo: FUNCTION,
    WebGLBuffer: FUNCTION,
    WebGLContextEvent: CTOR,
    WebGLFramebuffer: FUNCTION,
    WebGLProgram: FUNCTION,
    WebGLRenderbuffer: FUNCTION,
    WebGLRenderingContext: FUNCTION,
    WebGLShader: FUNCTION,
    WebGLShaderPrecisionFormat: FUNCTION,
    WebGLTexture: FUNCTION,
    WebGLUniformLocation: FUNCTION,
    WebKitAnimationEvent: CTOR,
    WebKitCSSMatrix: CTOR,
    WebKitTransitionEvent: CTOR,
    WebSocket: RAW,
    WheelEvent: CTOR,
    Window: FUNCTION,
    XMLDocument: FUNCTION,
    XMLHttpRequest: CTOR,
    XMLHttpRequestEventTarget: FUNCTION,
    XMLHttpRequestUpload: FUNCTION,
    XMLSerializer: CTOR,
    XPathEvaluator: CTOR,
    XPathExpression: FUNCTION,
    XPathResult: FUNCTION,
    XSLTProcessor: CTOR,
    alert: FUNCTION,
    atob: FUNCTION,
    blur: FUNCTION,
    btoa: FUNCTION,
    cancelAnimationFrame: FUNCTION,
    cancelIdleCallback: FUNCTION,
    captureEvents: FUNCTION,
    chrome: DEFAULT,
    clearInterval: FUNCTION,
    clearTimeout: FUNCTION,
    close: FUNCTION,
    closed: DEFAULT,
    confirm: FUNCTION,
    console: RAW,
    createImageBitmap: FUNCTION,
    crypto: DEFAULT,
    defaultStatus: DEFAULT,
    defaultstatus: DEFAULT,
    devicePixelRatio: DEFAULT,
    document: DEFAULT,
    fetch: FUNCTION,
    find: FUNCTION,
    focus: FUNCTION,
    frameElement: DEFAULT,
    frames: DEFAULT,
    getComputedStyle: FUNCTION,
    getMatchedCSSRules: FUNCTION,
    // getSelection: FUNCTION, // Custom descriptor
    // Replaced by SecureHistory
    // history: RAW,
    History: FUNCTION,
    innerHeight: DEFAULT,
    innerWidth: DEFAULT,
    isSecureContext: DEFAULT,
    length: DEFAULT,
    localStorage: DEFAULT,
    locationbar: DEFAULT,
    matchMedia: FUNCTION,
    menubar: DEFAULT,
    moveBy: FUNCTION,
    moveTo: FUNCTION,
    name: DEFAULT,
    navigator: DEFAULT,
    offscreenBuffering: DEFAULT,
    onabort: EVENT,
    onanimationend: EVENT,
    onanimationiteration: EVENT,
    onanimationstart: EVENT,
    onautocomplete: EVENT,
    onautocompleteerror: EVENT,
    onbeforeunload: EVENT,
    onblur: EVENT,
    oncancel: EVENT,
    oncanplay: EVENT,
    oncanplaythrough: EVENT,
    onchange: EVENT,
    onclick: EVENT,
    onclose: EVENT,
    oncontextmenu: EVENT,
    oncuechange: EVENT,
    ondblclick: EVENT,
    ondevicemotion: EVENT,
    ondeviceorientation: EVENT,
    ondeviceorientationabsolute: EVENT,
    ondrag: EVENT,
    ondragend: EVENT,
    ondragenter: EVENT,
    ondragleave: EVENT,
    ondragover: EVENT,
    ondragstart: EVENT,
    ondrop: EVENT,
    ondurationchange: EVENT,
    onemptied: EVENT,
    onended: EVENT,
    onerror: EVENT,
    onfocus: EVENT,
    onhashchange: EVENT,
    oninput: EVENT,
    oninvalid: EVENT,
    onkeydown: EVENT,
    onkeypress: EVENT,
    onkeyup: EVENT,
    onlanguagechange: EVENT,
    onload: EVENT,
    onloadeddata: EVENT,
    onloadedmetadata: EVENT,
    onloadstart: EVENT,
    onmessage: EVENT,
    onmousedown: EVENT,
    onmouseenter: EVENT,
    onmouseleave: EVENT,
    onmousemove: EVENT,
    onmouseout: EVENT,
    onmouseover: EVENT,
    onmouseup: EVENT,
    onmousewheel: EVENT,
    onoffline: EVENT,
    ononline: EVENT,
    onpagehide: EVENT,
    onpageshow: EVENT,
    onpause: EVENT,
    onplay: EVENT,
    onplaying: EVENT,
    onpopstate: EVENT,
    onprogress: EVENT,
    onratechange: EVENT,
    onrejectionhandled: EVENT,
    onreset: EVENT,
    onresize: EVENT,
    onscroll: EVENT,
    onsearch: EVENT,
    onseeked: EVENT,
    onseeking: EVENT,
    onselect: EVENT,
    onshow: EVENT,
    onstalled: EVENT,
    onstorage: EVENT,
    onsubmit: EVENT,
    onsuspend: EVENT,
    ontimeupdate: EVENT,
    ontoggle: EVENT,
    ontransitionend: EVENT,
    ontouchcancel: EVENT,
    ontouchend: EVENT,
    ontouchmove: EVENT,
    ontouchstart: EVENT,
    onunhandledrejection: EVENT,
    onunload: EVENT,
    onvolumechange: EVENT,
    onwaiting: EVENT,
    onwheel: EVENT,
    open: FUNCTION,
    outerHeight: DEFAULT,
    outerWidth: DEFAULT,
    pageStartTime: DEFAULT,
    pageXOffset: DEFAULT,
    pageYOffset: DEFAULT,
    parent: DEFAULT,
    performance: RAW,
    personalbar: DEFAULT,
    postMessage: FUNCTION_RAW_ARGS_DEEP,
    print: FUNCTION,
    prompt: FUNCTION,
    releaseEvents: FUNCTION,
    requestAnimationFrame: FUNCTION,
    requestIdleCallback: FUNCTION,
    resizeBy: FUNCTION,
    resizeTo: FUNCTION,
    screen: RAW,
    screenLeft: DEFAULT,
    screenTop: DEFAULT,
    screenX: DEFAULT,
    screenY: DEFAULT,
    scroll: FUNCTION,
    scrollBy: FUNCTION,
    scrollTo: FUNCTION,
    scrollX: DEFAULT,
    scrollY: DEFAULT,
    scrollbars: DEFAULT,
    sessionStorage: DEFAULT,
    self: DEFAULT,
    setInterval: FUNCTION,
    setTimeout: FUNCTION,
    status: DEFAULT,
    statusbar: DEFAULT,
    stop: FUNCTION,
    styleMedia: DEFAULT,
    toolbar: DEFAULT,
    top: DEFAULT,
    window: DEFAULT
  };
  var metadataView = {
    prototypes: {
      EventTarget: EventTarget$1,
      Window: Window$1
    }
  };

  // Possibly replace with `$A.get('$Browser')` at a later time. Until then
  // combo the user agent sniff with a browser inference check based on
  // https://developer.mozilla.org/en-US/docs/Web/API/Microsoft_Extensions
  const isEdgeMSHTML = /\bEdge\//.test(navigator.userAgent) && typeof navigator.msLaunchUri === 'function';
  let W6081125_windowOpenNoopener;
  function setWindowRealm(realmRec) {
    W6081125_windowOpenNoopener = realmRec.apiOptions.W6081125_windowOpenNoopener;
  }
  function SecureWindow(win, key) {
    let o = getFromCache(win, key);
    if (o) {
      return o;
    }

    // Create prototype to allow basic object operations like hasOwnProperty etc
    const props = getOwnPropertyDescriptors(Object.prototype);
    // Do not treat window like a plain object, $A.util.isPlainObject() returns true if we leave the constructor intact.
    delete props.constructor;
    const emptyProto = create$1(null, props);
    freeze(emptyProto);
    let parentValue;
    o = create$1(emptyProto, {
      DOMImplementation: {
        enumerable: false,
        configurable: true,
        writable: true,
        value: SecureDOMImplementation(win, key)
      },
      document: {
        enumerable: true,
        value: SecureDocument(win.document, key)
      },
      window: {
        enumerable: true,
        get: function () {
          return o;
        }
      },
      // Expose raw `DOMParser` directly to make it jsdom testable.
      DOMParser: {
        enumerable: false,
        value: win.DOMParser
      },
      MutationObserver: {
        enumerable: true,
        value: SecureMutationObserver(key)
      },
      navigator: {
        enumerable: true,
        writable: true,
        value: SecureNavigator(win.navigator, key)
      },
      Range: {
        configurable: true,
        value: SecureRange(win, key),
        writable: true
      },
      Selection: {
        configurable: true,
        value: SecureSelection(win, key),
        writable: true
      },
      XMLHttpRequest: {
        enumerable: true,
        value: SecureXMLHttpRequest(key)
      },
      getSelection: {
        configurable: true,
        enumerable: true,
        value: function () {
          const rawSelection = win.getSelection();
          setKey(rawSelection, key);
          return SecureSelectionWrapper(rawSelection, key);
        },
        writable: true
      },
      setTimeout: {
        enumerable: true,
        value: function (callback) {
          return setTimeout.apply(win, [FunctionBind(callback, o)].concat(ArraySlice(arguments, 1)));
        }
      },
      setInterval: {
        enumerable: true,
        value: function (callback) {
          return setInterval.apply(win, [FunctionBind(callback, o)].concat(ArraySlice(arguments, 1)));
        }
      },
      location: {
        enumerable: true,
        get: function () {
          return SecureLocation(win.location, key);
        },
        set: function (value) {
          const ret = win.location.href = value;
          return ret;
        }
      },
      URL: {
        enumerable: true,
        value: SecureURL(win, key)
      },
      history: {
        enumerable: true,
        value: SecureHistory(win.history, key)
      },
      top: {
        enumerable: true,
        get() {
          if (win.top === window) {
            return o;
          }
          return SecureIFrameContentWindow(win.top, key);
        }
      },
      parent: {
        enumerable: true,
        get() {
          if (parentValue) {
            return parentValue;
          }
          if (win.parent === window) {
            return o;
          }
          return SecureIFrameContentWindow(win.parent, key);
        },
        set(value) {
          parentValue = value;
          return true;
        }
      },
      toString: {
        value: function () {
          return `SecureWindow: ${win}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    addMethodIfSupported(o, win, 'getComputedStyle', RAW_ARGS);
    fastArrayForEach(['outerHeight', 'outerWidth'], name => addPropertyIfSupported(o, win, name));
    fastArrayForEach(['scroll', 'scrollBy', 'scrollTo'], name => addMethodIfSupported(o, win, name));
    defineProperty(o, 'open', {
      enumerable: true,
      writable: true,
      value(href, ...args) {
        // Empty string (or 'about:blank' which we're not supporting) are special case URLs as per the specs.
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Parameters
        // https://html.spec.whatwg.org/multipage/window-object.html#apis-for-creating-and-navigating-browsing-contexts-by-name
        let shouldOpen = false;
        if (href === '') {
          shouldOpen = true;
        } else {
          // Don't sanitize blank URLs because they get transformed
          href = sanitizeURLForElement(href);
          if (!isValidURLScheme(href, EXTENDED_URL_SCHEMES)) {
            throw new error(getSupportedSchemesErrorMessage('open', 'SecureWindow', EXTENDED_URL_SCHEMES));
          }
          shouldOpen = confirmLocationChange(win.location.href, href);
        }
        if (shouldOpen) {
          const filteredArgs = filterArguments(o, [href, ...args]);
          if (W6081125_windowOpenNoopener) {
            let windowFeatures = filteredArgs[2];

            // Specify boolean window features with no value as a workaround for
            // Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=1566619.
            if (windowFeatures === undefined || windowFeatures === null) {
              // Boolean window features will default to "no" unless specified.
              // https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Toolbar_and_chrome_features
              windowFeatures = 'location,menubar,noopener,resizable,scrollbars,status';
            } else {
              windowFeatures = asString(windowFeatures).replace(/\bnoopener\b[^,]*,?/g, '');
              windowFeatures = `${windowFeatures},noopener`;
            }
            filteredArgs[2] = windowFeatures;
          }
          let res;

          // MSHTML flavors of Microsoft Edge (v18 and below) don't support noopener.
          // https://caniuse.com/#feat=rel-noopener
          if (W6081125_windowOpenNoopener && isEdgeMSHTML) {
            // See https://mathiasbynens.github.io/rel-noopener/#recommendations
            res = win.open(null, filteredArgs[1], filteredArgs[2]);
            res.opener = null;
            res.location.href = href;
          } else {
            res = win.open(...filteredArgs);
          }
          return isWindowLikeObject(res) ? SecureIFrameContentWindow(res, key) : res;
        }
        // window.open spec expects a null return value if the operation fails
        return null;
      }
    });
    if ('fetch' in win) {
      defineProperty(o, 'fetch', {
        enumerable: true,
        value: function () {
          if (arguments[0]) {
            arguments[0] = sanitizeURLForRequests(arguments[0]);
          }
          return win.fetch(...arguments);
        }
      });
    }
    if (ObjectHasOwnProperty(win, 'localStorage')) {
      let secureStorage, errThrown;
      try {
        // Chrome blocks access to localStorage when 3rd party cookies are disabled.
        secureStorage = SecureStorage(win.localStorage, 'LOCAL', key);
      } catch (err) {
        // Keep the original error and throw a new copy of it later upon localStorage access.
        errThrown = err;
      }
      defineProperty(o, 'localStorage', {
        enumerable: true,
        get: function () {
          if (secureStorage) {
            return secureStorage;
          }
          throw new DOMException(errThrown.message, errThrown.name);
        }
      });
    }
    if (ObjectHasOwnProperty(win, 'sessionStorage')) {
      let secureStorage, errThrown;
      try {
        // Chrome blocks access to sessionStorage when 3rd party cookies are disabled.
        secureStorage = SecureStorage(win.sessionStorage, 'SESSION', key);
      } catch (err) {
        // Keep the original error and throw a new copy of it later upon sessionStorage access.
        errThrown = err;
      }
      defineProperty(o, 'sessionStorage', {
        enumerable: true,
        get: function () {
          if (secureStorage) {
            return secureStorage;
          }
          throw new DOMException(errThrown.message, errThrown.name);
        }
      });
    }
    if ('FormData' in win) {
      let formDataValueOverride;
      defineProperty(o, 'FormData', {
        get: function () {
          return formDataValueOverride || function () {
            const args = ArraySlice(arguments);
            // make sure we have access to any <form> passed in to constructor
            let form;
            if (args.length > 0) {
              form = args[0];
              verifyAccess(o, form);
            }
            const rawArgs = form ? [getRef(form, getKey(form))] : [];
            const cls = win['FormData'];
            if (typeof cls === 'function') {
              return new (Function.prototype.bind.apply(window['FormData'], [null].concat(rawArgs)))();
            }
            return new cls(rawArgs);
          };
        },
        set: function (value) {
          formDataValueOverride = value;
        }
      });
    }
    if ('Notification' in win) {
      let notificationValueOverride;
      defineProperty(o, 'Notification', {
        get: function () {
          if (notificationValueOverride) {
            return notificationValueOverride;
          }
          const notification = SecureNotification(key);
          if ('requestPermission' in win['Notification']) {
            defineProperty(notification, 'requestPermission', {
              enumerable: true,
              value: function (callback) {
                return Notification['requestPermission'](callback);
              }
            });
          }
          if ('permission' in win['Notification']) {
            defineProperty(notification, 'permission', {
              enumerable: true,
              value: Notification['permission']
            });
          }
          return notification;
        },
        set: function (value) {
          notificationValueOverride = value;
        }
      });
    }
    if ('Blob' in win) {
      defineProperty(o, 'Blob', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: win.Blob
      });
    }
    if ('CSS' in win) {
      defineProperty(o, 'CSS', createFilteredMethod(o, win, 'CSS', RAW_ARGS));
      defineProperty(o.CSS, 'supports', createFilteredMethod(o.CSS, win.CSS, 'supports', RAW_ARGS));
    }
    if ('File' in win) {
      defineProperty(o, 'File', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: win.File
      });
    }
    if ('MediaSource' in win) {
      defineProperty(o, 'MediaSource', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: win.MediaSource
      });
    }
    if ('Touch' in win) {
      defineProperty(o, 'Touch', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: SecureTouch(win, key)
      });
    }
    if ('TouchList' in win) {
      defineProperty(o, 'TouchList', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: SecureTouchList(win, key)
      });
    }
    if ('TouchEvent' in win) {
      defineProperty(o, 'TouchEvent', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: SecureTouchEvent(win, key)
      });
    }
    if ('CustomEvent' in win) {
      defineProperty(o, 'CustomEvent', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: SecureCustomEventFactory(win['CustomEvent'], key)
      });
    }
    if ('webkit' in win) {
      defineProperty(o, 'webkit', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: win.webkit
      });
    }
    addEventTargetMethods(o, win, key);

    // Has to happen last because it depends on the secure getters defined above that require the object to be keyed
    fastArrayForEach(stdlib,
    // These are direct passthrough's and should never be wrapped in a SecureObject
    // They are non-writable to make them compatible with the evaluator.
    name => defineProperty(o, name, {
      enumerable: true,
      value: win[name]
    }));
    if (windowAddPropertiesHook) {
      windowAddPropertiesHook(o, win, key);
    }
    addPrototypeMethodsAndProperties(metadataView, o, win, key);
    setRef(o, win, key);
    addToCache(win, o, key);
    registerProxy(o);
    return o;
  }
  function SecureGlobal(raw, key) {
    const cache = getFromCache(raw, key);
    if (cache) {
      return cache;
    }

    // Create prototype to allow basic object operations like hasOwnProperty etc
    const props = getOwnPropertyDescriptors(Object.prototype);
    // Do not treat global like a plain object, $A.util.isPlainObject() returns true if we leave the constructor intact.
    delete props.constructor;
    const emptyProto = create$1(null, props);
    const st = create$1(emptyProto);
    defineProperty(st, 'global', {
      enumerable: true,
      value: st
    });
    defineProperty(st, 'Infinity', {
      enumerable: true,
      value: Infinity
    });
    fastArrayForEach(stdlib,
    // These are direct passthrough's and should never be wrapped in a SecureObject
    // They are non-writable to make them compatible with the evaluator.
    name => defineProperty(st, name, {
      enumerable: true,
      value: raw[name]
    }));
    setRef(st, raw, key);
    addToCache(raw, st, key);
    registerProxy(st);
    return st;
  }
  var DocumentOrShadowRoot = {
    activeElement: READ_ONLY_PROPERTY,
    elementFromPoint: FUNCTION,
    elementsFromPoint: FUNCTION
    // getSelection: FUNCTION (NOT EXPOSED!)
    // pointerLockElement: DEFAULT (NOT EXPOSED!)
    // styleSheets: DEFAULT (NOT EXPOSED!)
  };

  var ShadowRoot$1 = {
    delegatesFocus: READ_ONLY_PROPERTY,
    host: READ_ONLY_PROPERTY_FORCE_OPAQUE,
    innerHTML: READ_ONLY_PROPERTY,
    mode: READ_ONLY_PROPERTY
  };
  const DocumentFragmentView = assign({}, DocumentFragment$1, {
    childElementCount: READ_ONLY_PROPERTY,
    children: READ_ONLY_PROPERTY,
    firstElementChild: SKIP_OPAQUE
  });
  const EventTargetView = assign({}, EventTarget$1);

  // getElementById: FUNCTION (NOT EXPOSED!)
  delete DocumentFragmentView.getElementById;

  // dispatchEvent: FUNCTION (NOT EXPOSED!)
  delete EventTargetView.dispatchEvent;
  var metadataViewSecureTemplate = {
    prototypes: {
      DocumentFragment: DocumentFragmentView,
      DocumentOrShadowRoot,
      EventTarget: EventTargetView,
      Node: Node$1,
      // NonDocumentTypeChildNode: {
      //   nextElementSibling: READ_ONLY_PROPERTY (NULL!)
      //   previousElementSibling: READ_ONLY_PROPERTY (NULL!)
      // },
      // ParentNode: {
      //   append: FUNCTION (NOT EXPOSED!)
      //   prepend: FUNCTION (NOT EXPOSED!)
      // },
      ShadowRoot: ShadowRoot$1
    }
  };
  function doFreeze(obj) {
    if (!isPrimitive(obj)) {
      freeze(obj);
    }
  }

  /**
   * Shallow freeze to prevent tampering of [value, get, set] objects!
   */
  function shallowFreeze(obj) {
    if (isPrimitive(obj)) {
      return;
    }
    doFreeze(obj);
    const descs = getOwnPropertyDescriptors(obj);
    for (const key in descs) {
      const desc = getOwnPropertyDescriptor(obj, key);
      if ('value' in desc) {
        doFreeze(desc.value);
      } else {
        const {
          get,
          set
        } = desc;
        if (get) doFreeze(get);
        if (set) doFreeze(set);
      }
    }

    // NOTE: Using the descriptor to evade invoking any accessor named 'prototype'
    const prototype = descs.prototype && descs.prototype.value;
    for (const key in prototype) {
      const desc = getOwnPropertyDescriptor(prototype, key);
      if ('value' in desc) {
        doFreeze(desc.value);
      } else {
        const {
          get,
          set
        } = desc;
        if (get) doFreeze(get);
        if (set) doFreeze(set);
      }
    }
  }

  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const additionalAttributes$LWS = ['role', 'target'];
  const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
  const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
  const allTags$LWS = ArrayConcat$LWS(htmlTags$LWS, svgTags$LWS);
  const CUSTOM_ELEMENT_HANDLING$LWS = {
    attributeNameCheck: /.+/,
    allowCustomizedBuiltInElements: false,
    // The regexp is based on the WHATWG spec:
    // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
    // However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.
    tagNameCheck: /^[a-z][-_.\w]*-[-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF]*$/
  };
  // A generic config in which the sanitizer attempts in place sanitization and
  // returns node.
  const NODE_ALL_IN_PLACE$LWS = {
    ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
    // Add '#document-fragment' to ALLOWED_TAGS to avoid a forbidden root node
    // exception.
    // https://github.com/cure53/DOMPurify/issues/664
    ALLOWED_TAGS: ArrayConcat$LWS(allTags$LWS, '#document-fragment'),
    CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
    IN_PLACE: true,
    // @ts-ignore this type is on DOMPurifyConfig
    TRUSTED_TYPES_POLICY: trusted
  };
  // A config to use only svg tags in which the sanitizer returns a document
  // fragment.
  const NODE_SVG$LWS = {
    ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
    ALLOWED_TAGS: shallowCloneArray$LWS(svgTags$LWS),
    CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
    RETURN_DOM_FRAGMENT: true,
    SANITIZE_DOM: false,
    // @ts-ignore this type is on DOMPurifyConfig
    TRUSTED_TYPES_POLICY: trusted
  };
  // A config to use only tags allowed for blob and file.
  const STRING_BLOB_HTML$LWS = {
    ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
    ALLOWED_TAGS: ReflectApply$LWS$1(ArrayProtoFilter$LWS$1, allTags$LWS, [tag$LWS => tag$LWS !== 'iframe']),
    CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
    SANITIZE_DOM: false,
    // @ts-ignore this type is on DOMPurifyConfig
    TRUSTED_TYPES_POLICY: trusted
  };
  var CONFIG$LWS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NODE_ALL_IN_PLACE: NODE_ALL_IN_PLACE$LWS,
    NODE_SVG: NODE_SVG$LWS,
    STRING_BLOB_HTML: STRING_BLOB_HTML$LWS
  });
  const instancesBySandboxKeyRegistry$LWS = {
    __proto__: null
  };
  const SANITIZE_ATTRIBUTES_LIST$LWS = toSafeArray$LWS$1(['href', 'xlink:href']);
  const SHARED_SVG_SANITIZER_KEY$LWS = 'SHARED_SVG_SANITIZER_KEY';
  ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
  // Queue for managing pending XHR requests.
  const queue$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
  // A regexp to find all non lowercase alphanumeric.
  const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;
  function createSantizerHooksRegistry$LWS(sandboxKey$LWS) {
    return {
      __proto__: null,
      // uponSanitizeAttribute is generic, so its definition can be a reused function
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      uponSanitizeAttribute: uponSanitizeAttribute$LWS,
      // uponSanitizeElement is sandbox-key-specific
      uponSanitizeElement(node$LWS, data$LWS, config$LWS) {
        var _config$CUSTOM_ELEMEN$LWS;
        const {
          tagName: tagName$LWS
        } = data$LWS;
        const tagNameCheck$LWS = config$LWS == null || (_config$CUSTOM_ELEMEN$LWS = config$LWS.CUSTOM_ELEMENT_HANDLING) == null ? void 0 : _config$CUSTOM_ELEMEN$LWS.tagNameCheck;
        if (tagNameCheck$LWS && ReflectApply$LWS$1(RegExpProtoTest$LWS$1, tagNameCheck$LWS, [tagName$LWS]) &&
        // This MUST be called ONLY after we've ensured the previous
        // two conditions have been met, otherwise it may result in an
        // unwanted "Illegal invocation" on a node we don't care about.
        !ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS])) {
          ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS, sandboxKey$LWS]);
        }
      }
    };
  }
  function createUrlContainer$LWS(url$LWS) {
    const container$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['div']);
    ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ['style', 'display:none']);
    ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ['id', url$LWS]);
    const body$LWS = ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, document, []);
    ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, body$LWS, [container$LWS]);
    return container$LWS;
  }
  function getSanitizerForConfig$LWS(sandboxKey$LWS, configName$LWS) {
    if (typeof sandboxKey$LWS !== 'string') {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    if (typeof configName$LWS !== 'string') {
      throw new LockerSecurityError$LWS('Invalid config name.');
    }
    let sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS];
    if (sandboxConfiguredSanitizerInstances$LWS === undefined) {
      sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS] = {
        __proto__: null
      };
    }
    let configuredDOMPurifyInstance$LWS = sandboxConfiguredSanitizerInstances$LWS[configName$LWS];
    if (configuredDOMPurifyInstance$LWS === undefined) {
      const config$LWS = CONFIG$LWS[configName$LWS];
      configuredDOMPurifyInstance$LWS = DOMPurify();
      configuredDOMPurifyInstance$LWS.setConfig(config$LWS);
      const hooksRegistry$LWS = createSantizerHooksRegistry$LWS(sandboxKey$LWS);
      for (const hookName$LWS in hooksRegistry$LWS) {
        configuredDOMPurifyInstance$LWS.addHook(hookName$LWS, hooksRegistry$LWS[hookName$LWS]);
      }
      sandboxConfiguredSanitizerInstances$LWS[configName$LWS] = configuredDOMPurifyInstance$LWS;
    }
    return configuredDOMPurifyInstance$LWS;
  }
  function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
    const svgSanitizer$LWS = getSanitizerForConfig$LWS(SHARED_SVG_SANITIZER_KEY$LWS, 'NODE_SVG');
    return svgSanitizer$LWS.sanitize(dirty$LWS);
  }
  function sanitizeSvgHref$LWS(url$LWS) {
    const urlAsString$LWS = toString$LWS(url$LWS);
    if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, urlAsString$LWS, ['#'])) {
      return url$LWS;
    }
    const normalizedHref$LWS = parseHref$LWS(urlAsString$LWS);
    // Sanitize only for supported URL_SCHEMES_LIST.
    if (URL_SCHEMES_LIST$LWS.includes(normalizedHref$LWS.protocol)) {
      const container$LWS = ReflectApply$LWS$1(DocumentProtoGetElementById$LWS, document, [normalizedHref$LWS.normalizedURL]);
      // Have we sanitized this URL already?
      if (container$LWS && normalizedHref$LWS.normalizedFragment) {
        checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
      } else if (!container$LWS) {
        fetchAndSanitize$LWS(normalizedHref$LWS);
      }
      // If this has been in the form of http://my-url/file.svg#fragment we
      // return the normalized fragment otherwise we return the normalized URL.
      return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedURL}`;
    }
    return url$LWS;
  }
  function updater$LWS(container$LWS, normalizedHref$LWS) {
    const {
      normalizedFragment: normalizedFragment$LWS,
      requestedFragment: requestedFragment$LWS
    } = normalizedHref$LWS;
    let el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${normalizedFragment$LWS}`]);
    // istanbul ignore else
    if (el$LWS === null) {
      try {
        el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${requestedFragment$LWS}`]);
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ['id', normalizedFragment$LWS]);
      } catch (_unused$LWS) {
        // Catch all malformed CSS3 selectors.
        // getElementById not available on Node.
        // Cannot use document.getElementById because multiple containers
        // may have the same ids for SVG elements.
      }
    }
  }
  function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
    if (queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
      // Wait for request to finish, then update content.
      const interval$LWS = WindowSetInterval$LWS(() => {
        // istanbul ignore else
        if (!queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
          updater$LWS(container$LWS, normalizedHref$LWS);
          WindowClearInterval$LWS(interval$LWS);
        }
      }, 50);
    } else {
      updater$LWS(container$LWS, normalizedHref$LWS);
    }
  }
  function fetchAndSanitize$LWS(normalizedHref$LWS) {
    // This is the first time we see this href.
    const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedURL);
    // Put the URL we're fetching in a queue.
    queue$LWS.add(normalizedHref$LWS.normalizedURL);
    // Initiate an XHR to fetch the resource.
    const xhr$LWS = new XhrCtor$LWS();
    ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
      const status$LWS = ReflectApply$LWS$1(XhrProtoStatusGetter$LWS, xhr$LWS, []);
      // istanbul ignore next: the following is well tested via integration-karma
      if (status$LWS === 200) {
        // Retrieved content should be sanitized immediately.
        const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(responseText$LWS);
        // Look for the container again in case other requests have finished
        // earlier for the same URL.
        if (normalizedHref$LWS.requestedFragment) {
          const el$LWS = ReflectApply$LWS$1(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [normalizedHref$LWS.requestedFragment]);
          if (el$LWS) {
            ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ['id', normalizedHref$LWS.normalizedFragment]);
          }
        }
        ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, container$LWS, [fragment$LWS]);
        queue$LWS.delete(normalizedHref$LWS.normalizedURL);
      }
    }]);
    ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', normalizedHref$LWS.requestedURL]);
    ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
  }
  function parseHref$LWS(url$LWS) {
    ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
    const href$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
    const protocol$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []);
    const {
      0: requestedURL$LWS,
      1: requestedFragment$LWS
    } = ReflectApply$LWS$1(StringProtoSplit$LWS, href$LWS, ['#']);
    const loweredUrl$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, requestedURL$LWS, []);
    // RegExp.prototype[Symbol.replace] resets the lastIndex of global regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    const normalizedURL$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredUrl$LWS, [urlReplacerRegExp$LWS, '']);
    const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedURL$LWS}_${ReflectApply$LWS$1(StringProtoReplace$LWS, requestedFragment$LWS, [urlReplacerRegExp$LWS, ''])}` : '';
    return {
      normalizedFragment: normalizedFragment$LWS,
      normalizedURL: normalizedURL$LWS,
      protocol: protocol$LWS,
      requestedFragment: requestedFragment$LWS,
      requestedURL: requestedURL$LWS
    };
  }
  // Sanitize a URL representing a SVG href attribute value.
  function uponSanitizeAttribute$LWS(node$LWS, data$LWS, _config$LWS) {
    const {
      attrValue: attrValue$LWS,
      attrName: attrName$LWS
    } = data$LWS;
    if (attrValue$LWS && ReflectApply$LWS$1(StringProtoToUpperCase$LWS, ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, []), []) === 'USE' && SANITIZE_ATTRIBUTES_LIST$LWS.includes(attrName$LWS)) {
      data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
    }
    return data$LWS;
  }
  function blobSanitizer$LWS(sandboxKey$LWS) {
    if (typeof sandboxKey$LWS !== 'string') {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    return getSanitizerForConfig$LWS(sandboxKey$LWS, 'STRING_BLOB_HTML');
  }
  /*! version: 0.21.7 */

  /*!
   * Copyright (C) 2023 salesforce.com, inc.
   */
  const inflightRequests$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  async function getSourceText$LWS(resourceURL$LWS, targetElement$LWS) {
    abortInFlightRequest$LWS(targetElement$LWS);
    const controller$LWS = new AbortControllerCtor$LWS();
    inflightRequests$LWS.set(targetElement$LWS, controller$LWS);
    // The error "The value of the 'Access-Control-Allow-Origin' header in the
    // response must not be the wildcard '*' when the request's credentials mode
    // is 'include'" occurs when the Access-Control-Allow-Credentials header is
    // set to true and the Access-Control-Allow-Origin header is set to an asterisk *.
    //
    // The error may be resolved in one of two ways:
    //   1) Set the Access-Control-Allow-Credentials header to 'false' and keep
    //      the Access-Control-Allow-Origin header as an asterisk * to allow all
    //      origins to access your server.
    //   2) Set the Access-Control-Allow-Origin header to a specific origin,
    //      e.g. 'http://localhost:3000' or a list of allowlisted origins that
    //      are allowed to access your server. Note that the origin must specify
    //      the protocol, domain and port.
    const hostname$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []);
    // To avoid the CORS error above without burdening users with header adjustments
    // we limit credentials mode of 'include' to "trusted" domains.
    const credentials$LWS = ReflectApply$LWS$1(RegExpProtoTest$LWS$1, TRUSTED_DOMAINS_REG_EXP$LWS, [hostname$LWS]) ? 'include' : 'same-origin';
    const signal$LWS = ReflectApply$LWS$1(AbortControllerProtoSignalGetter$LWS, controller$LWS, []);
    const response$LWS = await WindowFetch$LWS(resourceURL$LWS, {
      __proto__: null,
      method: 'GET',
      credentials: credentials$LWS,
      signal: signal$LWS
    });
    inflightRequests$LWS.delete(targetElement$LWS);
    if (!ReflectApply$LWS$1(ResponseProtoOkGetter$LWS, response$LWS, [])) {
      throw new ErrorCtor$LWS$1('Request failed.');
    }
    const sourceText$LWS = await ReflectApply$LWS$1(ResponseProtoText$LWS, response$LWS, []);
    return sourceText$LWS;
  }
  function abortInFlightRequest$LWS(element$LWS) {
    const abortController$LWS = inflightRequests$LWS.get(element$LWS);
    // istanbul ignore if: currently unreachable via tests (this path can be invoked, however it will cause the tests to time out)
    if (abortController$LWS) {
      ReflectApply$LWS$1(AbortControllerProtoAbort$LWS, abortController$LWS, []);
    }
  }
  const EVALUATOR_PROPERTY_KEY$LWS = '$evaluator$';
  const BLOB_SCRIPT_SOURCE$LWS = `document.currentScript['${EVALUATOR_PROPERTY_KEY$LWS}']`;

  // eslint-disable-next-line no-shadow
  var ContentType$LWS;
  (function (ContentType$LWS) {
    ContentType$LWS[ContentType$LWS["HTML"] = 0] = "HTML";
    ContentType$LWS[ContentType$LWS["SVG"] = 1] = "SVG";
    ContentType$LWS[ContentType$LWS["XML"] = 2] = "XML";
  })(ContentType$LWS || (ContentType$LWS = {}));
  const evaluatedScripts$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  const scriptURLsCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const htmlTemplate$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
  const policyOptions$LWS = {
    createHTML(dirty$LWS, lwsKey$LWS, contentType$LWS) {
      // istanbul ignore if: currently unreachable via tests, may indicate a dead code path
      if (dirty$LWS === null || dirty$LWS === undefined) {
        return '';
      }
      if (typeof lwsKey$LWS !== 'string') {
        throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
      }
      switch (contentType$LWS) {
        case ContentType$LWS.HTML:
          {
            ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, htmlTemplate$LWS, [trusted.createHTML(dirty$LWS)]);
            const content$LWS = ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, htmlTemplate$LWS, []);
            const sanitizer$LWS = getSanitizerForConfig$LWS(lwsKey$LWS, 'NODE_ALL_IN_PLACE');
            sanitizer$LWS.sanitize(content$LWS);
            return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, htmlTemplate$LWS, []);
          }
        case ContentType$LWS.SVG:
          {
            const tplElement$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
            ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, tplElement$LWS, [trusted.createHTML(dirty$LWS)]);
            const wrappedDirty$LWS = ReflectApply$LWS$1(DocumentProtoCreateElementNS$LWS, document, [NAMESPACE_SVG$LWS, 'svg']);
            ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, wrappedDirty$LWS, [trusted.createHTML(dirty$LWS)]);
            const sanitized$LWS = getSanitizerForConfig$LWS('SHARED_SVG_SANITIZER_KEY', 'NODE_SVG').sanitize(wrappedDirty$LWS);
            const firstChild$LWS = ReflectApply$LWS$1(NodeProtoFirstChildGetter$LWS, sanitized$LWS, []);
            return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, firstChild$LWS, []);
          }
        case ContentType$LWS.XML:
          return dirty$LWS;
        default:
          return '';
      }
    },
    createScript(_dirty$LWS, _evaluator$LWS) {
      return '';
    },
    createScriptURL(dirty$LWS, evaluator$LWS, targetElement$LWS) {
      const setURL$LWS = encloseSrcSetter$LWS(targetElement$LWS);
      dirty$LWS = `${dirty$LWS}`;
      // Passthrough for any script element evaluated by us
      // or if userland code tries to set a falsy value.
      if (evaluatedScripts$LWS.has(targetElement$LWS) || dirty$LWS === '' || dirty$LWS === 'undefined' || dirty$LWS === 'null') {
        setURL$LWS(trusted.createScriptURL(dirty$LWS));
        return dirty$LWS;
      }
      const targetElementIsConnected$LWS = ReflectApply$LWS$1(NodeProtoIsConnectedGetter$LWS, targetElement$LWS, []);
      const resolvedURL$LWS = resolveURL$LWS(dirty$LWS);
      if (targetElementIsConnected$LWS) {
        // When the script is connected and has a .src value it is safe to let the url passthrough
        // because it will never be evaluated again.
        if (getURL$LWS(targetElement$LWS)) {
          evaluatedScripts$LWS.add(targetElement$LWS);
          setURL$LWS(trusted.createScriptURL(dirty$LWS));
          return dirty$LWS;
        }
        // There is a small window while the source code is asynchronously fetched but the script may
        // have already been placed in the DOM without having yet our blob URL set as the .src value.
        // We block the request in this scenario and set the last URL after we evaluate.
        if (scriptURLsCache$LWS.has(targetElement$LWS)) {
          return '';
        }
      }
      const asyncRequest$LWS = getSourceText$LWS(resolvedURL$LWS, targetElement$LWS);
      scriptURLsCache$LWS.set(targetElement$LWS, resolvedURL$LWS);
      const safeURL$LWS = createSandboxURL$LWS();
      const onFulfill$LWS = sourceText$LWS => {
        ReflectDefineProperty$LWS$1(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS, {
          __proto__: null,
          configurable: true,
          get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
            ReflectDeleteProperty$LWS$1(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS);
            URLRevokeObjectURL$LWS(safeURL$LWS);
            const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
            scriptURLsCache$LWS.delete(targetElement$LWS);
            evaluatedScripts$LWS.add(targetElement$LWS);
            // We sign & assign the original URL even though it will not be executed.
            // The wrappedEvaluator is guaranteed to run only one time once the script
            // is appended in the dom.
            // Re-assigning .src after it ran will not retrigger the evaluation
            // of the new URL.
            // However, TrustedTypes still requires this assignment to be signed.
            // We do this because we don't want to leave observable traces in the DOM.
            setURL$LWS(trusted.createScriptURL(cachedURL$LWS));
            evaluator$LWS(sourceText$LWS);
          }, [targetElement$LWS]),
          set: undefined
        });
        setURL$LWS(trusted.createScriptURL(safeURL$LWS));
      };
      const onReject$LWS = _error$LWS => {
        URLRevokeObjectURL$LWS(safeURL$LWS);
        const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
        scriptURLsCache$LWS.delete(targetElement$LWS);
        // We are only able to generate 404 errors and we cannot trust any other URL.
        // This blob URL will be sufficient to trigger error event handlers.
        // We still have to sign this URL, TrustedTypes does not take into consideration
        // the state of the script elements. It's an either or operation: either we set a
        // signed value and we are ok or we don't and the browser throws an error. We
        // want our 404 URL to be set and trigger the event handlers, hence we have to sign.
        setURL$LWS(trusted.createScriptURL('blob:http://localhost/not-found'));
        // This error event handler will get triggered after we set our 404 blob URL.
        const errorEventHandler$LWS = () => {
          // Similar to our wrappedEvaluator, we leave no traces.
          setURL$LWS(trusted.createScriptURL(cachedURL$LWS));
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, targetElement$LWS, ['error', errorEventHandler$LWS]);
        };
        ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, targetElement$LWS, ['error', errorEventHandler$LWS]);
      };
      ReflectApply$LWS$1(PromiseProtoThen$LWS, asyncRequest$LWS, [onFulfill$LWS, onReject$LWS]);
      return '';
    }
  };
  const lwsInternalPolicy$LWS = createPolicy('lwsInternal', policyOptions$LWS);
  // Even though the content is always the same we use unique URLs for each script.
  function createSandboxURL$LWS() {
    return URLCreateObjectURL$LWS(new BlobCtor$LWS([BLOB_SCRIPT_SOURCE$LWS], {
      __proto__: null,
      type: 'text/javascript'
    }));
  }
  function getURL$LWS(targetElement$LWS) {
    const isHTMLScriptElement$LWS = targetElement$LWS instanceof HTMLScriptElementCtor$LWS;
    if (isHTMLScriptElement$LWS) {
      return ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement$LWS, ['src']);
    }
    const hasHref$LWS = ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, targetElement$LWS, ['href']);
    return hasHref$LWS ? ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement$LWS, ['href']) : ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement$LWS, ['xlink:href']);
  }
  function encloseSrcSetter$LWS(targetElement$LWS) {
    const namespaceURI$LWS = ReflectApply$LWS$1(ElementProtoNamespaceURIGetter$LWS, targetElement$LWS, []);
    const attributeNamespaceURI$LWS = namespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;
    const attributeName$LWS = targetElement$LWS instanceof HTMLScriptElementCtor$LWS ? 'src' : 'href';
    return function (src$LWS) {
      ReflectApply$LWS$1(ElementProtoSetAttributeNS$LWS, targetElement$LWS, [attributeNamespaceURI$LWS, attributeName$LWS, src$LWS]);
    };
  }
  /*! version: 0.21.7 */

  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  var _rootWindow$CustomEle$LWS;
  const ERR_ILLEGAL_CONSTRUCTOR$LWS = 'Illegal constructor';
  const ERR_ILLEGAL_INVOCATION$LWS = 'Illegal invocation.';
  const ERR_NO_NEW_OP_HTML_ELEMENT$LWS = "Failed to construct 'HTMLElement': Please use the 'new' operator, this DOM object constructor cannot be called as a function.";
  let currentRegistry$LWS;
  let currentUpgradingInstance$LWS;
  const definitionCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const globalRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const pivotCtorCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const sandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const CustomElementRegistryProto$LWS = (_rootWindow$CustomEle$LWS = rootWindow$LWS$1.CustomElementRegistry) == null ? void 0 : _rootWindow$CustomEle$LWS.prototype;
  const CustomElementRegistryProtoDefine$LWS = CustomElementRegistryProto$LWS ? getUnmaskedFunction$LWS(CustomElementRegistryProto$LWS.define) : /* istanbul ignore next: this is a safety precaution that is unreachable via tests */undefined;
  const CustomElementRegistryProtoWhenDefined$LWS = CustomElementRegistryProto$LWS ? getUnmaskedFunction$LWS(CustomElementRegistryProto$LWS.whenDefined) : /* istanbul ignore next: this is a safety precaution that is unreachable via tests */undefined;
  const CustomElementRegistryProtoUpgrade$LWS = CustomElementRegistryProto$LWS ? getUnmaskedFunction$LWS(CustomElementRegistryProto$LWS.upgrade) : /* istanbul ignore next: this is a safety precaution that is unreachable via tests */undefined;
  /* eslint-disable no-underscore-dangle */
  class VirtualRegistry$LWS {
    constructor(document$LWS, originalHTMLElementCtor$LWS = getUnmaskedFunction$LWS(ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, document$LWS, []).HTMLElement)) {
      this._awaitingUpgrade = toSafeMap$LWS$1(new MapCtor$LWS$1());
      this._definedCtors = toSafeSet$LWS(new SetCtor$LWS$1());
      this._definitionByElement = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      this._definitionByTag = toSafeMap$LWS$1(new MapCtor$LWS$1());
      this._pendingRegistryByElement = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      this._document = document$LWS;
      this._originalHTMLElementCtor = originalHTMLElementCtor$LWS;
    }
    applyDefine(cer$LWS, args$LWS) {
      const {
        0: tagName$LWS,
        1: LocalCtor$LWS,
        2: options$LWS
      } = args$LWS;
      if (options$LWS && options$LWS.extends) {
        throw new DOMExceptionCtor$LWS$1("NotSupportedError: 'extends' key in customElements.define() options is not supported.");
      }
      if (this._definitionByTag.has(tagName$LWS)) {
        throw new DOMExceptionCtor$LWS$1(`Failed to execute 'define' on 'CustomElementRegistry': the name "${tagName$LWS}" has already been used with this registry.`);
      }
      if (this._definedCtors.has(LocalCtor$LWS)) {
        throw new DOMExceptionCtor$LWS$1("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry.");
      }
      const definition$LWS = getDefinitionForCtor$LWS(LocalCtor$LWS);
      let PivotCtor$LWS = pivotCtorCache$LWS.get(tagName$LWS);
      if (PivotCtor$LWS === undefined) {
        PivotCtor$LWS = createPivotingClass$LWS(this._document, this._originalHTMLElementCtor, definition$LWS, tagName$LWS);
        // Register a pivoting class which will handle global registry initializations.
        ReflectApply$LWS$1(CustomElementRegistryProtoDefine$LWS, cer$LWS, [tagName$LWS, PivotCtor$LWS]);
      } else {
        // When there is already a PivotCtor for the given tagName, we need to ensure that
        // this definition doesn't have a conflicting formAssociated value for that tagName.
        const {
          formAssociated: formAssociated$LWS = false
        } = definition$LWS;
        if (PivotCtor$LWS.formAssociated !== formAssociated$LWS) {
          throw new LockerSecurityError$LWS(`Cannot create a definition for <${tagName$LWS}> with "formAssociated = ${formAssociated$LWS}". Either use "formAssociated = ${PivotCtor$LWS.formAssociated}" for this component or rename the component to not conflict with <${tagName$LWS}>`);
        }
      }
      // We MUST keep track of the constructor used to define custom elements
      // to prevent accidental re-use of constructors in userland code.
      //
      // Only cache AFTER `CustomElementRegistryProtoDefine` has been called
      // because if it throws an error (e.g. for an invalid tag name), then we
      // don't want to cache anything.
      pivotCtorCache$LWS.set(tagName$LWS, PivotCtor$LWS);
      definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
      this._definedCtors.add(LocalCtor$LWS);
      this._definitionByTag.set(tagName$LWS, definition$LWS);
      // For globally defined custom elements, the definition associated
      // with the `LocalCtor` has a back-pointer to `PivotCtor` in case the
      // user new's the `LocalCtor`, so we know how to create the underlying
      // element.
      definition$LWS.PivotCtor = PivotCtor$LWS;
      // Immediately upgrade any elements created in this scope before define was called,
      // e.g. LWC using a tagName in a template before the same tagName is
      // registered.
      const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
      if (awaiting$LWS) {
        awaiting$LWS.forEach(element$LWS => {
          const originalDefinition$LWS = this._pendingRegistryByElement.get(element$LWS);
          // istanbul ignore else: it is unnecessary to cover the else path here
          if (originalDefinition$LWS) {
            this._pendingRegistryByElement.delete(element$LWS);
            this.upgrade(element$LWS, originalDefinition$LWS, definition$LWS);
          }
        });
      }
    }
    applyGet(cer$LWS, args$LWS) {
      const tagName$LWS = args$LWS[0];
      const definition$LWS = this._definitionByTag.get(tagName$LWS);
      return definition$LWS ? definition$LWS.LocalCtor : undefined;
    }
    applyUpgrade(cer$LWS, args$LWS) {
      const element$LWS = args$LWS[0];
      const tagName$LWS = ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, element$LWS, []);
      const tagNameLowerCased$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tagName$LWS, []);
      const definition$LWS = this._definitionByTag.get(tagNameLowerCased$LWS);
      // There is no way to to tell `customElements.upgrade` which definition to use to upgrade,
      // so we're only using the definition as a check to make sure this sandbox actually has a
      // definition for the given not-yet-upgraded-element. Regardless of the code being run in a
      // sandbox, or not, when the browser invokes the process to upgrade, it will take our
      // patched path and the result will be the correct definition.
      if (definition$LWS) {
        ReflectApply$LWS$1(CustomElementRegistryProtoUpgrade$LWS, cer$LWS, [element$LWS]);
      }
    }
    applyWhenDefined(cer$LWS, args$LWS) {
      const tagName$LWS = args$LWS[0];
      const promise$LWS = ReflectApply$LWS$1(CustomElementRegistryProtoWhenDefined$LWS, cer$LWS, args$LWS);
      return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
        ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [() => {
          const definition$LWS = this._definitionByTag.get(tagName$LWS);
          if (definition$LWS) {
            resolve$LWS(definition$LWS.LocalCtor);
          }
        }, reject$LWS]);
      });
    }
    getDefinition(instance$LWS) {
      return this._definitionByElement.get(instance$LWS);
    }
    newCtor(instance$LWS, newTarget$LWS, originalHTMLElementCtor$LWS) {
      // Upgrading case: the pivoting class constructor was run by the
      // browser's native custom elements and we're in the process of running
      // the "constructor call trick" on the natively constructed instance,
      // so just return that here.
      const pendingUpgrade$LWS = currentUpgradingInstance$LWS;
      if (pendingUpgrade$LWS) {
        currentUpgradingInstance$LWS = undefined;
        return pendingUpgrade$LWS;
      }
      // NOTE: This precaution is necessary because custom elements created outside
      // of the sandbox are not discoverable, which would result in a failure.
      // In case the custom element is not found, the code will automatically
      // resort to using the global custom element registry.
      // Construction case: We need to construct the pivoting instance and
      // return it. This is possible when the user instantiate it via
      // `new LocalCtor()`.
      const {
        constructor: LocalCtor$LWS
      } = instance$LWS;
      const definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
      if (definition$LWS === undefined || typeof definition$LWS.PivotCtor !== 'function') {
        // If we can get the tag name without triggering "Illegal invocation", then
        // it's plausible that this is an instance of a registered custom element
        // that was defined _before_ LWS was run. Attempting to invoke the getter
        // on an instance that wasn't constructed from a registered definition
        // will not have the Element prototype in its chain and will fail with
        // an "Illegal invocation" exception.
        try {
          ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, this, []);
          // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
          return instance$LWS;
        } catch (_unused$LWS) {
          return ReflectConstruct$LWS(originalHTMLElementCtor$LWS, [], newTarget$LWS);
        }
      }
      // This constructor is ONLY invoked when it is the user instantiating
      // an element via `new LocalCtor(`) while `LocalCtor` is a locally
      // registered constructor.
      return new definition$LWS.PivotCtor(this, definition$LWS);
    }
    scheduleConnectedCallback(instance$LWS, tagName$LWS) {
      // Register for upgrade when defined (only when connected, so we don't leak).
      let awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
      if (awaiting$LWS === undefined) {
        awaiting$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
        this._awaitingUpgrade.set(tagName$LWS, awaiting$LWS);
      }
      awaiting$LWS.add(instance$LWS);
    }
    scheduleDisconnectedCallback(instance$LWS, tagName$LWS) {
      // Un-register for upgrade when defined (so we don't leak).
      const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
      // istanbul ignore else: currently unreachable via tests
      if (awaiting$LWS) {
        awaiting$LWS.delete(instance$LWS);
      }
    }
    scheduleOrUpgrade(instance$LWS, tagName$LWS, originalDefinition$LWS) {
      const definition$LWS = this._definitionByTag.get(tagName$LWS);
      if (definition$LWS) {
        // Browser's initiated a controlled instantiation where we
        // were able to set up the internal registry and the definition.
        this.upgrade(instance$LWS, originalDefinition$LWS, definition$LWS);
      } else {
        // This is the case in which there is no definition yet, and we
        // need to add it to the pending queue just in case it eventually
        // gets defined locally.
        this._pendingRegistryByElement.set(instance$LWS, originalDefinition$LWS);
        // We need to install the minimum HTMLElement prototype so that
        // this instance works like a regular element without a registered
        // definition. `instanceRegistryMap.get(this)!.upgrade()` will eventually
        // install the full custom element prototype.
        ReflectSetPrototypeOf$LWS$1(instance$LWS, this._originalHTMLElementCtor.prototype);
      }
    }
    setDefinition(instance$LWS, definition$LWS) {
      ReflectSetPrototypeOf$LWS$1(instance$LWS, definition$LWS.LocalCtor.prototype);
      this._definitionByElement.set(instance$LWS, definition$LWS);
    }
    // Helper to upgrade an instance with a custom element definition using the
    // "constructor call trick".
    upgrade(instance$LWS, originalDefinition$LWS, definition$LWS) {
      const {
        LocalCtor: LocalCtor$LWS,
        connectedCallback: connectedCallback$LWS
      } = definition$LWS;
      this.setDefinition(instance$LWS, definition$LWS);
      // This path will be taken when any _globally_ registered tag name has
      // more than one possible definition. See explanation at `patchAttributes()`.
      if (definition$LWS !== originalDefinition$LWS) {
        patchAttributes$LWS(instance$LWS, originalDefinition$LWS, definition$LWS);
      }
      // Tricking the construction path to believe that a new instance is being
      // created, that way it will execute the super initialization mechanism
      // but the HTMLElement constructor will reuse the instance by returning
      // the `currentUpgradingInstance`. This is by far the most important piece
      // of the puzzle.
      currentUpgradingInstance$LWS = instance$LWS;
      ReflectConstruct$LWS(LocalCtor$LWS, []);
      const tagName$LWS = ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, instance$LWS, []);
      const tagNameLowerCased$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tagName$LWS, []);
      const awaiting$LWS = this._awaitingUpgrade.get(tagNameLowerCased$LWS);
      if (awaiting$LWS && awaiting$LWS.size) {
        triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS);
        // @TODO: Maybe this should only be done when there is something
        // awaiting upgrade?
        // `awaiting` is a safe Set.
        const needsConnectedCallback$LWS = awaiting$LWS.has(instance$LWS);
        // istanbul ignore else: currently unreachable via tests
        if (needsConnectedCallback$LWS && ReflectApply$LWS$1(NodeProtoIsConnectedGetter$LWS, instance$LWS, [])) {
          if (typeof connectedCallback$LWS === 'function') {
            ReflectApply$LWS$1(connectedCallback$LWS, instance$LWS, []);
          }
          awaiting$LWS.delete(instance$LWS);
          if (!awaiting$LWS.size) {
            this._awaitingUpgrade.delete(tagNameLowerCased$LWS);
          }
        }
      }
    }
  }
  /* eslint-enable no-underscore-dangle */
  function createDefinitionRecord$LWS(LocalCtor$LWS) {
    let attributeChangedCallback$LWS, formAssociatedCallback$LWS, formDisabledCallback$LWS, formResetCallback$LWS, formStateRestoreCallback$LWS;
    const {
      formAssociated: formAssociated$LWS = false,
      observedAttributes: observedAttributesIterable$LWS,
      prototype: LocalCtorProto$LWS
    } = LocalCtor$LWS;
    const {
      adoptedCallback: adoptedCallback$LWS,
      connectedCallback: connectedCallback$LWS,
      disconnectedCallback: disconnectedCallback$LWS
    } = LocalCtorProto$LWS;
    if (formAssociated$LWS) {
      ({
        formAssociatedCallback: formAssociatedCallback$LWS,
        formDisabledCallback: formDisabledCallback$LWS,
        formResetCallback: formResetCallback$LWS,
        formStateRestoreCallback: formStateRestoreCallback$LWS
      } = LocalCtorProto$LWS);
    }
    // Step 14 > Step 5 > Step 2
    // Convert the iterable into an array.
    // https://html.spec.whatwg.org/multipage/custom-elements.html#dom-customelementregistry-define
    let observedAttributes$LWS = observedAttributesIterable$LWS ? [...observedAttributesIterable$LWS] : undefined;
    if (observedAttributes$LWS && !observedAttributes$LWS.length) {
      observedAttributes$LWS = undefined;
    }
    if (observedAttributes$LWS) {
      ({
        attributeChangedCallback: attributeChangedCallback$LWS
      } = LocalCtorProto$LWS);
      if (typeof attributeChangedCallback$LWS !== 'function') {
        attributeChangedCallback$LWS = undefined;
        observedAttributes$LWS = undefined;
      }
    }
    return {
      LocalCtor: LocalCtor$LWS,
      PivotCtor: undefined,
      formAssociated: formAssociated$LWS,
      observedAttributes: observedAttributes$LWS,
      // The set variation of the observedAttributes array used for faster lookups.
      observedAttributesAsSet: observedAttributes$LWS ? toSafeSet$LWS(new SetCtor$LWS$1(observedAttributes$LWS)) : undefined,
      adoptedCallback: typeof adoptedCallback$LWS === 'function' ? adoptedCallback$LWS : undefined,
      attributeChangedCallback: attributeChangedCallback$LWS,
      connectedCallback: typeof connectedCallback$LWS === 'function' ? connectedCallback$LWS : undefined,
      disconnectedCallback: typeof disconnectedCallback$LWS === 'function' ? disconnectedCallback$LWS : undefined,
      formAssociatedCallback: typeof formAssociatedCallback$LWS === 'function' ? formAssociatedCallback$LWS : undefined,
      formDisabledCallback: typeof formDisabledCallback$LWS === 'function' ? formDisabledCallback$LWS : undefined,
      formResetCallback: typeof formResetCallback$LWS === 'function' ? formResetCallback$LWS : undefined,
      formStateRestoreCallback: typeof formStateRestoreCallback$LWS === 'function' ? formStateRestoreCallback$LWS : undefined
    };
  }
  const instanceRegistryMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  // Helper to create stand-in element for each tagName registered that delegates
  // out to the registry for the given element.
  function createPivotingClass$LWS(document$LWS, originalHTMLElementCtor$LWS,
  // This is the definition based on the LocalCtor the user code provided to
  // `customElements.define(tagName, definition)`.
  originalDefinition$LWS, tagName$LWS) {
    var _a$LWS;
    return _a$LWS = class PivotCtor$LWS extends originalHTMLElementCtor$LWS {
      constructor(localRegistry$LWS, definition$LWS) {
        // This constructor can only be invoked by:
        // a) The browser instantiating  an element from parsing or via
        //    `document.createElement()`.
        // b) A `new LocalCtor()` call from the blue realm (system mode).
        // c) A `new LocalCtor()` call from the red realm (sandbox).
        super();
        let instanceRegistry$LWS;
        if (localRegistry$LWS && definition$LWS) {
          instanceRegistry$LWS = localRegistry$LWS;
          localRegistry$LWS.setDefinition(this, definition$LWS);
        } else {
          instanceRegistry$LWS =
          // Usually `el.innerHTML` or any other parsing driven
          // initialization.
          getNodeRegistry$LWS(document$LWS, this) ||
          // Usually `document.createElement()`,
          // or any DOM API that has been patched to call
          // `setCustomElementsRegistry(globalObject, key)`
          // prior to element creation.
          getCurrentRegistry$LWS() ||
          // Global stuff.
          getGlobalCustomElementRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS);
          instanceRegistry$LWS.scheduleOrUpgrade(this, tagName$LWS, originalDefinition$LWS);
        }
        instanceRegistryMap$LWS.set(this, instanceRegistry$LWS);
      }
      adoptedCallback() {
        const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
        const adoptedCallback$LWS = definition$LWS && definition$LWS.adoptedCallback;
        // istanbul ignore else: currently unreachable via tests
        if (adoptedCallback$LWS) {
          ReflectApply$LWS$1(adoptedCallback$LWS, this, []);
        }
      }
      attributeChangedCallback(attrName$LWS, oldValue$LWS, newValue$LWS) {
        const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
        const attributeChangedCallback$LWS = definition$LWS && definition$LWS.attributeChangedCallback;
        if (attributeChangedCallback$LWS && (
        // If both definitions are the same, then the observedAttributes
        // is the same, but if they are different and only if the
        // runtime definition has the attribute marked as observed,
        // then it should invoke attributeChangedCallback.
        originalDefinition$LWS === definition$LWS || definition$LWS.observedAttributesAsSet.has(attrName$LWS))) {
          ReflectApply$LWS$1(attributeChangedCallback$LWS, this, [attrName$LWS, oldValue$LWS, newValue$LWS]);
        }
      }
      connectedCallback() {
        const instanceRegistry$LWS = instanceRegistryMap$LWS.get(this);
        const definition$LWS = instanceRegistry$LWS.getDefinition(this);
        if (definition$LWS) {
          const {
            connectedCallback: connectedCallback$LWS
          } = definition$LWS;
          if (connectedCallback$LWS) {
            ReflectApply$LWS$1(connectedCallback$LWS, this, []);
          }
        } else {
          instanceRegistry$LWS.scheduleConnectedCallback(this, tagName$LWS);
        }
      }
      disconnectedCallback() {
        const instanceRegistry$LWS = instanceRegistryMap$LWS.get(this);
        const definition$LWS = instanceRegistry$LWS.getDefinition(this);
        if (definition$LWS) {
          const {
            disconnectedCallback: disconnectedCallback$LWS
          } = definition$LWS;
          if (disconnectedCallback$LWS) {
            ReflectApply$LWS$1(disconnectedCallback$LWS, this, []);
          }
        } else {
          instanceRegistry$LWS.scheduleDisconnectedCallback(this, tagName$LWS);
        }
      }
      formAssociatedCallback(form$LWS) {
        const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
        const formAssociatedCallback$LWS = definition$LWS && definition$LWS.formAssociatedCallback;
        if (formAssociatedCallback$LWS) {
          ReflectApply$LWS$1(formAssociatedCallback$LWS, this, [form$LWS]);
        }
      }
      formDisabledCallback(disabled$LWS) {
        const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
        const formDisabledCallback$LWS = definition$LWS && definition$LWS.formDisabledCallback;
        if (formDisabledCallback$LWS) {
          ReflectApply$LWS$1(formDisabledCallback$LWS, this, [disabled$LWS]);
        }
      }
      formResetCallback() {
        const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
        const formResetCallback$LWS = definition$LWS && definition$LWS.formResetCallback;
        if (formResetCallback$LWS) {
          ReflectApply$LWS$1(formResetCallback$LWS, this, []);
        }
      }
      // istanbul ignore next: currently unreachable via tests because the browser mechanics that would result in its execution cannot be simulated or reproduced.
      formStateRestoreCallback(state$LWS, reason$LWS) {
        const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
        const formStateRestoreCallback$LWS = definition$LWS && definition$LWS.formStateRestoreCallback;
        if (formStateRestoreCallback$LWS) {
          ReflectApply$LWS$1(formStateRestoreCallback$LWS, this, [state$LWS, reason$LWS]);
        }
      }
    },
    // This ensures that the first-come definition for the given tagName gets
    // to define the formAssociated-ness of the tag. In the likely case
    // that formAssociated is not explicitly defined, coerce the "undefined"
    // value to a boolean to ensure we get a true or false.
    _a$LWS.formAssociated = Boolean(originalDefinition$LWS.formAssociated), _a$LWS.observedAttributes = originalDefinition$LWS.observedAttributes ? shallowCloneArray$LWS(originalDefinition$LWS.observedAttributes) : [], _a$LWS;
  }
  function getCurrentRegistry$LWS() {
    const registry$LWS = currentRegistry$LWS;
    currentRegistry$LWS = undefined;
    return registry$LWS;
  }
  function getDefinitionForCtor$LWS(LocalCtor$LWS) {
    const proto$LWS = typeof LocalCtor$LWS === 'function' ? LocalCtor$LWS.prototype : undefined;
    if (!isObject$LWS$1(proto$LWS)) {
      throw new TypeErrorCtor$LWS$1('Invalid custom element constructor.');
    }
    let definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
    // istanbul ignore else: getDefinitionForCtor is only called after a this._definedCtors.has(LocalCtor) check, which would throw if LocalCtor already existed. this._definedCtors & definitionCache are updated at the same time.
    if (definition$LWS === undefined) {
      definition$LWS = createDefinitionRecord$LWS(LocalCtor$LWS);
      definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
    }
    // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
    return definition$LWS;
  }
  function getGlobalCustomElementRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS) {
    let registry$LWS = globalRegistryCache$LWS.get(document$LWS);
    if (registry$LWS) {
      return registry$LWS;
    }
    registry$LWS = new VirtualRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS);
    globalRegistryCache$LWS.set(document$LWS, registry$LWS);
    return registry$LWS;
  }
  function getNodeRegistry$LWS(document$LWS, node$LWS) {
    const key$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS]);
    if (key$LWS === null) {
      return undefined;
    }
    ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS]);
    const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, node$LWS, []);
    // istanbul ignore if: it's unclear how this could actually happen, if the node is coming from parsed/sanitized html.
    if (ownerDoc$LWS !== document$LWS) {
      // This is an extra restriction when the node is coming from a different
      // document. @TODO: We're sure how they can achieve this, but just being
      // defensive.
      return undefined;
    }
    const registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
    return registries$LWS ? registries$LWS.get(key$LWS) : /* istanbul ignore next: currently unreachable via tests */undefined;
  }
  function getObservedAttributesDifference$LWS(originalDefinition$LWS, definition$LWS) {
    // Natively, the attributes observed by the original definition are going to
    // be taken care of by the browser, only the difference between the two sets
    // has to be taken care by the patched version.
    const {
      observedAttributes: observedAttributes$LWS
    } = definition$LWS;
    // istanbul ignore if: this is a safety precaution that is unreachable via tests
    if (originalDefinition$LWS === definition$LWS || observedAttributes$LWS === undefined) {
      return undefined;
    }
    const {
      observedAttributesAsSet: originalObservedAttributesAsSet$LWS
    } = originalDefinition$LWS;
    if (originalObservedAttributesAsSet$LWS === undefined) {
      return toSafeSet$LWS(new SetCtor$LWS$1(observedAttributes$LWS));
    }
    const difference$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
    for (let i$LWS = 0, {
        length: length$LWS
      } = observedAttributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const attrName$LWS = observedAttributes$LWS[i$LWS];
      if (!originalObservedAttributesAsSet$LWS.has(attrName$LWS)) {
        difference$LWS.add(attrName$LWS);
      }
    }
    return difference$LWS;
  }
  // Patches removeAttribute, setAttribute, toggleAttribute to ensure correctness
  // of attributeChangedCallback when more than one definition is registered for a
  // given tag name. There can be only one tag name + definition per sandbox, but
  // multiple sandboxes may define custom elements with the same tag name. Since
  // the first definition locks up the observedAttributes with its list, all
  // following definitions must have their instances patched to correctly fire
  // attributeChangedCallback on attributes that are listed in those subsequent
  // custom elements observedAttributes.
  function patchAttributes$LWS(instance$LWS, originalDefinition$LWS, definition$LWS) {
    const {
      attributeChangedCallback: attributeChangedCallback$LWS
    } = definition$LWS;
    // istanbul ignore if: there is no way to test that nothing happens when this condition is met
    if (attributeChangedCallback$LWS === undefined) {
      return;
    }
    const observedAttributesDifference$LWS = getObservedAttributesDifference$LWS(originalDefinition$LWS, definition$LWS);
    // If there are no unique attributes to observe, then there is no need to
    // patch removeAttribute, setAttribute and toggleAttribute
    // istanbul ignore if: there is no way to test that nothing happens when this condition is met
    if (observedAttributesDifference$LWS === undefined) {
      return;
    }
    instance$LWS.removeAttribute = maskFunction$LWS(function removeAttribute$LWS(attrName$LWS) {
      const args$LWS = [attrName$LWS];
      // `observedAttributesDifference` is a safe Set.
      if (observedAttributesDifference$LWS.has(attrName$LWS)) {
        const old$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS);
        ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, this, args$LWS);
        args$LWS[1] = old$LWS;
        args$LWS[2] = null;
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
      } else {
        ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, this, args$LWS);
      }
    }, ElementProtoRemoveAttribute$LWS);
    instance$LWS.setAttribute = maskFunction$LWS(function setAttribute$LWS(attrName$LWS, value$LWS) {
      const args$LWS = [attrName$LWS];
      const stringifiedValue$LWS = toString$LWS(value$LWS);
      const setAttributeArgs$LWS = [attrName$LWS, stringifiedValue$LWS];
      // `observedAttributesDifference` is a safe Set.
      if (observedAttributesDifference$LWS.has(attrName$LWS)) {
        const old$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS);
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, this, setAttributeArgs$LWS);
        args$LWS[1] = old$LWS;
        args$LWS[2] = stringifiedValue$LWS;
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
      } else {
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, this, setAttributeArgs$LWS);
      }
    }, ElementProtoSetAttribute$LWS$1);
    instance$LWS.toggleAttribute = maskFunction$LWS(function toggleAttribute$LWS(attrName$LWS) {
      const args$LWS = [attrName$LWS];
      let returnValue$LWS;
      // `observedAttributesDifference` is a safe Set.
      if (observedAttributesDifference$LWS.has(attrName$LWS)) {
        const hasAttribute$LWS = ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, this, args$LWS);
        const old$LWS = hasAttribute$LWS ? ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS) : null;
        returnValue$LWS = ReflectApply$LWS$1(ElementProtoToggleAttribute$LWS, this, args$LWS);
        args$LWS[1] = old$LWS;
        if (hasAttribute$LWS) {
          args$LWS[2] = null;
        }
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
      } else {
        returnValue$LWS = ReflectApply$LWS$1(ElementProtoToggleAttribute$LWS, this, args$LWS);
      }
      return returnValue$LWS;
    }, ElementProtoToggleAttribute$LWS);
    // `observedAttributesDifference` is a safe Set.
    for (const originalAttrName$LWS of observedAttributesDifference$LWS) {
      // Here we're ensuring support for attributes which have very explicit
      // names that differ from their property name:
      //
      // "accesskey" -> "accessKey"
      // "contenteditable" -> "contentEditable"
      // "tabindex" -> "tabIndex"
      //
      // As well as all of the aria-* properties
      //
      const attrPropName$LWS = HTMLElementGlobalAttributesToPropertyName$LWS[originalAttrName$LWS] || ElementAriaAttributesToPropertyName$LWS[originalAttrName$LWS] || originalAttrName$LWS;
      if (attrPropName$LWS in instance$LWS) {
        ReflectDefineProperty$LWS$1(instance$LWS, attrPropName$LWS, {
          __proto__: null,
          enumerable: true,
          configurable: true,
          get() {
            return ReflectGet$LWS(ReflectGetPrototypeOf$LWS$1(this), attrPropName$LWS, this);
          },
          set(value$LWS) {
            // This is necessary for both comparing the old attribute
            // value to the new attribute value and then for use in the
            // arguments that are passed to attributeChangedCallback.
            const oldValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, [originalAttrName$LWS]);
            // Because property assignment to special built-in setters
            // may have "magic" behavior to determine the actual value
            // that gets set, we need to invoke the original setter,
            // then get the new attribute value for comparison.
            // If _that_ value is different from the old value, then we
            // trigger the attributeChangedCallback
            // ReflectApply(originalSetter, this, [value]);
            ReflectSet$LWS(ReflectGetPrototypeOf$LWS$1(this), attrPropName$LWS, value$LWS, this);
            const newValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, [originalAttrName$LWS]);
            if (oldValue$LWS !== newValue$LWS) {
              ReflectApply$LWS$1(attributeChangedCallback$LWS, this, [originalAttrName$LWS, oldValue$LWS, newValue$LWS]);
            }
          }
        });
      }
    }
  }
  function patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS) {
    const {
      CustomElementRegistry: {
        prototype: globalCustomElementRegistryProto$LWS
      },
      customElements: customElements$LWS
    } = globalObject$LWS;
    const {
      define: originalDefine$LWS,
      get: originalGet$LWS,
      upgrade: originalUpgrade$LWS,
      whenDefined: originalWhenDefined$LWS
    } = globalCustomElementRegistryProto$LWS;
    globalCustomElementRegistryProto$LWS.define = maskFunction$LWS(function define$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because
        // in native this is normally a runtime error when
        // attempting to define a class that setDefinition from a
        // constructor from another window. But right now, we
        // don't know how to do this runtime check, the safe bet
        // is to throw here.
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyDefine(this, args$LWS);
    }, originalDefine$LWS, createUnmaskableTraps$LWS(originalDefine$LWS));
    globalCustomElementRegistryProto$LWS.get = maskFunction$LWS(function get$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because
        // in native this is going to leak constructors from
        // another windows. But right now, we don't know the
        // implications yet, the safe bet is to throw here.
        // @TODO: This could leak pivots from another document,
        // that's the concern.
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyGet(this, args$LWS);
    }, originalGet$LWS, createUnmaskableTraps$LWS(originalGet$LWS));
    globalCustomElementRegistryProto$LWS.upgrade = maskFunction$LWS(function upgrade$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because
        // in native this is going to leak constructors from
        // another windows. But right now, we don't know the
        // implications yet, the safe bet is to throw here.
        // @TODO: This could leak pivots from another document,
        // that's the concern.
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      registry$LWS.applyUpgrade(this, args$LWS);
    }, originalUpgrade$LWS, createUnmaskableTraps$LWS(originalUpgrade$LWS));
    globalCustomElementRegistryProto$LWS.whenDefined = maskFunction$LWS(function whenDefined$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in native
        // this is going to leak constructors from another windows when
        // defined. But right now, we don't know the implications yet, the
        // safe bet is to throw here.
        // @TODO: Maybe returning a promise that never fulfills is better.
        return PromiseReject$LWS(new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS));
      }
      return registry$LWS.applyWhenDefined(this, args$LWS);
    }, originalWhenDefined$LWS, createUnmaskableTraps$LWS(originalWhenDefined$LWS));
  }
  function patchHTMLElement$LWS(globalObject$LWS, registry$LWS) {
    const {
      HTMLElement: originalHTMLElementCtor$LWS
    } = globalObject$LWS;
    globalObject$LWS.HTMLElement = maskFunction$LWS(function HTMLElement$LWS() {
      if (new.target === undefined) {
        throw new TypeErrorCtor$LWS$1(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
      }
      if (new.target === HTMLElement$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
      }
      return registry$LWS.newCtor(this, new.target, originalHTMLElementCtor$LWS);
    }, originalHTMLElementCtor$LWS, createUnmaskableTraps$LWS(originalHTMLElementCtor$LWS));
  }
  function triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS) {
    // The below case patches observed attributes for the case where the HTML
    // element is upgraded from a pre-existing one in the DOM.
    const {
      attributeChangedCallback: attributeChangedCallback$LWS
    } = originalDefinition$LWS;
    // istanbul ignore if: current tests have no way of expressing a state that would cause this condition to evaluate true
    if (attributeChangedCallback$LWS === undefined) {
      return;
    }
    // Approximate observedAttributes from the user class, but only for the
    // new observed attributes.
    const {
      observedAttributes: observedAttributes$LWS
    } = originalDefinition$LWS;
    for (let i$LWS = 0, {
        length: length$LWS
      } = observedAttributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const attrName$LWS = observedAttributes$LWS[i$LWS];
      if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, instance$LWS, [attrName$LWS])) {
        const newValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, instance$LWS, [attrName$LWS]);
        ReflectApply$LWS$1(attributeChangedCallback$LWS, instance$LWS, [attrName$LWS, null, newValue$LWS]);
      }
    }
  }
  function getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS) {
    let registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
    if (registries$LWS === undefined) {
      registries$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
      sandboxRegistryCache$LWS.set(document$LWS, registries$LWS);
    }
    let registry$LWS = registries$LWS.get(key$LWS);
    if (registry$LWS) {
      return registry$LWS;
    }
    registry$LWS = new VirtualRegistry$LWS(document$LWS);
    registries$LWS.set(key$LWS, registry$LWS);
    return registry$LWS;
  }
  function patchGlobalObject$LWS(globalObject$LWS, /* istanbul ignore next: function is never called without a document */
  document$LWS = globalObject$LWS.document) {
    const {
      HTMLElement: HTMLElementCtor$LWS
    } = globalObject$LWS;
    const isHTMLElementCtorPatched$LWS = isMaskedFunction$LWS(HTMLElementCtor$LWS);
    const isCustomElementRegistryPatched$LWS = isMaskedFunction$LWS(globalObject$LWS.CustomElementRegistry.prototype.get);
    const registry$LWS = !isHTMLElementCtorPatched$LWS || !isCustomElementRegistryPatched$LWS ? getGlobalCustomElementRegistry$LWS(document$LWS, getUnmaskedFunction$LWS(HTMLElementCtor$LWS)) : undefined;
    if (!isHTMLElementCtorPatched$LWS) {
      patchHTMLElement$LWS(globalObject$LWS, registry$LWS);
    }
    if (!isCustomElementRegistryPatched$LWS) {
      patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS);
    }
  }
  // This function is to be used by other distortions to prepare this library
  // before creating a custom element using a native mechanism, so the key is in
  // place for the internal registry.
  function setCustomElementsRegistry$LWS(document$LWS, key$LWS) {
    currentRegistry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
  }
  const attributeDistortionFactoriesCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const sandboxAttributeDistortionRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function finalizeAttributeDistortions$LWS(record$LWS) {
    const attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
    // istanbul ignore if: currently unreachable via tests
    if (attributeFactories$LWS === undefined) {
      return;
    }
    attributeDistortionFactoriesCache$LWS.delete(record$LWS);
    const {
      document: document$LWS,
      key: key$LWS
    } = record$LWS;
    let sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
    if (sandboxAttributeDistortionRegistry$LWS === undefined) {
      sandboxAttributeDistortionRegistry$LWS = {
        __proto__: null
      };
      sandboxAttributeDistortionRegistryCache$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
    }
    const attributeDistortionRegistry$LWS = {
      __proto__: null
    };
    sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
    for (let i$LWS = 0, {
        length: length$LWS
      } = attributeFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      attributeFactories$LWS[i$LWS](attributeDistortionRegistry$LWS);
    }
  }
  function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
    const {
      document: document$LWS,
      key: key$LWS
    } = record$LWS;
    const sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
    // istanbul ignore if: currently unreachable via tests
    if (sandboxAttributeDistortionRegistry$LWS === undefined) {
      return undefined;
    }
    const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS];
    // istanbul ignore if: currently unreachable via tests
    if (attributeDistortionRegistry$LWS === undefined) {
      return undefined;
    }
    const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attrName$LWS, [])];
    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      return undefined;
    }
    const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
    if (elementCtorMap$LWS === undefined) {
      return undefined;
    }
    const mapIterator$LWS = elementCtorMap$LWS.entries();
    for (const {
      0: Ctor$LWS,
      1: distortion$LWS
    } of mapIterator$LWS) {
      // Element can inherit from Ctor but Ctor may not be the first entry in
      // the proto chain thus element.prototype checks are not sufficient.
      if (element$LWS instanceof Ctor$LWS) {
        return distortion$LWS;
      }
    }
    return undefined;
  }
  // Utility for normalizing namespaces which default to HTML behavior.
  // script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
  // script.setAttribute('src', 'foo.js').
  function normalizeNamespace$LWS(ns$LWS) {
    return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
  }
  function registerAttributeDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
    let attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
    if (attributeFactories$LWS === undefined) {
      attributeFactories$LWS = [];
      attributeDistortionFactoriesCache$LWS.set(record$LWS, attributeFactories$LWS);
    }
    const loweredAttributeName$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attributeName$LWS, []);
    attributeFactories$LWS[attributeFactories$LWS.length] = attributeDistortionRegistry$LWS => {
      let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];
      if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
        elementCtorMapByAttributeNamespaceRegistry$LWS = {
          __proto__: null
        };
        attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
      }
      let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
      if (elementCtorMap$LWS === undefined) {
        elementCtorMap$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
        elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
      }
      elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
    };
  }
  function initDistortionAttrValueSetter$LWS({
    globalObject: {
      Attr: Attr$LWS
    }
  }) {
    const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');
    return function distortionAttrValueSetter$LWS(record$LWS) {
      return [originalAttrValueSetter$LWS, function value$LWS(val$LWS) {
        const ownerElement$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
        // istanbul ignore else: needs default platform behavior test
        if (ownerElement$LWS) {
          const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
          const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
          const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
          // istanbul ignore if: coverage missing, needs investigation
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, ownerElement$LWS, [val$LWS]);
            return;
          }
        }
        ReflectApply$LWS$1(originalAttrValueSetter$LWS, this, [val$LWS]);
      }];
    };
  }
  function initDistortionAuraUtilGlobalEval$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: globalObject$LWS
  }) {
    var _globalObject$aura$LWS;
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null || (_globalObject$aura$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$LWS.globalEval;
    // istanbul ignore else: external is the default sandbox type for coverage runs
    if (typeof originalGlobalEval$LWS !== 'function') {
      return noop$LWS$1;
    }
    // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only
    return function distortionAuraUtilGlobalEval$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
      return [originalGlobalEval$LWS, function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
        let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;
        if (typeof descriptor$LWS === 'string') {
          const split$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, descriptor$LWS, ['://']);
          const {
            length: length$LWS
          } = split$LWS;
          const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
          wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, ['.', '/'])}` : `/components/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, [':', '/'])}.js`);
        }
        return sandboxEvaluator$LWS(transformSourceText$LWS(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCacheStorageDelete$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy$LWS;
    // Chrome and Safari will only expose CacheStorage over HTTPS.
    const originalDelete$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;
    if (typeof originalDelete$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCacheStorageDelete$LWS({
      key: key$LWS
    }) {
      return [originalDelete$LWS, function patchedDelete$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: cacheName$LWS
          } = args$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCacheStorageHas$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy2$LWS;
    // Chrome and Safari will only expose CacheStorage over HTTPS.
    const originalHas$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;
    if (typeof originalHas$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCacheStorageHas$LWS({
      key: key$LWS
    }) {
      return [originalHas$LWS, function has$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: cacheName$LWS
          } = args$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return ReflectApply$LWS$1(originalHas$LWS, this, args$LWS);
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCacheStorageKeys$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy3$LWS;
    // Chrome and Safari will only expose CacheStorage over HTTPS.
    const originalKeys$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;
    if (typeof originalKeys$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCacheStorageKeys$LWS({
      key: key$LWS
    }) {
      return [originalKeys$LWS, function keys$LWS() {
        const keysResultPromise$LWS = ReflectApply$LWS$1(originalKeys$LWS, this, []);
        return ReflectApply$LWS$1(PromiseProtoThen$LWS, keysResultPromise$LWS, [result$LWS => {
          const sandboxedCacheNames$LWS = [];
          for (let i$LWS = 0, j$LWS = 0, {
              length: length$LWS
            } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
            const cacheName$LWS = result$LWS[i$LWS];
            if (startsWithNamespaceMarker$LWS(cacheName$LWS, key$LWS)) {
              sandboxedCacheNames$LWS[j$LWS++] = removeNamespaceMarker$LWS(cacheName$LWS, key$LWS);
            }
          }
          return sandboxedCacheNames$LWS;
        }]);
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCacheStorageMatch$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy4$LWS;
    // Chrome and Safari will only expose CacheStorage over HTTPS.
    const originalMatch$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;
    if (typeof originalMatch$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCacheStorageMatch$LWS({
      key: key$LWS
    }) {
      return [originalMatch$LWS, function match$LWS(...args$LWS) {
        const {
          length: length$LWS
        } = args$LWS;
        // Let the native method handle missing parameters.
        if (!length$LWS) {
          return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
        }
        // Next we check `length` is at least 2, which means options are present.
        const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined;
        // In order to enforce the sandbox partition, we must REQUIRE the
        // `options.cacheName` value. The value of `options.cacheName` must
        // also be safely convertible to a string.
        if (isObjectLike$LWS(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
          const {
            cacheName: cacheName$LWS
          } = matchOptions$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            const clonedOptions$LWS = shallowCloneOptions$LWS(matchOptions$LWS);
            clonedOptions$LWS.cacheName = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
            args$LWS[1] = clonedOptions$LWS;
            return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
          }
        }
        return PromiseReject$LWS(new LockerSecurityError$LWS("caches.match() expects 'options.cacheName' to be present."));
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCacheStorageOpen$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy5$LWS;
    // Chrome and Safari will only expose CacheStorage over HTTPS.
    const originalOpen$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;
    if (typeof originalOpen$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCacheStorageOpen$LWS({
      key: key$LWS
    }) {
      return [originalOpen$LWS, function open$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: cacheName$LWS
          } = args$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
      }];
    };
  }
  const COOKIE_DELIMITER$LWS = '; ';
  /* istanbul ignore next: only available in secure context */
  function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, namespace$LWS) {
    if (isObjectLike$LWS(detailsOrName$LWS)) {
      const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
      clonedDetails$LWS.name = prependNamespaceMarker$LWS(clonedDetails$LWS.name, namespace$LWS);
      return clonedDetails$LWS;
    }
    return prependNamespaceMarker$LWS(detailsOrName$LWS, namespace$LWS);
  }
  function unprefixCookie$LWS(cookieEntry$LWS, namespace$LWS) {
    // First check that this cookie belongs to this sandbox,
    // if not then return `null`.
    if (!startsWithNamespaceMarker$LWS(cookieEntry$LWS, namespace$LWS)) {
      return null;
    }
    // If this cookie belongs to this sandbox, remove the marker.
    const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
    const {
      length: markerLength$LWS
    } = marker$LWS;
    const pos$LWS = cookieEntry$LWS.length > markerLength$LWS && cookieEntry$LWS[markerLength$LWS] === '=' ? markerLength$LWS + 1 : markerLength$LWS;
    return ReflectApply$LWS$1(StringProtoSlice$LWS$1, cookieEntry$LWS, [pos$LWS]);
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCookieStoreDelete$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp$LWS;
    const originalDelete$LWS = CookieStore$LWS == null || (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;
    if (typeof originalDelete$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCookieStoreDelete$LWS({
      key: key$LWS
    }) {
      return [originalDelete$LWS, function deleteValue$LWS(...args$LWS) {
        const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
          args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
        }
        return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCookieStoreGet$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp2$LWS;
    const originalGet$LWS = CookieStore$LWS == null || (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;
    if (typeof originalGet$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCookieStoreGet$LWS({
      key: key$LWS
    }) {
      return [originalGet$LWS, function get$LWS(...args$LWS) {
        const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
          args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
        }
        const getResultPromise$LWS = ReflectApply$LWS$1(originalGet$LWS, this, args$LWS);
        return ReflectApply$LWS$1(PromiseProtoThen$LWS, getResultPromise$LWS, [cookieListItem$LWS => {
          if (cookieListItem$LWS) {
            const {
              name: name$LWS
            } = cookieListItem$LWS;
            if (startsWithNamespaceMarker$LWS(name$LWS, key$LWS)) {
              cookieListItem$LWS.name = removeNamespaceMarker$LWS(name$LWS, key$LWS);
              return cookieListItem$LWS;
            }
          }
          return null;
        }]);
      }];
    };
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCookieStoreGetAll$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp3$LWS;
    const originalGetAll$LWS = CookieStore$LWS == null || (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;
    if (typeof originalGetAll$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCookieStoreGetAll$LWS({
      key: key$LWS
    }) {
      return [originalGetAll$LWS, function getAll$LWS(...args$LWS) {
        const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
          args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
        }
        const getAllResultPromise$LWS = ReflectApply$LWS$1(originalGetAll$LWS, this, args$LWS);
        return ReflectApply$LWS$1(PromiseProtoThen$LWS, getAllResultPromise$LWS, [result$LWS => {
          const sandboxedCookies$LWS = [];
          let sandboxedCookiesOffset$LWS = 0;
          for (let i$LWS = 0, {
              length: length$LWS
            } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
            const cookieListItem$LWS = result$LWS[i$LWS];
            if (cookieListItem$LWS) {
              const {
                name: name$LWS
              } = cookieListItem$LWS;
              if (startsWithNamespaceMarker$LWS(name$LWS, key$LWS)) {
                cookieListItem$LWS.name = removeNamespaceMarker$LWS(name$LWS, key$LWS);
                sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
              }
            }
          }
          return sandboxedCookies$LWS;
        }]);
      }];
    };
  }
  const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
    __proto__: null
  };
  function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
    const {
      key: key$LWS
    } = record$LWS;
    const {
      [key$LWS]: restrictedEventTargetRegistry$LWS
    } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
    if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
      return false;
    }
    return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
  }
  function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
    // istanbul ignore if: this is a safety precaution that is unreachable via tests
    if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
      return;
    }
    const {
      key: key$LWS
    } = record$LWS;
    const {
      [key$LWS]: restrictedEventTargetRegistry$LWS = {
        __proto__: null
      }
    } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
    const {
      [eventName$LWS]: restrictedEventTargetCtors$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1())
    } = restrictedEventTargetRegistry$LWS;
    restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
    restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
    restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
  }
  // This is for use with DOM-0 style "event handler" distortions, eg.
  // - window.onsecuritypolicyviolation
  // - window.onstorage
  function createEventHandlerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
    let exceptionMessage$LWS = `Cannot set '${eventName$LWS}' event handler`;
    const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(instanceOrProto$LWS.constructor, 'name');
    // istanbul ignore else: needs default platform behavior test
    if (safeDesc$LWS) {
      ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      const {
        value: name$LWS
      } = safeDesc$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (typeof name$LWS === 'string') {
        exceptionMessage$LWS += ` on ${name$LWS} object`;
      }
    }
    return `${exceptionMessage$LWS}.`;
  }
  // This is for use with DOM-2 style "event listener" distortions, eg.
  // - window.addEventListener('securitypolicyviolation', ...)
  // - window.addEventListener('storage', ...)
  function createEventListenerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
    let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;
    const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(instanceOrProto$LWS.constructor, 'name');
    // istanbul ignore else: needs default platform behavior test
    if (safeDesc$LWS) {
      ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      const {
        value: name$LWS
      } = safeDesc$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (typeof name$LWS === 'string') {
        exceptionMessage$LWS += ` to ${name$LWS} object`;
      }
    }
    return `${exceptionMessage$LWS}.`;
  }
  function createEventDistortionFactory$LWS(eventHandlerTarget$LWS, eventListenerTarget$LWS, eventName$LWS) {
    const onEventHandlerName$LWS = `on${eventName$LWS}`;
    const originalEventHandlerSetter$LWS = ObjectLookupOwnSetter$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
    // istanbul ignore if: currently unreachable via tests
    if (typeof originalEventHandlerSetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    const eventExceptionMessage$LWS = createEventHandlerExceptionMessage$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
    const distortionMapEntry$LWS = [originalEventHandlerSetter$LWS, function () {
      throw new LockerSecurityError$LWS(eventExceptionMessage$LWS);
    }];
    return function distortionEventHandler$LWS(record$LWS) {
      registerEventTargetRestriction$LWS(record$LWS, eventListenerTarget$LWS, eventName$LWS);
      return distortionMapEntry$LWS;
    };
  }
  function initDistortionCookieStoreOnChange$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    return createEventDistortionFactory$LWS( /* istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator */CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, CookieStore$LWS, 'change');
  }

  /* istanbul ignore next: only available in secure context */
  function initDistortionCookieStoreSet$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp4$LWS;
    const originalSet$LWS = CookieStore$LWS == null || (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;
    if (typeof originalSet$LWS !== 'function') {
      return noop$LWS$1;
    }
    return function distortionCookieStoreSet$LWS({
      key: key$LWS
    }) {
      return [originalSet$LWS, function set$LWS(...args$LWS) {
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS > 1) {
          args$LWS[0] = prependNamespaceMarker$LWS(args$LWS[0], key$LWS);
        } else if (length$LWS) {
          const {
            0: details$LWS
          } = args$LWS;
          if (isObjectLike$LWS(details$LWS)) {
            const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
            clonedDetails$LWS.name = prependNamespaceMarker$LWS(clonedDetails$LWS.name, key$LWS);
            args$LWS[0] = clonedDetails$LWS;
          }
        }
        return ReflectApply$LWS$1(originalSet$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionCSSStyleRuleStyleGetter$LWS({
    globalObject: {
      CSSStyleRule: CSSStyleRule$LWS
    }
  }) {
    const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(CSSStyleRule$LWS.prototype, 'style');
    const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
    }];
    return function distortionCSSStyleRuleStyleGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionCustomElementRegistryDefine$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr$LWS;
    // Next, we MUST use a reference to the now patched version of this API method,
    // or else we'll end up attempting to distort the wrong definition.
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    const originalCustomElementsDefine$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.define;
    return function distortionCustomElementRegistryDefine$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsDefine$LWS, function define$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          // This is more restricted than native behavior because in native
          // this is normally a runtime error when attempting to define a
          // class that inherit from a constructor from another window.
          // But right now, we don't know how to do this runtime check,
          // the safe bet is to throw here.
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
        }
        return registry$LWS.applyDefine(this, args$LWS);
      }];
    };
  }
  function initDistortionCustomElementRegistryGet$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr2$LWS;
    // Next, we MUST use a reference to the now patched version of this API method,
    // or else we'll end up attempting to distort the wrong definition.
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    const originalCustomElementsGet$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr2$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr2$LWS.get;
    return function distortionCustomElementRegistryGet$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsGet$LWS, function get$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          // This is more restricted than native behavior because in
          // native this is going to leak constructors from another
          // windows. But right now, we don't know the implications yet,
          // the safe bet is to throw here.
          // @TODO: this could leak pivots from another document,
          // that's the concern.
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
        }
        return registry$LWS.applyGet(this, args$LWS);
      }];
    };
  }
  function initDistortionCustomElementRegistryUpgrade$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr3$LWS;
    // Next, we MUST use a reference to the now patched version of this API method,
    // or else we'll end up attempting to distort the wrong definition.
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    const originalCustomElementsUpgrade$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr3$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr3$LWS.upgrade;
    return function distortionCustomElementRegistryUpgrade$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsUpgrade$LWS, function upgrade$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          // This is more restricted than native behavior because in native
          // this is normally a runtime error when attempting to upgrade a
          // class that inherit from a constructor from another window.
          // But right now, we don't know how to do this runtime check,
          // the safe bet is to throw here.
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
        }
        registry$LWS.applyUpgrade(this, args$LWS);
      }];
    };
  }
  function initDistortionCustomElementRegistryWhenDefined$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr4$LWS;
    // Next, we MUST use a reference to the now patched version of this API method,
    // or else we'll end up attempting to distort the wrong definition.
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    const originalCustomElementsWhenDefined$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr4$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr4$LWS.whenDefined;
    return function distortionCustomElementRegistryWhenDefined$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsWhenDefined$LWS, function whenDefined$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          // This is more restricted than native behavior because in
          // native this is going to leak constructors from another
          // windows when defined. But right now, we don't know the
          // implications yet, the safe bet is to throw here.
          // @TODO: Maybe returning a promise that never fulfills is
          // better.
          return PromiseReject$LWS(new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS));
        }
        return registry$LWS.applyWhenDefined(this, args$LWS);
      }];
    };
  }
  function initDistortionDocumentCookieGetter$LWS({
    globalObject: {
      Document: Document$LWS
    }
  }) {
    const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS$1(Document$LWS.prototype, 'cookie');
    return function distortionDocumentCookieGetter$LWS({
      key: key$LWS
    }) {
      return [originalCookieGetter$LWS, function get$LWS() {
        const documentCookieValue$LWS = ReflectApply$LWS$1(DocumentProtoCookieGetter$LWS, this, []);
        const cookies$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
        const sandboxedCookies$LWS = [];
        let sandboxedCookiesOffset$LWS = 0;
        for (let i$LWS = 0, {
            length: length$LWS
          } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);
          if (cookie$LWS) {
            sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
          }
        }
        return ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
      }];
    };
  }
  function initDistortionDocumentCookieSetter$LWS({
    globalObject: {
      Document: Document$LWS
    }
  }) {
    const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');
    return function distortionDocumentCookieSetter$LWS({
      key: key$LWS
    }) {
      return [originalCookieSetter$LWS, function set$LWS(value$LWS) {
        const cookieEntries$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [COOKIE_DELIMITER$LWS]);
        let {
          0: newCookieEntry$LWS
        } = cookieEntries$LWS;
        if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
          newCookieEntry$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS$1, newCookieEntry$LWS, [1]);
        }
        cookieEntries$LWS[0] = prependNamespaceMarker$LWS(newCookieEntry$LWS, key$LWS);
        const cookie$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
        ReflectApply$LWS$1(DocumentProtoCookieSetter$LWS, this, [cookie$LWS]);
      }];
    };
  }
  function initDistortionDocumentCreateElement$LWS({
    document: document$LWS,
    globalObject: {
      Document: {
        prototype: {
          createElement: originalDocumentCreateElement$LWS
        }
      }
    }
  }) {
    return function distortionDocumentCreateElement$LWS({
      key: key$LWS
    }) {
      return [originalDocumentCreateElement$LWS, function (...args$LWS) {
        const {
          0: tagName$LWS
        } = args$LWS;
        // Slow path for potential custom elements that might be registered
        // in the sandbox's virtual custom element registry.
        if (ReflectApply$LWS$1(StringProtoIncludes$LWS, tagName$LWS, ['-'])) {
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created will be
          // a custom element and it must be marked for association to
          // this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        }
        return ReflectApply$LWS$1(originalDocumentCreateElement$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionDocumentCreateElementNS$LWS({
    document: document$LWS,
    globalObject: {
      Document: {
        prototype: {
          createElementNS: originalDocumentCreateElementNS$LWS
        }
      }
    }
  }) {
    return function distortionDocumentCreateElementNS$LWS({
      key: key$LWS
    }) {
      return [originalDocumentCreateElementNS$LWS, function (...args$LWS) {
        const {
          1: tagName$LWS
        } = args$LWS;
        // Slow path for potential custom elements that might
        // be registered in the sandbox's virtual custom element registry.
        if (ReflectApply$LWS$1(StringProtoIncludes$LWS, tagName$LWS, ['-'])) {
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created will be
          // a custom element and it must be marked for association to
          // this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        }
        return ReflectApply$LWS$1(originalDocumentCreateElementNS$LWS, this, args$LWS);
      }];
    };
  }
  function domain$LWS() {
    throw new LockerSecurityError$LWS('Cannot set document.domain.');
  }
  function initDistortionDocumentDomainSetter$LWS({
    globalObject: {
      Document: Document$LWS
    }
  }) {
    const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');
    const distortionEntry$LWS = [originalDomainSetter$LWS, domain$LWS];
    return function distortionDocumentDomainSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$r$LWS
  } = rootValidator$LWS;
  function throwLockerSecurityError$LWS(command$LWS, target$LWS) {
    throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, target$LWS, [])}.`);
  }
  function initDistortionDocumentExecCommand$LWS({
    document: document$LWS,
    globalObject: {
      Document: {
        prototype: {
          execCommand: originalExecCommand$LWS
        }
      },
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS$1(Document.prototype, 'activeElement');
    const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'isContentEditable');
    return function distortionDocumentExecCommand$LWS({
      key: key$LWS,
      type: type$LWS
    }) {
      return [originalExecCommand$LWS, function execCommand$LWS(...args$LWS) {
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS >= 1) {
          const command$LWS = toString$LWS(args$LWS[0]);
          const loweredCommand$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, command$LWS, []);
          if (loweredCommand$LWS === 'selectall' && this === rootDocument$LWS) {
            throwLockerSecurityError$LWS(command$LWS, this);
          }
          if (length$LWS > 2) {
            const {
              2: unsanitizedValue$LWS
            } = args$LWS;
            // istanbul ignore else: needs default platform behavior test
            if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
              // istanbul ignore else: LWS does not test for all possible commands
              if (loweredCommand$LWS === 'inserthtml') {
                // istanbul ignore else: external is the default sandbox type for coverage runs
                if (type$LWS === 0 /* SandboxType.External */) {
                  const activeElement$LWS = ReflectApply$LWS$1(originalActiveElement$LWS, this, []);
                  if (isSharedElement$r$LWS(activeElement$LWS) && ReflectApply$LWS$1(originalIsContentEditable$LWS, activeElement$LWS, [])) {
                    throwLockerSecurityError$LWS(command$LWS, activeElement$LWS);
                  }
                }
                // This must be called to signal to the virtual
                // CustomElementRegistry that the next thing created
                // MAY CONTAIN a custom element, which must be marked
                // for association to this sandbox.
                setCustomElementsRegistry$LWS(document$LWS, key$LWS);
                args$LWS[0] = command$LWS;
                args$LWS[2] = lwsInternalPolicy$LWS.createHTML(unsanitizedValue$LWS, key$LWS, ContentType$LWS.HTML);
              }
            }
          }
        }
        return ReflectApply$LWS$1(originalExecCommand$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionDocumentOnsecuritypolicyviolation$LWS({
    globalObject: {
      Document: {
        prototype: DocumentProto$LWS
      },
      HTMLDocument: HTMLDocument$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(DocumentProto$LWS, HTMLDocument$LWS, 'securitypolicyviolation');
  }
  function initDistortionDocumentOpen$LWS({
    globalObject: {
      Document: {
        prototype: {
          open: originalDocumentOpen$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalDocumentOpen$LWS, function open$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // @ts-ignore: document.open() can be called with no arguments.
      if (this === rootDocument$LWS && length$LWS === 0) {
        throw new LockerSecurityError$LWS(`Cannot open top level document.`);
      }
      // istanbul ignore else: needs default platform behavior test
      if (length$LWS >= 3) {
        // Distort three-argument document.open calls which is an alias
        // for window.open
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
        const normalizedArgs$LWS = normalizeWindowOpenArguments$LWS(args$LWS);
        const childWindow$LWS = ReflectApply$LWS$1(originalDocumentOpen$LWS, this, normalizedArgs$LWS);
        if (childWindow$LWS) {
          initWindowOpenChildWindow$LWS(childWindow$LWS, normalizedArgs$LWS[0]);
        }
        return childWindow$LWS;
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalDocumentOpen$LWS, this, args$LWS);
    }];
    return function distortionDocumentOpen$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionDocumentReplaceChildren$LWS({
    globalObject: {
      Document: {
        prototype: {
          replaceChildren: originalReplaceChild$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChildren$LWS(...args$LWS) {
      if (this === rootDocument$LWS) {
        throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
    }];
    return function distortionDocumentReplaceChildren$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionDOMParserParseFromString$LWS({
    document: document$LWS,
    globalObject: {
      DOMParser: {
        prototype: {
          parseFromString: originalParseFromString$LWS
        }
      }
    }
  }) {
    return function distortionDOMParserParseFromString$LWS({
      key: key$LWS
    }) {
      return [originalParseFromString$LWS, function parseFromString$LWS(...args$LWS) {
        // DOMParser.prototype.parseFromString can only be called with
        // exactly two arguments. If it receives one argument, it will fail.
        // Some implementations will also fail if it receives more than two
        // arguments. Since any call that does not have at least two arguments
        // will fail no matter what, we only need to expend effort to sanitize
        // when we know that the operation is definitely NOT going to fail.
        if (args$LWS.length >= 2) {
          // Override the value of the first argument with a sanitized version
          // of that argument.
          const string$LWS = toString$LWS(args$LWS[0]);
          const mimeType$LWS = toString$LWS(args$LWS[1]);
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created
          // MAY CONTAIN a custom element, which must be marked for
          // association to this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          let contentType$LWS;
          switch (mimeType$LWS) {
            case 'application/xhtml+xml':
            case 'application/xml':
            case 'text/xml':
              contentType$LWS = ContentType$LWS.XML;
              break;
            case 'image/svg+xml':
              contentType$LWS = ContentType$LWS.SVG;
              break;
            default:
              contentType$LWS = ContentType$LWS.HTML;
          }
          args$LWS[0] = lwsInternalPolicy$LWS.createHTML(string$LWS, key$LWS, contentType$LWS);
        }
        return ReflectApply$LWS$1(originalParseFromString$LWS, this, args$LWS);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$q$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$6$LWS
  } = rootValidator$LWS;
  function initDistortionElementAfter$LWS({
    globalObject: {
      Element: {
        prototype: {
          after: originalAfter$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalAfter$LWS, function after$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$q$LWS(this)) {
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          if (!isAllowedSharedElementChild$6$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalAfter$LWS, this, args$LWS);
    }];
    return function distortionElementAfter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$p$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$5$LWS
  } = rootValidator$LWS;
  function initDistortionElementAppend$LWS({
    globalObject: {
      Element: {
        prototype: {
          append: originalAppend$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalAppend$LWS, function append$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$p$LWS(this)) {
        // Element.prototype.append(...args) accepts an arbitrary number
        // of arguments which can be comprised of Nodes and DOMStrings.
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          // ...If any of the provided arguments is NOT a valid shared
          // element child which is limited to script and link, an
          // exception is thrown.
          if (!isAllowedSharedElementChild$5$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalAppend$LWS, this, args$LWS);
    }];
    return function distortionElementAppend$LWS() {
      return distortionEntry$LWS;
    };
  }
  const elementShadowRootBySandboxKeyRegistry$LWS = {
    __proto__: null
  };
  function registerShadowRootInSandbox$LWS(sandboxKey$LWS, shadowRoot$LWS) {
    const {
      [sandboxKey$LWS]: elementShadowRootRegistry$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1())
    } = elementShadowRootBySandboxKeyRegistry$LWS;
    elementShadowRootRegistry$LWS.add(shadowRoot$LWS);
    if (!elementShadowRootBySandboxKeyRegistry$LWS[sandboxKey$LWS]) {
      elementShadowRootBySandboxKeyRegistry$LWS[sandboxKey$LWS] = elementShadowRootRegistry$LWS;
    }
  }
  function isShadowRootAccessibleInThisSandbox$LWS(sandboxKey$LWS, shadowRoot$LWS) {
    const elementShadowRootRegistry$LWS = elementShadowRootBySandboxKeyRegistry$LWS[sandboxKey$LWS];
    if (!elementShadowRootRegistry$LWS) {
      return false;
    }
    return elementShadowRootRegistry$LWS.has(shadowRoot$LWS);
  }
  function initDistortionElementAttachShadow$LWS({
    globalObject: {
      Element: {
        prototype: {
          attachShadow: originalAttachShadow$LWS
        }
      }
    }
  }) {
    return function distortionElementAttachShadow$LWS({
      key: key$LWS
    }) {
      return [originalAttachShadow$LWS, function attachShadow$LWS(...args$LWS) {
        const shadowRoot$LWS = ReflectApply$LWS$1(originalAttachShadow$LWS, this, args$LWS);
        registerShadowRootInSandbox$LWS(key$LWS, shadowRoot$LWS);
        return shadowRoot$LWS;
      }];
    };
  }
  const namedNodeMapToElementCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function pairElement$LWS(attrInstance$LWS, element$LWS) {
    namedNodeMapToElementCache$LWS.set(attrInstance$LWS, element$LWS);
  }
  function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
    const element$LWS = namedNodeMapToElementCache$LWS.get(nodeNameMap$LWS);
    // istanbul ignore else: nothing to do if there's no element
    if (element$LWS) {
      const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
      const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS);
      // istanbul ignore else: nothing to do if there's no distortion
      if (distortion$LWS) {
        const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
        return ReflectApply$LWS$1(distortion$LWS, element$LWS, [attrValue$LWS]);
      }
    }
    // istanbul ignore next: needs default platform behavior test
    return ReflectApply$LWS$1(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
  }
  function initDistortionElementAttributesGetter$LWS({
    globalObject: {
      Element: Element$LWS
    }
  }) {
    const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, 'attributes');
    const distortionEntry$LWS = [originalAttributesGetter$LWS, function attributes$LWS() {
      const attrs$LWS = ReflectApply$LWS$1(originalAttributesGetter$LWS, this, []);
      pairElement$LWS(attrs$LWS, this);
      return attrs$LWS;
    }];
    return function distortionElementAttributesGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$o$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$4$LWS
  } = rootValidator$LWS;
  function initDistortionElementBefore$LWS({
    globalObject: {
      Element: {
        prototype: {
          before: originalBefore$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalBefore$LWS, function before$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$o$LWS(this)) {
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          // istanbul ignore else: needs default platform behavior test
          if (!isAllowedSharedElementChild$4$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalBefore$LWS, this, args$LWS);
    }];
    return function distortionElementBefore$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionElementGetInnerHTML$LWS({
    globalObject: {
      Element: {
        prototype: {
          getInnerHTML: originalGetInnerHTML$LWS
        }
      }
    }
  }) {
    if (typeof originalGetInnerHTML$LWS !== 'function') {
      // istanbul ignore next: only runs in browsers without property
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalGetInnerHTML$LWS, function getInnerHTML$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: options$LWS
        } = args$LWS;
        if (isObjectLike$LWS(options$LWS)) {
          const clonedOptions$LWS = shallowCloneOptions$LWS(options$LWS);
          clonedOptions$LWS.includeShadowRoots = false;
          args$LWS[0] = clonedOptions$LWS;
        } else {
          // If there was an argument, but it wasn't "object like",
          // it is considered invalid, so override it.
          args$LWS[0] = {
            __proto__: null,
            includeShadowRoots: false
          };
        }
      } else {
        args$LWS[0] = {
          __proto__: null,
          includeShadowRoots: false
        };
      }
      return ReflectApply$LWS$1(originalGetInnerHTML$LWS, this, args$LWS);
    }];
    return function distortionElementGetInnerHTML$LWS() {
      return distortionEntry$LWS;
    };
  }
  function scriptPropertySetters$LWS(incomingThis$LWS, property$LWS, valueAsTrustedString$LWS, originalScriptPropertyGetter$LWS, originalScriptPropertySetter$LWS, distortions$LWS, sandboxEvaluator$LWS, signedScriptHookSourceText$LWS) {
    const valueAsString$LWS = toString$LWS(valueAsTrustedString$LWS);
    if (!isScriptPropertyEvaluatorHookDefined$LWS(incomingThis$LWS)) {
      const distortedScriptPropertyGetter$LWS = distortions$LWS.get(originalScriptPropertyGetter$LWS);
      defineScriptAccessorProperty$LWS(incomingThis$LWS, property$LWS, distortedScriptPropertyGetter$LWS, originalScriptPropertySetter$LWS);
    }
    setOriginalScriptScriptProperty$LWS(incomingThis$LWS, valueAsString$LWS);
    if (!isScriptEvaluated$LWS(incomingThis$LWS)) {
      // Skip script property evaluation if script URL is already
      // specified.
      if (!isScriptURLEvaluatorHookDefined$LWS(incomingThis$LWS)) {
        defineScriptEvaluatorProperty$LWS(incomingThis$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
          deleteOriginalScriptProperty$LWS(incomingThis$LWS);
          ReflectDeleteProperty$LWS$1(incomingThis$LWS, property$LWS);
          // Set the script property immediately
          // after the evaluator hook fires to overwrite
          // the evaluator hook source text.
          ReflectApply$LWS$1(originalScriptPropertySetter$LWS, incomingThis$LWS, [valueAsTrustedString$LWS]);
          sandboxEvaluator$LWS(transformSourceText$LWS(valueAsString$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
        });
        // Set the script property to the evaluator
        // hook which will run once the node is inserted
        // into a document. Subsequent changes to script
        // property are not evaluated.
        ReflectApply$LWS$1(originalScriptPropertySetter$LWS, incomingThis$LWS, [signedScriptHookSourceText$LWS]);
      }
      return true;
    }
    return false;
  }
  const {
    isSharedElement: isSharedElement$n$LWS
  } = rootValidator$LWS;
  function initDistortionElementInnerHTMLSetter$LWS({
    document: document$LWS,
    globalObject: {
      Element: Element$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      SVGElement: SVGElement$LWS,
      XMLDocument: XMLDocument$LWS
    },
    root: {
      distortions: distortions$LWS
    }
  }) {
    const {
      get: originalInnerHTMLGetter$LWS,
      set: originalInnerHTMLSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(Element$LWS.prototype, 'innerHTML');
    return function distortionElementInnerHTMLSetter$LWS({
      key: key$LWS,
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
        const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;
        if (!isOwnerXMLDocument$LWS) {
          // istanbul ignore else: needs default platform behavior test
          if (isSharedElement$n$LWS(this)) {
            throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
          if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement) {
            const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'innerHTML', trusted.createScript(value$LWS), originalInnerHTMLGetter$LWS, originalInnerHTMLSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
            if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
              return;
            }
          }
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created
          // MAY CONTAIN a custom element, which must be marked for
          // association to this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          const contentType$LWS = this instanceof SVGElement$LWS ? ContentType$LWS.SVG : ContentType$LWS.HTML;
          value$LWS = lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, contentType$LWS);
        }
        ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [value$LWS]);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$m$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$3$LWS
  } = rootValidator$LWS;
  function initDistortionElementInsertAdjacentElement$LWS({
    globalObject: {
      Element: {
        prototype: {
          insertAdjacentElement: originalInsertAdjacentElement$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalInsertAdjacentElement$LWS, function insertAdjacentElement$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length > 1) {
        const {
          1: element$LWS
        } = args$LWS;
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$m$LWS(this) && !isAllowedSharedElementChild$3$LWS(element$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot insert ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, element$LWS, [])} adjacent to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalInsertAdjacentElement$LWS, this, args$LWS);
    }];
    return function distortionElementInsertAdjacentElement$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$l$LWS
  } = rootValidator$LWS;
  const allowedElementHTMLRegExp$LWS = /^\s*<(link|script|style)/i;
  function initDistortionElementInsertAdjacentHTML$LWS({
    document: document$LWS,
    globalObject: {
      Element: {
        prototype: {
          insertAdjacentHTML: originalInsertAdjacentHTML$LWS
        }
      }
    }
  }) {
    return function distortionElementInsertAdjacentHTML$LWS({
      key: key$LWS
    }) {
      return [originalInsertAdjacentHTML$LWS, function insertAdjacentHTML$LWS(...args$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (args$LWS.length > 1) {
          const match$LWS = ReflectApply$LWS$1(StringProtoMatch$LWS, args$LWS[1], [allowedElementHTMLRegExp$LWS]);
          if (isSharedElement$l$LWS(this) && match$LWS === null) {
            throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}`);
          }
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created
          // MAY CONTAIN a custom element, which must be marked for
          // association to this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          const contentType$LWS = this instanceof SVGElement ? ContentType$LWS.SVG : ContentType$LWS.HTML;
          args$LWS[1] = lwsInternalPolicy$LWS.createHTML(args$LWS[1], key$LWS, contentType$LWS);
        }
        ReflectApply$LWS$1(originalInsertAdjacentHTML$LWS, this, args$LWS);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$k$LWS
  } = rootValidator$LWS;
  function initDistortionElementOuterHTMLSetter$LWS({
    document: document$LWS,
    globalObject: {
      Element: Element$LWS
    }
  }) {
    const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML');
    return function distortionElementOuterHTMLSetter$LWS({
      key: key$LWS
    }) {
      return [originalOuterHTMLSetter$LWS, function outerHTML$LWS(value$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$k$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        ReflectApply$LWS$1(originalOuterHTMLSetter$LWS, this, [lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, ContentType$LWS.HTML)]);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$j$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$2$LWS
  } = rootValidator$LWS;
  function initDistortionElementPrepend$LWS({
    globalObject: {
      Element: {
        prototype: {
          prepend: originalPrepend$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalPrepend$LWS, function prepend$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$j$LWS(this)) {
        // Element.prototype.prepend(...args) accepts an arbitrary
        // number of arguments which can be comprised of Nodes and
        // DOMStrings.
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          // ...If any of the provided arguments is NOT a valid shared
          // element child, which is limited to script and link, an
          // exception is thrown.
          if (!isAllowedSharedElementChild$2$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalPrepend$LWS, this, args$LWS);
    }];
    return function distortionElementPrepend$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$i$LWS
  } = rootValidator$LWS;
  function initDistortionElementRemove$LWS({
    globalObject: {
      Element: {
        prototype: {
          remove: originalRemove$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalRemove$LWS, function remove$LWS() {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$i$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      ReflectApply$LWS$1(originalRemove$LWS, this, []);
    }];
    return function distortionElementRemove$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$h$LWS
  } = rootValidator$LWS;
  function initDistortionElementReplaceChildren$LWS({
    globalObject: {
      Element: {
        prototype: {
          replaceChildren: originalReplaceChildren$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceChildren$LWS, function replaceChildren$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$h$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot replace children of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      return ReflectApply$LWS$1(originalReplaceChildren$LWS, this, args$LWS);
    }];
    return function distortionElementReplaceChildren$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$g$LWS
  } = rootValidator$LWS;
  function initDistortionElementReplaceWith$LWS({
    globalObject: {
      Element: {
        prototype: {
          replaceWith: originalReplaceWith$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceWith$LWS, function replaceWith$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$g$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      return ReflectApply$LWS$1(originalReplaceWith$LWS, this, args$LWS);
    }];
    return function distortionElementReplaceWith$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionElementSetAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttribute$LWS(record$LWS) {
      return [originalSetAttribute$LWS, function setAttribute$LWS(...args$LWS) {
        if (args$LWS.length > 1) {
          const attrName$LWS = normalizeNamespacedAttributeName$LWS(toString$LWS(args$LWS[0]));
          const attrValue$LWS = toString$LWS(args$LWS[1]);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
            return;
          }
          // Cannot use the normalized attrNameDistortionKey because
          // that value has been lowercased, which may cause issues
          // with case-sensitive attribute names such as SVG element's
          // "viewBox".
          args$LWS[0] = attrName$LWS;
          args$LWS[1] = attrValue$LWS;
        }
        ReflectApply$LWS$1(originalSetAttribute$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionElementSetAttributeNode$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Element: {
        prototype: {
          setAttributeNode: originalSetAttributeNode$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttributeNode$LWS(record$LWS) {
      return [originalSetAttributeNode$LWS, function setAttributeNode$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (!(attr$LWS instanceof Attr$LWS)) {
          // Handle non-Attr values using the native API.
          return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
        }
        // We can't set an attribute connected to another element.
        // Calling the original getter for property ownerElement
        // validates that we are dealing with an instance of Attr.
        // istanbul ignore if: needs default platform behavior test
        if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
          return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
        }
        const attrName$LWS = normalizeNamespacedAttributeName$LWS(ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []));
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
        if (distortion$LWS) {
          const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);
          if (oldAttr$LWS) {
            // Disconnect old attribute.
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
          }
          const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);
          if (newAttr$LWS) {
            // Remove distorted attribute.
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
          }
          if (oldAttr$LWS) {
            // Re-attach old attribute to maintain identify checks.
            ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
          }
          if (newAttr$LWS) {
            const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []);
            // Set the distorted attr value.
            ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]);
            // Replace old attr.
            return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [attr$LWS]);
          }
          return undefined;
        }
        return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionElementSetAttributeNodeNS$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Element: {
        prototype: {
          setAttributeNodeNS: originalSetAttributeNodeNS$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
      return [originalSetAttributeNodeNS$LWS, function setAttributeNodeNS$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (!(attr$LWS instanceof Attr$LWS)) {
          // Handle non-Attr values using the native API.
          return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
        }
        // We can't set an attribute connected to another element.
        // Calling the original getter for property ownerElement
        // validates that we are dealing with an instance of Attr.
        // istanbul ignore if: needs default platform behavior test
        if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
          return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
        }
        const attrName$LWS = normalizeNamespacedAttributeName$LWS(ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []));
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
        if (distortion$LWS) {
          const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);
          if (oldAttr$LWS) {
            // Disconnect the old attribute.
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
          }
          const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);
          if (newAttr$LWS) {
            // Remove the distorted attribute.
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
          }
          if (oldAttr$LWS) {
            // Re-attach old attribute to maintain identify checks.
            ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
          }
          if (newAttr$LWS) {
            const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []);
            // Set the distorted attr value.
            ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]);
            // Replace old attr.
            return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
          }
          return null;
        }
        return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }];
    };
  }
  function initDistortionElementSetAttributeNS$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttributeNS: originalSetAttributeNS$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttributeNS$LWS(record$LWS) {
      return [originalSetAttributeNS$LWS, function setAttributeNS$LWS(...args$LWS) {
        // istanbul ignore next: needs default platform behavior test
        if (args$LWS.length < 3) {
          ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
          return;
        }
        let {
          0: attrNamespace$LWS
        } = args$LWS;
        if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
          attrNamespace$LWS = toString$LWS(attrNamespace$LWS);
        }
        const attrName$LWS = normalizeNamespacedAttributeName$LWS(toString$LWS(args$LWS[1]));
        const attrValue$LWS = toString$LWS(args$LWS[2]);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          return;
        }
        // istanbul ignore next: needs default platform behavior test
        // eslint-disable-next-line no-lone-blocks
        {
          // This is in a block to avoid requiring an
          // "istanbul ignore next" for all for lines.
          // We could avoid this entirely by testing the default
          // platform behavior.
          args$LWS[0] = attrNamespace$LWS;
          // Cannot use the normalized attrNameDistortionKey because
          // that value has been lowercased, which may cause issues
          // with case-sensitive attribute names such as SVG element's
          // "viewBox".
          args$LWS[1] = attrName$LWS;
          args$LWS[2] = attrValue$LWS;
          ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
        }
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$f$LWS
  } = rootValidator$LWS;
  function initDistortionElementSetHTML$LWS({
    document: document$LWS,
    globalObject: {
      Element: {
        prototype: {
          setHTML: originalSetHTML$LWS
        }
      },
      SVGElement: SVGElement$LWS,
      XMLDocument: XMLDocument$LWS
    }
  }) {
    if (typeof originalSetHTML$LWS !== 'function') {
      // istanbul ignore next: only runs in browsers without property
      return noop$LWS$1;
    }
    // istanbul ignore next: Element.prototype.setHTML is not supported in any browser yet
    return function distortionElementSetHTML$LWS({
      key: key$LWS
    }) {
      return [originalSetHTML$LWS, function setHTML$LWS(...args$LWS) {
        const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;
        if (!isOwnerXMLDocument$LWS) {
          // istanbul ignore else: needs default platform behavior test
          if (isSharedElement$f$LWS(this)) {
            throw new LockerSecurityError$LWS(`Cannot setHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created
          // MAY CONTAIN a custom element, which must be marked for
          // association to this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          // If options not specified, the default Sanitizer object is used.
          // This will be in addition to the sanitization we have.
          const value$LWS = args$LWS[0];
          const contentType$LWS = this instanceof SVGElement$LWS ? ContentType$LWS.SVG : ContentType$LWS.HTML;
          args$LWS[0] = lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, contentType$LWS);
        }
        ReflectApply$LWS$1(originalSetHTML$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionElementShadowRootGetter$LWS({
    globalObject: {
      Element: Element$LWS
    }
  }) {
    const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, 'shadowRoot');
    return function distortionShadowRootGetter$LWS({
      key: key$LWS
    }) {
      return [originalShadowRootGetter$LWS, function shadowRoot$LWS() {
        const realShadowRoot$LWS = ReflectApply$LWS$1(originalShadowRootGetter$LWS, this, []);
        if (isShadowRootAccessibleInThisSandbox$LWS(key$LWS, realShadowRoot$LWS)) {
          return realShadowRoot$LWS;
        }
        return null;
      }];
    };
  }
  function initDistortionElementToggleAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          hasAttribute: ElementProtoHasAttribute$LWS,
          toggleAttribute: originalToggleAttribute$LWS
        }
      }
    }
  }) {
    return function distortionElementToggleAttribute$LWS(record$LWS) {
      return [originalToggleAttribute$LWS, function toggleAttribute$LWS(...args$LWS) {
        const {
          length: length$LWS
        } = args$LWS;
        // istanbul ignore else: needs default platform behavior test
        if (length$LWS > 0) {
          const attrName$LWS = toString$LWS(args$LWS[0]);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
          // istanbul ignore else: needs default platform behavior test
          if (distortion$LWS) {
            const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : [];
            // Calling the distortion may end this execution entirely,
            // if the distortion throws.
            ReflectApply$LWS$1(distortion$LWS, this, distortionArgs$LWS);
            // If the distortion does not throw, then we need to
            // return true | false, based on the presence or absence
            // of this attribute.
            return ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
          }
          // Cannot use the normalized attrNameDistortionKey because
          // that value has been lowercased, which may cause issues
          // with case-sensitive attribute names such as SVG element's
          // "viewBox".
          // istanbul ignore next: needs default platform behavior test
          args$LWS[0] = attrName$LWS;
        }
        // istanbul ignore next: needs default platform behavior test
        return ReflectApply$LWS$1(originalToggleAttribute$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionEval$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      eval: originalEval$LWS
    }
  }) {
    return function distortionEval$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalEval$LWS, sourceText$LWS => sandboxEvaluator$LWS(transformSourceText$LWS(toString$LWS(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS)];
    };
  }
  function createDistortedComposedPath$LWS(event$LWS, sandboxKey$LWS) {
    const currentTarget$LWS = ReflectApply$LWS$1(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
    const {
      composedPath: originalComposedPath$LWS
    } = Event.prototype;
    const rawComposedPath$LWS = ReflectApply$LWS$1(originalComposedPath$LWS, event$LWS, []);
    const currentTargetIndex$LWS = ReflectApply$LWS$1(ArrayProtoIndexOf$LWS$1, rawComposedPath$LWS, [currentTarget$LWS]);
    let distortedComposedPath$LWS = rawComposedPath$LWS;
    for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
      const objectThatMightBeAShadowRoot$LWS = rawComposedPath$LWS[i$LWS];
      if (objectThatMightBeAShadowRoot$LWS instanceof ShadowRoot &&
      // Only interfere if this sandbox is not allowed to access this shadowRoot
      !isShadowRootAccessibleInThisSandbox$LWS(sandboxKey$LWS, objectThatMightBeAShadowRoot$LWS)) {
        // If we reach an instance of ShadowRoot, we don't want
        // to include it in the returned path list. This matches
        // the behavior of mode: closed.
        distortedComposedPath$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, rawComposedPath$LWS, [i$LWS + 1]);
        break;
      }
    }
    return distortedComposedPath$LWS;
  }
  function initDistortionEventComposedPath$LWS({
    globalObject: {
      Event: {
        prototype: {
          composedPath: originalComposedPath$LWS
        }
      }
    }
  }) {
    return function distortionEventComposedPath$LWS({
      key: key$LWS
    }) {
      return [originalComposedPath$LWS, function composedPath$LWS() {
        return createDistortedComposedPath$LWS(this, key$LWS);
      }];
    };
  }
  function initDistortionEventPathGetter$LWS({
    globalObject: {
      Event: Event$LWS
    }
  }) {
    const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS$1(Event$LWS.prototype, 'path');
    // istanbul ignore else: currently unreachable via tests
    if (typeof originalPathGetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    // istanbul ignore next: currently unreachable via tests
    return function distortionEventPathGetter$LWS({
      key: key$LWS
    }) {
      return [originalPathGetter$LWS,
      // Chromium 109 removed Event.prototype.path
      // https://chromestatus.com/feature/5726124632965120
      // istanbul ignore next: currently unreachable via tests
      function path$LWS() {
        return createDistortedComposedPath$LWS(this, key$LWS);
      }];
    };
  }
  function initDistortionEventTargetAddEventListener$LWS({
    globalObject: {
      EventTarget: {
        prototype: {
          addEventListener: originalAddEventListener$LWS
        }
      }
    }
  }) {
    return function distortionEventTargetAddEventListener$LWS(record$LWS) {
      function addEventListener$LWS(...args$LWS) {
        const {
          length: length$LWS
        } = args$LWS;
        // Ensure that we fallback to the default platform behavior which
        // should fail if less than 2 arguments are provided.
        // istanbul ignore else: needs default platform behavior test
        if (length$LWS > 1) {
          const eventName$LWS = toString$LWS(args$LWS[0]);
          if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
            throw new LockerSecurityError$LWS(createEventListenerExceptionMessage$LWS(this, eventName$LWS));
          }
          args$LWS[0] = eventName$LWS;
        }
        return ReflectApply$LWS$1(originalAddEventListener$LWS, this, args$LWS);
      }
      return [originalAddEventListener$LWS, addEventListener$LWS];
    };
  }
  function initDistortionFunction$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      Function: originalFunction$LWS
    }
  }) {
    const funcFooterRegExp$LWS = /\n?}[^}]*$/;
    return function distortionFunction$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalFunction$LWS, function Function$LWS(...args$LWS) {
        // The `arguments` object has `Symbol.iterator` as an own
        // property, not inherited, so it avoids prototype pollution
        // attacks.
        const sandboxFuncCtor$LWS = sandboxEvaluator$LWS('(function() {return Function(...arguments)})');
        const {
          length: length$LWS
        } = args$LWS;
        if (!length$LWS) {
          return ReflectApply$LWS$1(sandboxFuncCtor$LWS, this, []);
        }
        const lastIndex$LWS = length$LWS - 1;
        const funcBody$LWS = toString$LWS(args$LWS[lastIndex$LWS]);
        // Validate parsing the function body.
        ReflectApply$LWS$1(sandboxFuncCtor$LWS, this, [funcBody$LWS]);
        // Make function body empty to create the wire-frame.
        args$LWS[lastIndex$LWS] = '';
        const wireFunc$LWS = ReflectApply$LWS$1(sandboxFuncCtor$LWS, this, args$LWS);
        const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(UNIVERSAL_CONTEXT_NAMES$LWS)};`;
        const header$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, `${wireFunc$LWS}`, [funcFooterRegExp$LWS, '']);
        const code$LWS = compileSourceText$LWS(funcBody$LWS);
        // NOTE: Function constructor and eval are controlled by the
        // same CSP rules, which means we can rely on eval to fulfill
        // the behavior of the Function constructor.
        return sandboxEvaluator$LWS(`${prefix$LWS}(${header$LWS}${code$LWS}\n})`, UNCOMPILED_CONTEXT$LWS);
      }];
    };
  }
  function initDistortionHistoryPushState$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      History: {
        prototype: {
          pushState: originalPushState$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalPushState$LWS, function pushState$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const state$LWS = args$LWS[0];
          if (isObject$LWS$1(state$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(state$LWS);
            return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionHistoryPushState$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHistoryReplaceState$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      History: {
        prototype: {
          replaceState: originalReplaceState$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceState$LWS, function replaceState$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const state$LWS = args$LWS[0];
          if (isObject$LWS$1(state$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(state$LWS);
            return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionHistoryReplaceState$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLBodyElementOnrejectionhandled$LWS({
    globalObject: {
      HTMLBodyElement: HTMLBodyElement$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'rejectionhandled');
  }
  function initDistortionHTMLBodyElementOnstorage$LWS({
    globalObject: {
      HTMLBodyElement: HTMLBodyElement$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'storage');
  }
  function initDistortionHTMLBodyElementOnunhandledrejection$LWS({
    globalObject: {
      HTMLBodyElement: HTMLBodyElement$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'unhandledrejection');
  }
  function initDistortionHTMLElementCtor$LWS({
    document: document$LWS,
    globalObject: {
      HTMLElement: originalHTMLElementCtor$LWS
    }
  }) {
    // We MUST use a reference to the now patched version of this API method,
    // or else we'll end up attempting to distort the wrong definition.
    return function distortionHTMLElementCtor$LWS({
      key: key$LWS
    }) {
      let registry$LWS;
      return [originalHTMLElementCtor$LWS, function HTMLElement$LWS() {
        if (new.target === undefined) {
          throw new TypeErrorCtor$LWS$1(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
        }
        if (new.target === HTMLElement$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
        }
        if (registry$LWS === undefined) {
          registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
        }
        return registry$LWS.newCtor(this, new.target, originalHTMLElementCtor$LWS);
      }];
    };
  }
  function initDistortionHTMLElementDatasetGetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'dataset');
    const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
    }];
    return function distortionHTMLElementDatasetGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$e$LWS
  } = rootValidator$LWS;
  function initDistortionHTMLElementInnerTextSetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText');
    // istanbul ignore if: currently unreachable via tests
    if (typeof originalInnerTextSetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalInnerTextSetter$LWS, function innerText$LWS(value$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$e$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set innerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      ReflectApply$LWS$1(originalInnerTextSetter$LWS, this, [value$LWS]);
    }];
    return function distortionHTMLElementInnerTextSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$d$LWS
  } = rootValidator$LWS;
  // The outerText property is non-standard, so the descriptor could be undefined,
  // like in the case of Firefox.
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility
  function initDistortionHTMLElementOuterTextSetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText');
    // istanbul ignore if: currently unreachable via tests
    if (typeof originalOuterTextSetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalOuterTextSetter$LWS, function outerText$LWS(value$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$d$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set outerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      ReflectApply$LWS$1(originalOuterTextSetter$LWS, this, [value$LWS]);
    }];
    return function distortionHTMLElementOuterTextSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLElementStyleGetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'style');
    const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
    }];
    return function distortionHTMLElementStyleGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLFrameSetElementOnrejectionhandled$LWS({
    globalObject: {
      HTMLFrameSetElement: HTMLFrameSetElement$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'rejectionhandled');
  }
  function initDistortionHTMLFrameSetElementOnstorage$LWS({
    globalObject: {
      HTMLFrameSetElement: HTMLFrameSetElement$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'storage');
  }
  function initDistortionHTMLFrameSetElementOnunhandledrejection$LWS({
    globalObject: {
      HTMLFrameSetElement: HTMLFrameSetElement$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'unhandledrejection');
  }
  function initDistortionIFrameElementContentDocumentGetter$LWS({
    globalObject: {
      HTMLIFrameElement: HTMLIFrameElement$LWS
    }
  }) {
    const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElement$LWS.prototype, 'contentDocument');
    const distortionEntry$LWS = [originalContentDocumentGetter$LWS, function get$LWS() {
      // The contentDocument proxy object of a kept alive sandbox iframe is revoked.
      return isRevokedProxy$LWS(this) ? /* istanbul ignore next: currently unreachable via tests */null : ReflectApply$LWS$1(originalContentDocumentGetter$LWS, this, []);
    }];
    return function distortionIFrameElementContentDocument$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionIFrameElementContentWindowGetter$LWS({
    globalObject: {
      HTMLIFrameElement: HTMLIFrameElement$LWS
    }
  }) {
    const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElement$LWS.prototype, 'contentWindow');
    const distortionEntry$LWS = [originalContentWindowGetter$LWS, function get$LWS() {
      // The contentWindow proxy object of a kept alive sandbox iframe is revoked.
      return isRevokedProxy$LWS(this) ? /* istanbul ignore next: currently unreachable via tests */null : ReflectApply$LWS$1(originalContentWindowGetter$LWS, this, []);
    }];
    return function distortionIFrameElementContentWindow$LWS() {
      return distortionEntry$LWS;
    };
  }
  function src$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);
    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes, relative urls and about:blank.');
    }
    ReflectApply$LWS$1(HTMLIFrameElementProtoSrcSetter$LWS, this, [urlString$LWS]);
  }
  function initDistortionHTMLIFrameElementSrcSetter$LWS({
    globalObject: {
      HTMLIFrameElement: HTMLIFrameElement$LWS
    }
  }) {
    const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');
    const distortionMapEntry$LWS = [originalSrcSetter$LWS, src$LWS];
    return function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
      return distortionMapEntry$LWS;
    };
  }
  const importRegExp$LWS = /import/i;
  const WARN_MESSAGE$LWS = 'Lightning Web Security: HTMLLinkElement does not allow setting "rel" property to "import" value.';
  function isValidRelValue$LWS(value$LWS) {
    return typeof value$LWS !== 'string' || !ReflectApply$LWS$1(RegExpProtoTest$LWS$1, importRegExp$LWS, [value$LWS]);
  }
  function initDistortionHTMLLinkElementRelSetter$LWS({
    globalObject: {
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  }) {
    const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');
    function rel$LWS(value$LWS) {
      const valueAsString$LWS = toString$LWS(value$LWS);
      if (isValidRelValue$LWS(valueAsString$LWS)) {
        ReflectApply$LWS$1(originalRelSetter$LWS, this, [valueAsString$LWS]);
        return;
      }
      consoleWarn$LWS(WARN_MESSAGE$LWS);
    }
    const distortionEntry$LWS = [originalRelSetter$LWS, rel$LWS];
    return function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', NAMESPACE_DEFAULT$LWS, rel$LWS);
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLLinkElementRelListSetter$LWS({
    globalObject: {
      DOMTokenList: DOMTokenList$LWS,
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  }) {
    const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');
    const distortionEntry$LWS = [originalRelListSetter$LWS, function relList$LWS(relListValue$LWS) {
      const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? /* istanbul ignore next: needs default platform behavior test */ReflectApply$LWS$1(DOMTokenListProtoValueGetter$LWS, relListValue$LWS, []) : toString$LWS(relListValue$LWS);
      if (isValidRelValue$LWS(string$LWS)) {
        ReflectApply$LWS$1(originalRelListSetter$LWS, this, [string$LWS]);
        return;
      }
      consoleWarn$LWS(WARN_MESSAGE$LWS);
    }];
    return function distortionHTMLLinkElementRelListSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLObjectElementDataSetter$LWS({
    globalObject: {
      HTMLObjectElement: HTMLObjectElement$LWS
    }
  }) {
    const originalDataSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLObjectElement$LWS.prototype, 'data');
    function data$LWS(value$LWS) {
      const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);
      if (!isValidURLScheme$LWS(urlString$LWS)) {
        throw new LockerSecurityError$LWS('HTMLObjectElement.data supports http://, https:// schemes, relative urls and about:blank.');
      }
      const parsedURL$LWS = parseURL$LWS(urlString$LWS);
      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }
      ReflectApply$LWS$1(originalDataSetter$LWS, this, [trusted.createScriptURL(urlString$LWS)]);
    }
    const distortionEntry$LWS = [originalDataSetter$LWS, data$LWS];
    return function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', NAMESPACE_DEFAULT$LWS, data$LWS);
      return distortionEntry$LWS;
    };
  }
  const descriptorCaches$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributeName$LWS) {
    return function initDistortionBlockedAttribute$LWS() {
      const enquotedAttributeName$LWS = enquote$LWS(attributeName$LWS);
      const distortionName$LWS = `blocked${capitalizeFirstChar$LWS(attributeName$LWS)}Attribute`;
      // Use a computed property to dynamically set the distortion function
      // name without using `Reflect.defineProperty()`.
      const {
        [distortionName$LWS]: distortion$LWS
      } = {
        [distortionName$LWS]: () => {
          throw new LockerSecurityError$LWS(`Attribute ${enquotedAttributeName$LWS} not allowed on ${ctorName$LWS}.`);
        }
      };
      return function distortionBlockedAttribute$LWS(record$LWS) {
        registerAttributeDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, distortion$LWS);
      };
    };
  }
  function createGetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
    const originalGet$LWS = ObjectLookupOwnGetter$LWS$1(proto$LWS, key$LWS);
    const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
    const distortionEntry$LWS = [originalGet$LWS,
    // eslint-disable-next-line prefer-arrow-callback
    function get$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
    }];
    function getThrowerDistortionFactory$LWS() {
      return distortionEntry$LWS;
    }
    return function getThrowerDistortionFactoryInitializer$LWS() {
      return getThrowerDistortionFactory$LWS;
    };
  }
  function createSetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
    const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, key$LWS);
    const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
    const distortionEntry$LWS = [originalSet$LWS,
    // eslint-disable-next-line prefer-arrow-callback
    function set$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
    }];
    function setThrowerDistortionFactory$LWS() {
      return distortionEntry$LWS;
    }
    return function setThrowerDistortionFactoryInitializer$LWS() {
      return setThrowerDistortionFactory$LWS;
    };
  }
  function createValueThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
    const {
      [key$LWS]: originalValue$LWS
    } = proto$LWS;
    const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
    const distortionEntry$LWS = [originalValue$LWS,
    // eslint-disable-next-line prefer-arrow-callback
    function value$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
    }];
    function valueThrowerDistortionFactory$LWS() {
      return distortionEntry$LWS;
    }
    return function valueThrowerDistortionFactoryInitializer$LWS() {
      return valueThrowerDistortionFactory$LWS;
    };
  }
  function addBlockedAttributeDistortionFactoryInitializers$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS, factoryInitializers$LWS) {
    let {
      length: factoryInitializersOffset$LWS
    } = factoryInitializers$LWS;
    for (let i$LWS = 0, {
        length: length$LWS
      } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
      factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS[i$LWS]);
    }
  }
  function addBlockedPropertyDistortionFactoryInitializers$LWS({
    document: document$LWS
  }, proto$LWS, properties$LWS, factoryInitializers$LWS) {
    let {
      length: factoryInitializersOffset$LWS
    } = factoryInitializers$LWS;
    let descsCache$LWS = descriptorCaches$LWS.get(document$LWS);
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (descsCache$LWS === undefined) {
      descsCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      descriptorCaches$LWS.set(document$LWS, descsCache$LWS);
    }
    let safeDescs$LWS = descsCache$LWS.get(proto$LWS);
    // istanbul ignore else: need a test for this on the same document but different namespace
    if (safeDescs$LWS === undefined) {
      safeDescs$LWS = {
        __proto__: null
      };
      descsCache$LWS.set(proto$LWS, safeDescs$LWS);
    }
    for (let i$LWS = 0, {
        length: length$LWS
      } = properties$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const prop$LWS = properties$LWS[i$LWS];
      let safeDesc$LWS = safeDescs$LWS[prop$LWS];
      if (safeDesc$LWS === undefined) {
        var _ReflectGetOwnPropert$LWS;
        safeDesc$LWS = (_ReflectGetOwnPropert$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS)) != null ? _ReflectGetOwnPropert$LWS : null;
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
        }
        safeDescs$LWS[prop$LWS] = safeDesc$LWS;
      }
      if (safeDesc$LWS) {
        const {
          value: value$LWS
        } = safeDesc$LWS;
        if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
          const {
            get: getter$LWS,
            set: setter$LWS
          } = safeDesc$LWS;
          // istanbul ignore else
          if (getter$LWS) {
            factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createGetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
          }
          if (setter$LWS) {
            factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createSetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
          }
        } else {
          // The following if statement is enclosed in a dedicated else {}
          // because prettier won't allow a multi-line comment between
          // "else" and "if", which is where the istanbul ignore directive
          // must go to be effective.
          // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
          if (typeof value$LWS === 'function') {
            factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createValueThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
          }
        }
      }
    }
  }
  const scriptURLs$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function trackScriptURL$LWS(targetElement$LWS, url$LWS) {
    scriptURLs$LWS.set(targetElement$LWS, url$LWS);
  }
  function getScriptURL$LWS(targetElement$LWS) {
    return scriptURLs$LWS.get(targetElement$LWS);
  }
  function createScriptDistortion$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }, attributeName$LWS) {
    const distortionName$LWS = `script${capitalizeFirstChar$LWS(attributeName$LWS)}`;
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    // Use a computed property to dynamically set the distortion function name
    // without using `Reflect.defineProperty()`.
    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS](url$LWS) {
        trackScriptURL$LWS(this, resolveURL$LWS(url$LWS));
        const targetElement$LWS = this;
        const evaluator$LWS = function evaluator$LWS(sourceText$LWS) {
          const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, targetElement$LWS, []);
          const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
          const context$LWS = {
            [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
            [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
          };
          sourceText$LWS = transformSourceText$LWS(sourceText$LWS);
          return sandboxEvaluator$LWS(sourceText$LWS, context$LWS, defaultView$LWS, ownerDoc$LWS);
        };
        lwsInternalPolicy$LWS.createScriptURL(url$LWS, evaluator$LWS, targetElement$LWS);
      }
    };
    return distortion$LWS;
  }
  function initDistortionHTMLScriptElementSrcGetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  }) {
    const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLScriptElement$LWS.prototype, 'src');
    const distortionEntry$LWS = [originalSrcGetter$LWS, function src$LWS() {
      var _getScriptURL$LWS;
      return (_getScriptURL$LWS = getScriptURL$LWS(this)) != null ? _getScriptURL$LWS : ReflectApply$LWS$1(originalSrcGetter$LWS, this, []);
    }];
    return function distortionHTMLScriptElementSrcGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLScriptElementSrcSetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  }) {
    const {
      set: originalSrcSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement$LWS.prototype, 'src');
    return function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
      const src$LWS = createScriptDistortion$LWS(record$LWS, 'src');
      registerAttributeDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
      return [originalSrcSetter$LWS, src$LWS];
    };
  }
  function initDistortionHTMLScriptElementTextSetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    },
    root: {
      distortions: distortions$LWS
    }
  }) {
    const {
      get: originalTextGetter$LWS,
      set: originalTextSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement$LWS.prototype, 'text');
    return function distortionHTMLScriptElementTextSetter$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalTextSetter$LWS, function text$LWS(value$LWS) {
        // istanbul ignore else: this will never NOT be instanceof HTMLScriptElement
        if (this instanceof HTMLScriptElement$LWS) {
          const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'text', trusted.createScript(value$LWS), originalTextGetter$LWS, originalTextSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
          // istanbul ignore else
          if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
            return;
          }
        }
        // istanbul ignore next: currently unreachable via tests (see above)
        ReflectApply$LWS$1(originalTextSetter$LWS, this, [value$LWS]);
      }];
    };
  }
  function initDistortionIDBObjectStoreAdd$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      IDBObjectStore: {
        prototype: {
          add: originalAdd$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalAdd$LWS, function add$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const value$LWS = args$LWS[0];
          if (isObject$LWS$1(value$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(value$LWS);
            return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionIDBObjectStoreAdd$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionIDBObjectStorePut$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      IDBObjectStore: {
        prototype: {
          put: originalPut$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalPut$LWS, function put$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const value$LWS = args$LWS[0];
          if (isObject$LWS$1(value$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(value$LWS);
            return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionIDBObjectStorePut$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionMessagePortPostMessage$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      MessagePort: MessagePort$LWS
    }
  }) {
    const {
      postMessage: originalPostMessage$LWS
    } = MessagePort$LWS.prototype;
    const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
      } catch (error) {
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS && error instanceof DOMException$LWS) {
          const message$LWS = args$LWS[0];
          if (isObject$LWS$1(message$LWS)) {
            if (length$LWS > 1) {
              // MDN document providing a transfer list array
              // while the WHATWG documents providing an options
              // object with a 'transfer' property. To cover both
              // cases we structurally clone the entire `args` array.
              // https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage#parameters
              // https://html.spec.whatwg.org/multipage/web-messaging.html#dom-structuredserializeoptions-transfer
              args$LWS = partialStructuredClone$LWS(args$LWS);
            } else {
              args$LWS[0] = partialStructuredClone$LWS(message$LWS);
            }
            return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionMessagePortPostMessage$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNamedNodeMapSetNamedItem$LWS({
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: {
        prototype: {
          setNamedItem: originalSetNamedItem$LWS
        }
      }
    }
  }) {
    return function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
      return [originalSetNamedItem$LWS, function setNamedItem$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (attr$LWS && attr$LWS instanceof Attr$LWS) {
          return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
        }
        return ReflectApply$LWS$1(originalSetNamedItem$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionNamedNodeMapSetNamedItemNS$LWS({
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: {
        prototype: {
          setNamedItemNS: originalSetNamedItemNS$LWS
        }
      }
    }
  }) {
    return function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
      return [originalSetNamedItemNS$LWS, function setNamedItemNS$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
        if (attr$LWS && attr$LWS instanceof Attr$LWS) {
          return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
        }
        return ReflectApply$LWS$1(originalSetNamedItemNS$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionNavigatorSendBeacon$LWS({
    globalObject: {
      Navigator: {
        prototype: {
          sendBeacon: originalSendBeacon$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSendBeacon$LWS, function sendBeacon$LWS(...args$LWS) {
      if (args$LWS.length) {
        const parsedURL$LWS = parseURL$LWS(toString$LWS(args$LWS[0]));
        if (!isValidURL$LWS(parsedURL$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
        }
        args$LWS[0] = parsedURL$LWS.normalizedURL;
      }
      return ReflectApply$LWS$1(originalSendBeacon$LWS, this, args$LWS);
    }];
    return function distortionNavigatorSendBeacon$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNavigatorServiceWorkerGetter$LWS({
    globalObject: {
      Navigator: Navigator$LWS
    }
  }) {
    const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Navigator$LWS.prototype, 'serviceWorker');
    // istanbul ignore if: needs default platform behavior test
    if (typeof originalServiceWorkerGetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalServiceWorkerGetter$LWS, noop$LWS$1];
    return function distortionNavigatorServiceWorkerGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$c$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$1$LWS
  } = rootValidator$LWS;
  function initDistortionNodeInsertBefore$LWS({
    globalObject: {
      Node: {
        prototype: {
          insertBefore: originalInsertBefore$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalInsertBefore$LWS, function insertBefore$LWS(...args$LWS) {
      // Node.prototype.insertBefore accepts two arguments. The first is the
      // new node to insert, the second is the reference node.
      // If the new node argument is NOT a valid shared element child,
      // which is limited to script and link, an exception is thrown.
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS;
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$c$LWS(this) && !isAllowedSharedElementChild$1$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot insert child ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])} into ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])},`);
        }
      }
      return ReflectApply$LWS$1(originalInsertBefore$LWS, this, args$LWS);
    }];
    return function distortionNodeInsertBefore$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNodeValueSetter$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Node: Node$LWS
    }
  }) {
    const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');
    return function distortionNodeValueSetter$LWS(record$LWS) {
      return [originalNodeValueSetter$LWS, function nodeValue$LWS(value$LWS) {
        // W-10476944 Window access via nodeValue/textContent:
        // This distortion sanitizes the given text to prevent window
        // access from being achieved via the nodeValue property.
        // istanbul ignore else: needs default platform behavior test
        if (this instanceof Attr$LWS) {
          const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
          if (ownerEl$LWS === null) {
            ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
            return;
          }
          const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
          const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
          const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
          // istanbul ignore next: needs default platform behavior test
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [value$LWS]);
            return;
          }
        }
        // istanbul ignore next: needs default platform behavior test
        ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$b$LWS
  } = rootValidator$LWS;
  function initDistortionNodeRemoveChild$LWS({
    globalObject: {
      Node: {
        prototype: {
          removeChild: originalRemoveChild$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalRemoveChild$LWS, function removeChild$LWS(...args$LWS) {
      // Node.prototype.removeChild only accepts one child argument.
      // If that child argument is a valid shared element, an exception
      // is thrown.
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length) {
        const {
          0: child$LWS
        } = args$LWS;
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$b$LWS(child$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
        }
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalRemoveChild$LWS, this, args$LWS);
    }];
    return function distortionNodeRemoveChild$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$a$LWS
  } = rootValidator$LWS;
  function initDistortionNodeReplaceChild$LWS({
    globalObject: {
      Node: {
        prototype: {
          replaceChild: originalReplaceChild$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChild$LWS(...args$LWS) {
      // Node.prototype.replaceChild accepts two child element arguments.
      // If the "old element" argument is a valid shared element, an
      // exception is thrown.
      const {
        length: length$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (length$LWS > 1) {
        const {
          1: child$LWS
        } = args$LWS;
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$a$LWS(child$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
        }
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
    }];
    return function distortionNodeReplaceChild$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNodeTextContentGetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS,
      Node: Node$LWS,
      SVGScriptElement: SVGScriptElement$LWS
    }
  }) {
    const originalTextContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(Node$LWS.prototype, 'textContent');
    const distortionEntry$LWS = [originalTextContentGetter$LWS, function textContent$LWS() {
      if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
        var _getOriginalScriptPro$LWS;
        return (_getOriginalScriptPro$LWS = getOriginalScriptProperty$LWS(this)) != null ? _getOriginalScriptPro$LWS : ReflectApply$LWS$1(originalTextContentGetter$LWS, this, []);
      }
      return ReflectApply$LWS$1(originalTextContentGetter$LWS, this, []);
    }];
    return function distortionHTMLScriptElementSrcGetter$LWS() {
      return distortionEntry$LWS;
    };
  }

  // IMPORTANT! This validator MUST use the top "window" global object, and not
  // the provided "globalObject" because magenta objects (arbitrary user-code
  // created global objects) must be allowed to interact with their OWN <html>,
  // <head> and <body> (within the iframe content window). Using the provided
  // "globalObject" here would result in receiving a validator bound to the
  // magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.
  const {
    isSharedElement: isSharedElement$9$LWS
  } = rootValidator$LWS;
  function initDistortionNodeTextContentSetter$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Node: Node$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      SVGScriptElement: SVGScriptElement$LWS
    },
    root: {
      distortions: distortions$LWS
    }
  }) {
    const {
      get: originalTextContentGetter$LWS,
      set: originalTextContentSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(Node$LWS.prototype, 'textContent');
    return function distortionNodeTextContentSetter$LWS(record$LWS) {
      const {
        sandboxEvaluator: sandboxEvaluator$LWS
      } = record$LWS;
      return [originalTextContentSetter$LWS, function textContent$LWS(value$LWS) {
        const valueAsString$LWS = trusted.createScript(value$LWS);
        // There are two existence of the attribute textContent, one on
        // Attr and one on Node. This first if statement is checking to
        // figure out which distortion should be applied. The instanceof
        // operator tests to see if the current global object, this,
        // is of the type Attr, while also taking inheritance into
        // consideration.
        // W-10476944 Window access via nodeValue/textContent:
        // This distortion sanitizes the given text to prevent window
        // access from being achieved via the textContent property.
        // istanbul ignore else: needs default platform behavior test
        if (this instanceof Attr$LWS) {
          const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
          if (ownerEl$LWS === null) {
            ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
            return;
          }
          const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
          const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
          const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
          // istanbul ignore next: needs default platform behavior test
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
            return;
          }
        } else if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
          const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'textContent', valueAsString$LWS, originalTextContentGetter$LWS, originalTextContentSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
          if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
            return;
          }
        }
        // istanbul ignore else: needs default platform behavior test
        else if (isSharedElement$9$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot set textContent of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])} elements.`);
        }
        ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
      }];
    };
  }
  function initDistortionNotificationCtor$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      Notification: originalNotificationCtor$LWS
    }
  }) {
    // istanbul ignore if: needs default platform behavior test
    if (typeof originalNotificationCtor$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalNotificationCtor$LWS, function Notification$LWS(...args$LWS) {
      try {
        return ReflectConstruct$LWS(originalNotificationCtor$LWS, args$LWS);
      } catch (error) {
        if (args$LWS.length > 1 && error instanceof DOMException$LWS) {
          const providedOptions$LWS = args$LWS[1];
          if (isObjectLike$LWS(providedOptions$LWS)) {
            const {
              data: data$LWS
            } = providedOptions$LWS;
            if (isObject$LWS$1(data$LWS)) {
              args$LWS[1] = {
                // The Notification constructor accepts
                // inherited options property values.
                __proto__: providedOptions$LWS,
                // Shadow any inherited value.
                data: partialStructuredClone$LWS(data$LWS)
              };
              return ReflectConstruct$LWS(originalNotificationCtor$LWS, args$LWS);
            }
          }
        }
        throw error;
      }
    }];
    return function distortionNotificationCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionPerformanceMark$LWS({
    globalObject: {
      Performance: {
        prototype: {
          mark: originalMark$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalMark$LWS, function mark$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalMark$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length > 1 && error instanceof DOMException) {
          const providedOptions$LWS = args$LWS[1];
          if (isObject$LWS$1(providedOptions$LWS)) {
            args$LWS[1] = partialStructuredClone$LWS(providedOptions$LWS);
            return ReflectApply$LWS$1(originalMark$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionPerformanceMark$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionPerformanceMeasure$LWS({
    globalObject: {
      Performance: {
        prototype: {
          measure: originalMeasure$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalMeasure$LWS, function measure$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalMeasure$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length > 1 && error instanceof DOMException) {
          const providedOptions$LWS = args$LWS[1];
          if (isObject$LWS$1(providedOptions$LWS)) {
            args$LWS[1] = partialStructuredClone$LWS(providedOptions$LWS);
            return ReflectApply$LWS$1(originalMeasure$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionPerformanceMeasure$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionPerformanceMarkCtor$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      PerformanceMark: originalPerformanceMarkCtor$LWS
    }
  }) {
    // istanbul ignore if: needs default platform behavior test
    if (typeof originalPerformanceMarkCtor$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalPerformanceMarkCtor$LWS, function PerformanceMark$LWS(...args$LWS) {
      try {
        return ReflectConstruct$LWS(originalPerformanceMarkCtor$LWS, args$LWS);
      } catch (error) {
        if (args$LWS.length > 1 && error instanceof DOMException$LWS) {
          const providedOptions$LWS = args$LWS[1];
          if (isObject$LWS$1(providedOptions$LWS)) {
            args$LWS[1] = partialStructuredClone$LWS(providedOptions$LWS);
            return ReflectConstruct$LWS(originalPerformanceMarkCtor$LWS, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionPerformanceMarkCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionRangeCreateContextualFragment$LWS({
    document: document$LWS,
    globalObject: {
      Range: {
        prototype: {
          createContextualFragment: originalCreateContextualFragment$LWS
        }
      }
    }
  }) {
    return function distortionRangeCreateContextualFragment$LWS({
      key: key$LWS
    }) {
      return [originalCreateContextualFragment$LWS, function createContextualFragment$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: tagString$LWS
          } = args$LWS;
          if (tagString$LWS !== null && tagString$LWS !== undefined) {
            // This must be called to signal to the virtual
            // CustomElementRegistry that the next thing created
            // MAY CONTAIN a custom element, which must be marked
            // for association to this sandbox.
            setCustomElementsRegistry$LWS(document$LWS, key$LWS);
            args$LWS[0] = lwsInternalPolicy$LWS.createHTML(tagString$LWS, key$LWS, ContentType$LWS.HTML);
          }
        }
        return ReflectApply$LWS$1(originalCreateContextualFragment$LWS, this, args$LWS);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$8$LWS
  } = rootValidator$LWS;
  function initDistortionRangeDeleteContents$LWS({
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: {
        prototype: {
          deleteContents: originalDeleteContents$LWS
        }
      }
    }
  }) {
    // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
    //      endContainer/startContainer are defined on Range.prototype
    //
    // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
    //      endContainer/startContainer are defined on AbstractRange.prototype
    // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
    const {
      prototype: AbstractRangeProto$LWS
    } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
    const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'endContainer');
    const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'startContainer');
    const distortionEntry$LWS = [originalDeleteContents$LWS, function deleteContents$LWS(...args$LWS) {
      const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];
      for (let i$LWS = 0, {
          length: length$LWS
        } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const container$LWS = containers$LWS[i$LWS];
        if (isSharedElement$8$LWS(container$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot delete contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalDeleteContents$LWS, this, args$LWS);
    }];
    return function distortionRangeDeleteContents$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$7$LWS
  } = rootValidator$LWS;
  function initDistortionRangeExtractContents$LWS({
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: {
        prototype: {
          extractContents: originalExtractContents$LWS
        }
      }
    }
  }) {
    // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
    //      endContainer/startContainer are defined on Range.prototype
    //
    // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
    //      endContainer/startContainer are defined on AbstractRange.prototype
    // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
    const {
      prototype: AbstractRangeProto$LWS
    } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
    const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'endContainer');
    const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'startContainer');
    const distortionEntry$LWS = [originalExtractContents$LWS, function extractContents$LWS(...args$LWS) {
      const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];
      for (let i$LWS = 0, {
          length: length$LWS
        } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const container$LWS = containers$LWS[i$LWS];
        if (isSharedElement$7$LWS(container$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot extract contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalExtractContents$LWS, this, args$LWS);
    }];
    return function distortionRangeExtractContents$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$6$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = rootValidator$LWS;
  function initDistortionRangeInsertNode$LWS({
    globalObject: {
      Range: {
        prototype: {
          insertNode: originalInsertNode$LWS
        }
      }
    }
  }) {
    const originalCommonAncestorContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Range.prototype, 'commonAncestorContainer');
    const distortionEntry$LWS = [originalInsertNode$LWS, function insertNode$LWS(...args$LWS) {
      // Range.prototype.insertNode only accepts one child argument.
      // If that child argument is NOT a valid shared element child,
      // which is limited to script and link, an exception is thrown.
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length) {
        const commonAncestorContainer$LWS = ReflectApply$LWS$1(originalCommonAncestorContainerGetter$LWS, this, []);
        if (commonAncestorContainer$LWS && isSharedElement$6$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(args$LWS[0])) {
          throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, commonAncestorContainer$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalInsertNode$LWS, this, args$LWS);
    }];
    return function distortionRangeInsertNode$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$5$LWS
  } = rootValidator$LWS;
  function createRangeProtoMethodDistortionFactoryInitializer$LWS(methodName$LWS) {
    return function initDistortionContentWindowGetter$LWS({
      globalObject: {
        Range: {
          // @ts-ignore: Prevent index type error.
          prototype: {
            [methodName$LWS]: originalMethod$LWS
          }
        }
      }
    }) {
      // Use a computed property to dynamically set the distortion function
      // name without using `Reflect.defineProperty()`.
      const {
        [methodName$LWS]: distortion$LWS
      } = {
        [methodName$LWS](...args$LWS) {
          // istanbul ignore else: needs default platform behavior test
          if (args$LWS.length) {
            const {
              0: node$LWS
            } = args$LWS;
            // istanbul ignore else: needs default platform behavior test
            if (isSharedElement$5$LWS(node$LWS)) {
              throw new LockerSecurityError$LWS(`Cannot call ${methodName$LWS} with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}.`);
            }
          }
          return ReflectApply$LWS$1(originalMethod$LWS, this, args$LWS);
        }
      };
      const distortionEntry$LWS = [originalMethod$LWS, distortion$LWS];
      return function distortionContentWindowGetter$LWS() {
        return distortionEntry$LWS;
      };
    };
  }
  const initDistortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEnd');
  const initDistortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNode');
  const initDistortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNodeContents');
  const initDistortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndAfter');
  const initDistortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndBefore');
  const initDistortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStart');
  const initDistortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartAfter');
  const initDistortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartBefore');
  const initDistortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('surroundContents');
  const {
    isSharedElement: isSharedElement$4$LWS
  } = rootValidator$LWS;
  function initDistortionSelectionCollapse$LWS({
    globalObject: {
      Selection: {
        prototype: {
          collapse: originalSelectionCollapse$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSelectionCollapse$LWS, function collapse$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS;
        // The first arg to Selection.prototype.collapse is "Node | null"
        if (node$LWS && isSharedElement$4$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot collapse selection to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
        }
      }
      return ReflectApply$LWS$1(originalSelectionCollapse$LWS, this, args$LWS);
    }];
    return function distortionSelectionCollapse$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$3$LWS
  } = rootValidator$LWS;
  function initDistortionSelectionExtend$LWS({
    globalObject: {
      Selection: {
        prototype: {
          extend: originalSelectionExtend$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSelectionExtend$LWS, function extend$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS;
        if (isSharedElement$3$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot extend selection to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
        }
      }
      return ReflectApply$LWS$1(originalSelectionExtend$LWS, this, args$LWS);
    }];
    return function distortionSelectionExtend$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$2$LWS
  } = rootValidator$LWS;
  function initDistortionSelectionSelectAllChildren$LWS({
    globalObject: {
      Selection: {
        prototype: {
          selectAllChildren: originalSelectionSelectAllChildren$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSelectionSelectAllChildren$LWS, function selectAllChildren$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS;
        if (isSharedElement$2$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot select all children of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
        }
      }
      return ReflectApply$LWS$1(originalSelectionSelectAllChildren$LWS, this, args$LWS);
    }];
    return function distortionSelectionSelectAllChildren$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$1$LWS
  } = rootValidator$LWS;
  function initDistortionSelectionSetBaseAndExtent$LWS({
    globalObject: {
      Selection: {
        prototype: {
          setBaseAndExtent: originalSelectionSetBaseAndExtent$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSelectionSetBaseAndExtent$LWS, function setBaseAndExtent$LWS(...args$LWS) {
      // All 4 arguments are required, if any are missing then defer to
      // the platform for error handling.
      if (args$LWS.length === 4) {
        const {
          0: anchorNode$LWS,
          2: focusNode$LWS
        } = args$LWS;
        const anchorNodeIsShared$LWS = isSharedElement$1$LWS(anchorNode$LWS);
        const focusNodeIsShared$LWS = isSharedElement$1$LWS(focusNode$LWS);
        if (anchorNodeIsShared$LWS || focusNodeIsShared$LWS) {
          const subject$LWS = anchorNodeIsShared$LWS ? anchorNode$LWS : focusNode$LWS;
          throw new LockerSecurityError$LWS(`Cannot set selection with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, subject$LWS, [])}`);
        }
      }
      return ReflectApply$LWS$1(originalSelectionSetBaseAndExtent$LWS, this, args$LWS);
    }];
    return function distortionSelectionSetBaseAndExtent$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$LWS
  } = rootValidator$LWS;
  function initDistortionSelectionSetPosition$LWS({
    globalObject: {
      Selection: {
        prototype: {
          setPosition: originalSelectionSetPosition$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSelectionSetPosition$LWS, function setPosition$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS;
        // The first arg to Selection.prototype.setPosition is "Node | null"
        if (node$LWS && isSharedElement$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot set position with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
        }
      }
      return ReflectApply$LWS$1(originalSelectionSetPosition$LWS, this, args$LWS);
    }];
    return function distortionSelectionSetPosition$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionServiceWorkerContainerProto$LWS({
    globalObject: {
      ServiceWorkerContainer: ServiceWorkerContainer$LWS
    }
  }) {
    // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
    if (typeof ServiceWorkerContainer$LWS !== 'function') {
      return noop$LWS$1;
    }
    const {
      prototype: originalPrototype$LWS
    } = ServiceWorkerContainer$LWS;
    const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
    return function distortionServiceWorkerContainerProto$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionShadowRootInnerHTMLSetter$LWS({
    document: document$LWS,
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  }) {
    const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');
    return function distortionShadowRootInnerHTMLSetter$LWS({
      key: key$LWS
    }) {
      return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, ContentType$LWS.HTML)]);
      }];
    };
  }
  function SharedWorker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
  }
  function initDistortionSharedWorkerCtor$LWS({
    globalObject: {
      SharedWorker: originalSharedWorkerCtor$LWS
    }
  }) {
    // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
    if (typeof originalSharedWorkerCtor$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
    return function distortionSharedWorkerCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSharedWorkerProto$LWS({
    globalObject: {
      SharedWorker: SharedWorker$LWS
    }
  }) {
    // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
    if (typeof SharedWorker$LWS !== 'function') {
      return noop$LWS$1;
    }
    const {
      prototype: originalPrototype$LWS
    } = SharedWorker$LWS;
    const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
    return function distortionSharedWorkerProto$LWS() {
      return distortionEntry$LWS;
    };
  }
  function getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS) {
    const storageKeys$LWS = ObjectKeys$LWS$1(storage$LWS);
    const keys$LWS = [];
    let keysOffset$LWS = 0;
    for (let i$LWS = 0, {
        length: length$LWS
      } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeys$LWS[i$LWS];
      if (startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS)) {
        keys$LWS[keysOffset$LWS++] = key$LWS;
      }
    }
    return keys$LWS;
  }
  function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS) {
    const {
      length: length$LWS
    } = storageKeysForNamespace$LWS;
    const keys$LWS = ArrayCtor$LWS$1(length$LWS);
    for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      keys$LWS[i$LWS] = removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
    }
    return keys$LWS;
  }
  const storageToMetaMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
    const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS);
    // istanbul ignore if: currently unreachable via tests
    if (storageMeta$LWS === undefined) {
      throw new LockerSecurityError$LWS(ERR_ILLEGAL_INVOCATION$LWS);
    }
    return storageMeta$LWS;
  }
  function createStorageProxy$LWS(storageTarget$LWS) {
    const proxy$LWS = new ProxyCtor$LWS(storageTarget$LWS, {
      // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
      get(target$LWS, key$LWS, receiver$LWS) {
        if (typeof key$LWS === 'symbol') {
          return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        if (ObjectHasOwn$LWS$1(storage$LWS, markedKey$LWS)) {
          return ReflectGet$LWS(storage$LWS, markedKey$LWS);
        }
        const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
        return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
      },
      set(target$LWS, key$LWS, value$LWS) {
        if (typeof key$LWS === 'symbol') {
          return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, [markedKey$LWS, value$LWS]);
        return true;
      },
      defineProperty(target$LWS, key$LWS, unsafePartialDesc$LWS) {
        const safeDesc$LWS = unsafePartialDesc$LWS;
        ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
        if (typeof key$LWS === 'symbol') {
          return ReflectDefineProperty$LWS$1(target$LWS, key$LWS, safeDesc$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        return ReflectDefineProperty$LWS$1(storage$LWS, markedKey$LWS, safeDesc$LWS);
      },
      deleteProperty(target$LWS, key$LWS) {
        if (typeof key$LWS === 'symbol') {
          return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        return ReflectDeleteProperty$LWS$1(storage$LWS, markedKey$LWS);
      },
      getOwnPropertyDescriptor(target$LWS, key$LWS) {
        let safeDesc$LWS;
        if (typeof key$LWS === 'symbol') {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        } else {
          const {
            namespace: namespace$LWS,
            storage: storage$LWS
          } = storageToMetaMap$LWS.get(proxy$LWS);
          const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, markedKey$LWS);
        }
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
        }
        return safeDesc$LWS;
      },
      ownKeys(target$LWS) {
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
        const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS);
        const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
        return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
      },
      // istanbul ignore next: suspicious gap, currently unreachable via tests
      has(target$LWS, key$LWS) {
        if (typeof key$LWS === 'symbol') {
          return ReflectHas$LWS(target$LWS, key$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        if (ObjectHasOwn$LWS$1(storage$LWS, markedKey$LWS)) {
          return true;
        }
        const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
        if (proto$LWS === null) {
          return false;
        }
        return ReflectHas$LWS(proto$LWS, key$LWS);
      },
      preventExtensions(_target$LWS) {
        return false;
      }
    });
    return proxy$LWS;
  }
  class PatchedStorage$LWS {
    // istanbul ignore next: currently unreachable via tests
    constructor() {
      throw new LockerSecurityError$LWS(ERR_ILLEGAL_CONSTRUCTOR$LWS);
    }
    get length() {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      return storageKeysForNamespace$LWS.length;
    }
    key(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length) {
        const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
        const index$LWS = args$LWS[0];
        const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
        const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
        const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;
        if (typeof resolvedKey$LWS !== 'string') {
          return null;
        }
        return removeStorageNamespaceMarker$LWS(resolvedKey$LWS, namespace$LWS);
      }
      return ReflectApply$LWS$1(StorageProtoKey$LWS, storage$LWS, args$LWS);
    }
    getItem(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length) {
        args$LWS[0] = prependStorageNamespaceMarker$LWS(toString$LWS(args$LWS[0]), namespace$LWS);
      }
      return ReflectApply$LWS$1(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
    }
    setItem(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length > 1) {
        args$LWS[0] = prependStorageNamespaceMarker$LWS(toString$LWS(args$LWS[0]), namespace$LWS);
        args$LWS[1] = toString$LWS(args$LWS[1]);
      }
      ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
    }
    removeItem(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length) {
        args$LWS[0] = prependStorageNamespaceMarker$LWS(toString$LWS(args$LWS[0]), namespace$LWS);
      }
      ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
    }
    clear() {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      for (let i$LWS = 0, {
          length: length$LWS
        } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const key$LWS = storageKeysForNamespace$LWS[i$LWS];
        ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
      }
    }
  }
  function createStorage$LWS(storage$LWS, namespace$LWS) {
    const proxy$LWS = createStorageProxy$LWS({
      __proto__: PatchedStorage$LWS.prototype
    });
    trackAsLiveTarget$LWS(proxy$LWS);
    storageToMetaMap$LWS.set(proxy$LWS, {
      namespace: namespace$LWS,
      storage: storage$LWS
    });
    return proxy$LWS;
  }
  const {
    prototype: PatchedStorageProto$LWS
  } = PatchedStorage$LWS;
  const {
    clear: patchedStorageProtoClear$LWS,
    getItem: patchedStorageProtoGetItem$LWS,
    key: patchedStorageProtoKey$LWS,
    removeItem: patchedStorageProtoRemoveItem$LWS,
    setItem: patchedStorageProtoSetItem$LWS
  } = PatchedStorageProto$LWS;
  const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(PatchedStorageProto$LWS, 'length');
  function createDistortionStorageFactoryInitializer$LWS(storageName$LWS) {
    return function initDistortionStorageFactory$LWS({
      globalObject: globalObject$LWS
    }) {
      // Depending on browser configuration the storage object may be `null`
      // or throw an exception when its getter is accessed.
      let originalStorageObject$LWS;
      try {
        originalStorageObject$LWS = globalObject$LWS[storageName$LWS];
        // eslint-disable-next-line no-empty
      } catch (_unused2$LWS) {}
      // istanbul ignore if: currently unreachable via tests
      if (!isObject$LWS$1(originalStorageObject$LWS)) {
        return noop$LWS$1;
      }
      return function distortionStorageFactory$LWS({
        key: key$LWS
      }) {
        return [originalStorageObject$LWS, createStorage$LWS(originalStorageObject$LWS, key$LWS)];
      };
    };
  }
  function initDistortionStorageLength$LWS({
    globalObject: {
      Storage: Storage$LWS
    }
  }) {
    const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(Storage$LWS.prototype, 'length');
    const distortionEntry$LWS = [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
    return function distortionStorageLength$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageGetItem$LWS({
    globalObject: {
      Storage: {
        prototype: {
          getItem: originalStorageGetItem$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
    return function distortionStorageSetItem$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageSetItem$LWS({
    globalObject: {
      Storage: {
        prototype: {
          setItem: originalStorageSetItem$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
    return function distortionStorageSetItem$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageKey$LWS({
    globalObject: {
      Storage: {
        prototype: {
          key: originalStorageKey$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
    return function distortionStorageKey$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageRemoveItem$LWS({
    globalObject: {
      Storage: {
        prototype: {
          removeItem: originalStorageRemoveItem$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
    return function distortionStorageRemoveItem$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageClear$LWS({
    globalObject: {
      Storage: {
        prototype: {
          clear: originalStorageClear$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
    return function distortionStorageClear$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorage$LWS({
    globalObject: {
      Storage: Storage$LWS
    }
  }) {
    const distortionEntry$LWS = [Storage$LWS, PatchedStorage$LWS];
    return function distortionStorage$LWS() {
      return distortionEntry$LWS;
    };
  }
  const initDistortionLocalStorage$LWS = createDistortionStorageFactoryInitializer$LWS('localStorage');
  const initDistortionSessionStorage$LWS = createDistortionStorageFactoryInitializer$LWS('sessionStorage');
  function initDistortionSVGAnimateElementAttributeNameAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    return function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
      function distortAttribute$LWS(el$LWS, attrName$LWS) {
        if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
          const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
          // istanbul ignore else: needs default platform behavior test
          if (originalAttributeValue$LWS) {
            const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
            // istanbul ignore else: needs default platform behavior test
            if (distortion$LWS) {
              ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
            }
          }
        }
      }
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, function attributeName$LWS(value$LWS) {
        ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);
        if (value$LWS === 'href') {
          distortAttribute$LWS(this, 'from');
          distortAttribute$LWS(this, 'to');
          distortAttribute$LWS(this, 'values');
        }
      });
    };
  }
  function initDistortionSVGAnimateElementFromAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    function from$LWS(value$LWS) {
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
        value$LWS = sanitizeSvgHref$LWS(value$LWS);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['from', value$LWS]);
    }
    return function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', NAMESPACE_DEFAULT$LWS, from$LWS);
    };
  }
  function initDistortionSVGAnimateElementToAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    function to$LWS(value$LWS) {
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
        value$LWS = sanitizeSvgHref$LWS(value$LWS);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['to', value$LWS]);
    }
    return function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
    };
  }
  function initDistortionSVGAnimateElementValuesAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    function values$LWS(value$LWS) {
      let returnValues$LWS = value$LWS;
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
        const valuesSplit$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [';']);
        const {
          length: length$LWS
        } = valuesSplit$LWS;
        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
        }
        returnValues$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, valuesSplit$LWS, [';']);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
    }
    return function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', NAMESPACE_DEFAULT$LWS, values$LWS);
    };
  }
  function initDistortionSVGElementDatasetGetter$LWS({
    globalObject: {
      SVGElement: SVGElement$LWS
    }
  }) {
    const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, 'dataset');
    const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
    }];
    return function distortionSVGElementDatasetGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSVGElementStyleGetter$LWS({
    globalObject: {
      SVGElement: SVGElement$LWS
    }
  }) {
    const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, 'style');
    const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
    }];
    return function distortionSVGElementStyleGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const script$LWS = ReflectApply$LWS$1(DocumentProtoCreateElementNS$LWS, document, [NAMESPACE_SVG$LWS, 'script']);
  function initDistortionSVGScriptElementHrefGetter$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGScriptElement: SVGScriptElement$LWS
    }
  }) {
    const originalHrefGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGScriptElement$LWS.prototype, 'href');
    const distortionEntry$LWS = [originalHrefGetter$LWS, function href$LWS() {
      const url$LWS = getScriptURL$LWS(this);
      // istanbul ignore else: needs default platform behavior test
      if (typeof url$LWS === 'string') {
        ReflectApply$LWS$1(originalSetAttribute$LWS, script$LWS, ['href', trusted.createScriptURL(url$LWS)]);
        return ReflectApply$LWS$1(originalHrefGetter$LWS, script$LWS, []);
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalHrefGetter$LWS, this, []);
    }];
    return function distortionSVGScriptElementHrefGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSVGScriptElementHrefSetter$LWS({
    globalObject: {
      SVGScriptElement: SVGScriptElement$LWS
    }
  }) {
    return function distortionSVGScriptElementHrefSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'href'));
      registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href'));
      registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_DEFAULT$LWS, createScriptDistortion$LWS(record$LWS, 'href'));
      registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_DEFAULT$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href'));
    };
  }
  function initDistortionSVGSetElementAttributeNameAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGSetElement: SVGSetElement$LWS
    }
  }) {
    return function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
      function distortAttribute$LWS(el$LWS, attrName$LWS) {
        if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
          const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
          // istanbul ignore else: needs default platform behavior test
          if (originalAttributeValue$LWS) {
            const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
            // istanbul ignore else: needs default platform behavior test
            if (distortion$LWS) {
              ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
            }
          }
        }
      }
      function attributeName$LWS(value$LWS) {
        ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);
        if (value$LWS === 'href') {
          distortAttribute$LWS(this, 'to');
        }
      }
      registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, attributeName$LWS);
    };
  }
  function initDistortionSVGSetElementToAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGSetElement: SVGSetElement$LWS
    }
  }) {
    function to$LWS(value$LWS) {
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
        value$LWS = sanitizeSvgHref$LWS(value$LWS);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['to', value$LWS]);
    }
    return function distortionSVGSetElementToAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
    };
  }
  function createDistortionHrefAttributeFactoryInitializer$LWS(attributeName$LWS) {
    return function distortionHrefAttributeFactoryInitializer$LWS({
      globalObject: {
        Element: {
          prototype: {
            setAttribute: originalSetAttribute$LWS,
            setAttributeNS: originalSetAttributeNS$LWS
          }
        },
        SVGUseElement: SVGUseElement$LWS
      }
    }) {
      function xlinkNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? /* istanbul ignore next: needs default platform behavior test */value$LWS : sanitizeSvgHref$LWS(value$LWS);
        ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
      }
      return function distortionHrefAttributeFactory$LWS(record$LWS) {
        registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_XLINK$LWS, xlinkNamespaceDistortion$LWS);
        if (attributeName$LWS === 'href') {
          const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
            const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? /* istanbul ignore next: needs default platform behavior test */value$LWS : sanitizeSvgHref$LWS(value$LWS);
            ReflectApply$LWS$1(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
          };
          registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, defaultNamespaceDistortion$LWS);
        }
      };
    };
  }
  const initDistortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('href');
  const initDistortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('xlink:href');
  function initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS({
    globalObject: {
      TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
    }
  }) {
    var _TrustedTypePolicyFac$LWS;
    // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
    const originalCreatePolicy$LWS = TrustedTypePolicyFactory$LWS == null || (_TrustedTypePolicyFac$LWS = TrustedTypePolicyFactory$LWS.prototype) == null ? void 0 : _TrustedTypePolicyFac$LWS.createPolicy;
    // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
    if (typeof originalCreatePolicy$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalCreatePolicy$LWS, function createPolicy$LWS(...args$LWS) {
      const name$LWS = args$LWS.length ? args$LWS[0] : /* istanbul ignore next: needs default platform behavior test */undefined;
      // istanbul ignore else: needs default platform behavior test
      if (name$LWS === 'default') {
        throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalCreatePolicy$LWS, this, args$LWS);
    }];
    return function distortionTrustedTypePolicyFactoryCreatePolicy$LWS() {
      return distortionEntry$LWS;
    };
  }
  const HTML_MIME_TYPES_LIST$LWS = toSafeArray$LWS$1(['text/html', 'image/svg+xml', 'text/xml']);
  function initDistortionURLCreateObjectURL$LWS({
    document: document$LWS,
    globalObject: globalObject$LWS,
    globalObject: {
      MediaSource: MediaSource$LWS,
      URL: {
        createObjectURL: originalCreateObjectURL$LWS
      }
    }
  }) {
    // IMPORTANT! This validator MUST use the record's global object to create
    // a validator and not rely on the `rootValidator` because the validator
    // needs to be bound to the global object of the magenta object (arbitrary
    // user-code created global objects).
    const {
      isEqualDomString: isEqualDomString$LWS
    } = getValidator$LWS(document$LWS, globalObject$LWS);
    return function distortionURLCreateObjectURL$LWS({
      key: key$LWS
    }) {
      const sanitizer$LWS = blobSanitizer$LWS(key$LWS);
      return [originalCreateObjectURL$LWS, function createObjectURL$LWS(blobObject$LWS) {
        // Create a URL object first using the native APIs.
        // This will ensure native validation against undefined and other
        // non-accepted types.
        let outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [blobObject$LWS]);
        if (
        // MediaSource may not be defined in some browsers.
        // https://caniuse.com/mdn-api_mediasource
        MediaSource$LWS &&
        // MediaSource does not share the same prototype as Blob or File.
        // It can still be used with `createObjectURL()` however we need
        // to treat it separately. MediaSource does not accept plain text
        // input as Blob or File and does not have a MIME type.
        blobObject$LWS instanceof MediaSource$LWS) {
          return outURL$LWS;
        }
        const blobType$LWS = ReflectApply$LWS$1(BlobProtoTypeGetter$LWS, blobObject$LWS, []);
        if (blobType$LWS === '') {
          // Browsers interpret the empty MIME type differently.
          // Chrome makes it text/plain.
          // Firefox attempts to guess the content.
          // Safari makes it application/octet-stream effectively forcing a download of the content.
          // We need to normalize the behavior here.
          const plainTextBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, undefined, 'text/plain']);
          return ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
        }
        const loweredBlobType$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, blobType$LWS, []);
        if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
          const blobSize$LWS = ReflectApply$LWS$1(BlobProtoSizeGetter$LWS, blobObject$LWS, []);
          const normalizedBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
          URLRevokeObjectURL$LWS(outURL$LWS);
          outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
          const xhr$LWS = new XhrCtor$LWS();
          ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', outURL$LWS, false]);
          try {
            ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
          } catch (_unused3$LWS) {
            throw new LockerSecurityError$LWS(`Unable to verify ${toSafeTemplateStringValue$LWS(blobObject$LWS)} is secure.`);
          }
          const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
          const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);
          if (!isEqualDomString$LWS(trusted.createHTML(responseText$LWS), trusted.createHTML(sanitized$LWS))) {
            URLRevokeObjectURL$LWS(outURL$LWS);
            throw new LockerSecurityError$LWS(`Cannot 'createObjectURL' using an unsecure ${toSafeTemplateStringValue$LWS(blobObject$LWS)}.`);
          }
          return outURL$LWS;
        }
        if (isMIMETypeAllowed$LWS(loweredBlobType$LWS)) {
          return outURL$LWS;
        }
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS('Unsupported MIME type.');
      }];
    };
  }
  function initDistortionWindowFetch$LWS({
    globalObject: {
      fetch: originalFetch$LWS
    }
  }) {
    const distortionEntry$LWS = [originalFetch$LWS, function fetch$LWS(...args$LWS) {
      // Let the native method handle missing parameters error or null/undefined URL case.
      let {
        0: url$LWS
      } = args$LWS;
      if (url$LWS !== null && url$LWS !== undefined) {
        let parsedURL$LWS;
        if (url$LWS instanceof Request) {
          // Request will also normalize the url (partial to absolute url)
          // similar to link element's href.
          parsedURL$LWS = parseURL$LWS(ReflectApply$LWS$1(RequestProtoURLGetter$LWS, url$LWS, []));
        } else {
          parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
          url$LWS = parsedURL$LWS.normalizedURL;
          args$LWS[0] = url$LWS;
        }
        if (!isValidURL$LWS(parsedURL$LWS)) {
          const {
            normalizedURL: normalizedURL$LWS
          } = parsedURL$LWS;
          return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toSafeTemplateStringValue$LWS(normalizedURL$LWS)}`));
        }
      }
      return ReflectApply$LWS$1(originalFetch$LWS, this, args$LWS);
    }];
    return function distortionWindowFetch$LWS() {
      return distortionEntry$LWS;
    };
  }

  // The rules for this proxy are as follows:
  //
  // If the key is a string...
  //      ...And the key is a valid index that matches an existing
  //      index in the frame list or matches the value of a name
  //      property of a frame in the frame list, then return the
  //      appropriate frame from the frame list.
  //
  //      ...Or the key's value is "length", then return the number of
  //      frames in the in the frame list.
  //  Else,
  //      ...Return the value of the key from the shadow target
  class BaseFrameHandler$LWS {
    defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
      return true;
    }
    deleteProperty(_target$LWS, _key$LWS) {
      return true;
    }
    getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
      return undefined;
    }
    isExtensible(_target$LWS) {
      return true;
    }
    ownKeys(_target$LWS) {
      return [];
    }
    preventExtensions(_target$LWS) {
      return true;
    }
    set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
      return true;
    }
    setPrototypeOf(_target$LWS) {
      return false;
    }
  }
  ReflectSetPrototypeOf$LWS$1(BaseFrameHandler$LWS.prototype, null);
  class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}
  function initDistortionWindowFramesGetter$LWS({
    globalObject: globalObject$LWS
  }) {
    const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, 'frames');
    // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
    if (typeof originalWindowFramesGetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    const createFramesProxy$LWS = () => {
      const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS$1(globalObject$LWS);
      const WindowProperties$LWS = ReflectGetPrototypeOf$LWS$1(WindowPrototype$LWS);
      // Wrap `WindowLengthGetter` in bound function to obscure the getter
      // source as "[native code]".
      const framesLengthGetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, WindowLengthGetter$LWS, [globalObject$LWS]);
      // Wrap `noop` in bound function to obscure the setter source as
      // "[native code]".
      const framesLengthSetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, noop$LWS$1, []);
      const getFrameByIndexKey$LWS = key$LWS => {
        const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;
        if (possibleIndex$LWS > -1 && NumberIsInteger$LWS$1(possibleIndex$LWS) && possibleIndex$LWS < ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, [])) {
          const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);
          // istanbul ignore else: needs default platform behavior test
          if (isWindow$LWS(value$LWS)) {
            return value$LWS;
          }
        }
        return undefined;
      };
      const getFrameByNameKey$LWS = key$LWS => {
        if (typeof key$LWS === 'string' &&
        // Don't shadow properties on the global object...
        !ObjectHasOwn$LWS$1(globalObject$LWS, key$LWS) &&
        // ...Or its prototype.
        !ObjectHasOwn$LWS$1(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);
          if (isWindow$LWS(value$LWS)) {
            return value$LWS;
          }
        }
        return undefined;
      };
      const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);
      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getValueByKey$LWS(key$LWS);
          return value$LWS === undefined ?
          // window.frames.foo when iframe.name is 'foo'
          ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) :
          // window.frames.length
          // window.frames[n]
          // window.frames['n']
          value$LWS;
        }
        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === 'length') {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              get: framesLengthGetter$LWS,
              set: framesLengthSetter$LWS
            };
          }
          const value$LWS = getFrameByIndexKey$LWS(key$LWS);
          if (value$LWS) {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }
          return undefined;
        }
        // istanbul ignore next: suspicious gap, currently unreachable via tests
        has(target$LWS, key$LWS) {
          return ReflectHas$LWS(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
        }
        ownKeys() {
          const {
            length: length$LWS
          } = globalObject$LWS;
          const keys$LWS = ArrayCtor$LWS$1(length$LWS + 1);
          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }
          keys$LWS[length$LWS] = 'length';
          return keys$LWS;
        }
      }
      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === undefined ?
          // window.frames.foo when iframe.name is 'foo'
          ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : /* istanbul ignore next: needs default platform behavior test */value$LWS;
        }
        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          if (value$LWS === undefined) {
            return value$LWS;
          }
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }
        // istanbul ignore next: suspicious gap, currently unreachable via tests
        has(target$LWS, key$LWS) {
          return ReflectHas$LWS(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
        }
        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
          ReflectSetPrototypeOf$LWS$1(unsafeDescs$LWS, null);
          for (const key$LWS in unsafeDescs$LWS) {
            // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
            if (typeof key$LWS === 'string') {
              const unsafeDesc$LWS = unsafeDescs$LWS[key$LWS];
              if (ObjectHasOwn$LWS$1(unsafeDesc$LWS, 'value') && isWindow$LWS(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }
          return keys$LWS;
        }
      }
      // In order to preserve window.frames === window.frames, create a
      // shadow target object, to be used with the proxy object that is
      // returned by accesses to window.frames.
      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = new ShadowFrameHandler$LWS();
      const shadowFramesPrototypeHandler$LWS = new ShadowFramesPrototypeHandler$LWS();
      const shadowWindowPropertiesHandler$LWS = new ShadowWindowPropertiesHandler$LWS();
      const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      ReflectSetPrototypeOf$LWS$1(shadowFrames$LWS, framesPrototypeProxy$LWS);
      ReflectSetPrototypeOf$LWS$1(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      return new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
    };
    let framesProxy$LWS;
    const distortionEntry$LWS = [originalWindowFramesGetter$LWS,
    // eslint-disable-next-line prefer-arrow-callback
    function frames$LWS() {
      if (framesProxy$LWS === undefined) {
        framesProxy$LWS = createFramesProxy$LWS();
      }
      return framesProxy$LWS;
    }];
    return function distortionWindowFramesGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowGetComputedStyle$LWS({
    globalObject: {
      getComputedStyle: originalGetComputedStyle$LWS
    }
  }) {
    const distortionEntry$LWS = [originalGetComputedStyle$LWS, function getComputedStyle$LWS(...args$LWS) {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalGetComputedStyle$LWS, this, args$LWS));
    }];
    return function distortionWindowGetComputedStyle$LWS() {
      return distortionEntry$LWS;
    };
  }
  function length$LWS() {
    return 0;
  }
  function initDistortionWindowLengthGetter$LWS({
    globalObject: globalObject$LWS
  }) {
    const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, 'length');
    // istanbul ignore if: currently unreachable via tests
    if (typeof originalLengthGetter$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalLengthGetter$LWS, length$LWS];
    return function distortionWindowLengthGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowOnrejectionhandled$LWS({
    globalObject: globalObject$LWS,
    globalObject: {
      Window: Window$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'rejectionhandled');
  }
  function initDistortionWindowOnsecuritypolicyviolation$LWS({
    globalObject: globalObject$LWS,
    globalObject: {
      Window: Window$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'securitypolicyviolation');
  }
  function initDistortionWindowOnstorage$LWS({
    globalObject: globalObject$LWS,
    globalObject: {
      Window: Window$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'storage');
  }
  function initDistortionWindowOnunhandledrejection$LWS({
    globalObject: globalObject$LWS,
    globalObject: {
      Window: Window$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'unhandledrejection');
  }
  function initDistortionWindowOpen$LWS({
    globalObject: {
      open: originalWindowOpen$LWS
    }
  }) {
    const distortionEntry$LWS = [originalWindowOpen$LWS, function open$LWS(...args$LWS) {
      const normalizedArgs$LWS = normalizeWindowOpenArguments$LWS(args$LWS);
      const childWindow$LWS = ReflectApply$LWS$1(originalWindowOpen$LWS, this, normalizedArgs$LWS);
      // W-14218118
      // If the target is '_self', '_parent', or '_top', only makes one request
      if (normalizedArgs$LWS.length > 1) {
        const {
          1: target$LWS
        } = normalizedArgs$LWS;
        const willOpenInSameBrowsingContext$LWS = target$LWS === '_self' || target$LWS === '_parent' || target$LWS === '_top';
        if (willOpenInSameBrowsingContext$LWS) {
          return childWindow$LWS;
        }
      }
      // W-13552831
      // If the target is anything else, two requests are made
      if (childWindow$LWS && normalizedArgs$LWS.length) {
        initWindowOpenChildWindow$LWS(childWindow$LWS, normalizedArgs$LWS[0]);
      }
      return childWindow$LWS;
    }];
    return function distortionWindowOpen$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowPostMessage$LWS({
    globalObject: {
      postMessage: originalPostMessage$LWS
    }
  }) {
    const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
      } catch (error) {
        // We don't check if `error instance of DOMException` because
        // accessing `DOMException` of the `globalObject` will throw
        // an error for opaque windows.
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS) {
          const message$LWS = args$LWS[0];
          if (isObject$LWS$1(message$LWS)) {
            // Calling `window.postMessage(message, target, transfer)`
            // is equivalent to `window.postMessage(message, { targetOrigin, transfer })`.
            const providedOptions$LWS = length$LWS > 1 ? args$LWS[1] : /* istanbul ignore next: currently unreachable via tests */undefined;
            if (isObjectLike$LWS(providedOptions$LWS)) {
              // Structured clone all arguments so that `transfer`
              // is referenced correctly within `message`.
              args$LWS = partialStructuredClone$LWS(args$LWS);
            } else {
              args$LWS[0] = partialStructuredClone$LWS(message$LWS);
            }
            return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionWindowPostMessage$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowSetInterval$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setInterval: originalSetInterval$LWS
    }
  }) {
    return function distortionWndowSetInterval$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalSetInterval$LWS, function setInterval$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: callback$LWS
          } = args$LWS;
          if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
            // Snapshot callback source to prevent shapeshifting.
            const sourceText$LWS = toString$LWS(callback$LWS);
            // Defer transforming source text asynchronously.
            let transformedSourceText$LWS;
            // Replace callback parameter.
            args$LWS[0] = () => {
              // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
              if (transformedSourceText$LWS === undefined) {
                transformedSourceText$LWS = transformSourceText$LWS(sourceText$LWS);
              }
              sandboxEvaluator$LWS(transformedSourceText$LWS, UNCOMPILED_CONTEXT$LWS);
            };
          }
        }
        return ReflectApply$LWS$1(originalSetInterval$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionWindowSetTimeout$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setTimeout: originalSetTimeout$LWS
    }
  }) {
    return function distortionWindowSetTimeout$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalSetTimeout$LWS, function setTimeout$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: callback$LWS
          } = args$LWS;
          if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
            // Snapshot callback source to prevent shapeshifting.
            const sourceText$LWS = toString$LWS(callback$LWS);
            // Replace callback parameter.
            args$LWS[0] = () => {
              // Defer transforming source text asynchronously.
              sandboxEvaluator$LWS(transformSourceText$LWS(sourceText$LWS), UNCOMPILED_CONTEXT$LWS);
            };
          }
        }
        return ReflectApply$LWS$1(originalSetTimeout$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionWindowStructuredClone$LWS({
    // @ts-ignore: Prevent property existence error.
    globalObject: {
      DOMException: DOMException$LWS,
      structuredClone: originalStructuredClone$LWS
    }
  }) {
    // istanbul ignore if: currently unreachable via tests
    if (typeof originalStructuredClone$LWS !== 'function') {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalStructuredClone$LWS, function structuredClone$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
      } catch (error) {
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS && error instanceof DOMException$LWS) {
          const message$LWS = args$LWS[0];
          if (isObject$LWS$1(message$LWS)) {
            const providedOptions$LWS = length$LWS > 1 ? args$LWS[1] : undefined;
            if (isObjectLike$LWS(providedOptions$LWS)) {
              const {
                transfer: transfer$LWS
              } = providedOptions$LWS;
              args$LWS[1] = {
                // The structuredClone function accepts inherited
                // options property values.
                __proto__: providedOptions$LWS,
                // Shadow any inherited value.
                transfer: transfer$LWS
              };
              // Structured clone all arguments so that `options.transfer`
              // is referenced correctly within `value`.
              args$LWS = partialStructuredClone$LWS(args$LWS);
            } else {
              args$LWS[0] = partialStructuredClone$LWS(message$LWS);
            }
            return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionWindowStructuredClone$LWS() {
      return distortionEntry$LWS;
    };
  }
  function Worker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create Worker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
  }
  function initDistortionWorkerCtor$LWS({
    globalObject: {
      Worker: originalWorkerCtor$LWS
    }
  }) {
    const distortionEntry$LWS = [originalWorkerCtor$LWS, Worker$LWS];
    return function distortionWorkerCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWorkerProto$LWS({
    globalObject: {
      Worker: {
        prototype: originalPrototype$LWS
      }
    }
  }) {
    const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
    return function distortionWorkerProto$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionXMLHttpRequestOpen$LWS({
    globalObject: {
      XMLHttpRequest: {
        prototype: {
          open: originalOpen$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalOpen$LWS, function open$LWS(...args$LWS) {
      // Let the native method handle missing parameters error or null/undefined URL case.
      const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;
      if (url$LWS !== null && url$LWS !== undefined) {
        const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        if (!isValidURL$LWS(parsedURL$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
        }
        args$LWS[1] = parsedURL$LWS.normalizedURL;
      }
      ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
    }];
    return function distortionXMLHttpRequestOpen$LWS() {
      return distortionEntry$LWS;
    };
  }
  function replaceDocumentContent$LWS(doc$LWS, content$LWS) {
    const docImpl$LWS = ReflectApply$LWS$1(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
    const newDoc$LWS = ReflectApply$LWS$1(DOMImplementationProtoCreateDocument$LWS, docImpl$LWS, [NAMESPACE_XHTML$LWS, 'html']);
    const newDocEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, newDoc$LWS, []);
    ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, newDocEl$LWS, [content$LWS]);
    return newDoc$LWS;
  }
  function initDistortionXMLHttpRequestResponseGetter$LWS({
    document: document$LWS,
    globalObject: {
      Document: Document$LWS,
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  }) {
    const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, 'response');
    return function distortionXMLHttpRequestResponseGetter$LWS({
      key: key$LWS
    }) {
      return [originalResponseGetter$LWS, function response$LWS() {
        const rawResponse$LWS = ReflectApply$LWS$1(originalResponseGetter$LWS, this, []);
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        if (rawResponse$LWS instanceof Document$LWS) {
          const docEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, rawResponse$LWS, []);
          const content$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
          return replaceDocumentContent$LWS(rawResponse$LWS, lwsInternalPolicy$LWS.createHTML(content$LWS, key$LWS, ContentType$LWS.HTML));
        }
        return rawResponse$LWS;
      }];
    };
  }
  function initDistortionXMLHttpRequestResponseXMLGetter$LWS({
    document: document$LWS,
    globalObject: {
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  }) {
    const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, 'responseXML');
    return function distortionXMLHttpRequestResponseXMLGetter$LWS({
      key: key$LWS
    }) {
      return [originalResponseXMLGetter$LWS, function responseXML$LWS() {
        const rawResponseXML$LWS = ReflectApply$LWS$1(originalResponseXMLGetter$LWS, this, []);
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        const docEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, rawResponseXML$LWS, []);
        const content$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
        return replaceDocumentContent$LWS(rawResponseXML$LWS, lwsInternalPolicy$LWS.createHTML(content$LWS, key$LWS, ContentType$LWS.HTML));
      }];
    };
  }

  /*
  Naming convention for DistortionFactory function types:
      distortion[ObjectName][PropertyName] : used for property values
      distortion[ObjectName][PropertyName]Getter : used for property getters
      distortion[ObjectName][PropertyName]Setter : used for property setters
      distortion[ObjectName]Ctor : used for object constructors
      distortion[ObjectName]Proto : used for the object prototype itself
  */
  const internalDistortionFactoryInitializers$LWS = [
  // CSSStyleRule
  initDistortionCSSStyleRuleStyleGetter$LWS,
  // Document
  initDistortionDocumentDomainSetter$LWS, initDistortionDocumentOnsecuritypolicyviolation$LWS, initDistortionDocumentOpen$LWS,
  // Element
  initDistortionElementAttributesGetter$LWS, initDistortionElementGetInnerHTML$LWS, initDistortionElementRemove$LWS, initDistortionElementReplaceChildren$LWS, initDistortionElementReplaceWith$LWS,
  // Function
  initDistortionFunction$LWS,
  // History
  initDistortionHistoryPushState$LWS, initDistortionHistoryReplaceState$LWS,
  // HTMLElement
  initDistortionHTMLElementDatasetGetter$LWS, initDistortionHTMLElementInnerTextSetter$LWS, initDistortionHTMLElementOuterTextSetter$LWS, initDistortionHTMLElementStyleGetter$LWS,
  // HTMLIFrameElement
  initDistortionIFrameElementContentDocumentGetter$LWS, initDistortionIFrameElementContentWindowGetter$LWS, initDistortionHTMLIFrameElementSrcSetter$LWS,
  // HTMLLinkElement
  initDistortionHTMLLinkElementRelSetter$LWS, initDistortionHTMLLinkElementRelListSetter$LWS,
  // HTMLObjectElement
  initDistortionHTMLObjectElementDataSetter$LWS,
  // HTMLScriptElement
  initDistortionHTMLScriptElementSrcGetter$LWS, initDistortionHTMLScriptElementTextSetter$LWS,
  // IDBObjectStore
  initDistortionIDBObjectStoreAdd$LWS, initDistortionIDBObjectStorePut$LWS,
  // MessagePort
  initDistortionMessagePortPostMessage$LWS,
  // Navigator
  initDistortionNavigatorSendBeacon$LWS, initDistortionNavigatorServiceWorkerGetter$LWS,
  // Node
  initDistortionNodeRemoveChild$LWS, initDistortionNodeReplaceChild$LWS,
  // Performance
  initDistortionPerformanceMark$LWS, initDistortionPerformanceMeasure$LWS,
  // PerformanceMark
  initDistortionPerformanceMarkCtor$LWS,
  // Notification
  initDistortionNotificationCtor$LWS,
  // Range
  initDistortionRangeDeleteContents$LWS, initDistortionRangeExtractContents$LWS, initDistortionRangeInsertNode$LWS, initDistortionRangeSelectNode$LWS, initDistortionRangeSelectNodeContents$LWS, initDistortionRangeSetEnd$LWS, initDistortionRangeSetEndAfter$LWS, initDistortionRangeSetEndBefore$LWS, initDistortionRangeSetStart$LWS, initDistortionRangeSetStartAfter$LWS, initDistortionRangeSetStartBefore$LWS, initDistortionRangeSurroundContents$LWS,
  // Selection
  initDistortionSelectionCollapse$LWS, initDistortionSelectionExtend$LWS, initDistortionSelectionSelectAllChildren$LWS, initDistortionSelectionSetBaseAndExtent$LWS, initDistortionSelectionSetPosition$LWS,
  // ServiceWorkerContainer
  initDistortionServiceWorkerContainerProto$LWS,
  // SharedWorker
  initDistortionSharedWorkerCtor$LWS, initDistortionSharedWorkerProto$LWS,
  // Storage
  initDistortionStorage$LWS, initDistortionStorageClear$LWS, initDistortionStorageGetItem$LWS, initDistortionStorageKey$LWS, initDistortionStorageLength$LWS, initDistortionStorageRemoveItem$LWS, initDistortionStorageSetItem$LWS,
  // SVGAnimateElement
  initDistortionSVGAnimateElementFromAttribute$LWS, initDistortionSVGAnimateElementToAttribute$LWS, initDistortionSVGAnimateElementValuesAttribute$LWS,
  // SVGElement
  initDistortionSVGElementDatasetGetter$LWS, initDistortionSVGElementStyleGetter$LWS,
  // SVGSetElement
  initDistortionSVGSetElementToAttribute$LWS,
  // SVGUseElement
  initDistortionSVGUseElementHrefAttribute$LWS, initDistortionSVGUseElementXlinkHrefAttribute$LWS,
  // TrustedTypePolicyFactory
  initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS,
  // Window
  initDistortionWindowFetch$LWS, initDistortionWindowFramesGetter$LWS, initDistortionWindowGetComputedStyle$LWS, initDistortionWindowLengthGetter$LWS, initDistortionWindowOpen$LWS, initDistortionWindowPostMessage$LWS, initDistortionWindowStructuredClone$LWS,
  // Worker
  initDistortionWorkerCtor$LWS, initDistortionWorkerProto$LWS,
  // XHR
  initDistortionXMLHttpRequestOpen$LWS];
  const internalKeyedDistortionFactoryInitializers$LWS = [
  // Attr
  initDistortionAttrValueSetter$LWS,
  // Aura
  initDistortionAuraUtilGlobalEval$LWS,
  // CacheStorage
  initDistortionCacheStorageDelete$LWS, initDistortionCacheStorageHas$LWS, initDistortionCacheStorageKeys$LWS, initDistortionCacheStorageMatch$LWS, initDistortionCacheStorageOpen$LWS,
  // CookieStore
  initDistortionCookieStoreDelete$LWS, initDistortionCookieStoreGet$LWS, initDistortionCookieStoreGetAll$LWS, initDistortionCookieStoreOnChange$LWS, initDistortionCookieStoreSet$LWS,
  // CustomElementRegistry
  initDistortionCustomElementRegistryDefine$LWS, initDistortionCustomElementRegistryGet$LWS, initDistortionCustomElementRegistryUpgrade$LWS, initDistortionCustomElementRegistryWhenDefined$LWS,
  // Document
  initDistortionDocumentCookieGetter$LWS, initDistortionDocumentCookieSetter$LWS, initDistortionDocumentCreateElement$LWS, initDistortionDocumentCreateElementNS$LWS, initDistortionDocumentExecCommand$LWS, initDistortionDocumentReplaceChildren$LWS,
  // DOMParser
  initDistortionDOMParserParseFromString$LWS,
  // Element
  initDistortionElementAttachShadow$LWS, initDistortionElementInnerHTMLSetter$LWS, initDistortionElementInsertAdjacentHTML$LWS, initDistortionElementOuterHTMLSetter$LWS, initDistortionElementSetAttribute$LWS, initDistortionElementSetAttributeNode$LWS, initDistortionElementSetAttributeNodeNS$LWS, initDistortionElementSetAttributeNS$LWS, initDistortionElementSetHTML$LWS, initDistortionElementShadowRootGetter$LWS, initDistortionElementToggleAttribute$LWS,
  // Eval
  initDistortionEval$LWS,
  // Event
  initDistortionEventComposedPath$LWS, initDistortionEventPathGetter$LWS,
  // EventTarget
  initDistortionEventTargetAddEventListener$LWS,
  // HTMLBodyElement
  initDistortionHTMLBodyElementOnrejectionhandled$LWS, initDistortionHTMLBodyElementOnstorage$LWS, initDistortionHTMLBodyElementOnunhandledrejection$LWS,
  // HTMLElement
  initDistortionHTMLElementCtor$LWS,
  // HTMLFrameSetElement
  initDistortionHTMLFrameSetElementOnrejectionhandled$LWS, initDistortionHTMLFrameSetElementOnstorage$LWS, initDistortionHTMLFrameSetElementOnunhandledrejection$LWS,
  // HTMLScriptElement,
  initDistortionHTMLScriptElementSrcSetter$LWS, initDistortionHTMLScriptElementTextSetter$LWS,
  // NamedNodeMap
  initDistortionNamedNodeMapSetNamedItem$LWS, initDistortionNamedNodeMapSetNamedItemNS$LWS,
  // Node
  initDistortionNodeValueSetter$LWS, initDistortionNodeTextContentGetter$LWS, initDistortionNodeTextContentSetter$LWS,
  // Range
  initDistortionRangeCreateContextualFragment$LWS,
  // ShadowRoot
  initDistortionShadowRootInnerHTMLSetter$LWS,
  // Storage
  initDistortionLocalStorage$LWS, initDistortionSessionStorage$LWS,
  // SVGAnimationElement
  initDistortionSVGAnimateElementAttributeNameAttribute$LWS,
  // SVGScriptElement
  initDistortionSVGScriptElementHrefGetter$LWS, initDistortionSVGScriptElementHrefSetter$LWS,
  // SVGSetElement
  initDistortionSVGSetElementAttributeNameAttribute$LWS,
  // URL
  initDistortionURLCreateObjectURL$LWS,
  // Window
  initDistortionWindowOnrejectionhandled$LWS, initDistortionWindowOnsecuritypolicyviolation$LWS, initDistortionWindowOnstorage$LWS, initDistortionWindowOnunhandledrejection$LWS, initDistortionWindowSetInterval$LWS, initDistortionWindowSetTimeout$LWS,
  // XHR
  initDistortionXMLHttpRequestResponseGetter$LWS, initDistortionXMLHttpRequestResponseXMLGetter$LWS];
  const externalDistortionFactoryInitializers$LWS = ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, [
  // Element
  initDistortionElementAfter$LWS, initDistortionElementAppend$LWS, initDistortionElementBefore$LWS, initDistortionElementInsertAdjacentElement$LWS, initDistortionElementPrepend$LWS,
  // Node
  // The initDistortionNodeAppendChild distortion is temporarily disabled
  // until W-10409618 is resolved..
  // initDistortionNodeAppendChild,
  initDistortionNodeInsertBefore$LWS]);
  const externalKeyedDistortionFactoryInitializers$LWS = internalKeyedDistortionFactoryInitializers$LWS;
  toSafeMap$LWS$1(new MapCtor$LWS$1([[initDistortionCacheStorageDelete$LWS, 'caches'], [initDistortionCacheStorageHas$LWS, 'caches'], [initDistortionCacheStorageKeys$LWS, 'caches'], [initDistortionCacheStorageMatch$LWS, 'caches'], [initDistortionCacheStorageOpen$LWS, 'caches'], [initDistortionCookieStoreDelete$LWS, 'cookieStore'], [initDistortionCookieStoreGet$LWS, 'cookieStore'], [initDistortionCookieStoreGetAll$LWS, 'cookieStore'], [initDistortionCookieStoreOnChange$LWS, 'cookieStore'], [initDistortionCookieStoreSet$LWS, 'cookieStore'], [initDistortionCSSStyleRuleStyleGetter$LWS, 'style'], [initDistortionCustomElementRegistryDefine$LWS, 'customElements'], [initDistortionCustomElementRegistryGet$LWS, 'customElements'], [initDistortionCustomElementRegistryUpgrade$LWS, 'customElements'], [initDistortionCustomElementRegistryWhenDefined$LWS, 'customElements'], [initDistortionDocumentCookieGetter$LWS, 'documentCookie'], [initDistortionDocumentCookieSetter$LWS, 'documentCookie'], [initDistortionDocumentDomainSetter$LWS, 'documentDomain'], [initDistortionDocumentExecCommand$LWS, 'documentExecCommand'], [initDistortionDOMParserParseFromString$LWS, 'domParserParseFromString'], [initDistortionElementAfter$LWS, 'element'], [initDistortionElementAppend$LWS, 'element'], [initDistortionElementAttributesGetter$LWS, 'attributes'], [initDistortionElementBefore$LWS, 'element'], [initDistortionElementGetInnerHTML$LWS, 'innerHTML'], [initDistortionElementInnerHTMLSetter$LWS, 'innerHTML'], [initDistortionElementInsertAdjacentElement$LWS, 'element'], [initDistortionElementInsertAdjacentHTML$LWS, 'element'], [initDistortionElementOuterHTMLSetter$LWS, 'element'], [initDistortionElementPrepend$LWS, 'element'], [initDistortionElementRemove$LWS, 'element'], [initDistortionElementReplaceChildren$LWS, 'element'], [initDistortionElementReplaceWith$LWS, 'element'], [initDistortionElementSetAttribute$LWS, 'attributes'], [initDistortionElementSetAttributeNode$LWS, 'attributes'], [initDistortionElementSetAttributeNodeNS$LWS, 'attributes'], [initDistortionElementSetAttributeNS$LWS, 'attributes'], [initDistortionElementSetHTML$LWS, 'element'], [initDistortionElementToggleAttribute$LWS, 'attributes'], [initDistortionHistoryPushState$LWS, 'history'], [initDistortionHistoryReplaceState$LWS, 'history'], [initDistortionHTMLElementDatasetGetter$LWS, 'dataset'], [initDistortionHTMLElementStyleGetter$LWS, 'style'], [initDistortionHTMLScriptElementSrcGetter$LWS, 'script'], [initDistortionHTMLScriptElementSrcSetter$LWS, 'script'], [initDistortionHTMLScriptElementTextSetter$LWS, 'script'], [initDistortionIDBObjectStoreAdd$LWS, 'indexedDB'], [initDistortionIDBObjectStorePut$LWS, 'indexedDB'], [initDistortionLocalStorage$LWS, 'storage'], [initDistortionMessagePortPostMessage$LWS, 'postMessage'], [initDistortionNamedNodeMapSetNamedItem$LWS, 'attributes'], [initDistortionNamedNodeMapSetNamedItemNS$LWS, 'attributes'], [initDistortionNavigatorSendBeacon$LWS, 'navigatorSendBeacon'], [initDistortionNodeInsertBefore$LWS, 'node'], [initDistortionNodeRemoveChild$LWS, 'node'], [initDistortionNodeReplaceChild$LWS, 'node'], [initDistortionNodeTextContentGetter$LWS, 'node'], [initDistortionNodeTextContentSetter$LWS, 'node'], [initDistortionNodeValueSetter$LWS, 'node'], [initDistortionNotificationCtor$LWS, 'notification'], [initDistortionPerformanceMark$LWS, 'performance'], [initDistortionPerformanceMarkCtor$LWS, 'performance'], [initDistortionPerformanceMeasure$LWS, 'performance'], [initDistortionRangeCreateContextualFragment$LWS, 'range'], [initDistortionRangeDeleteContents$LWS, 'range'], [initDistortionRangeExtractContents$LWS, 'range'], [initDistortionRangeInsertNode$LWS, 'range'], [initDistortionRangeSelectNode$LWS, 'range'], [initDistortionRangeSelectNodeContents$LWS, 'range'], [initDistortionRangeSetEnd$LWS, 'range'], [initDistortionRangeSetEndAfter$LWS, 'range'], [initDistortionRangeSetEndBefore$LWS, 'range'], [initDistortionRangeSetStart$LWS, 'range'], [initDistortionRangeSetStartAfter$LWS, 'range'], [initDistortionRangeSetStartBefore$LWS, 'range'], [initDistortionRangeSurroundContents$LWS, 'range'], [initDistortionSelectionCollapse$LWS, 'selection'], [initDistortionSelectionExtend$LWS, 'selection'], [initDistortionSelectionSelectAllChildren$LWS, 'selection'], [initDistortionSelectionSetBaseAndExtent$LWS, 'selection'], [initDistortionSelectionSetPosition$LWS, 'selection'], [initDistortionSessionStorage$LWS, 'storage'], [initDistortionShadowRootInnerHTMLSetter$LWS, 'innerHTML'], [initDistortionStorage$LWS, 'storage'], [initDistortionStorageClear$LWS, 'storage'], [initDistortionStorageGetItem$LWS, 'storage'], [initDistortionStorageKey$LWS, 'storage'], [initDistortionStorageLength$LWS, 'storage'], [initDistortionStorageRemoveItem$LWS, 'storage'], [initDistortionStorageSetItem$LWS, 'storage'], [initDistortionSVGElementDatasetGetter$LWS, 'dataset'], [initDistortionSVGElementStyleGetter$LWS, 'style'], [initDistortionSVGScriptElementHrefGetter$LWS, 'script'], [initDistortionSVGScriptElementHrefSetter$LWS, 'script'], [initDistortionWindowFetch$LWS, 'windowFetch'], [initDistortionWindowFramesGetter$LWS, 'windowFrames'], [initDistortionWindowGetComputedStyle$LWS, 'style'], [initDistortionWindowLengthGetter$LWS, 'windowFrames'], [initDistortionWindowPostMessage$LWS, 'postMessage'], [initDistortionWindowSetInterval$LWS, 'setInterval'], [initDistortionWindowSetTimeout$LWS, 'setTimeout'], [initDistortionXMLHttpRequestResponseGetter$LWS, 'xhr'], [initDistortionXMLHttpRequestResponseXMLGetter$LWS, 'xhr']]));
  const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
  const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
  const EventBlockedProperties$LWS = ['originalTarget', 'explicitOriginalTarget'];
  const HTMLElementBlockedAttributes$LWS = ['nonce'];
  const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
  const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument'];

  // https://www.w3schools.com/tags/tag_iframe.asp
  const HTMLIFrameElementBlockedAttributes$LWS = ['srcdoc'];
  const HTMLIFrameElementBlockedProperties$LWS = ['getSVGDocument', 'srcdoc'];
  const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
  const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
  const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
  const SVGElementBlockedAttributes$LWS = ['nonce'];
  const SVGElementBlockedProperties$LWS = ['nonce'];
  const UIEventBlockedProperties$LWS = ['rangeParent'];
  const WindowBlockedProperties$LWS = ['find', 'requestFileSystem', 'webkitRequestFileSystem'];
  const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];
  /*! version: 0.21.7 */

  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const rootSandboxRegistry$LWS = {
    __proto__: null
  };
  const documentSandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[rootDocument$LWS, rootSandboxRegistry$LWS]]));
  const opaqueWindowSandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function getOpaqueSandboxRegistry$LWS(globalObject$LWS) {
    // Use the `document` as the key because a window object maintains its
    // identity continuity when its location changes and while the
    // non-configurable document property does not.
    let sandboxRegistry$LWS = opaqueWindowSandboxRegistryCache$LWS.get(globalObject$LWS);
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (sandboxRegistry$LWS === undefined) {
      sandboxRegistry$LWS = {
        __proto__: null
      };
      opaqueWindowSandboxRegistryCache$LWS.set(globalObject$LWS, sandboxRegistry$LWS);
    }
    return sandboxRegistry$LWS;
  }
  function getSandboxRegistry$LWS(document$LWS) {
    // Use the `document` as the key because a window object maintains its
    // identity continuity when its location changes and while the
    // non-configurable document property does not.
    let sandboxRegistry$LWS = documentSandboxRegistryCache$LWS.get(document$LWS);
    if (sandboxRegistry$LWS === undefined) {
      sandboxRegistry$LWS = {
        __proto__: null
      };
      documentSandboxRegistryCache$LWS.set(document$LWS, sandboxRegistry$LWS);
    }
    return sandboxRegistry$LWS;
  }
  const LightningWebSecurity$LWS = {
    __proto__: null
  };
  toSafeMap$LWS$1(new MapCtor$LWS$1());
  ObjectFreeze$LWS$1(LightningWebSecurity$LWS);
  const distortionFactoriesCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const opaqueWindowPostMessageDistortionFactoryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  // WebKit based browsers have a bug that prematurely removes distortion entries
  // from the distortions weak map.
  const SUPPORTS_DISTORTIONS_WEAK_MAP$LWS = !IS_WEBKIT_BROWSER$LWS;
  function createDistortionEntries$LWS(record$LWS, factories$LWS) {
    toSafeMap$LWS$1(new MapCtor$LWS$1());
    const entries$LWS = [];
    for (let i$LWS = 0, {
        length: length$LWS
      } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const factory$LWS = factories$LWS[i$LWS];
      const entry$LWS = factory$LWS(record$LWS);
      if (entry$LWS) {
        const {
          0: originalValue$LWS,
          1: distortedValue$LWS
        } = entry$LWS;
        if (typeof originalValue$LWS === 'function') {
          const proxyMaskedFunctionDistortion$LWS = proxyMaskFunctionDistortion$LWS(record$LWS, factory$LWS, distortedValue$LWS, originalValue$LWS);
          entries$LWS[entries$LWS.length] = [originalValue$LWS, proxyMaskedFunctionDistortion$LWS];
        } else {
          // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
          if (typeof originalValue$LWS === 'object' && originalValue$LWS !== null) {
            // TODO: we may need to make this assigned value a proxy when ENABLE_DISTORTION_TOGGLE_SWITCHES is true,
            // allowing us to change which value is provided for the distortion.
            entries$LWS[entries$LWS.length] = entry$LWS;
          }
        }
      }
    }
    return entries$LWS;
  }
  function createDistortionMap$LWS(entries$LWS) {
    return SUPPORTS_DISTORTIONS_WEAK_MAP$LWS ? toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1(entries$LWS)) :
    // istanbul ignore next: this code is not reachable in the coverage run.
    toSafeMap$LWS$1(new MapCtor$LWS$1(entries$LWS));
  }
  function getDistortionFactories$LWS(record$LWS) {
    const {
      document: document$LWS,
      globalObject: globalObject$LWS,
      type: type$LWS
    } = record$LWS;
    let factories$LWS = distortionFactoriesCache$LWS.get(document$LWS);
    if (factories$LWS) {
      return factories$LWS;
    }
    const {
      Document: Document$LWS,
      Element: Element$LWS,
      Event: Event$LWS,
      HTMLElement: HTMLElement$LWS,
      HTMLIFrameElement: HTMLIFrameElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      SVGElement: SVGElement$LWS,
      UIEvent: UIEvent$LWS,
      XSLTProcessor: XSLTProcessor$LWS
    } = globalObject$LWS;
    const initializers$LWS = type$LWS === 1 /* SandboxType.Internal */ ?
    // instanbul ignore next: coverage is collected on the external sandbox test run
    ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, internalKeyedDistortionFactoryInitializers$LWS) : ArrayConcat$LWS(externalDistortionFactoryInitializers$LWS, externalKeyedDistortionFactoryInitializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(HTMLElement$LWS, 'HTMLElement', HTMLElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(HTMLIFrameElement$LWS, 'HTMLIFrameElement', HTMLIFrameElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(HTMLScriptElement$LWS, 'HTMLScriptElement', HTMLScriptElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(SVGElement$LWS, 'SVGElement', SVGElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, Document$LWS.prototype, DocumentBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, Element$LWS.prototype, ElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, Event$LWS.prototype, EventBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, UIEvent$LWS.prototype, UIEventBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, globalObject$LWS, WindowBlockedProperties$LWS, initializers$LWS);
    // istanbul ignore else: this is a safety precaution that is unreachable via tests
    if (typeof XSLTProcessor$LWS === 'function') {
      addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS, initializers$LWS);
    }
    patchGlobalObject$LWS(globalObject$LWS, document$LWS);
    // Reuse the `initializers` array as the `factories` array.
    factories$LWS = initializers$LWS;
    for (let i$LWS = 0, {
        length: length$LWS
      } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
      factories$LWS[i$LWS] = initializers$LWS[i$LWS](record$LWS);
    }
    // Finalize attribute distortions last because the attribute registry is
    // populated by the other distortion factories.
    factories$LWS[factories$LWS.length] = finalizeAttributeDistortions$LWS;
    distortionFactoriesCache$LWS.set(document$LWS, factories$LWS);
    return factories$LWS;
  }
  function getOpaqueWindowPostMessageDistortionFactory$LWS(record$LWS) {
    const {
      globalObject: globalObject$LWS
    } = record$LWS;
    let opaqueWindowPostMessageDistortionFactory$LWS = opaqueWindowPostMessageDistortionFactoryCache$LWS.get(globalObject$LWS);
    // istanbul ignore next: this is a safety precaution that is unreachable via tests
    if (opaqueWindowPostMessageDistortionFactory$LWS) {
      return opaqueWindowPostMessageDistortionFactory$LWS;
    }
    opaqueWindowPostMessageDistortionFactory$LWS = initDistortionWindowPostMessage$LWS(record$LWS);
    opaqueWindowPostMessageDistortionFactoryCache$LWS.set(globalObject$LWS, opaqueWindowPostMessageDistortionFactory$LWS);
    return opaqueWindowPostMessageDistortionFactory$LWS;
  }
  function proxyMaskFunctionDistortion$LWS({
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    instrumentation: instrumentation$LWS,
    key: sandboxKey$LWS
  }, distortionFactory$LWS, distortionFunc$LWS, maskFunc$LWS) {
    let activityName$LWS;
    // istanbul ignore if: this is a safety precaution that is unreachable via tests
    if (LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS) {
      const {
        name: factoryName$LWS
      } = distortionFactory$LWS;
      activityName$LWS = factoryName$LWS ? ReflectApply$LWS$1(StringProtoReplace$LWS, factoryName$LWS, [LOCKER_IDENTIFIER_MARKER$LWS, '']) : '<unknown>';
    }
    return maskFunction$LWS(distortionFunc$LWS, maskFunc$LWS, {
      apply: function (target$LWS, thisArg$LWS, args$LWS) {
        const activity$LWS = LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS == null || instrumentation$LWS.startActivity == null ? void 0 : instrumentation$LWS.startActivity(activityName$LWS) : undefined;
        try {
          return ReflectApply$LWS$1(target$LWS, thisArg$LWS, args$LWS);
        } catch (error) {
          activity$LWS == null || activity$LWS.error({
            sandboxKey: sandboxKey$LWS,
            error
          });
          activity$LWS == null || activity$LWS.stop();
          throw error;
        } finally {
          activity$LWS == null || activity$LWS.stop();
        }
      },
      construct: function (target$LWS, args$LWS, newTarget$LWS) {
        const activity$LWS = LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS == null || instrumentation$LWS.startActivity == null ? void 0 : instrumentation$LWS.startActivity(activityName$LWS) : undefined;
        try {
          return ReflectConstruct$LWS(target$LWS, args$LWS, newTarget$LWS);
        } catch (error) {
          activity$LWS == null || activity$LWS.error({
            sandboxKey: sandboxKey$LWS,
            error
          });
          activity$LWS == null || activity$LWS.stop();
          throw error;
        } finally {
          activity$LWS == null || activity$LWS.stop();
        }
      }
    });
  }
  let lockerEvalContextValue$LWS;
  let lockerEvalHelpersValue$LWS;
  function clearEvalContext$LWS() {
    const evalContext$LWS = lockerEvalContextValue$LWS;
    lockerEvalContextValue$LWS = undefined;
    return evalContext$LWS;
  }
  function clearEvalHelpers$LWS() {
    const evalHelpers$LWS = lockerEvalHelpersValue$LWS;
    lockerEvalHelpersValue$LWS = undefined;
    return evalHelpers$LWS;
  }
  function setEvalContext$LWS(evalContext$LWS) {
    lockerEvalContextValue$LWS = evalContext$LWS;
  }
  function setEvalHelpers$LWS(evalHelpers$LWS) {
    lockerEvalHelpersValue$LWS = evalHelpers$LWS;
  }
  const CORE_SANDBOX_KEY$LWS = 'lws-core-sandbox';
  const DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS = {
    [SANDBOX_EVAL_CONTEXT_NAME$LWS]: {
      __proto__: null,
      get() {
        return clearEvalContext$LWS();
      }
    },
    [SANDBOX_EVAL_HELPERS_NAME$LWS]: {
      __proto__: null,
      get() {
        return clearEvalHelpers$LWS();
      }
    }
  };
  const EMPTY_DISTORTIONS_MAP$LWS = createDistortionMap$LWS();
  const EMPTY_OBJECT$LWS = {};
  const ROOT_UNCOMPILED_CONTEXT$LWS = {
    [UNCOMPILED_LOCATION_NAME$LWS]: rootWindowLocation$LWS,
    [UNCOMPILED_TOP_NAME$LWS]: rootWindowTop$LWS,
    // The following context entries are explicitly added because the
    // UNCOMPILED_*_NAME entries will only be added to the contextNames
    // via transforms when the fully qualified member expression is detected
    // in the code, eg. window.location, or window.top.
    // See complete explanation in packages/@locker/shared-dom/src/source-transformations.ts.
    location: rootWindowLocation$LWS,
    top: rootWindowTop$LWS
  };
  const {
    apply: ReflectApply$LWS,
    defineProperty: ReflectDefineProperty$LWS,
    deleteProperty: ReflectDeleteProperty$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    ownKeys: ReflectOwnKeys$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = Reflect;
  const ObjectCtor$LWS = Object;
  const {
    assign: ObjectAssign$LWS,
    freeze: ObjectFreeze$LWS,
    keys: ObjectKeys$LWS,
    prototype: ObjectProto$LWS
  } = ObjectCtor$LWS;
  const {
    hasOwn: OriginalObjectHasOwn$LWS
  } = ObjectCtor$LWS;
  const {
    __lookupGetter__: ObjectProtoLookupGetter$LWS,
    __lookupSetter__: ObjectProtoLookupSetter$LWS,
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS
  } = ObjectProto$LWS;
  const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : /* istanbul ignore next: currently unreachable via tests */function ObjectHasOwn$LWS(object$LWS, key$LWS) {
    return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
  };
  const {
    toString: ObjectProtoToString$LWS
  } = ObjectProto$LWS;
  function isObject$LWS(value$LWS) {
    return typeof value$LWS === 'object' && value$LWS !== null;
  }
  function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [key$LWS]);
  }
  const SymbolCtor$LWS = Symbol;
  const {
    for: SymbolFor$LWS,
    iterator: SymbolIterator$LWS,
    toStringTag: SymbolToStringTag$LWS,
    unscopables: SymbolUnscopables$LWS
  } = SymbolCtor$LWS;
  const ArrayCtor$LWS = Array;
  const {
    prototype: ArrayProto$LWS
  } = ArrayCtor$LWS;
  const {
    at: ArrayProtoAt$LWS,
    concat: ArrayProtoConcat$LWS,
    copyWithin: ArrayProtoCopyWithin$LWS,
    entries: ArrayProtoEntries$LWS,
    every: ArrayProtoEvery$LWS,
    fill: ArrayProtoFill$LWS,
    findIndex: ArrayProtoFindIndex$LWS,
    flat: ArrayProtoFlat$LWS,
    flatMap: ArrayProtoFlatMap$LWS,
    forEach: ArrayProtoForEach$LWS,
    join: ArrayProtoJoin$LWS,
    keys: ArrayProtoKeys$LWS,
    lastIndexOf: ArrayProtoLastIndexOf$LWS,
    pop: ArrayProtoPop$LWS,
    reduce: ArrayProtoReduce$LWS,
    reduceRight: ArrayProtoReduceRight$LWS,
    reverse: ArrayProtoReverse$LWS,
    slice: ArrayProtoSlice$LWS,
    some: ArrayProtoSome$LWS,
    toLocaleString: ArrayProtoToLocaleString$LWS,
    toString: ArrayProtoToString$LWS,
    values: ArrayProtoValues$LWS,
    [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
  } = ArrayProto$LWS;
  const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
    __proto__: null
  }, ArrayProto$LWS[SymbolUnscopables$LWS]));
  const {
    filter: ArrayProtoFilter$LWS,
    find: ArrayProtoFind$LWS,
    includes: ArrayProtoIncludes$LWS,
    indexOf: ArrayProtoIndexOf$LWS,
    map: ArrayProtoMap$LWS,
    push: ArrayProtoPush$LWS,
    shift: ArrayProtoShift$LWS,
    splice: ArrayProtoSplice$LWS,
    sort: ArrayProtoSort$LWS,
    unshift: ArrayProtoUnshift$LWS
  } = ArrayProto$LWS;
  const {
    isArray: ArrayIsArray$LWS
  } = ArrayCtor$LWS;
  function toSafeArray$LWS(array$LWS) {
    ReflectSetPrototypeOf$LWS(array$LWS, null);
    array$LWS.at = ArrayProtoAt$LWS;
    array$LWS.concat = ArrayProtoConcat$LWS;
    // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
    // https://bugs.chromium.org/p/v8/issues/detail?id=13202
    // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
    //
    // In V8 setting the constructor property of an array, promise, regexp, or
    // typed array triggers a de-opt because it could change an instance's
    // @@species. This de-opt affects at least `Array#splice` and occurs even
    // if the prototype of the array is change or nulled beforehand. Further,
    // the de-opt persists after a page refresh. It is not until navigating to
    // a different page that the performance of `Array#splice` is restored.
    array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
    array$LWS.entries = ArrayProtoEntries$LWS;
    array$LWS.every = ArrayProtoEvery$LWS;
    array$LWS.fill = ArrayProtoFill$LWS;
    array$LWS.filter = ArrayProtoFilter$LWS;
    array$LWS.find = ArrayProtoFind$LWS;
    array$LWS.findIndex = ArrayProtoFindIndex$LWS;
    array$LWS.flat = ArrayProtoFlat$LWS;
    array$LWS.flatMap = ArrayProtoFlatMap$LWS;
    array$LWS.forEach = ArrayProtoForEach$LWS;
    array$LWS.includes = ArrayProtoIncludes$LWS;
    array$LWS.indexOf = ArrayProtoIndexOf$LWS;
    array$LWS.join = ArrayProtoJoin$LWS;
    array$LWS.keys = ArrayProtoKeys$LWS;
    array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
    array$LWS.map = ArrayProtoMap$LWS;
    array$LWS.pop = ArrayProtoPop$LWS;
    array$LWS.push = ArrayProtoPush$LWS;
    array$LWS.reduce = ArrayProtoReduce$LWS;
    array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
    array$LWS.reverse = ArrayProtoReverse$LWS;
    array$LWS.shift = ArrayProtoShift$LWS;
    array$LWS.slice = ArrayProtoSlice$LWS;
    array$LWS.some = ArrayProtoSome$LWS;
    array$LWS.sort = ArrayProtoSort$LWS;
    array$LWS.splice = ArrayProtoSplice$LWS;
    array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
    array$LWS.toString = ArrayProtoToString$LWS;
    array$LWS.unshift = ArrayProtoUnshift$LWS;
    array$LWS.values = ArrayProtoValues$LWS;
    array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
    array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
    ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
    return array$LWS;
  }
  ObjectLookupOwnGetter$LWS(ArrayBuffer.prototype, 'byteLength');
  // Character constants.
  const CHAR_ELLIPSIS$LWS = '\u2026';
  // Near-membrane constants.
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');
  SymbolFor$LWS('@@lockerLiveValue');
  const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
  const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
  const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
  const TO_STRING_BRAND_STRING$LWS = '[object String]';
  const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
  const MapCtor$LWS = Map;
  const {
    prototype: MapProto$LWS
  } = MapCtor$LWS;
  const {
    clear: MapProtoClear$LWS,
    delete: MapProtoDelete$LWS,
    forEach: MapProtoForEach$LWS,
    get: MapProtoGet$LWS,
    has: MapProtoHas$LWS,
    keys: MapProtoKeys$LWS,
    values: MapProtoValues$LWS,
    [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
    [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
  } = MapProto$LWS;
  const {
    entries: MapProtoEntries$LWS,
    set: MapProtoSet$LWS
  } = MapProto$LWS;
  const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');
  function toSafeMap$LWS(map$LWS) {
    ReflectSetPrototypeOf$LWS(map$LWS, null);
    map$LWS.clear = MapProtoClear$LWS;
    map$LWS.delete = MapProtoDelete$LWS;
    map$LWS.entries = MapProtoEntries$LWS;
    map$LWS.forEach = MapProtoForEach$LWS;
    map$LWS.get = MapProtoGet$LWS;
    map$LWS.has = MapProtoHas$LWS;
    map$LWS.keys = MapProtoKeys$LWS;
    map$LWS.set = MapProtoSet$LWS;
    ReflectDefineProperty$LWS(map$LWS, 'size', {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: MapProtoSizeGetter$LWS,
      set: undefined
    });
    map$LWS.values = MapProtoValues$LWS;
    map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
    map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
    return map$LWS;
  }
  const NumberCtor$LWS = Number;
  const {
    isFinite: NumberIsFinite$LWS,
    isInteger: NumberIsInteger$LWS,
    isNaN: NumberIsNaN$LWS
  } = NumberCtor$LWS;
  const RegExpCtor$LWS = RegExp;
  const {
    prototype: RegExpProto$LWS
  } = RegExpCtor$LWS;
  const {
    test: RegExpProtoTest$LWS
  } = RegExpProto$LWS;
  ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
  const SetCtor$LWS = Set;
  const {
    prototype: SetProto$LWS
  } = SetCtor$LWS;
  const {
    add: SetProtoAdd$LWS,
    has: SetProtoHas$LWS,
    values: SetProtoValues$LWS
  } = SetProto$LWS;
  ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');
  const StringCtor$LWS = String;
  const {
    prototype: StringProto$LWS
  } = StringCtor$LWS;
  const {
    slice: StringProtoSlice$LWS,
    valueOf: StringProtoValueOf$LWS
  } = StringProto$LWS;
  const WeakMapCtor$LWS = WeakMap;
  const {
    prototype: WeakMapProto$LWS
  } = WeakMapCtor$LWS;
  const {
    has: WeakMapProtoHas$LWS
  } = WeakMapProto$LWS;
  const {
    delete: WeakMapProtoDelete$LWS,
    get: WeakMapProtoGet$LWS,
    set: WeakMapProtoSet$LWS,
    [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
  } = WeakMapProto$LWS;
  function toSafeWeakMap$LWS(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS;
    weakMap$LWS.get = WeakMapProtoGet$LWS;
    weakMap$LWS.has = WeakMapProtoHas$LWS;
    weakMap$LWS.set = WeakMapProtoSet$LWS;
    weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
    return weakMap$LWS;
  }
  const WeakSetCtor$LWS = WeakSet;
  const {
    prototype: WeakSetProto$LWS
  } = WeakSetCtor$LWS;
  const {
    has: WeakSetProtoHas$LWS
  } = WeakSetProto$LWS;
  const {
    add: WeakSetProtoAdd$LWS,
    delete: WeakSetProtoDelete$LWS,
    [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
  } = WeakSetProto$LWS;
  function toSafeWeakSet$LWS(weakSet$LWS) {
    ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
    weakSet$LWS.add = WeakSetProtoAdd$LWS;
    weakSet$LWS.delete = WeakSetProtoDelete$LWS;
    weakSet$LWS.has = WeakSetProtoHas$LWS;
    weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
    return weakSet$LWS;
  }
  // Used by '@locker/near-membrane-dom'.
  const {
    stringify: JSONStringify$LWS
  } = JSON;
  function getNearMembraneProxySerializedValue$LWS(object$LWS) {
    if (typeof object$LWS === 'object' && object$LWS !== null || typeof object$LWS === 'function') {
      // To extract the serialized value of a blue near-membrane proxy we must
      // perform a two step handshake. First, we trigger the "has" trap for
      // the `LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL` property which
      // must report `false`. Second, we trigger the "get" trap to return the
      // serialized value.
      return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
    }
    return undefined;
  }
  function isNearMembraneProxy$LWS(value$LWS) {
    if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
      // To extract the flag value of a blue near-membrane proxy we must
      // perform a two step handshake. First, we trigger the "has" trap for
      // the `LOCKER_NEAR_MEMBRANE_SYMBOL` property which must report `false`.
      // Second, we trigger the "get" trap to return the flag value.
      return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
    }
    return false;
  }
  toSafeMap$LWS(new MapCtor$LWS());
  const ErrorCtor$LWS = Error;
  const TypeErrorCtor$LWS = TypeError;
  function noop$LWS() {
    // No operation performed.
  }

  // Used by '@locker/near-membrane-dom'.
  const {
    min: MathMin$LWS
  } = Math;
  const rootWindow$LWS = window;
  const {
    // We don't cherry-pick the 'userAgent' property from `navigator` here
    // to avoid triggering its getter.
    navigator: navigator$LWS,
    navigator: {
      userAgentData: userAgentData$LWS
    }
  } = rootWindow$LWS;
  // The user-agent client hints API is experimental and subject to change.
  // https://caniuse.com/mdn-api_navigator_useragentdata
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;
  // Note: Chromium identifies itself as Chrome in its user-agent string.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
  const chromiumUserAgentRegExp$LWS = / (?:Headless)?Chrome\/\d+/;
  let userAgent$LWS;
  function getUserAgent$LWS() {
    if (userAgent$LWS === undefined) {
      userAgent$LWS = navigator$LWS.userAgent;
    }
    return userAgent$LWS;
  }
  const IS_CHROMIUM_BROWSER$LWS =
  // While experimental, `navigator.userAgentData.brands` may be defined as an
  // empty array in headless Chromium based browsers.
  ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ?
  // Use user-agent client hints API if available to avoid deprecation
  // warnings.
  // https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
  // istanbul ignore next: this code is not reachable in the coverage run.
  ReflectApply$LWS(ArrayProtoFind$LWS, brands$LWS, [
  // prettier-ignore
  item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined :
  // Fallback to a standard user-agent string sniff.
  ReflectApply$LWS(RegExpProtoTest$LWS, chromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
  const IS_OLD_CHROMIUM_BROWSER$LWS = IS_CHROMIUM_BROWSER$LWS &&
  // Chromium added support for `navigator.userAgentData` in v90.
  // https://caniuse.com/mdn-api_navigator_useragentdata
  userAgentData$LWS === undefined;
  const {
    prototype: DocumentProto$LWS
  } = Document;
  const {
    close: DocumentProtoClose$LWS,
    createElement: DocumentProtoCreateElement$LWS,
    open: DocumentProtoOpen$LWS
  } = DocumentProto$LWS;
  const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');

  // The DOMException constructor was exposed in Edge 12 but wasn't invocable
  // until Edge 79. As long as this is used for instanceof checks it should be fine.
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
  const DOMExceptionCtor$LWS = DOMException;
  ObjectLookupOwnGetter$LWS(DOMExceptionCtor$LWS.prototype, 'code');
  const {
    remove: ElementProtoRemove$LWS,
    setAttribute: ElementProtoSetAttribute$LWS
  } = Element.prototype;
  const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'style');
  const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement.prototype, 'contentWindow');
  const {
    prototype: NodeProto$LWS
  } = Node;
  const {
    appendChild: NodeProtoAppendChild$LWS
  } = NodeProto$LWS;
  const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');

  // This package is bundled by third-parties that have their own build time
  // replacement logic. Instead of customizing each build system to be aware
  // of this package we implement a two phase debug mode by performing small
  // runtime checks to determine phase one, our code is unminified, and
  // phase two, the user opted-in to custom devtools formatters. Phase one
  // is used for light weight initialization time debug while phase two is
  // reserved for post initialization runtime.
  // istanbul ignore else: not avoidable via tests
  {
    // We passed the phase one gate so we know our code is unminified and we can
    // install Locker's custom devtools formatter.
    let lockerDebugModeSymbolFlag$LWS = true;
    const LOCKER_DEBUG_MODE_SYMBOL$LWS = SymbolFor$LWS('@@lockerDebugMode');
    const MAX_ARRAY_DISPLAY$LWS = 100;
    const MAX_OBJECT_DISPLAY$LWS = 5;
    const MAX_STRING_DISPLAY$LWS = 100;
    const MID_STRING_DISPLAY$LWS = MAX_STRING_DISPLAY$LWS / 2;
    const headerCSSText$LWS = 'display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;';
    const bodyItemStyleObject$LWS = {
      style: 'margin-left:15px; margin-bottom: 3px;'
    };
    const bodyStyleObject$LWS = {
      style: 'display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;'
    };
    const keyEnumerableStringStyleObject$LWS = {
      style: 'color: #9d288c; font-weight: bold'
    };
    const keyNonEnumerableOrSymbolStyleObject$LWS = {
      style: 'color: #b17ab0'
    };
    const primitiveBlueColorStyleObject$LWS = {
      style: 'color: #16239f'
    };
    const primitiveGreenColorStyleObject$LWS = {
      style: 'color: #236d25'
    };
    const primitiveGreyColorStyleObject$LWS = {
      style: 'color: #606367'
    };
    const primitiveOrangeColorStyleObject$LWS = {
      style: 'color: #b82619'
    };
    // istanbul ignore next: currently unreachable via tests
    const formatValue$LWS = function formatValue$LWS(value$LWS) {
      if (value$LWS === null || value$LWS === undefined) {
        return ['span', primitiveGreyColorStyleObject$LWS, `${value$LWS}`];
      }
      if (typeof value$LWS === 'boolean') {
        return ['span', primitiveBlueColorStyleObject$LWS, value$LWS];
      }
      if (typeof value$LWS === 'number') {
        return NumberIsFinite$LWS(value$LWS) ? ['span', primitiveBlueColorStyleObject$LWS, value$LWS] : ['span', primitiveBlueColorStyleObject$LWS, `${value$LWS >= 0 ? '' : '-'}Infinity`];
      }
      if (typeof value$LWS === 'bigint') {
        return ['span', primitiveGreenColorStyleObject$LWS, `${value$LWS}n`];
      }
      if (typeof value$LWS === 'string') {
        let string$LWS = value$LWS;
        const {
          length: length$LWS
        } = string$LWS;
        if (length$LWS > MAX_STRING_DISPLAY$LWS) {
          const firstChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [0, MID_STRING_DISPLAY$LWS]);
          const lastChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [length$LWS - MID_STRING_DISPLAY$LWS - 1, length$LWS]);
          string$LWS = firstChunk$LWS + CHAR_ELLIPSIS$LWS + lastChunk$LWS;
        }
        // @TODO: Default to using single quotes on main header and double
        // quotes on body.
        return ['span', primitiveOrangeColorStyleObject$LWS, JSONStringify$LWS(string$LWS)];
      }
      if (ArrayIsArray$LWS(value$LWS)) {
        return ['span', {}, `Array(${value$LWS.length})`];
      }
      if (isObject$LWS(value$LWS)) {
        return ['span', {}, `{${CHAR_ELLIPSIS$LWS}}`];
      }
      // Symbol will be coerced to a string.
      return ['span', primitiveOrangeColorStyleObject$LWS, StringCtor$LWS(value$LWS)];
    };
    // istanbul ignore next: currently unreachable via tests
    const formatHeader$LWS = function formatHeader$LWS(object$LWS, config$LWS) {
      const isChildElement$LWS = config$LWS == null ? void 0 : config$LWS.isChildElement;
      const formattedHeader$LWS = [];
      let formattedHeaderOffset$LWS = 0;
      if (isChildElement$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', keyEnumerableStringStyleObject$LWS, config$LWS.childKey];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
      }
      const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
      let keys$LWS = ObjectKeys$LWS(object$LWS);
      if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
        if (!ReflectApply$LWS(ArrayProtoIncludes$LWS, keys$LWS, ['description'])) {
          ReflectApply$LWS(ArrayProtoUnshift$LWS, keys$LWS, ['description']);
        }
      } else if (brand$LWS === TO_STRING_BRAND_STRING$LWS) {
        const {
          length: length$LWS
        } = object$LWS;
        keys$LWS = ReflectApply$LWS(ArrayProtoFilter$LWS, keys$LWS, [key$LWS => {
          const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;
          return possibleIndex$LWS < 0 || possibleIndex$LWS >= length$LWS || !NumberIsInteger$LWS(possibleIndex$LWS);
        }]);
      }
      const ownKeysRaw$LWS = ReflectOwnKeys$LWS(object$LWS);
      const ownKeys$LWS = ReflectApply$LWS(ArrayProtoMap$LWS, ownKeysRaw$LWS, [StringCtor$LWS]);
      const {
        length: ownKeysLength$LWS
      } = ownKeys$LWS;
      if (ArrayIsArray$LWS(object$LWS)) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, `(${object$LWS.length}) [`];
        for (let i$LWS = 0, length$LWS = MathMin$LWS(ownKeysLength$LWS, MAX_ARRAY_DISPLAY$LWS); i$LWS < length$LWS; i$LWS += 1) {
          const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
          const ownKey$LWS = ownKeys$LWS[i$LWS];
          const value$LWS = object$LWS[ownKeyRaw$LWS];
          if (ownKey$LWS !== 'length') {
            if (!NumberIsNaN$LWS(NumberCtor$LWS(ownKey$LWS))) {
              formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
              formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
            } else {
              formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
              formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, StringCtor$LWS(ownKey$LWS)];
              formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
              formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
            }
          }
        }
        if (ownKeysLength$LWS > MAX_ARRAY_DISPLAY$LWS) {
          formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
        }
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ']'];
        return formattedHeader$LWS;
      }
      let boxedHeaderEntry$LWS;
      let headerOpening$LWS = '{';
      // eslint-disable-next-line default-case
      switch (brand$LWS) {
        case TO_STRING_BRAND_BIG_INT$LWS:
        case TO_STRING_BRAND_BOOLEAN$LWS:
        case TO_STRING_BRAND_NUMBER$LWS:
        case TO_STRING_BRAND_STRING$LWS:
        case TO_STRING_BRAND_SYMBOL$LWS:
          {
            let colorStyleObject$LWS = primitiveBlueColorStyleObject$LWS;
            if (brand$LWS === TO_STRING_BRAND_BIG_INT$LWS) {
              colorStyleObject$LWS = primitiveGreenColorStyleObject$LWS;
            } else if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
              colorStyleObject$LWS = primitiveOrangeColorStyleObject$LWS;
            }
            headerOpening$LWS = `${ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1])} {`;
            boxedHeaderEntry$LWS = ['span', colorStyleObject$LWS, `${StringCtor$LWS(getNearMembraneProxySerializedValue$LWS(object$LWS))}`];
            break;
          }
      }
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, headerOpening$LWS];
      if (boxedHeaderEntry$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = boxedHeaderEntry$LWS;
        if (ownKeysLength$LWS) {
          formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ', '];
        }
      }
      for (let i$LWS = 0, length$LWS = MathMin$LWS(ownKeysLength$LWS, MAX_OBJECT_DISPLAY$LWS); i$LWS < length$LWS; i$LWS += 1) {
        const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const value$LWS = object$LWS[ownKeyRaw$LWS];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, ownKey$LWS];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
      }
      if (ownKeysLength$LWS > MAX_OBJECT_DISPLAY$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
      }
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, '}'];
      return formattedHeader$LWS;
    };
    // istanbul ignore next: currently unreachable via tests
    const formatBody$LWS = function formatBody$LWS(object$LWS) {
      // @TODO: Arrays are broken into groups of 100.
      const ownKeysRaw$LWS = ReflectOwnKeys$LWS(object$LWS);
      const ownKeys$LWS = ReflectApply$LWS(ArrayProtoMap$LWS, ownKeysRaw$LWS, [StringCtor$LWS]);
      // Put 'length' at the end of array.
      const isArray$LWS = ArrayIsArray$LWS(object$LWS);
      if (isArray$LWS) {
        const lengthIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeys$LWS, ['length']);
        const lengthKeyRaw$LWS = ReflectApply$LWS(ArrayProtoSplice$LWS, ownKeysRaw$LWS, [lengthIndex$LWS, 1])[0];
        ReflectApply$LWS(ArrayProtoPush$LWS, ownKeysRaw$LWS, [lengthKeyRaw$LWS]);
        const lengthKey$LWS = ReflectApply$LWS(ArrayProtoSplice$LWS, ownKeys$LWS, [lengthIndex$LWS, 1])[0];
        ReflectApply$LWS(ArrayProtoPush$LWS, ownKeys$LWS, [lengthKey$LWS]);
      }
      const formattedBody$LWS = [];
      let formattedBodyOffset$LWS = 0;
      for (let i$LWS = 0, {
          length: length$LWS
        } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const value$LWS = object$LWS[ownKeyRaw$LWS];
        if (isObject$LWS(value$LWS)) {
          formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', {}, ['object', {
            object: value$LWS,
            config: {
              childKey: StringCtor$LWS(ownKey$LWS),
              isChildElement: true
            }
          }]];
        } else {
          let currentKeyStyle$LWS = keyEnumerableStringStyleObject$LWS;
          if (isArray$LWS && ownKey$LWS === 'length') {
            currentKeyStyle$LWS = keyNonEnumerableOrSymbolStyleObject$LWS;
          }
          formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', bodyItemStyleObject$LWS, ['span', currentKeyStyle$LWS, ownKey$LWS], ['span', {}, ': '], formatValue$LWS(value$LWS)];
        }
      }
      return formattedBody$LWS;
    };
    let {
      devtoolsFormatters: devtoolsFormatters$LWS
    } = rootWindow$LWS;
    if (!ArrayIsArray$LWS(devtoolsFormatters$LWS)) {
      devtoolsFormatters$LWS = [];
      ReflectDefineProperty$LWS(rootWindow$LWS, 'devtoolsFormatters', {
        __proto__: null,
        configurable: true,
        value: devtoolsFormatters$LWS,
        writable: true
      });
    }
    // Append our custom formatter to the array of devtools formatters.
    // istanbul ignore next: currently unreachable via tests
    devtoolsFormatters$LWS[devtoolsFormatters$LWS.length] = {
      // istanbul ignore next: currently unreachable via tests
      header(object$LWS, config$LWS) {
        if (lockerDebugModeSymbolFlag$LWS) {
          // We passed the second phase gate so we know that the user has
          // opted-in to custom devtools formatters. Close the gate and
          // define the @@lockerDebugMode symbol on window.
          lockerDebugModeSymbolFlag$LWS = false;
          ReflectDefineProperty$LWS(rootWindow$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS, {
            __proto__: null,
            configurable: true,
            value: true,
            writable: true
          });
        }
        if (!isNearMembraneProxy$LWS(object$LWS)) {
          return null;
        }
        const headerDiv$LWS = ['div', {
          style: `${headerCSSText$LWS}${config$LWS != null && config$LWS.isChildElement ? '' : 'font-style: italic;'}`
        }];
        ReflectApply$LWS(ArrayProtoPush$LWS, headerDiv$LWS, formatHeader$LWS(object$LWS, config$LWS));
        return ['div', {}, headerDiv$LWS];
      },
      // istanbul ignore next: currently unreachable via tests
      hasBody() {
        return true;
      },
      // istanbul ignore next: currently unreachable via tests
      body(object$LWS) {
        const bodyDiv$LWS = ['div', bodyStyleObject$LWS];
        ReflectApply$LWS(ArrayProtoPush$LWS, bodyDiv$LWS, formatBody$LWS(object$LWS));
        return bodyDiv$LWS;
      }
    };
  }

  /**
   * This file contains an exportable (portable) function `init()` used to initialize
   * one side of a membrane on any realm. The only prerequisite is the ability to
   * evaluate the sourceText of the `init()` function there. Once evaluated, the
   * function will return a set of values that can be used to wire up the side of
   * the membrane with another existing `init()` function from another realm, in
   * which case they will exchange callable functions that are required to connect
   * the two realms via the membrane.
   *
   * About the mechanics of the membrane, there are few important considerations:
   *
   * 1. Pointers are the way to pass reference to object and functions.
   * 2. A dedicated symbol (LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) is needed
   *    to represent the absence of a value.
   * 3. The realm that owns the object or function is responsible for projecting
   *    the proxy onto the other side (via callablePushTarget), which returns a
   *    Pointer that can be used by the realm to pass the reference to the same
   *    proxy over and over again.
   * 4. The realm that owns the proxy (after the other side projects it into it)
   *    will hold a Pointer alongside the proxy to signal what original object or
   *    function should the foreign operation operates, it is always the first
   *    argument of the foreign callable for proxies, and the other side can use
   *    it via `selectedTarget!`.
   */
  const proxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
  // istanbul ignore next
  function createMembraneMarshall$LWS(globalObject$LWS) {
    var _ref$LWS, _ref2$LWS, _ReflectApply$LWS, _globalThisRef$BigInt$LWS, _globalThisRef$BigUin$LWS;
    /* eslint-disable prefer-object-spread */
    const ArrayCtor$LWS = Array;
    const ArrayBufferCtor$LWS = ArrayBuffer;
    const ErrorCtor$LWS = Error;
    const NumberCtor$LWS = Number;
    const ObjectCtor$LWS = Object;
    const ProxyCtor$LWS = Proxy;
    const ReflectRef$LWS = Reflect;
    const RegExpCtor$LWS = RegExp;
    const StringCtor$LWS = String;
    const SymbolCtor$LWS = Symbol;
    const TypeErrorCtor$LWS = TypeError;
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    const WeakMapCtor$LWS = WeakMap;
    const WeakSetCtor$LWS = WeakSet;
    const {
      for: SymbolFor$LWS,
      toStringTag: SymbolToStringTag$LWS
    } = SymbolCtor$LWS;
    const {
      // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
      apply: ReflectApply$LWS,
      construct: ReflectConstruct$LWS,
      defineProperty: ReflectDefineProperty$LWS,
      deleteProperty: ReflectDeleteProperty$LWS,
      get: ReflectGet$LWS,
      getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
      getPrototypeOf: ReflectGetPrototypeOf$LWS,
      has: ReflectHas$LWS,
      isExtensible: ReflectIsExtensible$LWS,
      ownKeys: ReflectOwnKeys$LWS,
      preventExtensions: ReflectPreventExtensions$LWS,
      set: ReflectSet$LWS,
      // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
      setPrototypeOf: ReflectSetPrototypeOf$LWS
    } = ReflectRef$LWS;
    const {
      assign: ObjectAssign$LWS,
      defineProperties: ObjectDefineProperties$LWS,
      freeze: ObjectFreeze$LWS,
      getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor$LWS,
      getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
      isFrozen: ObjectIsFrozen$LWS,
      isSealed: ObjectIsSealed$LWS,
      keys: ObjectKeys$LWS,
      prototype: ObjectProto$LWS,
      seal: ObjectSeal$LWS
    } = ObjectCtor$LWS;
    const {
      hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
      propertyIsEnumerable: ObjectProtoPropertyIsEnumerable$LWS,
      toString: ObjectProtoToString$LWS
    } = ObjectProto$LWS;
    const {
      hasOwn: OriginalObjectHasOwn$LWS
    } = ObjectCtor$LWS;
    const {
      __defineGetter__: ObjectProtoDefineGetter$LWS,
      __defineSetter__: ObjectProtoDefineSetter$LWS,
      __lookupGetter__: ObjectProtoLookupGetter$LWS,
      __lookupSetter__: ObjectProtoLookupSetter$LWS
    } = ObjectProto$LWS;
    const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : (object$LWS, key$LWS) => ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
    const globalThisRef$LWS = (_ref$LWS = (_ref2$LWS = globalObject$LWS != null ? globalObject$LWS :
    // Support for globalThis was added in Chrome 71.
    // https://caniuse.com/mdn-javascript_builtins_globalthisfor
    typeof globalThis !== 'undefined' ? globalThis : undefined) != null ? _ref2$LWS :
    // However, environments like Android emulators are running Chrome 69.
    // eslint-disable-next-line no-restricted-globals
    typeof self !== 'undefined' ? self : undefined) != null ? _ref$LWS : (
    // See https://mathiasbynens.be/notes/globalthis for more details.
    ReflectDefineProperty$LWS(ObjectProto$LWS, 'globalThis', {
      __proto__: null,
      configurable: true,
      get() {
        ReflectDeleteProperty$LWS(ObjectProto$LWS, 'globalThis');
        // Safari 12 on iOS 12.1 has a `this` of `undefined` so we
        // fallback to `self`.
        // eslint-disable-next-line no-restricted-globals
        return this != null ? this : self;
      }
    }), globalThis);
    const IS_IN_SHADOW_REALM$LWS = typeof globalObject$LWS !== 'object' || globalObject$LWS === null;
    const IS_NOT_IN_SHADOW_REALM$LWS = !IS_IN_SHADOW_REALM$LWS;
    const LOCKER_DEBUG_MODE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerDebugMode') : undefined;
    const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
    const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembraneSerializedValue') : undefined;
    const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembrane') : undefined;
    const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue');
    // The default stack trace limit in Chrome is 10.
    // Set to 20 to account for stack trace filtering.
    const LOCKER_STACK_TRACE_LIMIT$LWS = 20;
    // Indicate whether debug support is available.
    const LOCKER_DEBUGGABLE_FLAG$LWS = IS_NOT_IN_SHADOW_REALM$LWS;
    const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = 'Illegal property access.';
    // BigInt is not supported in Safari 13.1.
    // https://caniuse.com/bigint
    const FLAGS_REG_EXP$LWS = IS_IN_SHADOW_REALM$LWS ? /\w*$/ : undefined;
    // Minification safe references to the private `BoundaryProxyHandler`
    // 'apply' and 'construct' trap variant's property names.
    let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS;
    const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
    const {
      isArray: isArrayOrThrowForRevoked$LWS
    } = ArrayCtor$LWS;
    const {
      includes: ArrayProtoIncludes$LWS,
      indexOf: ArrayProtoIndexOf$LWS,
      slice: ArrayProtoSlice$LWS
    } = ArrayCtor$LWS.prototype;
    const {
      isView: ArrayBufferIsView$LWS
    } = ArrayBufferCtor$LWS;
    const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
    const {
      valueOf: BooleanProtoValueOf$LWS
    } = Boolean.prototype;
    const {
      toString: ErrorProtoToString$LWS
    } = ErrorCtor$LWS.prototype;
    const {
      bind: FunctionProtoBind$LWS,
      toString: FunctionProtoToString$LWS
    } = Function.prototype;
    const {
      stringify: JSONStringify$LWS
    } = JSON;
    const {
      isInteger: NumberIsInteger$LWS
    } = NumberCtor$LWS;
    const {
      valueOf: NumberProtoValueOf$LWS
    } = NumberCtor$LWS.prototype;
    const {
      revocable: ProxyRevocable$LWS
    } = ProxyCtor$LWS;
    const {
      prototype: RegExpProto$LWS
    } = RegExpCtor$LWS;
    const {
      exec: RegExpProtoExec$LWS,
      test: RegExpProtoTest$LWS,
      toString: RegExProtoToString$LWS
    } = RegExpProto$LWS;
    // Edge 15 does not support RegExp.prototype.flags.
    // https://caniuse.com/mdn-javascript_builtins_regexp_flags
    const RegExpProtoFlagsGetter$LWS = IS_IN_SHADOW_REALM$LWS ? (_ReflectApply$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['flags'])) != null ? _ReflectApply$LWS : function flags$LWS() {
      const string$LWS = ReflectApply$LWS(RegExProtoToString$LWS, this, []);
      return ReflectApply$LWS(RegExpProtoExec$LWS, FLAGS_REG_EXP$LWS, [string$LWS])[0];
    } : undefined;
    const RegExpProtoSourceGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['source']);
    const {
      replace: StringProtoReplace$LWS,
      slice: StringProtoSlice$LWS,
      valueOf: StringProtoValueOf$LWS
    } = StringCtor$LWS.prototype;
    const {
      toString: SymbolProtoToString$LWS,
      valueOf: SymbolProtoValueOf$LWS
    } = SymbolCtor$LWS.prototype;
    const BigInt64ArrayProto$LWS = (_globalThisRef$BigInt$LWS = globalThisRef$LWS.BigInt64Array) == null ? void 0 : _globalThisRef$BigInt$LWS.prototype;
    const BigUint64ArrayProto$LWS = (_globalThisRef$BigUin$LWS = globalThisRef$LWS.BigUint64Array) == null ? void 0 : _globalThisRef$BigUin$LWS.prototype;
    const {
      prototype: Float32ArrayProto$LWS
    } = Float32Array;
    const {
      prototype: Float64ArrayProto$LWS
    } = Float64Array;
    const {
      prototype: Int8ArrayProto$LWS
    } = Int8Array;
    const {
      prototype: Int16ArrayProto$LWS
    } = Int16Array;
    const {
      prototype: Int32ArrayProto$LWS
    } = Int32Array;
    const {
      prototype: Uint8ArrayProto$LWS
    } = Uint8Array;
    const {
      prototype: Uint16ArrayProto$LWS
    } = Uint16Array;
    const {
      prototype: Uint32ArrayProto$LWS
    } = Uint32Array;
    // eslint-disable-next-line no-proto
    const TypedArrayProto$LWS = Uint8ArrayProto$LWS.__proto__;
    const TypedArrayProtoLengthGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, TypedArrayProto$LWS, ['length']);
    const {
      prototype: WeakMapProto$LWS
    } = WeakMapCtor$LWS;
    const {
      delete: WeakMapProtoDelete$LWS,
      has: WeakMapProtoHas$LWS,
      set: WeakMapProtoSet$LWS,
      [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
    } = WeakMapProto$LWS;
    const {
      prototype: WeakSetProto$LWS
    } = WeakSetCtor$LWS;
    const {
      add: WeakSetProtoAdd$LWS,
      has: WeakSetProtoHas$LWS,
      delete: WeakSetProtoDelete$LWS,
      [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
    } = WeakSetProto$LWS;
    const consoleObject$LWS = IS_NOT_IN_SHADOW_REALM$LWS && typeof console === 'object' && console !== null ? console : undefined;
    const consoleInfo$LWS = consoleObject$LWS == null ? void 0 : consoleObject$LWS.info;
    const localEval$LWS = IS_IN_SHADOW_REALM$LWS ? eval : undefined;
    // Install flags to ensure things are installed once per realm.
    let installedErrorPrepareStackTraceFlag$LWS = false;
    let installedPropertyDescriptorMethodWrappersFlag$LWS = false;
    function alwaysFalse$LWS() {
      return false;
    }
    const installErrorPrepareStackTrace$LWS = () => {
      if (installedErrorPrepareStackTraceFlag$LWS) {
        return;
      }
      installedErrorPrepareStackTraceFlag$LWS = true;
      // Feature detect the V8 stack trace API.
      // https://v8.dev/docs/stack-trace-api
      const CallSite$LWS = (() => {
        try {
          var _callSites$$LWS;
          ErrorCtor$LWS.prepareStackTrace = (_error$LWS, callSites) => callSites;
          const callSites = new ErrorCtor$LWS().stack;
          ReflectDeleteProperty$LWS(ErrorCtor$LWS, 'prepareStackTrace');
          return isArrayOrThrowForRevoked$LWS(callSites) && callSites.length > 0 ? (_callSites$$LWS = callSites[0]) == null ? void 0 : _callSites$$LWS.constructor : undefined;
          // eslint-disable-next-line no-empty
        } catch (_unused$LWS) {}
        return undefined;
      })();
      if (typeof CallSite$LWS !== 'function') {
        return;
      }
      const {
        getEvalOrigin: CallSiteProtoGetEvalOrigin$LWS,
        getFunctionName: CallSiteProtoGetFunctionName$LWS,
        toString: CallSiteProtoToString$LWS
      } = CallSite$LWS.prototype;
      // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.
      const lockerFunctionNameMarkerRegExp$LWS = new RegExpCtor$LWS(`${
      // Escape regexp special characters in LOCKER_IDENTIFIER_MARKER.
      ReflectApply$LWS(StringProtoReplace$LWS, LOCKER_IDENTIFIER_MARKER$LWS, [/[\\^$.*+?()[\]{}|]/g, '\\$&'])
      // Function name references in call sites also contain
      // the name of the class they belong to,
      // e.g. myClassName.myFunctionName.
      }(?=\\.|$)`);
      const formatStackTrace = function formatStackTrace(error, callSites) {
        // Based on V8's default stack trace formatting:
        // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371
        let stackTrace$LWS = '';
        try {
          stackTrace$LWS = ReflectApply$LWS(ErrorProtoToString$LWS, error, []);
        } catch (_unused2$LWS) {
          stackTrace$LWS = '<error>';
        }
        let consecutive$LWS = false;
        for (let i$LWS = 0, {
            length: length$LWS
          } = callSites; i$LWS < length$LWS; i$LWS += 1) {
          const callSite$LWS = callSites[i$LWS];
          const funcName$LWS = ReflectApply$LWS(CallSiteProtoGetFunctionName$LWS, callSite$LWS, []);
          let isMarked$LWS = false;
          if (typeof funcName$LWS === 'string' && funcName$LWS !== 'eval' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [funcName$LWS])) {
            isMarked$LWS = true;
          }
          if (!isMarked$LWS) {
            const evalOrigin$LWS = ReflectApply$LWS(CallSiteProtoGetEvalOrigin$LWS, callSite$LWS, []);
            if (typeof evalOrigin$LWS === 'string' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [evalOrigin$LWS])) {
              isMarked$LWS = true;
            }
          }
          // Only write a single LWS entry per consecutive LWS stacks.
          if (isMarked$LWS) {
            if (!consecutive$LWS) {
              consecutive$LWS = true;
              stackTrace$LWS += '\n    at LWS';
            }
            continue;
          } else {
            consecutive$LWS = false;
          }
          try {
            stackTrace$LWS += `\n    at ${ReflectApply$LWS(CallSiteProtoToString$LWS, callSite$LWS, [])}`;
            // eslint-disable-next-line no-empty
          } catch (_unused3$LWS) {}
        }
        return stackTrace$LWS;
      };
      try {
        // Error.prepareStackTrace cannot be a bound or proxy wrapped
        // function, so to obscure its source we wrap the call to
        // formatStackTrace().
        ErrorCtor$LWS.prepareStackTrace = function prepareStackTrace(error, callSites) {
          return formatStackTrace(error, callSites);
        };
        // eslint-disable-next-line no-empty
      } catch (_unused4$LWS) {}
      try {
        const {
          stackTraceLimit: stackTraceLimit$LWS
        } = ErrorCtor$LWS;
        if (typeof stackTraceLimit$LWS !== 'number' || stackTraceLimit$LWS < LOCKER_STACK_TRACE_LIMIT$LWS) {
          ErrorCtor$LWS.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT$LWS;
        }
        // eslint-disable-next-line no-empty
      } catch (_unused5$LWS) {}
    };
    function noop$LWS() {
      // No-operation.
    }
    const serializeBigIntObject$LWS = IS_IN_SHADOW_REALM$LWS ? bigIntObject$LWS =>
    // Section 21.2.3 Properties of the BigInt Prototype Object
    // https://tc39.es/ecma262/#thisbigintvalue
    // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
    //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
    ReflectApply$LWS(BigIntProtoValueOf$LWS, bigIntObject$LWS, []) : noop$LWS;
    const serializeBooleanObject$LWS = IS_IN_SHADOW_REALM$LWS ? booleanObject$LWS =>
    // Section 20.3.3 Properties of the Boolean Prototype Object
    // https://tc39.es/ecma262/#thisbooleanvalue
    // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
    //     a. Let b be value.[[BooleanData]].
    //     b. Assert: Type(b) is Boolean.
    ReflectApply$LWS(BooleanProtoValueOf$LWS, booleanObject$LWS, []) : noop$LWS;
    const serializeNumberObject$LWS = IS_IN_SHADOW_REALM$LWS ? numberObject$LWS =>
    // 21.1.3 Properties of the Number Prototype Object
    // https://tc39.es/ecma262/#thisnumbervalue
    // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
    //     a. Let n be value.[[NumberData]].
    //     b. Assert: Type(n) is Number.
    ReflectApply$LWS(NumberProtoValueOf$LWS, numberObject$LWS, []) : noop$LWS;
    const serializeRegExp$LWS = IS_IN_SHADOW_REALM$LWS ? value$LWS => {
      // 22.2.5.12 get RegExp.prototype.source
      // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
      // Step 3: If R does not have an [[OriginalSource]] internal slot, then
      //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
      //     b. Otherwise, throw a TypeError exception.
      if (value$LWS !== RegExpProto$LWS) {
        const source$LWS = ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
        return JSONStringify$LWS({
          __proto__: null,
          flags: ReflectApply$LWS(RegExpProtoFlagsGetter$LWS, value$LWS, []),
          source: source$LWS
        });
      }
      return undefined;
    } : noop$LWS;
    const serializeStringObject$LWS = IS_IN_SHADOW_REALM$LWS ? stringObject$LWS =>
    // 22.1.3 Properties of the String Prototype Object
    // https://tc39.es/ecma262/#thisstringvalue
    // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
    //     a. Let s be value.[[StringData]].
    //     b. Assert: Type(s) is String.
    ReflectApply$LWS(StringProtoValueOf$LWS, stringObject$LWS, []) : noop$LWS;
    const serializeSymbolObject$LWS = IS_IN_SHADOW_REALM$LWS ? symbolObject$LWS =>
    // 20.4.3 Properties of the Symbol Prototype Object
    // https://tc39.es/ecma262/#thissymbolvalue
    // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
    //     a. Let s be value.[[SymbolData]].
    //     b. Assert: Type(s) is Symbol.
    ReflectApply$LWS(SymbolProtoValueOf$LWS, symbolObject$LWS, []) : noop$LWS;
    const serializeTargetByBrand$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
      const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
      switch (brand$LWS) {
        // The brand checks below represent boxed primitives of
        // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
        // which are not remapped or reflective.
        case '[object Boolean]':
          return serializeBooleanObject$LWS(target$LWS);
        case '[object Number]':
          return serializeNumberObject$LWS(target$LWS);
        case '[object RegExp]':
          return serializeRegExp$LWS(target$LWS);
        case '[object String]':
          return serializeStringObject$LWS(target$LWS);
        case '[object Object]':
          try {
            // Symbol.prototype[@@toStringTag] is defined by default so
            // must have been removed.
            // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
            return serializeSymbolObject$LWS(target$LWS);
            // eslint-disable-next-line no-empty
          } catch (_unused6$LWS) {}
          if (SUPPORTS_BIG_INT$LWS) {
            // BigInt.prototype[@@toStringTag] is defined by default so
            // must have been removed.
            // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
            try {
              return serializeBigIntObject$LWS(target$LWS);
              // eslint-disable-next-line no-empty
            } catch (_unused7$LWS) {}
          }
        // eslint-disable-next-line no-fallthrough
        default:
          return undefined;
      }
    } : noop$LWS;
    const serializeTargetByTrialAndError$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
      // The serialization attempts below represent boxed primitives of
      // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
      // which are not remapped or reflective.
      try {
        // Symbol.prototype[@@toStringTag] is defined by default so
        // attempted before others.
        // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
        return serializeSymbolObject$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused8$LWS) {}
      if (SUPPORTS_BIG_INT$LWS) {
        // BigInt.prototype[@@toStringTag] is defined by default so
        // attempted before others.
        // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
        try {
          return serializeBigIntObject$LWS(target$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused9$LWS) {}
      }
      try {
        return serializeBooleanObject$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused10$LWS) {}
      try {
        return serializeNumberObject$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused11$LWS) {}
      try {
        return serializeRegExp$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused12$LWS) {}
      try {
        return serializeStringObject$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused13$LWS) {}
      return undefined;
    } : noop$LWS;
    function toSafeTemplateStringValue$LWS(value$LWS) {
      if (typeof value$LWS === 'string') {
        return value$LWS;
      }
      try {
        if (typeof value$LWS === 'object' && value$LWS !== null) {
          const result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
          return result$LWS === '[object Symbol]' ? ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
        }
        if (typeof value$LWS === 'function') {
          return ReflectApply$LWS(FunctionProtoToString$LWS, value$LWS, []);
        }
        // Attempt to coerce `value` to a string with the String() constructor.
        // Section 22.1.1.1 String ( value )
        // https://tc39.es/ecma262/#sec-string-constructor-string-value
        return StringCtor$LWS(value$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused14$LWS) {}
      return '[Object Unknown]';
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    function toSafeWeakMap$LWS(weakMap$LWS) {
      ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
      weakMap$LWS.delete = WeakMapProtoDelete$LWS;
      weakMap$LWS.has = WeakMapProtoHas$LWS;
      weakMap$LWS.set = WeakMapProtoSet$LWS;
      weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
      ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
      return weakMap$LWS;
    }
    function toSafeWeakSet$LWS(weakSet$LWS) {
      ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
      weakSet$LWS.add = WeakSetProtoAdd$LWS;
      weakSet$LWS.delete = WeakSetProtoDelete$LWS;
      weakSet$LWS.has = WeakSetProtoHas$LWS;
      weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
      ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
      return weakSet$LWS;
    }
    return function createHooksCallback$LWS(color$LWS, foreignCallableHooksCallback$LWS, options$LWS) {
      if (IS_IN_SHADOW_REALM$LWS) {
        options$LWS = undefined;
      }
      const {
        distortionCallback: distortionCallback$LWS,
        liveTargetCallback: liveTargetCallback$LWS,
        revokedProxyCallback: revokedProxyCallback$LWS
        // eslint-disable-next-line prefer-object-spread
      } = ObjectAssign$LWS({
        __proto__: null
      }, options$LWS);
      const applyTrapNameRegistry$LWS = {
        // Populated in the returned connector function below.
        __proto__: null,
        0: undefined,
        1: undefined,
        2: undefined,
        3: undefined,
        4: undefined,
        n: undefined
      };
      const constructTrapNameRegistry$LWS = {
        // Populated in the returned connector function below.
        __proto__: null,
        0: undefined,
        1: undefined,
        2: undefined,
        3: undefined,
        4: undefined,
        n: undefined
      };
      const lazyPropertyDescriptorStateCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
      const proxyPointerCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
      let foreignCallablePushErrorTarget$LWS;
      let foreignCallablePushTarget$LWS;
      let foreignCallableApply$LWS;
      let foreignCallableConstruct$LWS;
      let foreignCallableDefineProperty$LWS;
      let foreignCallableDeleteProperty$LWS;
      let foreignCallableGet$LWS;
      let foreignCallableGetOwnPropertyDescriptor$LWS;
      let foreignCallableGetPrototypeOf$LWS;
      let foreignCallableHas$LWS;
      let foreignCallableIsExtensible$LWS;
      let foreignCallableOwnKeys$LWS;
      let foreignCallablePreventExtensions$LWS;
      let foreignCallableSet$LWS;
      let foreignCallableSetPrototypeOf$LWS;
      let foreignCallableDebugInfo$LWS;
      let foreignCallableGetPropertyValue$LWS;
      let foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS;
      let foreignCallableGetTargetIntegrityTraits$LWS;
      let foreignCallableGetToStringTagOfTarget$LWS;
      let foreignCallableInstallErrorPrepareStackTrace$LWS;
      let foreignCallableIsTargetLive$LWS;
      let foreignCallableIsTargetRevoked$LWS;
      let foreignCallableSerializeTarget$LWS;
      let foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS;
      let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS;
      let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS;
      let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS;
      let fastForeignTargetPointers$LWS;
      let foreignPointerBigInt64ArrayProto$LWS;
      let foreignPointerBigUint64ArrayProto$LWS;
      let foreignPointerFloat32ArrayProto$LWS;
      let foreignPointerFloat64ArrayProto$LWS;
      let foreignPointerInt8ArrayProto$LWS;
      let foreignPointerInt16ArrayProto$LWS;
      let foreignPointerInt32ArrayProto$LWS;
      let foreignPointerObjectProto$LWS;
      let foreignPointerTypedArrayProto$LWS;
      let foreignPointerUint8ArrayProto$LWS;
      let foreignPointerUint16ArrayProto$LWS;
      let foreignPointerUint32ArrayProto$LWS;
      let selectedTarget$LWS;
      let lastProxyTrapCalled$LWS = 0 /* ProxyHandlerTraps.None */;
      let handshakePropertyFlag$LWS = false;
      let useFastForeignTargetPath$LWS = IS_IN_SHADOW_REALM$LWS;
      let useFastForeignTargetPathForTypedArrays$LWS = IS_IN_SHADOW_REALM$LWS;
      const activateLazyOwnPropertyDefinition$LWS = IS_IN_SHADOW_REALM$LWS ? (target$LWS, key$LWS, state$LWS) => {
        state$LWS[key$LWS] = false;
        const foreignTargetPointer$LWS = getTransferablePointer$LWS(target$LWS);
        let safeDesc$LWS;
        try {
          foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
          });
        } catch (error) {
          var _selectedTarget$LWS;
          const errorToThrow$LWS = (_selectedTarget$LWS = selectedTarget$LWS) != null ? _selectedTarget$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (safeDesc$LWS) {
          ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
        } else {
          ReflectDeleteProperty$LWS(target$LWS, key$LWS);
        }
      } : noop$LWS;
      let checkDebugMode$LWS = LOCKER_DEBUGGABLE_FLAG$LWS ? () => {
        try {
          if (ObjectHasOwn$LWS(globalThisRef$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS)) {
            checkDebugMode$LWS = () => true;
            installErrorPrepareStackTrace$LWS();
            foreignCallableInstallErrorPrepareStackTrace$LWS();
          }
        } catch (_unused15$LWS) {
          checkDebugMode$LWS = alwaysFalse$LWS;
        }
        return false;
      } : alwaysFalse$LWS;
      const clearFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
        fastForeignTargetPointers$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
      } : noop$LWS;
      function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS) {
        let protoPointerOrNull$LWS;
        try {
          protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS(foreignTargetPointer$LWS, (...descriptorTuples$LWS) => {
            const descriptors$LWS = {};
            for (let i$LWS = 0, {
                length: length$LWS
              } = descriptorTuples$LWS; i$LWS < length$LWS; i$LWS += 7) {
              const key$LWS = descriptorTuples$LWS[i$LWS];
              descriptors$LWS[key$LWS] = createDescriptorFromMeta$LWS(descriptorTuples$LWS[i$LWS + 1],
              // configurable
              descriptorTuples$LWS[i$LWS + 2],
              // enumerable
              descriptorTuples$LWS[i$LWS + 3],
              // writable
              descriptorTuples$LWS[i$LWS + 4],
              // valuePointer
              descriptorTuples$LWS[i$LWS + 5],
              // getterPointer
              descriptorTuples$LWS[i$LWS + 6] // setterPointer
              );
            }
            // Use `ObjectDefineProperties()` instead of individual
            // `ReflectDefineProperty()` calls for better performance.
            ObjectDefineProperties$LWS(shadowTarget$LWS, descriptors$LWS);
          });
        } catch (error) {
          var _selectedTarget2$LWS;
          const errorToThrow$LWS = (_selectedTarget2$LWS = selectedTarget$LWS) != null ? _selectedTarget2$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let proto$LWS;
        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          proto$LWS = null;
        }
        ReflectSetPrototypeOf$LWS(shadowTarget$LWS, proto$LWS);
      }
      function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrap$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          if (length$LWS !== 0) {
            var _arityToApplyOrConstr$LWS;
            return this[(_arityToApplyOrConstr$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
            // Inline getTransferableValue().
            typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS);
          } catch (error) {
            var _selectedTarget3$LWS;
            const errorToThrow$LWS = (_selectedTarget3$LWS = selectedTarget$LWS) != null ? _selectedTarget3$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createApplyOrConstructTrapForOneOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForOneOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          if (length$LWS !== 1) {
            var _arityToApplyOrConstr2$LWS;
            return this[(_arityToApplyOrConstr2$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr2$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS
            } = args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
            // Inline getTransferableValue().
            typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
            // Inline getTransferableValue().
            typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS);
          } catch (error) {
            var _selectedTarget4$LWS;
            const errorToThrow$LWS = (_selectedTarget4$LWS = selectedTarget$LWS) != null ? _selectedTarget4$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          if (length$LWS !== 2) {
            var _arityToApplyOrConstr3$LWS;
            return this[(_arityToApplyOrConstr3$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr3$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS
            } = args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
            // Inline getTransferableValue().
            typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
            // Inline getTransferableValue().
            typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
            // Inline getTransferableValue().
            typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS);
          } catch (error) {
            var _selectedTarget5$LWS;
            const errorToThrow$LWS = (_selectedTarget5$LWS = selectedTarget$LWS) != null ? _selectedTarget5$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          if (length$LWS !== 3) {
            var _arityToApplyOrConstr4$LWS;
            return this[(_arityToApplyOrConstr4$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr4$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS,
              2: arg2$LWS
            } = args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
            // Inline getTransferableValue().
            typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
            // Inline getTransferableValue().
            typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
            // Inline getTransferableValue().
            typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
            // Inline getTransferableValue().
            typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS);
          } catch (error) {
            var _selectedTarget6$LWS;
            const errorToThrow$LWS = (_selectedTarget6$LWS = selectedTarget$LWS) != null ? _selectedTarget6$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createApplyOrConstructTrapForFourOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          if (length$LWS !== 4) {
            var _arityToApplyOrConstr5$LWS;
            return this[(_arityToApplyOrConstr5$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr5$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS,
              2: arg2$LWS,
              3: arg3$LWS
            } = args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
            // Inline getTransferableValue().
            typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
            // Inline getTransferableValue().
            typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
            // Inline getTransferableValue().
            typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
            // Inline getTransferableValue().
            typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS,
            // Inline getTransferableValue().
            typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS);
          } catch (error) {
            var _selectedTarget7$LWS;
            const errorToThrow$LWS = (_selectedTarget7$LWS = selectedTarget$LWS) != null ? _selectedTarget7$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          if (length$LWS !== 5) {
            var _arityToApplyOrConstr6$LWS;
            return this[(_arityToApplyOrConstr6$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr6$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS,
              2: arg2$LWS,
              3: arg3$LWS,
              4: arg4$LWS
            } = args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
            // Inline getTransferableValue().
            typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
            // Inline getTransferableValue().
            typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
            // Inline getTransferableValue().
            typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
            // Inline getTransferableValue().
            typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS,
            // Inline getTransferableValue().
            typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS,
            // Inline getTransferableValue().
            typeof arg4$LWS === 'object' && arg4$LWS !== null || typeof arg4$LWS === 'function' ? getTransferablePointer$LWS(arg4$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg4$LWS === 'undefined' ? undefined : arg4$LWS);
          } catch (error) {
            var _selectedTarget8$LWS;
            const errorToThrow$LWS = (_selectedTarget8$LWS = selectedTarget$LWS) != null ? _selectedTarget8$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForAnyNumberOfArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          // @ts-ignore: Prevent private property access error.
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: length$LWS
          } = args$LWS;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let combinedOffset$LWS = 2;
          const combinedArgs$LWS = new ArrayCtor$LWS(length$LWS + combinedOffset$LWS);
          combinedArgs$LWS[0] = foreignTargetPointer$LWS;
          let pointerOrPrimitive$LWS;
          try {
            combinedArgs$LWS[1] = typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS;
            for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
              const arg$LWS = args$LWS[i$LWS];
              // Inlining `getTransferableValue()`.
              combinedArgs$LWS[combinedOffset$LWS++] = typeof arg$LWS === 'object' && arg$LWS !== null || typeof arg$LWS === 'function' ? getTransferablePointer$LWS(arg$LWS) :
              // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof arg$LWS === 'undefined' ? undefined : arg$LWS;
            }
            pointerOrPrimitive$LWS = ReflectApply$LWS(foreignCallableApplyOrConstruct$LWS, undefined, combinedArgs$LWS);
          } catch (error) {
            var _selectedTarget9$LWS;
            const errorToThrow$LWS = (_selectedTarget9$LWS = selectedTarget$LWS) != null ? _selectedTarget9$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let result$LWS;
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
          return result$LWS;
        };
      }
      function createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) {
        const safeDesc$LWS = {
          __proto__: null
        };
        if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
          safeDesc$LWS.configurable = configurable$LWS;
        }
        if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
          safeDesc$LWS.enumerable = enumerable$LWS;
        }
        if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
          safeDesc$LWS.writable = writable$LWS;
        }
        if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
          if (typeof getterPointerOrPrimitive$LWS === 'function') {
            getterPointerOrPrimitive$LWS();
            safeDesc$LWS.get = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            safeDesc$LWS.get = undefined;
          }
        }
        if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
          if (typeof setterPointerOrPrimitive$LWS === 'function') {
            setterPointerOrPrimitive$LWS();
            safeDesc$LWS.set = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            safeDesc$LWS.set = undefined;
          }
        }
        if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
          if (typeof valuePointerOrPrimitive$LWS === 'function') {
            valuePointerOrPrimitive$LWS();
            safeDesc$LWS.value = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
          }
        }
        return safeDesc$LWS;
      }
      function createPointer$LWS(originalTarget$LWS) {
        const pointer$LWS = () => {
          // assert: selectedTarget is undefined
          selectedTarget$LWS = originalTarget$LWS;
        };
        return pointer$LWS;
      }
      const disableFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
        useFastForeignTargetPath$LWS = false;
        useFastForeignTargetPathForTypedArrays$LWS = false;
        clearFastForeignTargetPointers$LWS();
      } : noop$LWS;
      const getLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
        let state$LWS = lazyPropertyDescriptorStateCache$LWS.get(target$LWS);
        if (state$LWS === undefined) {
          const statePointerOrUndefined$LWS = foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(target$LWS));
          if (typeof statePointerOrUndefined$LWS === 'function') {
            statePointerOrUndefined$LWS();
            state$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
            if (state$LWS) {
              lazyPropertyDescriptorStateCache$LWS.set(target$LWS, state$LWS);
            }
          }
        }
        return state$LWS;
      } : noop$LWS;
      const isForeignPointerOfObjectProto$LWS = IS_IN_SHADOW_REALM$LWS ?
      // eslint-disable-next-line no-return-assign
      foreignTargetPointer$LWS => foreignTargetPointer$LWS === (foreignPointerObjectProto$LWS === undefined ? foreignPointerObjectProto$LWS = getTransferablePointer$LWS(ObjectProto$LWS) : foreignPointerObjectProto$LWS) : alwaysFalse$LWS;
      const isForeignPointerOfTypedArrayProto$LWS = IS_IN_SHADOW_REALM$LWS ?
      // eslint-disable-next-line no-return-assign
      foreignTargetPointer$LWS => foreignTargetPointer$LWS === (foreignPointerFloat32ArrayProto$LWS === undefined ? foreignPointerFloat32ArrayProto$LWS = getTransferablePointer$LWS(Float32ArrayProto$LWS) : foreignPointerFloat32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerFloat64ArrayProto$LWS === undefined ? foreignPointerFloat64ArrayProto$LWS = getTransferablePointer$LWS(Float64ArrayProto$LWS) : foreignPointerFloat64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt8ArrayProto$LWS === undefined ? foreignPointerInt8ArrayProto$LWS = getTransferablePointer$LWS(Int8ArrayProto$LWS) : foreignPointerInt8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt16ArrayProto$LWS === undefined ? foreignPointerInt16ArrayProto$LWS = getTransferablePointer$LWS(Int16ArrayProto$LWS) : foreignPointerInt16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt32ArrayProto$LWS === undefined ? foreignPointerInt32ArrayProto$LWS = getTransferablePointer$LWS(Int32ArrayProto$LWS) : foreignPointerInt32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint8ArrayProto$LWS === undefined ? foreignPointerUint8ArrayProto$LWS = getTransferablePointer$LWS(Uint8ArrayProto$LWS) : foreignPointerUint8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint16ArrayProto$LWS === undefined ? foreignPointerUint16ArrayProto$LWS = getTransferablePointer$LWS(Uint16ArrayProto$LWS) : foreignPointerUint16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint32ArrayProto$LWS === undefined ? foreignPointerUint32ArrayProto$LWS = getTransferablePointer$LWS(Uint32ArrayProto$LWS) : foreignPointerUint32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerTypedArrayProto$LWS === undefined ? foreignPointerTypedArrayProto$LWS = getTransferablePointer$LWS(TypedArrayProto$LWS) : foreignPointerTypedArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigInt64ArrayProto$LWS === undefined ? foreignPointerBigInt64ArrayProto$LWS = BigInt64ArrayProto$LWS ? getTransferablePointer$LWS(BigInt64ArrayProto$LWS) : noop$LWS : foreignPointerBigInt64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigUint64ArrayProto$LWS === undefined ? foreignPointerBigUint64ArrayProto$LWS = BigUint64ArrayProto$LWS ? getTransferablePointer$LWS(BigUint64ArrayProto$LWS) : noop$LWS : foreignPointerBigUint64ArrayProto$LWS) : alwaysFalse$LWS;
      function getTransferablePointer$LWS(originalTarget$LWS, foreignCallablePusher$LWS = foreignCallablePushTarget$LWS) {
        let proxyPointer$LWS = proxyPointerCache$LWS.get(originalTarget$LWS);
        if (proxyPointer$LWS) {
          return proxyPointer$LWS;
        }
        let targetFunctionArity$LWS = 0;
        let targetFunctionName$LWS = '';
        let targetTypedArrayLength$LWS = 0;
        if (revokedProxyCallback$LWS && revokedProxyCallback$LWS(originalTarget$LWS)) {
          proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(originalTarget$LWS), 64 /* TargetTraits.Revoked */, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
          proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
          return proxyPointer$LWS;
        }
        let distortionTarget$LWS;
        let targetTraits$LWS = 16 /* TargetTraits.IsObject */;
        if (distortionCallback$LWS) {
          distortionTarget$LWS = distortionCallback$LWS(originalTarget$LWS);
          // If a distortion entry is found, it must be a valid proxy target.
          if (distortionTarget$LWS !== originalTarget$LWS && typeof distortionTarget$LWS !== typeof originalTarget$LWS) {
            throw new TypeErrorCtor$LWS(`Invalid distortion ${toSafeTemplateStringValue$LWS(originalTarget$LWS)}.`);
          }
        } else {
          distortionTarget$LWS = originalTarget$LWS;
        }
        let isPossiblyRevoked$LWS = true;
        if (typeof distortionTarget$LWS === 'function') {
          isPossiblyRevoked$LWS = false;
          targetFunctionArity$LWS = 0;
          targetTraits$LWS = 4 /* TargetTraits.IsFunction */;
          try {
            // Detect arrow functions.
            if (!('prototype' in distortionTarget$LWS)) {
              targetTraits$LWS |= 8 /* TargetTraits.IsArrowFunction */;
            }

            const safeLengthDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'length');
            if (safeLengthDesc$LWS) {
              ReflectSetPrototypeOf$LWS(safeLengthDesc$LWS, null);
              const {
                value: safeLengthDescValue$LWS
              } = safeLengthDesc$LWS;
              if (typeof safeLengthDescValue$LWS === 'number') {
                targetFunctionArity$LWS = safeLengthDescValue$LWS;
              }
            }
            const safeNameDesc$LWS = false ? ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'name') : undefined;
            if (safeNameDesc$LWS) ;
          } catch (_unused16$LWS) {
            isPossiblyRevoked$LWS = true;
          }
        } else if (ArrayBufferIsView$LWS(distortionTarget$LWS)) {
          isPossiblyRevoked$LWS = false;
          targetTraits$LWS = 2 /* TargetTraits.IsArrayBufferView */;
          try {
            targetTypedArrayLength$LWS = ReflectApply$LWS(TypedArrayProtoLengthGetter$LWS, distortionTarget$LWS, []);
            targetTraits$LWS |= 32 /* TargetTraits.IsTypedArray */;
            // eslint-disable-next-line no-empty
          } catch (_unused17$LWS) {
            // Could be a DataView object or a revoked proxy.
            isPossiblyRevoked$LWS = true;
          }
        }
        if (isPossiblyRevoked$LWS) {
          try {
            if (isArrayOrThrowForRevoked$LWS(distortionTarget$LWS)) {
              targetTraits$LWS = 1 /* TargetTraits.IsArray */;
            }
          } catch (_unused18$LWS) {
            targetTraits$LWS = 64 /* TargetTraits.Revoked */;
          }
        }

        proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(distortionTarget$LWS), targetTraits$LWS, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
        proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
        return proxyPointer$LWS;
      }
      const installPropertyDescriptorMethodWrappers$LWS = IS_IN_SHADOW_REALM$LWS ? unforgeableGlobalThisKeys$LWS => {
        if (installedPropertyDescriptorMethodWrappersFlag$LWS) {
          return;
        }
        installedPropertyDescriptorMethodWrappersFlag$LWS = true;
        // We wrap property descriptor methods to activate lazy
        // descriptors and/or workaround browser bugs. The following
        // methods are wrapped:
        //   Object.getOwnPropertyDescriptors()
        //   Object.getOwnPropertyDescriptor()
        //   Reflect.defineProperty()
        //   Reflect.getOwnPropertyDescriptor()
        //   Object.prototype.__defineGetter__()
        //   Object.prototype.__defineSetter__()
        //   Object.prototype.__lookupGetter__()
        //   Object.prototype.__lookupSetter__()
        //
        // Chromium based browsers have a bug that nulls the result
        // of `window` getters in detached iframes when the property
        // descriptor of `window.window` is retrieved.
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
        //
        // Methods may be poisoned when they interact with the `window`
        // object and retrieve property descriptors, like 'window',
        // that contain the `window` object itself. The following
        // built-in methods are susceptible to this issue:
        //     console.log(window);
        //     Object.getOwnPropertyDescriptors(window);
        //     Object.getOwnPropertyDescriptor(window, 'window');
        //     Reflect.getOwnPropertyDescriptor(window, 'window');
        //     window.__lookupGetter__('window');
        //     window.__lookupSetter__('window');
        //
        // We side step issues with `console` by mapping it to the
        // primary realm's `console`. Since we're already wrapping
        // property descriptor methods to activate lazy descriptors
        // we use the wrapper to workaround the `window` getter
        // nulling bug.
        const shouldFixChromeBug$LWS = isArrayOrThrowForRevoked$LWS(unforgeableGlobalThisKeys$LWS) && unforgeableGlobalThisKeys$LWS.length > 0;
        // Lazily populated by `getUnforgeableGlobalThisGetter()`;
        const keyToGlobalThisGetterRegistry$LWS = shouldFixChromeBug$LWS ? {
          __proto__: null
        } : undefined;
        const getFixedDescriptor$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? {
          configurable: false,
          enumerable: ReflectApply$LWS(ObjectProtoPropertyIsEnumerable$LWS, target$LWS, [key$LWS]),
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          get: getUnforgeableGlobalThisGetter$LWS(key$LWS),
          set: undefined
        } : ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS) : undefined;
        const getUnforgeableGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? key$LWS => {
          let globalThisGetter$LWS = keyToGlobalThisGetterRegistry$LWS[key$LWS];
          if (globalThisGetter$LWS === undefined) {
            // We can't access the original getter to mask
            // with `proxyMaskFunction()`, so instead we wrap
            // `unboundGlobalThisGetter` in bound function
            // to obscure the getter source as "[native code]".
            globalThisGetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS,
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            unboundGlobalThisGetter$LWS, []);
            // Preserve identity continuity of getters.
            keyToGlobalThisGetterRegistry$LWS[key$LWS] = globalThisGetter$LWS;
          }
          return globalThisGetter$LWS;
        } : undefined;
        const lookupFixedGetter$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? getUnforgeableGlobalThisGetter$LWS(key$LWS) : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, target$LWS, [key$LWS]) : undefined;
        const lookupFixedSetter$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, target$LWS, [key$LWS]) : undefined;
        const unboundGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? () => globalThisRef$LWS : undefined;
        const wrapDefineAccessOrProperty$LWS = originalFunc$LWS => {
          const {
            length: originalFuncLength$LWS
          } = originalFunc$LWS;
          // `__defineGetter__()` and `__defineSetter__()` have
          // function lengths of 2 while `Reflect.defineProperty()`
          // has a function length of 3.
          const useThisArgAsTarget$LWS = originalFuncLength$LWS === 2;
          return new ProxyCtor$LWS(originalFunc$LWS, {
            apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
              if (args$LWS.length >= originalFuncLength$LWS) {
                const target$LWS = useThisArgAsTarget$LWS ? thisArg$LWS : args$LWS[0];
                if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
                  const key$LWS = useThisArgAsTarget$LWS ? args$LWS[0] : args$LWS[1];
                  const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
                  if (state$LWS != null && state$LWS[key$LWS]) {
                    // Activate the descriptor by triggering
                    // its getter.
                    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                    target$LWS[key$LWS];
                  }
                }
              }
              return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
            }
          });
        };
        const wrapLookupAccessor$LWS = (originalFunc$LWS, lookupFixedAccessor$LWS) => new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
            if (args$LWS.length && (typeof thisArg$LWS === 'object' && thisArg$LWS !== null || typeof thisArg$LWS === 'function')) {
              const {
                0: key$LWS
              } = args$LWS;
              const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(thisArg$LWS);
              if (state$LWS != null && state$LWS[key$LWS]) {
                // Activate the descriptor by triggering
                // its getter.
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                thisArg$LWS[key$LWS];
              }
              if (shouldFixChromeBug$LWS && thisArg$LWS === globalThisRef$LWS) {
                return lookupFixedAccessor$LWS(thisArg$LWS, key$LWS);
              }
            }
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          }
        });
        const wrapGetOwnPropertyDescriptor$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
            if (args$LWS.length > 1) {
              const {
                0: target$LWS,
                1: key$LWS
              } = args$LWS;
              if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
                const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
                if (state$LWS != null && state$LWS[key$LWS]) {
                  // Activate the descriptor by triggering
                  // its getter.
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  target$LWS[key$LWS];
                }
                if (shouldFixChromeBug$LWS && target$LWS === globalThisRef$LWS) {
                  return getFixedDescriptor$LWS(target$LWS, key$LWS);
                }
              }
            }
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          }
        });
        const wrapGetOwnPropertyDescriptors$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
            const target$LWS = args$LWS.length ? args$LWS[0] : undefined;
            if (!(typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function')) {
              // Defer to native method to throw exception.
              return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
            }
            const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
            const isFixingChromeBug$LWS = target$LWS === globalThisRef$LWS && shouldFixChromeBug$LWS;
            const unsafeDescs$LWS = isFixingChromeBug$LWS ?
            // Create an empty property descriptor map
            // to populate with curated descriptors.
            {} :
            // Since this is not a global object it is
            // safe to use the native method.
            ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
            if (!isFixingChromeBug$LWS && state$LWS === undefined) {
              // Exit early if the target is not a global
              // object and there are no lazy descriptors.
              return unsafeDescs$LWS;
            }
            const ownKeys$LWS = ReflectOwnKeys$LWS(isFixingChromeBug$LWS ? target$LWS : unsafeDescs$LWS);
            for (let i$LWS = 0, {
                length: length$LWS
              } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
              const ownKey$LWS = ownKeys$LWS[i$LWS];
              const isLazyProp$LWS = !!(state$LWS != null && state$LWS[ownKey$LWS]);
              if (isLazyProp$LWS) {
                // Activate the descriptor by triggering
                // its getter.
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                target$LWS[ownKey$LWS];
              }
              if (isLazyProp$LWS || isFixingChromeBug$LWS) {
                const unsafeDesc$LWS = isFixingChromeBug$LWS ? getFixedDescriptor$LWS(target$LWS, ownKey$LWS) : ReflectGetOwnPropertyDescriptor$LWS(target$LWS, ownKey$LWS);
                // Update the descriptor map entry.
                if (unsafeDesc$LWS) {
                  unsafeDescs$LWS[ownKey$LWS] = unsafeDesc$LWS;
                } else if (!isFixingChromeBug$LWS) {
                  ReflectDeleteProperty$LWS(unsafeDescs$LWS, ownKey$LWS);
                }
              }
            }
            return unsafeDescs$LWS;
          }
        });
        try {
          ReflectRef$LWS.defineProperty = wrapDefineAccessOrProperty$LWS(ReflectDefineProperty$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused19$LWS) {}
        try {
          ReflectRef$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ReflectGetOwnPropertyDescriptor$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused20$LWS) {}
        try {
          ObjectCtor$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ObjectGetOwnPropertyDescriptor$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused21$LWS) {}
        try {
          ObjectCtor$LWS.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors$LWS(ObjectGetOwnPropertyDescriptors$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused22$LWS) {}
        try {
          // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
          ObjectProto$LWS.__defineGetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineGetter$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused23$LWS) {}
        try {
          // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
          ObjectProto$LWS.__defineSetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineSetter$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused24$LWS) {}
        try {
          // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
          ObjectProto$LWS.__lookupGetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupGetter$LWS, lookupFixedGetter$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused25$LWS) {}
        try {
          // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
          ObjectProto$LWS.__lookupSetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupSetter$LWS, lookupFixedSetter$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused26$LWS) {}
      } : noop$LWS;
      function lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS) {
        let protoPointerOrNull$LWS;
        let safeDesc$LWS;
        try {
          protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) => {
            safeDesc$LWS = {
              __proto__: null,
              foreign: true
            };
            if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
              safeDesc$LWS.configurable = configurable$LWS;
            }
            if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
              safeDesc$LWS.enumerable = enumerable$LWS;
            }
            if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
              safeDesc$LWS.writable = writable$LWS;
            }
            if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
              if (typeof getterPointerOrPrimitive$LWS === 'function') {
                getterPointerOrPrimitive$LWS();
                safeDesc$LWS.get = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                safeDesc$LWS.get = undefined;
              }
            }
            if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
              if (typeof setterPointerOrPrimitive$LWS === 'function') {
                setterPointerOrPrimitive$LWS();
                safeDesc$LWS.set = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                safeDesc$LWS.set = undefined;
              }
            }
            if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
              if (typeof valuePointerOrPrimitive$LWS === 'function') {
                valuePointerOrPrimitive$LWS();
                safeDesc$LWS.value = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
              }
            }
            if (configurable$LWS === false) {
              // Update the descriptor to non-configurable on
              // the shadow target.
              ReflectDefineProperty$LWS(shadowTarget$LWS, key$LWS, safeDesc$LWS);
            }
          });
        } catch (error) {
          var _selectedTarget10$LWS;
          const errorToThrow$LWS = (_selectedTarget10$LWS = selectedTarget$LWS) != null ? _selectedTarget10$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (safeDesc$LWS === undefined) {
          // Avoiding calling the has trap for any proto chain operation,
          // instead we implement the regular logic here in this trap.
          let currentObject$LWS;
          if (typeof protoPointerOrNull$LWS === 'function') {
            protoPointerOrNull$LWS();
            currentObject$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            currentObject$LWS = null;
          }
          while (currentObject$LWS) {
            safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(currentObject$LWS, key$LWS);
            if (safeDesc$LWS) {
              ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
              break;
            }
            currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
          }
          if (safeDesc$LWS) {
            var _ref3$LWS;
            const {
              get: getter$LWS,
              set: setter$LWS,
              value: localValue$LWS
            } = safeDesc$LWS;
            const possibleProxy$LWS = (_ref3$LWS = getter$LWS != null ? getter$LWS : setter$LWS) != null ? _ref3$LWS : localValue$LWS;
            safeDesc$LWS.foreign = (typeof possibleProxy$LWS === 'object' && possibleProxy$LWS !== null || typeof possibleProxy$LWS === 'function') && proxyPointerCache$LWS.get(possibleProxy$LWS) !== undefined;
          }
        }
        return safeDesc$LWS;
      }
      function passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
        const safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
        // Following the specification steps for
        // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).
        // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor
        if (safeDesc$LWS) {
          if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
            const {
              set: setter$LWS
            } = safeDesc$LWS;
            if (setter$LWS) {
              if (safeDesc$LWS.foreign) {
                foreignCallableApply$LWS(getTransferablePointer$LWS(setter$LWS),
                // Inline getTransferableValue().
                typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) :
                // Intentionally ignoring `document.all`.
                // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
                // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
                typeof receiver$LWS === 'undefined' ? undefined : receiver$LWS,
                // Inline getTransferableValue().
                typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
                // Intentionally ignoring `document.all`.
                // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
                // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
                typeof value$LWS === 'undefined' ? undefined : value$LWS);
              } else {
                // Even though the setter function exists, we can't
                // use `ReflectSet()` because there might be a
                // distortion for that setter function, in which
                // case we must resolve the local setter and call
                // it instead.
                ReflectApply$LWS(setter$LWS, receiver$LWS, [value$LWS]);
              }
              // If there is a setter, it either throw or we can assume
              // the value was set.
              return true;
            }
            return false;
          }
          if (safeDesc$LWS.writable === false) {
            return false;
          }
        }
        // Exit early if receiver is not object like.
        if (!(typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function')) {
          return false;
        }
        const safeReceiverDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(receiver$LWS, key$LWS);
        if (safeReceiverDesc$LWS) {
          ReflectSetPrototypeOf$LWS(safeReceiverDesc$LWS, null);
          // Exit early for accessor descriptors or non-writable data
          // descriptors.
          if ('get' in safeReceiverDesc$LWS || 'set' in safeReceiverDesc$LWS || safeReceiverDesc$LWS.writable === false) {
            return false;
          }
          // Setting the descriptor with only a value entry should not
          // affect existing descriptor traits.
          ReflectDefineProperty$LWS(receiver$LWS, key$LWS, {
            __proto__: null,
            value: value$LWS
          });
          return true;
        }
        // `ReflectDefineProperty()` and `ReflectSet()` both are expected
        // to return `false` when attempting to add a new property if the
        // receiver is not extensible.
        return ReflectDefineProperty$LWS(receiver$LWS, key$LWS, {
          __proto__: null,
          configurable: true,
          enumerable: true,
          value: value$LWS,
          writable: true
        });
      }
      function pushErrorAcrossBoundary$LWS(error) {
        if (LOCKER_DEBUGGABLE_FLAG$LWS) {
          checkDebugMode$LWS();
        }
        // Inline getTransferableValue().
        if (typeof error === 'object' && error !== null || typeof error === 'function') {
          const foreignErrorPointer$LWS = getTransferablePointer$LWS(error, foreignCallablePushErrorTarget$LWS);
          foreignErrorPointer$LWS();
        }
        return error;
      }
      function pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const {
          proxy: proxy$LWS
        } = new BoundaryProxyHandler$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
        proxyPointerCache$LWS.set(proxy$LWS, foreignTargetPointer$LWS);
        return createPointer$LWS(proxy$LWS);
      }
      const setLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (target$LWS, state$LWS) => {
        lazyPropertyDescriptorStateCache$LWS.set(target$LWS, state$LWS);
        foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(target$LWS), getTransferablePointer$LWS(state$LWS));
      } : noop$LWS;
      class BoundaryProxyHandler$LWS {
        constructor(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
          // Internal red/shadow realm side utilities:
          this.makeProxyLive = IS_IN_SHADOW_REALM$LWS ? function () {
            // Replace pending traps with live traps that can work with the
            // target without taking snapshots.
            this.deleteProperty = BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
            this.defineProperty = BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
            this.preventExtensions = BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
            this.set = BoundaryProxyHandler$LWS.passthruSetTrap;
            this.setPrototypeOf = BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
          } : noop$LWS;
          this.makeProxyStatic = IS_IN_SHADOW_REALM$LWS ? function () {
            // Reset all traps except apply and construct for static proxies
            // since the proxy target is the shadow target and all operations
            // are going to be applied to it rather than the real target.
            this.defineProperty = BoundaryProxyHandler$LWS.staticDefinePropertyTrap;
            this.deleteProperty = BoundaryProxyHandler$LWS.staticDeletePropertyTrap;
            this.get = BoundaryProxyHandler$LWS.staticGetTrap;
            this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap;
            this.getPrototypeOf = BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap;
            this.has = BoundaryProxyHandler$LWS.staticHasTrap;
            this.isExtensible = BoundaryProxyHandler$LWS.staticIsExtensibleTrap;
            this.ownKeys = BoundaryProxyHandler$LWS.staticOwnKeysTrap;
            this.preventExtensions = BoundaryProxyHandler$LWS.staticPreventExtensionsTrap;
            this.set = BoundaryProxyHandler$LWS.staticSetTrap;
            this.setPrototypeOf = BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;
            const {
              foreignTargetPointer: foreignTargetPointer$LWS,
              foreignTargetTraits: foreignTargetTraits$LWS,
              shadowTarget: shadowTarget$LWS
            } = this;
            if (useFastForeignTargetPath$LWS) {
              fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
            }
            // We don't wrap `foreignCallableGetTargetIntegrityTraits()`
            // in a try-catch because it cannot throw.
            const targetIntegrityTraits$LWS = foreignCallableGetTargetIntegrityTraits$LWS(foreignTargetPointer$LWS);
            if (targetIntegrityTraits$LWS & 8 /* TargetIntegrityTraits.Revoked */) {
              // the target is a revoked proxy, in which case we revoke
              // this proxy as well.
              this.revoke();
              return;
            }
            // A proxy can revoke itself when traps are triggered and break
            // the membrane, therefore we need protection.
            try {
              copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            } catch (_unused27$LWS) {
              // We don't wrap `foreignCallableIsTargetRevoked()` in a
              // try-catch because it cannot throw.
              if (foreignCallableIsTargetRevoked$LWS(foreignTargetPointer$LWS)) {
                this.revoke();
                return;
              }
            }
            if (foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */ && !(SymbolToStringTag$LWS in shadowTarget$LWS)) {
              let toStringTag$LWS = 'Object';
              try {
                toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
                // eslint-disable-next-line no-empty
              } catch (_unused28$LWS) {}
              this.staticToStringTag = toStringTag$LWS;
            }
            // Preserve the semantics of the target.
            if (targetIntegrityTraits$LWS & 4 /* TargetIntegrityTraits.IsFrozen */) {
              ObjectFreeze$LWS(shadowTarget$LWS);
            } else {
              if (targetIntegrityTraits$LWS & 2 /* TargetIntegrityTraits.IsSealed */) {
                ObjectSeal$LWS(shadowTarget$LWS);
              } else if (targetIntegrityTraits$LWS & 1 /* TargetIntegrityTraits.IsNotExtensible */) {
                ReflectPreventExtensions$LWS(shadowTarget$LWS);
              }
              {
                // We don't wrap `foreignCallableDebugInfo()` in a try-catch
                // because it cannot throw.
                foreignCallableDebugInfo$LWS('Mutations on the membrane of an object originating ' + 'outside of the sandbox will not be reflected on ' + 'the object itself:', foreignTargetPointer$LWS);
              }
            }
          } : noop$LWS;
          let shadowTarget$LWS;
          const isForeignTargetArray$LWS = foreignTargetTraits$LWS & 1 /* TargetTraits.IsArray */;
          const isForeignTargetFunction$LWS = foreignTargetTraits$LWS & 4 /* TargetTraits.IsFunction */;
          if (isForeignTargetFunction$LWS) {
            // This shadow target is never invoked. It's needed to avoid
            // proxy trap invariants. Because it's not invoked the code
            // does not need to be instrumented for code coverage.
            //
            // istanbul ignore next
            shadowTarget$LWS = foreignTargetTraits$LWS & 8 /* TargetTraits.IsArrowFunction */ ? () => {} : function () {};
          } else if (isForeignTargetArray$LWS) {
            shadowTarget$LWS = [];
          } else {
            shadowTarget$LWS = {};
          }
          const {
            proxy: proxy$LWS,
            revoke: revoke$LWS
          } = ProxyRevocable$LWS(shadowTarget$LWS, this);
          this.foreignTargetPointer = foreignTargetPointer$LWS;
          this.foreignTargetTraits = foreignTargetTraits$LWS;
          this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength$LWS;
          // Define in the BoundaryProxyHandler constructor so it is bound
          // to the BoundaryProxyHandler instance.
          this.nonConfigurableDescriptorCallback = (key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            // Update the descriptor to non-configurable on the shadow
            // target.
            ReflectDefineProperty$LWS(this.shadowTarget, key$LWS, createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS));
          };
          this.proxy = proxy$LWS;
          this.revoke = revoke$LWS;
          this.serialize = noop$LWS;
          this.shadowTarget = shadowTarget$LWS;
          this.staticToStringTag = 'Object';
          // Define traps.
          if (isForeignTargetFunction$LWS) {
            var _applyTrapNameRegistr$LWS, _constructTrapNameReg$LWS;
            this.apply = this[(_applyTrapNameRegistr$LWS = applyTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _applyTrapNameRegistr$LWS : applyTrapNameRegistry$LWS.n];
            this.construct = this[(_constructTrapNameReg$LWS = constructTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _constructTrapNameReg$LWS : constructTrapNameRegistry$LWS.n];
          }
          this.defineProperty = BoundaryProxyHandler$LWS.defaultDefinePropertyTrap;
          this.deleteProperty = BoundaryProxyHandler$LWS.defaultDeletePropertyTrap;
          this.isExtensible = BoundaryProxyHandler$LWS.defaultIsExtensibleTrap;
          this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap;
          this.getPrototypeOf = BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap;
          this.get = foreignTargetTraits$LWS & 32 /* TargetTraits.IsTypedArray */ ? BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray : BoundaryProxyHandler$LWS.defaultGetTrap;
          this.has = BoundaryProxyHandler$LWS.defaultHasTrap;
          this.ownKeys = BoundaryProxyHandler$LWS.defaultOwnKeysTrap;
          this.preventExtensions = BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap;
          this.setPrototypeOf = BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap;
          this.set = BoundaryProxyHandler$LWS.defaultSetTrap;
          if (foreignTargetTraits$LWS & 64 /* TargetTraits.Revoked */) {
            this.revoke();
          } else if (IS_IN_SHADOW_REALM$LWS) {
            if (isForeignTargetArray$LWS || foreignTargetTraits$LWS & 2 /* TargetTraits.IsArrayBufferView */) {
              this.makeProxyLive();
            }
          } else {
            if (foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */) {
              // Lazily define serialize method.
              let cachedSerializedValue$LWS = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
              this.serialize = () => {
                if (cachedSerializedValue$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
                  cachedSerializedValue$LWS = foreignCallableSerializeTarget$LWS(this.foreignTargetPointer);
                }
                return cachedSerializedValue$LWS;
              };
            }
          }
        }
        // Passthru traps:
        static passthruDefinePropertyTrap(_shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS) {
          lastProxyTrapCalled$LWS = 4 /* ProxyHandlerTraps.DefineProperty */;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            nonConfigurableDescriptorCallback: nonConfigurableDescriptorCallback$LWS
          } = this;
          const safePartialDesc$LWS = unsafePartialDesc$LWS;
          ReflectSetPrototypeOf$LWS(safePartialDesc$LWS, null);
          const {
            get: getter$LWS,
            set: setter$LWS,
            value: value$LWS
          } = safePartialDesc$LWS;
          const valuePointerOrPrimitive$LWS = 'value' in safePartialDesc$LWS ?
          // Inline getTransferableValue().
          typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          const getterPointerOrUndefinedSymbol$LWS = 'get' in safePartialDesc$LWS ?
          // Inline getTransferableValue().
          typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          const setterPointerOrUndefinedSymbol$LWS = 'set' in safePartialDesc$LWS ?
          // Inline getTransferableValue().
          typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          let result$LWS = false;
          try {
            result$LWS = foreignCallableDefineProperty$LWS(foreignTargetPointer$LWS, key$LWS, 'configurable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, valuePointerOrPrimitive$LWS, getterPointerOrUndefinedSymbol$LWS, setterPointerOrUndefinedSymbol$LWS, nonConfigurableDescriptorCallback$LWS);
          } catch (error) {
            var _selectedTarget11$LWS;
            const errorToThrow$LWS = (_selectedTarget11$LWS = selectedTarget$LWS) != null ? _selectedTarget11$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (useFastForeignTargetPath$LWS && result$LWS && (typeof getterPointerOrUndefinedSymbol$LWS === 'function' || typeof setterPointerOrUndefinedSymbol$LWS === 'function')) {
            fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
          }
          return result$LWS;
        }
        static passthruDeletePropertyTrap(_shadowTarget$LWS, key$LWS) {
          lastProxyTrapCalled$LWS = 8 /* ProxyHandlerTraps.DeleteProperty */;
          let result$LWS = false;
          try {
            result$LWS = foreignCallableDeleteProperty$LWS(this.foreignTargetPointer, key$LWS);
          } catch (error) {
            var _selectedTarget12$LWS;
            const errorToThrow$LWS = (_selectedTarget12$LWS = selectedTarget$LWS) != null ? _selectedTarget12$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          return result$LWS;
        }
        static passthruGetPrototypeOfTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 64 /* ProxyHandlerTraps.GetPrototypeOf */;
          let protoPointerOrNull$LWS;
          try {
            protoPointerOrNull$LWS = foreignCallableGetPrototypeOf$LWS(this.foreignTargetPointer);
          } catch (error) {
            var _selectedTarget13$LWS;
            const errorToThrow$LWS = (_selectedTarget13$LWS = selectedTarget$LWS) != null ? _selectedTarget13$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          let proto$LWS;
          if (typeof protoPointerOrNull$LWS === 'function') {
            protoPointerOrNull$LWS();
            proto$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            proto$LWS = null;
          }
          return proto$LWS;
        }
        static passthruIsExtensibleTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 256 /* ProxyHandlerTraps.IsExtensible */;
          const {
            shadowTarget: shadowTarget$LWS
          } = this;
          let result$LWS = false;
          // Check if already locked.
          if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
            const {
              foreignTargetPointer: foreignTargetPointer$LWS
            } = this;
            try {
              result$LWS = foreignCallableIsExtensible$LWS(foreignTargetPointer$LWS);
            } catch (error) {
              var _selectedTarget14$LWS;
              const errorToThrow$LWS = (_selectedTarget14$LWS = selectedTarget$LWS) != null ? _selectedTarget14$LWS : error;
              selectedTarget$LWS = undefined;
              throw errorToThrow$LWS;
            }
            if (!result$LWS) {
              copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
              ReflectPreventExtensions$LWS(shadowTarget$LWS);
            }
          }
          return result$LWS;
        }
        static passthruOwnKeysTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 512 /* ProxyHandlerTraps.OwnKeys */;
          let ownKeys$LWS;
          try {
            foreignCallableOwnKeys$LWS(this.foreignTargetPointer, (...args$LWS) => {
              ownKeys$LWS = args$LWS;
            });
          } catch (error) {
            var _selectedTarget15$LWS;
            const errorToThrow$LWS = (_selectedTarget15$LWS = selectedTarget$LWS) != null ? _selectedTarget15$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          return ownKeys$LWS || [];
        }
        static passthruGetOwnPropertyDescriptorTrap(_shadowTarget$LWS, key$LWS) {
          lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          let safeDesc$LWS;
          try {
            foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
              safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
              if (safeDesc$LWS.configurable === false) {
                // Update the descriptor to non-configurable on
                // the shadow target.
                ReflectDefineProperty$LWS(shadowTarget$LWS, key$LWS, safeDesc$LWS);
              }
            });
          } catch (error) {
            var _selectedTarget16$LWS;
            const errorToThrow$LWS = (_selectedTarget16$LWS = selectedTarget$LWS) != null ? _selectedTarget16$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          // Getting forged descriptors of handshake properties is not allowed.
          if (IS_NOT_IN_SHADOW_REALM$LWS && safeDesc$LWS && (key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS)) {
            throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
          return safeDesc$LWS;
        }
        static passthruPreventExtensionsTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 1024 /* ProxyHandlerTraps.PreventExtensions */;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          let result$LWS = true;
          if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
            let resultEnum$LWS = 0 /* PreventExtensionsResult.None */;
            try {
              resultEnum$LWS = foreignCallablePreventExtensions$LWS(foreignTargetPointer$LWS);
            } catch (error) {
              var _selectedTarget17$LWS;
              const errorToThrow$LWS = (_selectedTarget17$LWS = selectedTarget$LWS) != null ? _selectedTarget17$LWS : error;
              selectedTarget$LWS = undefined;
              throw errorToThrow$LWS;
            }
            // If the target is a proxy it might reject the
            // preventExtension call, in which case we should not
            // attempt to lock down the shadow target.
            if (!(resultEnum$LWS & 1 /* PreventExtensionsResult.Extensible */)) {
              copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
              ReflectPreventExtensions$LWS(shadowTarget$LWS);
            }
            result$LWS = !(resultEnum$LWS & 2 /* PreventExtensionsResult.False */);
          }

          return result$LWS;
        }
        static passthruSetPrototypeOfTrap(_shadowTarget$LWS, proto$LWS) {
          lastProxyTrapCalled$LWS = 4096 /* ProxyHandlerTraps.SetPrototypeOf */;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const transferableProto$LWS = proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
          let result$LWS = false;
          try {
            result$LWS = foreignCallableSetPrototypeOf$LWS(foreignTargetPointer$LWS, transferableProto$LWS);
          } catch (error) {
            var _selectedTarget18$LWS;
            const errorToThrow$LWS = (_selectedTarget18$LWS = selectedTarget$LWS) != null ? _selectedTarget18$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (useFastForeignTargetPath$LWS && result$LWS) {
            fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
          }
          return result$LWS;
        }
        static passthruSetTrap(_shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
          lastProxyTrapCalled$LWS = 2048 /* ProxyHandlerTraps.Set */;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            proxy: proxy$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          if (typeof value$LWS === 'undefined') {
            value$LWS = undefined;
          }
          if (typeof receiver$LWS === 'undefined') {
            receiver$LWS = proxy$LWS;
          }
          // Setting forged values of handshake properties is not allowed.
          if (IS_NOT_IN_SHADOW_REALM$LWS && (key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS)) {
            throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
          const isFastPath$LWS = proxy$LWS === receiver$LWS;
          let result$LWS = false;
          try {
            result$LWS = isFastPath$LWS ? foreignCallableSet$LWS(foreignTargetPointer$LWS, key$LWS,
            // Inline getTransferableValue().
            typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS) : passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS);
          } catch (error) {
            var _selectedTarget19$LWS;
            const errorToThrow$LWS = (_selectedTarget19$LWS = selectedTarget$LWS) != null ? _selectedTarget19$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          return result$LWS;
        }
      }
      // Logic implementation of all traps.
      // Hybrid traps:
      // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):
      BoundaryProxyHandler$LWS.hybridGetTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS,
          proxy: proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let safeDesc$LWS;
        let result$LWS;
        if (useFastForeignTargetPath$LWS && fastForeignTargetPointers$LWS.has(foreignTargetPointer$LWS)) {
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, key$LWS);
          } catch (error) {
            var _selectedTarget20$LWS;
            const errorToThrow$LWS = (_selectedTarget20$LWS = selectedTarget$LWS) != null ? _selectedTarget20$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
        } else {
          safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
          if (safeDesc$LWS) {
            const {
              get: getter$LWS,
              value: localValue$LWS
            } = safeDesc$LWS;
            if (getter$LWS) {
              if (safeDesc$LWS.foreign) {
                const foreignGetterPointer$LWS = getTransferablePointer$LWS(getter$LWS);
                const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
                // Inline getTransferableValue().
                typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
                let pointerOrPrimitive$LWS;
                try {
                  pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
                } catch (error) {
                  var _selectedTarget21$LWS;
                  const errorToThrow$LWS = (_selectedTarget21$LWS = selectedTarget$LWS) != null ? _selectedTarget21$LWS : error;
                  selectedTarget$LWS = undefined;
                  throw errorToThrow$LWS;
                }
                if (typeof pointerOrPrimitive$LWS === 'function') {
                  pointerOrPrimitive$LWS();
                  result$LWS = selectedTarget$LWS;
                  selectedTarget$LWS = undefined;
                } else {
                  result$LWS = pointerOrPrimitive$LWS;
                }
              } else {
                // Even though the getter function exists,
                // we can't use `ReflectGet()` because there
                // might be a distortion for that getter function,
                // in which case we must resolve the local getter
                // and call it instead.
                result$LWS = ReflectApply$LWS(getter$LWS, receiver$LWS, []);
              }
            } else {
              result$LWS = localValue$LWS;
            }
          } else {
            const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
            // Inline getTransferableValue().
            typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
            let pointerOrPrimitive$LWS;
            try {
              pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, key$LWS, transferableReceiver$LWS);
            } catch (error) {
              var _selectedTarget22$LWS;
              const errorToThrow$LWS = (_selectedTarget22$LWS = selectedTarget$LWS) != null ? _selectedTarget22$LWS : error;
              selectedTarget$LWS = undefined;
              throw errorToThrow$LWS;
            }
            if (typeof pointerOrPrimitive$LWS === 'function') {
              pointerOrPrimitive$LWS();
              result$LWS = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              result$LWS = pointerOrPrimitive$LWS;
            }
          }
        }
        if (safeDesc$LWS === undefined && result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */) {
          let toStringTag$LWS;
          try {
            toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget23$LWS;
            const errorToThrow$LWS = (_selectedTarget23$LWS = selectedTarget$LWS) != null ? _selectedTarget23$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          // The default language toStringTag is "Object". If we
          // receive "Object" we return `undefined` to let the
          // language resolve it naturally without projecting a
          // value.
          if (toStringTag$LWS !== 'Object') {
            result$LWS = toStringTag$LWS;
          }
        }
        return result$LWS;
      } : noop$LWS;
      BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTypedArrayLength: foreignTargetTypedArrayLength$LWS,
          proxy: proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let useFastPath$LWS = useFastForeignTargetPathForTypedArrays$LWS;
        if (!useFastPath$LWS && typeof key$LWS === 'string') {
          const possibleIndex$LWS = +key$LWS;
          useFastPath$LWS = possibleIndex$LWS > -1 && possibleIndex$LWS < foreignTargetTypedArrayLength$LWS && NumberIsInteger$LWS(possibleIndex$LWS);
        }
        let result$LWS;
        if (useFastPath$LWS) {
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, key$LWS);
          } catch (error) {
            var _selectedTarget24$LWS;
            const errorToThrow$LWS = (_selectedTarget24$LWS = selectedTarget$LWS) != null ? _selectedTarget24$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
        } else {
          const safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
          if (safeDesc$LWS) {
            const {
              get: getter$LWS,
              value: localValue$LWS
            } = safeDesc$LWS;
            if (getter$LWS) {
              if (safeDesc$LWS.foreign) {
                const foreignGetterPointer$LWS = getTransferablePointer$LWS(getter$LWS);
                const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
                // Inline getTransferableValue().
                typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
                let pointerOrPrimitive$LWS;
                try {
                  pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
                } catch (error) {
                  var _selectedTarget25$LWS;
                  const errorToThrow$LWS = (_selectedTarget25$LWS = selectedTarget$LWS) != null ? _selectedTarget25$LWS : error;
                  selectedTarget$LWS = undefined;
                  throw errorToThrow$LWS;
                }
                if (typeof pointerOrPrimitive$LWS === 'function') {
                  pointerOrPrimitive$LWS();
                  result$LWS = selectedTarget$LWS;
                  selectedTarget$LWS = undefined;
                } else {
                  result$LWS = pointerOrPrimitive$LWS;
                }
              } else {
                // Even though the getter function exists,
                // we can't use `ReflectGet()` because there
                // might be a distortion for that getter function,
                // in which case we must resolve the local getter
                // and call it instead.
                result$LWS = ReflectApply$LWS(getter$LWS, receiver$LWS, []);
              }
            } else {
              result$LWS = localValue$LWS;
            }
          }
        }
        return result$LWS;
      } : noop$LWS;
      BoundaryProxyHandler$LWS.hybridHasTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS) {
        let trueOrProtoPointerOrNull$LWS;
        try {
          trueOrProtoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS(this.foreignTargetPointer, key$LWS);
        } catch (error) {
          var _selectedTarget26$LWS;
          const errorToThrow$LWS = (_selectedTarget26$LWS = selectedTarget$LWS) != null ? _selectedTarget26$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS = false;
        if (trueOrProtoPointerOrNull$LWS === true) {
          result$LWS = true;
        } else {
          // Avoiding calling the has trap for any proto chain operation,
          // instead we implement the regular logic here in this trap.
          let currentObject$LWS;
          if (typeof trueOrProtoPointerOrNull$LWS === 'function') {
            trueOrProtoPointerOrNull$LWS();
            currentObject$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            currentObject$LWS = null;
          }
          while (currentObject$LWS) {
            if (ObjectHasOwn$LWS(currentObject$LWS, key$LWS)) {
              result$LWS = true;
              break;
            }
            currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
          }
        }
        return result$LWS;
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.passthruGetTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
        // Only allow accessing handshake property values if the
        // "has" trap has been triggered immediately BEFORE and
        // the property does NOT exist.
        handshakePropertyFlag$LWS && (handshakePropertyFlag$LWS = lastProxyTrapCalled$LWS === 128 /* ProxyHandlerTraps.Has */);
        lastProxyTrapCalled$LWS = 16 /* ProxyHandlerTraps.Get */;
        const isNearMembraneSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
        const isNearMembraneSerializedValueSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
        if (handshakePropertyFlag$LWS) {
          // Exit without performing a [[Get]] for handshake
          // properties because we know that when the
          // `handshakePropertyFlag` is ON that there are NO
          // shadowed values.
          if (isNearMembraneSymbol$LWS) {
            return true;
          }
          if (isNearMembraneSerializedValueSymbol$LWS) {
            return this.serialize();
          }
        }
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS,
          proxy: proxy$LWS
        } = this;
        if (typeof receiver$LWS === 'undefined') {
          receiver$LWS = proxy$LWS;
        }
        const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS :
        // Inline getTransferableValue().
        typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, key$LWS, transferableReceiver$LWS);
        } catch (error) {
          var _selectedTarget27$LWS;
          const errorToThrow$LWS = (_selectedTarget27$LWS = selectedTarget$LWS) != null ? _selectedTarget27$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        // Getting forged values of handshake properties is not allowed.
        if (result$LWS !== undefined && (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS)) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      } : noop$LWS;
      BoundaryProxyHandler$LWS.passthruHasTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 128 /* ProxyHandlerTraps.Has */;
        let result$LWS;
        try {
          result$LWS = foreignCallableHas$LWS(this.foreignTargetPointer, key$LWS);
        } catch (error) {
          var _selectedTarget28$LWS;
          const errorToThrow$LWS = (_selectedTarget28$LWS = selectedTarget$LWS) != null ? _selectedTarget28$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        const isNearMembraneSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
        const isNearMembraneSerializedValueSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
        if (result$LWS) {
          handshakePropertyFlag$LWS = false;
          // Checking the existence of forged handshake properties
          // is not allowed.
          if (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS) {
            throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
        } else {
          // The `handshakePropertyFlag` is ON if the handshake
          // property does NOT exist on the object or its [[Prototype]].
          handshakePropertyFlag$LWS = isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS;
        }
        return result$LWS;
      } : alwaysFalse$LWS;
      // Pending traps:
      BoundaryProxyHandler$LWS.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS
        } = this;
        // We don't wrap `foreignCallableIsTargetLive()` in a
        // try-catch because it cannot throw.
        if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
          this.makeProxyLive();
        } else {
          if (useFastForeignTargetPath$LWS) {
            if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
              disableFastForeignTargetPointers$LWS();
            } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
              useFastForeignTargetPathForTypedArrays$LWS = false;
            }
          }
          this.makeProxyStatic();
        }
        return this.defineProperty(shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS) {
        // We don't wrap `foreignCallableIsTargetLive()` in a
        // try-catch because it cannot throw.
        if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
          this.makeProxyLive();
        } else {
          this.makeProxyStatic();
        }
        return this.deleteProperty(shadowTarget$LWS, key$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS) {
        // We don't wrap `foreignCallableIsTargetLive()` in a
        // try-catch because it cannot throw.
        if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
          this.makeProxyLive();
        } else {
          this.makeProxyStatic();
        }
        return this.preventExtensions(shadowTarget$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, proto$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS
        } = this;
        // We don't wrap `foreignCallableIsTargetLive()` in a
        // try-catch because it cannot throw.
        if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
          this.makeProxyLive();
        } else {
          if (useFastForeignTargetPath$LWS) {
            if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
              disableFastForeignTargetPointers$LWS();
            } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
              useFastForeignTargetPathForTypedArrays$LWS = false;
            }
          }
          this.makeProxyStatic();
        }
        return this.setPrototypeOf(shadowTarget$LWS, proto$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingSetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS
        } = this;
        // We don't wrap `foreignCallableIsTargetLive()` in a
        // try-catch because it cannot throw.
        if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
          this.makeProxyLive();
        } else {
          if (useFastForeignTargetPath$LWS) {
            if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
              disableFastForeignTargetPointers$LWS();
            } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
              useFastForeignTargetPathForTypedArrays$LWS = false;
            }
          }
          this.makeProxyStatic();
        }
        return this.set(shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS);
      } : alwaysFalse$LWS;
      //  Static traps:
      BoundaryProxyHandler$LWS.staticDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDefineProperty$LWS : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDeleteProperty$LWS : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetOwnPropertyDescriptor$LWS : noop$LWS;
      BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetPrototypeOf$LWS : () => null;
      BoundaryProxyHandler$LWS.staticGetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, receiver$LWS) {
        const {
          foreignTargetTraits: foreignTargetTraits$LWS,
          staticToStringTag: staticToStringTag$LWS
        } = this;
        const result$LWS = ReflectGet$LWS(shadowTarget$LWS, key$LWS, receiver$LWS);
        if (result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */ &&
        // The default language toStringTag is "Object". If we
        // receive "Object" we return `undefined` to let the
        // language resolve it naturally without projecting a
        // value.
        staticToStringTag$LWS !== 'Object' && !(key$LWS in shadowTarget$LWS)) {
          return staticToStringTag$LWS;
        }
        return result$LWS;
      } : noop$LWS;
      BoundaryProxyHandler$LWS.staticHasTrap = IS_IN_SHADOW_REALM$LWS ? ReflectHas$LWS : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticIsExtensibleTrap = IS_IN_SHADOW_REALM$LWS ? ReflectIsExtensible$LWS : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticOwnKeysTrap = IS_IN_SHADOW_REALM$LWS ? ReflectOwnKeys$LWS : () => [];
      BoundaryProxyHandler$LWS.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? ReflectPreventExtensions$LWS : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSetPrototypeOf$LWS : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticSetTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSet$LWS : alwaysFalse$LWS;
      // Default traps:
      // Pending traps are needed for the shadow realm side of the membrane
      // to avoid leaking mutation operations on the primary realm side.
      BoundaryProxyHandler$LWS.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDefinePropertyTrap : BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
      BoundaryProxyHandler$LWS.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDeletePropertyTrap : BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
      BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap;
      BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap = BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap;
      BoundaryProxyHandler$LWS.defaultGetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridGetTrap : BoundaryProxyHandler$LWS.passthruGetTrap;
      BoundaryProxyHandler$LWS.defaultHasTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridHasTrap : BoundaryProxyHandler$LWS.passthruHasTrap;
      BoundaryProxyHandler$LWS.defaultIsExtensibleTrap = BoundaryProxyHandler$LWS.passthruIsExtensibleTrap;
      BoundaryProxyHandler$LWS.defaultOwnKeysTrap = BoundaryProxyHandler$LWS.passthruOwnKeysTrap;
      BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap : BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
      BoundaryProxyHandler$LWS.defaultSetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetTrap : BoundaryProxyHandler$LWS.passthruSetTrap;
      BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap : BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
      if (IS_IN_SHADOW_REALM$LWS) {
        // Initialize `fastForeignTargetPointers` weak map.
        clearFastForeignTargetPointers$LWS();
      }
      // Export callable hooks to a foreign realm.
      foreignCallableHooksCallback$LWS(
      // globalThisPointer
      // When crossing, should be mapped to the foreign globalThis
      createPointer$LWS(globalThisRef$LWS),
      // getSelectedTarget
      IS_NOT_IN_SHADOW_REALM$LWS ? () => {
        const result$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        return result$LWS;
      } : noop$LWS,
      // getTransferableValue
      value$LWS => {
        if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
          return getTransferablePointer$LWS(value$LWS);
        }
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        return typeof value$LWS === 'undefined' ? undefined : value$LWS;
      },
      // callableGetPropertyValuePointer: this callable function allows
      // the foreign realm to access a linkable pointer for a property value.
      // In order to do that, the foreign side must provide a pointer and
      // a key access the value in order to produce a pointer
      (targetPointer$LWS, key$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        const value$LWS = target$LWS == null ? void 0 : target$LWS[key$LWS];
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        return createPointer$LWS(typeof value$LWS === 'undefined' ? undefined : value$LWS);
      },
      // callableEvaluate
      IS_IN_SHADOW_REALM$LWS ? sourceText$LWS => {
        let result$LWS;
        try {
          result$LWS = localEval$LWS(sourceText$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Inline getTransferableValue().
        return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) : result$LWS;
      } : noop$LWS,
      // callableLinkPointers: this callable function allows the foreign
      // realm to define a linkage between two values across the membrane.
      (targetPointer$LWS, newPointer$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
          proxyPointerCache$LWS.set(target$LWS, newPointer$LWS);
        }
      },
      // callablePushErrorTarget
      LOCKER_DEBUGGABLE_FLAG$LWS ? (foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) => {
        const pointer$LWS = pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
        const pointerWrapper$LWS = () => {
          checkDebugMode$LWS();
          return pointer$LWS();
        };
        return pointerWrapper$LWS;
      } : pushTarget$LWS,
      // callablePushTarget: This function can be used by a foreign realm
      // to install a proxy into this realm that correspond to an object
      // from the foreign realm. It returns a Pointer that can be used by
      // the foreign realm to pass back a reference to this realm when
      // passing arguments or returning from a foreign callable invocation.
      // This function is extremely important to understand the mechanics
      // of this membrane.
      pushTarget$LWS,
      // callableApply
      (targetPointer$LWS, thisArgPointerOrUndefined$LWS, ...args$LWS) => {
        targetPointer$LWS();
        const func$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let thisArg$LWS;
        if (typeof thisArgPointerOrUndefined$LWS === 'function') {
          thisArgPointerOrUndefined$LWS();
          thisArg$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const pointerOrPrimitive$LWS = args$LWS[i$LWS];
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            args$LWS[i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          }
        }
        let result$LWS;
        try {
          result$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, args$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Inline getTransferableValue().
        return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof result$LWS === 'undefined' ? undefined : result$LWS;
      },
      // callableConstruct
      (targetPointer$LWS, newTargetPointerOrUndefined$LWS, ...args$LWS) => {
        targetPointer$LWS();
        const constructor$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let newTarget$LWS;
        if (typeof newTargetPointerOrUndefined$LWS === 'function') {
          newTargetPointerOrUndefined$LWS();
          newTarget$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const pointerOrPrimitive$LWS = args$LWS[i$LWS];
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            args$LWS[i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          }
        }
        let result$LWS;
        try {
          result$LWS = ReflectConstruct$LWS(constructor$LWS, args$LWS, newTarget$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Inline getTransferableValue().
        return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof result$LWS === 'undefined' ? undefined : result$LWS;
      },
      // callableDefineProperty
      (targetPointer$LWS, key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, foreignCallableNonConfigurableDescriptorCallback$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        const safePartialDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
        let result$LWS = false;
        try {
          result$LWS = ReflectDefineProperty$LWS(target$LWS, key$LWS, safePartialDesc$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (result$LWS && configurable$LWS === false) {
          let safeDesc$LWS;
          try {
            safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
          } catch (error) {
            throw pushErrorAcrossBoundary$LWS(error);
          }
          if (safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
            if (safeDesc$LWS.configurable === false) {
              const {
                get: getter$LWS,
                set: setter$LWS,
                value: value$LWS
              } = safeDesc$LWS;
              foreignCallableNonConfigurableDescriptorCallback$LWS(key$LWS, false,
              // configurable
              'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
              // Inline getTransferableValue().
              typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
              // Inline getTransferableValue().
              typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
              // Inline getTransferableValue().
              typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
            }
          }
        }
        return result$LWS;
      },
      // callableDeleteProperty
      (targetPointer$LWS, key$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        try {
          return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      },
      // callableGet
      (targetPointer$LWS, targetTraits$LWS, key$LWS, receiverPointerOrPrimitive$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let receiver$LWS;
        if (typeof receiverPointerOrPrimitive$LWS === 'function') {
          receiverPointerOrPrimitive$LWS();
          receiver$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? target$LWS : receiverPointerOrPrimitive$LWS;
        }
        let result$LWS;
        try {
          result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Inline getTransferableValue().
        if (typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function') {
          return getTransferablePointer$LWS(result$LWS);
        }
        if (result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && targetTraits$LWS & 16 /* TargetTraits.IsObject */) {
          try {
            if (!(key$LWS in target$LWS)) {
              // Section 19.1.3.6 Object.prototype.toString()
              // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
              const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
              // The default language toStringTag is "Object". If
              // we receive "[object Object]" we return `undefined`
              // to let the language resolve it naturally without
              // projecting a value.
              if (brand$LWS !== '[object Object]') {
                result$LWS = ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
              }
            }
          } catch (error) {
            throw pushErrorAcrossBoundary$LWS(error);
          }
        }
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        return typeof result$LWS === 'undefined' ? undefined : result$LWS;
      },
      // callableGetOwnPropertyDescriptor
      (targetPointer$LWS, key$LWS, foreignCallableDescriptorCallback$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let safeDesc$LWS;
        try {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
          const {
            get: getter$LWS,
            set: setter$LWS,
            value: value$LWS
          } = safeDesc$LWS;
          foreignCallableDescriptorCallback$LWS(key$LWS, 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
        }
      },
      // callableGetPrototypeOf
      targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let proto$LWS;
        try {
          proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        if (typeof proto$LWS === 'undefined') {
          return null;
        }
        return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
      },
      // callableHas
      (targetPointer$LWS, key$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        try {
          return key$LWS in target$LWS;
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      },
      // callableIsExtensible
      targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        try {
          return ReflectIsExtensible$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      },
      // callableOwnKeys
      (targetPointer$LWS, foreignCallableKeysCallback$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let ownKeys$LWS;
        try {
          ownKeys$LWS = ReflectOwnKeys$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        ReflectApply$LWS(foreignCallableKeysCallback$LWS, undefined, ownKeys$LWS);
      },
      // callablePreventExtensions
      targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let result$LWS = 2 /* PreventExtensionsResult.False */;
        try {
          if (ReflectPreventExtensions$LWS(target$LWS)) {
            result$LWS = 4 /* PreventExtensionsResult.True */;
          } else if (ReflectIsExtensible$LWS(target$LWS)) {
            result$LWS |= 1 /* PreventExtensionsResult.Extensible */;
          }
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return result$LWS;
      },
      // callableSet
      (targetPointer$LWS, key$LWS, valuePointerOrPrimitive$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let value$LWS;
        if (typeof valuePointerOrPrimitive$LWS === 'function') {
          valuePointerOrPrimitive$LWS();
          value$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          value$LWS = valuePointerOrPrimitive$LWS;
        }
        try {
          return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      },
      // callableSetPrototypeOf
      (targetPointer$LWS, protoPointerOrNull$LWS = null) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let proto$LWS;
        if (typeof protoPointerOrNull$LWS === 'function') {
          // Instead of calling `protoPointerOrNull()` directly we use
          // `ReflectApply` to avoid a Maglev (https://v8.dev/blog/maglev)
          // optimizing JIT bug in Chrome >= 117:
          // https://bugs.chromium.org/p/chromium/issues/detail?id=1494060
          ReflectApply$LWS(protoPointerOrNull$LWS, undefined, []);
          proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          proto$LWS = null;
        }
        try {
          return ReflectSetPrototypeOf$LWS(target$LWS, proto$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      },
      // callableDebugInfo
      LOCKER_DEBUGGABLE_FLAG$LWS ? (...args$LWS) => {
        if (checkDebugMode$LWS()) {
          for (let i$LWS = 0, {
              length: length$LWS
            } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
            const pointerOrPrimitive$LWS = args$LWS[i$LWS];
            if (typeof pointerOrPrimitive$LWS === 'function') {
              pointerOrPrimitive$LWS();
              args$LWS[i$LWS] = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            }
          }
          try {
            ReflectApply$LWS(consoleInfo$LWS, consoleObject$LWS, args$LWS);
            // eslint-disable-next-line no-empty
          } catch (_unused29$LWS) {}
        }
      } : noop$LWS,
      // callableDefineProperties
      IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...descriptorTuples$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        for (let i$LWS = 0, {
            length: length$LWS
          } = descriptorTuples$LWS; i$LWS < length$LWS; i$LWS += 7) {
          // We don't use `ObjectDefineProperties()` here because it
          // will throw an exception if it fails to define one of its
          // properties.
          ReflectDefineProperty$LWS(target$LWS, descriptorTuples$LWS[i$LWS], createDescriptorFromMeta$LWS(descriptorTuples$LWS[i$LWS + 1],
          // configurable
          descriptorTuples$LWS[i$LWS + 2],
          // enumerable
          descriptorTuples$LWS[i$LWS + 3],
          // writable
          descriptorTuples$LWS[i$LWS + 4],
          // valuePointer
          descriptorTuples$LWS[i$LWS + 5],
          // getterPointer
          descriptorTuples$LWS[i$LWS + 6] // setterPointer
          ));
        }
      } : noop$LWS,
      // callableGetLazyPropertyDescriptorStateByTarget
      IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        // We don't wrap the weak map `get()` call in a try-catch
        // because we know `target` is an object.
        const state$LWS = proxyTargetToLazyPropertyDescriptorStateMap$LWS.get(target$LWS);
        return state$LWS ? getTransferablePointer$LWS(state$LWS) : state$LWS;
      } : noop$LWS,
      // callableGetPropertyValue
      IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, key$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let value$LWS;
        try {
          value$LWS = target$LWS[key$LWS];
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS;
      } : noop$LWS,
      // callableGetTargetIntegrityTraits
      IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        // A target may be a proxy that is revoked or throws in its
        // "isExtensible" trap.
        try {
          if (!ReflectIsExtensible$LWS(target$LWS)) {
            if (ObjectIsFrozen$LWS(target$LWS)) {
              return 4 /* TargetIntegrityTraits.IsFrozen */ & 2 /* TargetIntegrityTraits.IsSealed */ & 1 /* TargetIntegrityTraits.IsNotExtensible */;
            }

            if (ObjectIsSealed$LWS(target$LWS)) {
              return 2 /* TargetIntegrityTraits.IsSealed */ & 1 /* TargetIntegrityTraits.IsNotExtensible */;
            }

            return 1 /* TargetIntegrityTraits.IsNotExtensible */;
          }
        } catch (_unused30$LWS) {
          try {
            isArrayOrThrowForRevoked$LWS(target$LWS);
          } catch (_unused31$LWS) {
            return 8 /* TargetIntegrityTraits.Revoked */;
          }
        }

        return 0 /* TargetIntegrityTraits.None */;
      } : () => 0 /* TargetIntegrityTraits.None */,
      // callableGetToStringTagOfTarget
      targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        try {
          // Section 19.1.3.6 Object.prototype.toString()
          // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
          const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
          return brand$LWS === '[object Object]' ? 'Object' : ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      },
      // callableInstallErrorPrepareStackTrace
      installErrorPrepareStackTrace$LWS,
      // callableInstallLazyPropertyDescriptors
      IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
        const sliceIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS]);
        let ownKeys$LWS;
        let unforgeableGlobalThisKeys$LWS;
        if (sliceIndex$LWS === -1) {
          ownKeys$LWS = ownKeysAndUnforgeableGlobalThisKeys$LWS;
        } else {
          ownKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [0, sliceIndex$LWS]);
          unforgeableGlobalThisKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [sliceIndex$LWS + 1]);
        }
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
        if (state$LWS === undefined) {
          state$LWS = {
            __proto__: null
          };
          setLazyPropertyDescriptorStateByTarget$LWS(target$LWS, state$LWS);
        }
        for (let i$LWS = 0, {
            length: length$LWS
          } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const ownKey$LWS = ownKeys$LWS[i$LWS];
          state$LWS[ownKey$LWS] = true;
          ReflectDefineProperty$LWS(target$LWS, ownKey$LWS,
          // The role of this descriptor is to serve as a
          // bouncer. When either a getter or a setter is
          // invoked the descriptor will be replaced with
          // the descriptor from the foreign side and the
          // get/set operation will carry on from there.
          {
            __proto__: null,
            // We DO explicitly set configurability in the
            // off chance that the property doesn't exist.
            configurable: true,
            // We DON'T explicitly set enumerability to
            // defer to the enumerability of the existing
            // property. In the off chance the property
            // doesn't exist the property will be defined
            // as non-enumerable.
            get() {
              activateLazyOwnPropertyDefinition$LWS(target$LWS, ownKey$LWS, state$LWS);
              return target$LWS[ownKey$LWS];
            },
            set(value$LWS) {
              activateLazyOwnPropertyDefinition$LWS(target$LWS, ownKey$LWS, state$LWS);
              ReflectSet$LWS(target$LWS, ownKey$LWS, value$LWS);
            }
          });
        }
        installPropertyDescriptorMethodWrappers$LWS(unforgeableGlobalThisKeys$LWS);
      } : noop$LWS,
      // callableIsTargetLive
      IS_NOT_IN_SHADOW_REALM$LWS && liveTargetCallback$LWS ? (targetPointer$LWS, targetTraits$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        if (target$LWS !== ObjectProto$LWS && target$LWS !== RegExpProto$LWS) {
          try {
            return liveTargetCallback$LWS(target$LWS, targetTraits$LWS);
            // eslint-disable-next-line no-empty
          } catch (_unused32$LWS) {}
        }
        return false;
      } : alwaysFalse$LWS,
      // callableIsTargetRevoked
      IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        try {
          isArrayOrThrowForRevoked$LWS(target$LWS);
          return false;
          //  eslint-disable-next-line no-empty
        } catch (_unused33$LWS) {}
        return true;
      } : alwaysFalse$LWS,
      // callableSerializeTarget
      IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        try {
          return SymbolToStringTag$LWS in target$LWS ? serializeTargetByTrialAndError$LWS(target$LWS) :
          // Fast path.
          serializeTargetByBrand$LWS(target$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused34$LWS) {}
        return undefined;
      } : noop$LWS,
      // callableSetLazyPropertyDescriptorStateByTarget
      IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, statePointer$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        statePointer$LWS();
        const state$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        // We don't wrap the weak map `set()` call in a try-catch
        // because we know `target` is an object.
        proxyTargetToLazyPropertyDescriptorStateMap$LWS.set(target$LWS, state$LWS);
      } : noop$LWS,
      // callableTrackAsFastTarget
      IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        if (useFastForeignTargetPath$LWS) {
          fastForeignTargetPointers$LWS.add(getTransferablePointer$LWS(target$LWS));
        }
      } : noop$LWS,
      // callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors
      (targetPointer$LWS, foreignCallableDescriptorsCallback$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let unsafeDescs$LWS;
        try {
          unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeDescs$LWS);
        const {
          length: length$LWS
        } = ownKeys$LWS;
        const descriptorTuples$LWS = new ArrayCtor$LWS(length$LWS * 7);
        for (let i$LWS = 0, j$LWS = 0; i$LWS < length$LWS; i$LWS += 1, j$LWS += 7) {
          const ownKey$LWS = ownKeys$LWS[i$LWS];
          const safeDesc$LWS = unsafeDescs$LWS[ownKey$LWS];
          ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
          const {
            get: getter$LWS,
            set: setter$LWS,
            value: value$LWS
          } = safeDesc$LWS;
          descriptorTuples$LWS[j$LWS] = ownKey$LWS;
          descriptorTuples$LWS[j$LWS + 1] = 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          descriptorTuples$LWS[j$LWS + 2] = 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          descriptorTuples$LWS[j$LWS + 3] = 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          descriptorTuples$LWS[j$LWS + 4] = 'value' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          descriptorTuples$LWS[j$LWS + 5] = 'get' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          descriptorTuples$LWS[j$LWS + 6] = 'set' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        }
        ReflectApply$LWS(foreignCallableDescriptorsCallback$LWS, undefined, descriptorTuples$LWS);
        let proto$LWS;
        try {
          proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        if (typeof proto$LWS === 'undefined') {
          return null;
        }
        return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
      },
      // callableBatchGetPrototypeOfWhenHasNoOwnProperty
      (targetPointer$LWS, key$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let proto$LWS;
        try {
          if (ObjectHasOwn$LWS(target$LWS, key$LWS)) {
            return true;
          }
          proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        if (typeof proto$LWS === 'undefined') {
          return null;
        }
        return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
      },
      // callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor
      (targetPointer$LWS, key$LWS, foreignCallableDescriptorCallback$LWS) => {
        targetPointer$LWS();
        const target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
        let safeDesc$LWS;
        try {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
          const {
            get: getter$LWS,
            set: setter$LWS,
            value: value$LWS
          } = safeDesc$LWS;
          foreignCallableDescriptorCallback$LWS(key$LWS, 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
          // Inline getTransferableValue().
          typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
          return undefined;
        }
        let proto$LWS;
        try {
          proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        if (typeof proto$LWS === 'undefined') {
          return null;
        }
        return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
      });
      let foreignCallablesHooked$LWS = false;
      return (...hooks$LWS) => {
        if (foreignCallablesHooked$LWS) {
          return;
        }
        foreignCallablesHooked$LWS = true;
        ({
          // 0: globalThisPointer,
          // 1: getSelectedTarget,
          // 2: getTransferableValue,
          // 3: callableGetPropertyValuePointer,
          // 4: callableEvaluate,
          // 5: callableLinkPointers,
          6: foreignCallablePushErrorTarget$LWS,
          7: foreignCallablePushTarget$LWS,
          8: foreignCallableApply$LWS,
          9: foreignCallableConstruct$LWS,
          10: foreignCallableDefineProperty$LWS,
          11: foreignCallableDeleteProperty$LWS,
          12: foreignCallableGet$LWS,
          13: foreignCallableGetOwnPropertyDescriptor$LWS,
          14: foreignCallableGetPrototypeOf$LWS,
          15: foreignCallableHas$LWS,
          16: foreignCallableIsExtensible$LWS,
          17: foreignCallableOwnKeys$LWS,
          18: foreignCallablePreventExtensions$LWS,
          19: foreignCallableSet$LWS,
          20: foreignCallableSetPrototypeOf$LWS,
          21: foreignCallableDebugInfo$LWS,
          // 22: callableDefineProperties,
          23: foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS,
          24: foreignCallableGetPropertyValue$LWS,
          25: foreignCallableGetTargetIntegrityTraits$LWS,
          26: foreignCallableGetToStringTagOfTarget$LWS,
          27: foreignCallableInstallErrorPrepareStackTrace$LWS,
          // 28: callableInstallLazyPropertyDescriptors,
          29: foreignCallableIsTargetLive$LWS,
          30: foreignCallableIsTargetRevoked$LWS,
          31: foreignCallableSerializeTarget$LWS,
          32: foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS,
          // 33: callableTrackAsFastTarget,
          34: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
          35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
          36: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
        } = hooks$LWS);
        const applyTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const applyTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const applyTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const applyTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const applyTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const applyTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const applyTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
        const constructTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        const constructTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        const constructTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        const constructTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        const constructTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        const constructTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        const constructTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
        if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS === undefined) {
          // A minification safe way to get the 'apply' and 'construct'
          // trap property names.
          MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS = ObjectKeys$LWS({
            applyTrapForZeroOrMoreArgs: applyTrapForZeroOrMoreArgs$LWS,
            applyTrapForOneOrMoreArgs: applyTrapForOneOrMoreArgs$LWS,
            applyTrapForTwoOrMoreArgs: applyTrapForTwoOrMoreArgs$LWS,
            applyTrapForThreeOrMoreArgs: applyTrapForThreeOrMoreArgs$LWS,
            applyTrapForFourOrMoreArgs: applyTrapForFourOrMoreArgs$LWS,
            applyTrapForFiveOrMoreArgs: applyTrapForFiveOrMoreArgs$LWS,
            applyTrapForAnyNumberOfArgs: applyTrapForAnyNumberOfArgs$LWS,
            constructTrapForZeroOrMoreArgs: constructTrapForZeroOrMoreArgs$LWS,
            constructTrapForOneOrMoreArgs: constructTrapForOneOrMoreArgs$LWS,
            constructTrapForTwoOrMoreArgs: constructTrapForTwoOrMoreArgs$LWS,
            constructTrapForThreeOrMoreArgs: constructTrapForThreeOrMoreArgs$LWS,
            constructTrapForFourOrMoreArgs: constructTrapForFourOrMoreArgs$LWS,
            constructTrapForFiveOrMoreArgs: constructTrapForFiveOrMoreArgs$LWS,
            constructTrapForAnyNumberOfArgs: constructTrapForAnyNumberOfArgs$LWS
          });
        }
        applyTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[0];
        applyTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[1];
        applyTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[2];
        applyTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[3];
        applyTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[4];
        applyTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[5];
        applyTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[6];
        constructTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[7];
        constructTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[8];
        constructTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[9];
        constructTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[10];
        constructTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[11];
        constructTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[12];
        constructTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[13];
        const {
          prototype: BoundaryProxyHandlerProto$LWS
        } = BoundaryProxyHandler$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[0]] = applyTrapForZeroOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[1]] = applyTrapForOneOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[2]] = applyTrapForTwoOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[3]] = applyTrapForThreeOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[4]] = applyTrapForFourOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[5]] = applyTrapForFiveOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS.n] = applyTrapForAnyNumberOfArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[0]] = constructTrapForZeroOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[1]] = constructTrapForOneOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[2]] = constructTrapForTwoOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[3]] = constructTrapForThreeOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[4]] = constructTrapForFourOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[5]] = constructTrapForFiveOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS.n] = constructTrapForAnyNumberOfArgs$LWS;
        ReflectSetPrototypeOf$LWS(BoundaryProxyHandlerProto$LWS, null);
      };
    };
    /* eslint-enable prefer-object-spread */
  }

  const createMembraneMarshallSourceInStrictMode$LWS = `
'use strict';
(${createMembraneMarshall$LWS})`;
  function createBlueConnector$LWS(globalObject$LWS) {
    if (typeof globalObject$LWS !== 'object' || globalObject$LWS === null) {
      throw new TypeErrorCtor$LWS('Missing globalObject.');
    }
    return createMembraneMarshall$LWS(globalObject$LWS);
  }
  function createRedConnector$LWS(evaluator$LWS) {
    if (typeof evaluator$LWS !== 'function') {
      throw new TypeErrorCtor$LWS('Missing evaluator function.');
    }
    return evaluator$LWS(createMembraneMarshallSourceInStrictMode$LWS)();
  }
  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue');
  class VirtualEnvironment$LWS {
    constructor(options$LWS) {
      if (options$LWS === undefined) {
        throw new ErrorCtor$LWS('Missing required VirtualEnvironment options.');
      }
      // prettier-ignore
      const {
        blueConnector: blueConnector$LWS,
        redConnector: redConnector$LWS,
        distortionCallback: distortionCallback$LWS,
        instrumentation: instrumentation$LWS,
        liveTargetCallback: liveTargetCallback$LWS,
        revokedProxyCallback: revokedProxyCallback$LWS,
        signSourceCallback: signSourceCallback$LWS
        // eslint-disable-next-line prefer-object-spread
      } = ObjectAssign$LWS({
        __proto__: null
      }, options$LWS);
      let blueHooks$LWS;
      const blueConnect$LWS = blueConnector$LWS('blue', (...hooks$LWS) => {
        blueHooks$LWS = hooks$LWS;
      }, {
        distortionCallback: distortionCallback$LWS,
        instrumentation: instrumentation$LWS,
        liveTargetCallback: liveTargetCallback$LWS,
        revokedProxyCallback: revokedProxyCallback$LWS
      });
      const {
        0: blueGlobalThisPointer$LWS,
        1: blueGetSelectedTarget$LWS,
        2: blueGetTransferableValue$LWS,
        3: blueCallableGetPropertyValuePointer$LWS,
        // 4: blueCallableEvaluate,
        5: blueCallableLinkPointers$LWS,
        6: blueCallablePushErrorTarget$LWS,
        7: blueCallablePushTarget$LWS,
        8: blueCallableApply$LWS,
        9: blueCallableConstruct$LWS,
        10: blueCallableDefineProperty$LWS,
        11: blueCallableDeleteProperty$LWS,
        12: blueCallableGet$LWS,
        13: blueCallableGetOwnPropertyDescriptor$LWS,
        14: blueCallableGetPrototypeOf$LWS,
        15: blueCallableHas$LWS,
        16: blueCallableIsExtensible$LWS,
        17: blueCallableOwnKeys$LWS,
        18: blueCallablePreventExtensions$LWS,
        19: blueCallableSet$LWS,
        20: blueCallableSetPrototypeOf$LWS,
        // 21: blueCallableDebugInfo,
        // 22: blueCallableDefineProperties,
        23: blueCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        24: blueCallableGetPropertyValue$LWS,
        25: blueCallableGetTargetIntegrityTraits$LWS,
        26: blueCallableGetToStringTagOfTarget$LWS,
        27: blueCallableInstallErrorPrepareStackTrace$LWS,
        // 28: blueCallableInstallLazyPropertyDescriptors,
        29: blueCallableIsTargetLive$LWS,
        // 30: blueCallableIsTargetRevoked,
        // 31: blueCallableSerializeTarget,
        32: blueCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        // 33: blueTrackAsFastTarget,
        34: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        35: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        36: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = blueHooks$LWS;
      let redHooks$LWS;
      const redConnect$LWS = redConnector$LWS('red', (...hooks$LWS) => {
        redHooks$LWS = hooks$LWS;
      });
      const {
        0: redGlobalThisPointer$LWS,
        // 1: redGetSelectedTarget,
        // 2: redGetTransferableValue,
        3: redCallableGetPropertyValuePointer$LWS,
        4: redCallableEvaluate$LWS,
        5: redCallableLinkPointers$LWS,
        6: redCallablePushErrorTarget$LWS,
        7: redCallablePushTarget$LWS,
        8: redCallableApply$LWS,
        9: redCallableConstruct$LWS,
        10: redCallableDefineProperty$LWS,
        11: redCallableDeleteProperty$LWS,
        12: redCallableGet$LWS,
        13: redCallableGetOwnPropertyDescriptor$LWS,
        14: redCallableGetPrototypeOf$LWS,
        15: redCallableHas$LWS,
        16: redCallableIsExtensible$LWS,
        17: redCallableOwnKeys$LWS,
        18: redCallablePreventExtensions$LWS,
        19: redCallableSet$LWS,
        20: redCallableSetPrototypeOf$LWS,
        21: redCallableDebugInfo$LWS,
        22: redCallableDefineProperties$LWS,
        23: redCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        // 24: redCallableGetPropertyValue,
        25: redCallableGetTargetIntegrityTraits$LWS,
        26: redCallableGetToStringTagOfTarget$LWS,
        27: redCallableInstallErrorPrepareStackTrace$LWS,
        28: redCallableInstallLazyPropertyDescriptors$LWS,
        // 29: redCallableIsTargetLive,
        30: redCallableIsTargetRevoked$LWS,
        31: redCallableSerializeTarget$LWS,
        32: redCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        33: redCallableTrackAsFastTarget$LWS,
        34: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        35: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        36: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = redHooks$LWS;
      blueConnect$LWS(noop$LWS,
      // redGlobalThisPointer,
      noop$LWS,
      // redGetSelectedTarget,
      noop$LWS,
      // redGetTransferableValue,
      noop$LWS,
      // redCallableGetPropertyValuePointer,
      noop$LWS,
      // redCallableEvaluate,
      noop$LWS,
      // redCallableLinkPointers,
      redCallablePushErrorTarget$LWS, redCallablePushTarget$LWS, redCallableApply$LWS, redCallableConstruct$LWS, redCallableDefineProperty$LWS, redCallableDeleteProperty$LWS, redCallableGet$LWS, redCallableGetOwnPropertyDescriptor$LWS, redCallableGetPrototypeOf$LWS, redCallableHas$LWS, redCallableIsExtensible$LWS, redCallableOwnKeys$LWS, redCallablePreventExtensions$LWS, redCallableSet$LWS, redCallableSetPrototypeOf$LWS, redCallableDebugInfo$LWS, noop$LWS,
      // redCallableDefineProperties,
      redCallableGetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS,
      // redCallableGetPropertyValue,
      redCallableGetTargetIntegrityTraits$LWS, redCallableGetToStringTagOfTarget$LWS, redCallableInstallErrorPrepareStackTrace$LWS, noop$LWS,
      // redCallableInstallLazyPropertyDescriptors,
      noop$LWS,
      // redCallableIsTargetLive,
      redCallableIsTargetRevoked$LWS, redCallableSerializeTarget$LWS, redCallableSetLazyPropertyDescriptorStateByTarget$LWS, redCallableTrackAsFastTarget$LWS, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
      redConnect$LWS(noop$LWS,
      // blueGlobalThisPointer,
      noop$LWS,
      // blueGetSelectedTarget,
      noop$LWS,
      // blueGetTransferableValue,
      noop$LWS,
      // blueCallableGetPropertyValuePointer,
      noop$LWS,
      // blueCallableEvaluate,
      noop$LWS,
      // blueCallableLinkPointers,
      blueCallablePushErrorTarget$LWS, blueCallablePushTarget$LWS, blueCallableApply$LWS, blueCallableConstruct$LWS, blueCallableDefineProperty$LWS, blueCallableDeleteProperty$LWS, blueCallableGet$LWS, blueCallableGetOwnPropertyDescriptor$LWS, blueCallableGetPrototypeOf$LWS, blueCallableHas$LWS, blueCallableIsExtensible$LWS, blueCallableOwnKeys$LWS, blueCallablePreventExtensions$LWS, blueCallableSet$LWS, blueCallableSetPrototypeOf$LWS, noop$LWS,
      // blueCallableDebugInfo
      noop$LWS,
      // blueCallableDefineProperties,
      blueCallableGetLazyPropertyDescriptorStateByTarget$LWS, blueCallableGetPropertyValue$LWS, blueCallableGetTargetIntegrityTraits$LWS, blueCallableGetToStringTagOfTarget$LWS, blueCallableInstallErrorPrepareStackTrace$LWS, noop$LWS,
      // blueCallableInstallLazyPropertyDescriptors,
      blueCallableIsTargetLive$LWS, noop$LWS,
      // blueCallableIsTargetRevoked,
      noop$LWS,
      // blueCallableSerializeTarget,,
      blueCallableSetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS,
      // blueCallableTrackAsFastTarget,
      blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
      this.blueGlobalThisPointer = blueGlobalThisPointer$LWS;
      this.blueGetSelectedTarget = blueGetSelectedTarget$LWS;
      this.blueGetTransferableValue = blueGetTransferableValue$LWS;
      this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer$LWS;
      this.blueCallableLinkPointers = blueCallableLinkPointers$LWS;
      // Ensure the `this` context of red callable functions is `undefined`.
      this.redGlobalThisPointer = () => redGlobalThisPointer$LWS();
      this.redCallableGetPropertyValuePointer = (targetPointer$LWS, key$LWS) => redCallableGetPropertyValuePointer$LWS(targetPointer$LWS, key$LWS);
      this.redCallableEvaluate = signSourceCallback$LWS ? sourceText$LWS => redCallableEvaluate$LWS(signSourceCallback$LWS(sourceText$LWS)) : sourceText$LWS => redCallableEvaluate$LWS(sourceText$LWS);
      this.redCallableLinkPointers = (targetPointer$LWS, foreignTargetPointer$LWS) => redCallableLinkPointers$LWS(targetPointer$LWS, foreignTargetPointer$LWS);
      this.redCallableSetPrototypeOf = (targetPointer$LWS, protoPointerOrNull$LWS) => redCallableSetPrototypeOf$LWS(targetPointer$LWS, protoPointerOrNull$LWS);
      this.redCallableDefineProperties = (targetPointer$LWS, ...descriptorTuples$LWS) => {
        const {
          length: length$LWS
        } = descriptorTuples$LWS;
        const args$LWS = new ArrayCtor$LWS(length$LWS + 1);
        args$LWS[0] = targetPointer$LWS;
        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          args$LWS[i$LWS + 1] = descriptorTuples$LWS[i$LWS];
        }
        ReflectApply$LWS(redCallableDefineProperties$LWS, undefined, args$LWS);
      };
      this.redCallableInstallLazyPropertyDescriptors = (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
        const {
          length: length$LWS
        } = ownKeysAndUnforgeableGlobalThisKeys$LWS;
        const args$LWS = new ArrayCtor$LWS(length$LWS + 1);
        args$LWS[0] = targetPointer$LWS;
        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          args$LWS[i$LWS + 1] = ownKeysAndUnforgeableGlobalThisKeys$LWS[i$LWS];
        }
        ReflectApply$LWS(redCallableInstallLazyPropertyDescriptors$LWS, undefined, args$LWS);
      };
      this.redCallableTrackAsFastTarget = targetPointer$LWS => redCallableTrackAsFastTarget$LWS(targetPointer$LWS);
    }
    evaluate(sourceText$LWS) {
      try {
        const bluePointerOrPrimitiveValue$LWS = this.redCallableEvaluate(sourceText$LWS);
        if (typeof bluePointerOrPrimitiveValue$LWS === 'function') {
          bluePointerOrPrimitiveValue$LWS();
          return this.blueGetSelectedTarget();
        }
        return bluePointerOrPrimitiveValue$LWS;
      } catch (error) {
        var _this$blueGetSelected$LWS;
        throw (_this$blueGetSelected$LWS = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected$LWS : error;
      }
    }
    lazyRemapProperties(target$LWS, ownKeys$LWS, unforgeableGlobalThisKeys$LWS) {
      if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
        const args$LWS = [this.blueGetTransferableValue(target$LWS)];
        ReflectApply$LWS(ArrayProtoPush$LWS, args$LWS, ownKeys$LWS);
        if (unforgeableGlobalThisKeys$LWS != null && unforgeableGlobalThisKeys$LWS.length) {
          // Use `LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL` to delimit
          // `ownKeys` and `unforgeableGlobalThisKeys`.
          args$LWS[args$LWS.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          ReflectApply$LWS(ArrayProtoPush$LWS, args$LWS, unforgeableGlobalThisKeys$LWS);
        }
        ReflectApply$LWS(this.redCallableInstallLazyPropertyDescriptors, undefined, args$LWS);
      }
    }
    link(...keys$LWS) {
      let bluePointer$LWS = this.blueGlobalThisPointer;
      let redPointer$LWS = this.redGlobalThisPointer;
      for (let i$LWS = 0, {
          length: length$LWS
        } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const key$LWS = keys$LWS[i$LWS];
        bluePointer$LWS = this.blueCallableGetPropertyValuePointer(bluePointer$LWS, key$LWS);
        redPointer$LWS = this.redCallableGetPropertyValuePointer(redPointer$LWS, key$LWS);
        this.redCallableLinkPointers(redPointer$LWS, bluePointer$LWS);
        this.blueCallableLinkPointers(bluePointer$LWS, redPointer$LWS);
      }
    }
    remapProperties(target$LWS, unsafeBlueDescs$LWS) {
      if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
        const targetPointer$LWS = this.blueGetTransferableValue(target$LWS);
        const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeBlueDescs$LWS);
        const {
          length: length$LWS
        } = ownKeys$LWS;
        const args$LWS = new ArrayCtor$LWS(1 + length$LWS * 7);
        args$LWS[0] = targetPointer$LWS;
        for (let i$LWS = 0, j$LWS = 1; i$LWS < length$LWS; i$LWS += 1, j$LWS += 7) {
          const ownKey$LWS = ownKeys$LWS[i$LWS];
          const unsafeBlueDesc$LWS = unsafeBlueDescs$LWS[ownKey$LWS];
          // Avoid poisoning by only installing own properties from unsafeBlueDescs.
          // We don't use a toSafeDescriptor() style helper since that mutates
          // the unsafeBlueDesc.
          // eslint-disable-next-line prefer-object-spread
          const safeBlueDesc$LWS = ObjectAssign$LWS({
            __proto__: null
          }, unsafeBlueDesc$LWS);
          args$LWS[j$LWS] = ownKey$LWS;
          args$LWS[j$LWS + 1] = 'configurable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          args$LWS[j$LWS + 2] = 'enumerable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          args$LWS[j$LWS + 3] = 'writable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          args$LWS[j$LWS + 4] = 'value' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          args$LWS[j$LWS + 5] = 'get' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          args$LWS[j$LWS + 6] = 'set' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        }
        ReflectApply$LWS(this.redCallableDefineProperties, this, args$LWS);
      }
    }
    remapProto(target$LWS, proto$LWS) {
      if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
        const foreignTargetPointer$LWS = this.blueGetTransferableValue(target$LWS);
        const transferableProto$LWS = proto$LWS ? this.blueGetTransferableValue(proto$LWS) : proto$LWS;
        this.redCallableSetPrototypeOf(foreignTargetPointer$LWS, transferableProto$LWS);
      }
    }
    trackAsFastTarget(target$LWS) {
      if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
        this.redCallableTrackAsFastTarget(this.blueGetTransferableValue(target$LWS));
      }
    }
  }

  /**
   * This list must be in sync with ecma-262, anything new added to the global object
   * should be considered, to decide whether or not they need remapping. The default
   * behavior, if missing form the following list, is to be remapped, which is safer.
   *
   * Note: remapped means the functionality is provided by the blue realm, rather than
   * the red one. This helps with the identity discontinuity issue, e.g.: all Set objects
   * have the same identity because it is always derived from the outer realm's Set.
   *
   * Note 1: We have identified 3 types of intrinsics
   * A: primitives driven intrinsics
   * B: syntax driven intrinsics (they usually have a imperative form as well)
   * C: imperative only intrinsics
   *
   * While A is not remapped, it is safe, and works fast that way, and C is remapped to
   * preserve the identity of all produced objects from the same realm, B is really
   * problematic, and requires a lot more work to guarantee that objects from both sides
   * can be considered equivalents (without identity discontinuity).
   */
  function getESGlobalKeys$LWS(remapTypedArrays$LWS = true) {
    const ESGlobalKeys$LWS = [
    // *** 19.1 Value Properties of the Global Object
    'globalThis', 'Infinity', 'NaN', 'undefined',
    // *** 19.2 Function Properties of the Global Object
    // 'eval', // dangerous & Reflective
    'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
    // *** 19.3 Constructor Properties of the Global Object
    // 'AggregateError', // Reflective
    // 'Array', // Reflective
    'BigInt', 'Boolean',
    // 'Date', // Remapped
    // 'Error', // Reflective
    // 'EvalError', // Reflective
    'FinalizationRegistry',
    // 'Function', // dangerous & Reflective
    // 'Map', // Remapped
    'Number',
    // 'Object', // Reflective
    // Allow blue `Promise` constructor to overwrite the Red one so that promises
    // created by the `Promise` constructor or APIs like `fetch` will work.
    // 'Promise', // Remapped
    // 'Proxy', // Reflective
    // 'RangeError', // Reflective
    // 'ReferenceError', // Reflective
    'RegExp',
    // 'Set', // Remapped
    'String', 'Symbol',
    // 'SyntaxError', // Reflective
    // 'TypeError', // Reflective
    // 'URIError', // Reflective
    // 'WeakMap', // Remapped
    // 'WeakSet', // Remapped
    'WeakRef',
    // *** 18.4 Other Properties of the Global Object
    // 'Atomics', // Remapped
    'JSON', 'Math', 'Reflect',
    // *** Annex B
    'escape', 'unescape'
    // *** ECMA-402
    // 'Intl',  // Remapped
    ];

    if (remapTypedArrays$LWS === false) {
      ESGlobalKeys$LWS.push('ArrayBuffer', 'BigInt64Array', 'BigUint64Array', 'DataView', 'Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'SharedArrayBuffer', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array');
    }
    return ESGlobalKeys$LWS;
  }
  // These are foundational things that should never be wrapped but are equivalent
  // @TODO: Revisit this list.
  const ReflectiveIntrinsicObjectNames$LWS = ['AggregateError', 'Array', 'Error', 'EvalError', 'Function', 'Object', 'Proxy', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'eval', 'globalThis'];
  function getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(remapTypedArrays$LWS = true) {
    const ESGlobalKeys$LWS = getESGlobalKeys$LWS(remapTypedArrays$LWS);
    return toSafeArray$LWS([...ESGlobalKeys$LWS, ...ReflectiveIntrinsicObjectNames$LWS]);
  }
  function getGlobalObjectOwnKeys$LWS(source$LWS) {
    const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);
    // WKWebView incorrectly excludes the 'webkit' own property of the global
    // object from `Object.keys()` and `Reflect.ownKeys()` results, so add it.
    // istanbul ignore if: currently unreachable via tests
    if (ObjectHasOwn$LWS(source$LWS, 'webkit') && !ReflectApply$LWS(ArrayProtoIncludes$LWS, ownKeys$LWS, ['webkit'])) {
      ownKeys$LWS[ownKeys$LWS.length] = 'webkit';
    }
    return ownKeys$LWS;
  }
  function assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(descs$LWS, source$LWS, includeTypedArrays$LWS) {
    const ownKeys$LWS = getGlobalObjectOwnKeys$LWS(source$LWS);
    const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(includeTypedArrays$LWS);
    for (let i$LWS = 0, {
        length: length$LWS
      } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const ownKey$LWS = ownKeys$LWS[i$LWS];
      // Avoid overriding ECMAScript global names that correspond to
      // global intrinsics. This guarantee that those entries will be
      // ignored if present in the source property descriptor map.
      if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
        const unsafeDesc$LWS = source$LWS[ownKey$LWS];
        if (unsafeDesc$LWS) {
          // Avoid poisoning by only installing own properties from
          // unsafeDesc. We don't use a toSafeDescriptor() style helper
          // since that mutates the unsafeBlueDesc.
          // eslint-disable-next-line prefer-object-spread
          descs$LWS[ownKey$LWS] = ObjectAssign$LWS({
            __proto__: null
          }, unsafeDesc$LWS);
        }
      }
    }
    return descs$LWS;
  }
  function getFilteredGlobalOwnKeys$LWS(source$LWS, includeTypedArrays$LWS) {
    const result$LWS = [];
    let resultOffset$LWS = 0;
    const ownKeys$LWS = getGlobalObjectOwnKeys$LWS(source$LWS);
    const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(includeTypedArrays$LWS);
    for (let i$LWS = 0, {
        length: length$LWS
      } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const ownKey$LWS = ownKeys$LWS[i$LWS];
      // Avoid overriding ECMAScript global names that correspond to global
      // intrinsics. This guarantees that those entries will be ignored if
      // present in the source object.
      if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
        result$LWS[resultOffset$LWS++] = ownKey$LWS;
      }
    }
    return result$LWS;
  }
  function linkIntrinsics$LWS(env$LWS, globalObject$LWS) {
    // Remap intrinsics that are realm agnostic.
    for (let i$LWS = 0, {
        length: length$LWS
      } = ReflectiveIntrinsicObjectNames$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const globalName$LWS = ReflectiveIntrinsicObjectNames$LWS[i$LWS];
      const reflectiveValue$LWS = globalObject$LWS[globalName$LWS];
      if (reflectiveValue$LWS) {
        // Proxy.prototype is undefined.
        if (reflectiveValue$LWS.prototype) {
          env$LWS.link(globalName$LWS, 'prototype');
        } else {
          env$LWS.link(globalName$LWS);
        }
      }
    }
  }
  const blueDocumentToRecordMap$LWS = toSafeWeakMap$LWS(new WeakMap());
  // Chromium based browsers have a bug that nulls the result of `window`
  // getters in detached iframes when the property descriptor of `window.window`
  // is retrieved.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
  const unforgeablePoisonedWindowKeys$LWS = IS_CHROMIUM_BROWSER$LWS ? ['window'] : undefined;
  function getCachedGlobalObjectReferences$LWS(globalObject$LWS) {
    const {
      window: window$LWS
    } = globalObject$LWS;
    let record$LWS;
    let document$LWS;
    // Suppress errors thrown on cross-origin opaque windows.
    try {
      ({
        document: document$LWS
      } = globalObject$LWS);
      record$LWS = blueDocumentToRecordMap$LWS.get(document$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {
      return undefined;
    }
    if (record$LWS) {
      return record$LWS;
    }
    // Cache references to object values that can't be replaced
    // window -> Window -> WindowProperties -> EventTarget
    const WindowProto$LWS = ReflectGetPrototypeOf$LWS(window$LWS);
    const WindowPropertiesProto$LWS = ReflectGetPrototypeOf$LWS(WindowProto$LWS);
    const EventTargetProto$LWS = ReflectGetPrototypeOf$LWS(WindowPropertiesProto$LWS);
    record$LWS = {
      document: document$LWS,
      DocumentProto: ReflectGetPrototypeOf$LWS(document$LWS),
      window: window$LWS,
      WindowProto: ReflectGetPrototypeOf$LWS(window$LWS),
      WindowPropertiesProto: ReflectGetPrototypeOf$LWS(WindowProto$LWS),
      EventTargetProto: EventTargetProto$LWS,
      // Some simulated browser environments, e.g. those using JSDOM, may lack an EventTargetProto.
      EventTargetProtoOwnKeys: EventTargetProto$LWS ? ReflectOwnKeys$LWS(EventTargetProto$LWS) : []
    };
    blueDocumentToRecordMap$LWS.set(document$LWS, record$LWS);
    return record$LWS;
  }
  function filterWindowKeys$LWS(keys$LWS, remapTypedArrays$LWS) {
    const excludedKeys$LWS = new SetCtor$LWS(['document', 'location', 'top', 'window']);
    // Crypto and typed arrays must be from the same global object
    if (remapTypedArrays$LWS === false) {
      excludedKeys$LWS.add('crypto');
      excludedKeys$LWS.add('Crypto');
      excludedKeys$LWS.add('SubtleCrypto');
      excludedKeys$LWS.add('Blob');
      excludedKeys$LWS.add('File');
      excludedKeys$LWS.add('FileReader');
      excludedKeys$LWS.add('URL');
    }
    const result$LWS = [];
    let resultOffset$LWS = 0;
    for (let i$LWS = 0, {
        length: length$LWS
      } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = keys$LWS[i$LWS];
      if (ReflectApply$LWS(SetProtoHas$LWS, excludedKeys$LWS, [key$LWS])) {
        continue;
      }
      result$LWS[resultOffset$LWS++] = key$LWS;
    }
    return result$LWS;
  }
  /**
   * global descriptors are a combination of 3 set of descriptors:
   * - first, the key of the red descriptors define the descriptors
   *   provided by the browser when creating a brand new window.
   * - second, once we know the base keys, we get the actual descriptors
   *   from the blueDescriptors, since those are the one we want to provide
   *   access to via the membrane.
   * - third, the user of this library can provide endowments, which define
   *   global descriptors that should be installed into the sandbox on top
   *   of the base descriptors.
   *
   * Note: The main reason for using redDescriptors as the base keys instead
   * of blueDescriptor is because there is no guarantee that this library is
   * the first one to be evaluated in the host app, which means it has no ways
   * to determine what is a real DOM API vs app specific globals.
   *
   * Quirk: The only quirk here is for the case in which this library runs
   * after some other code that patches some of the DOM APIs. This means
   * the installed proxy in the sandbox will point to the patched global
   * API in the blue realm, rather than the original, because we don't have
   * a way to access the original anymore. This should not be a deal-breaker
   * if the patched API behaves according to the spec.
   *
   * The result of this method is a descriptor map that contains everything
   * that will be installed (via the membrane) as global descriptors in
   * the red realm.
   */
  function removeWindowDescriptors$LWS(unsafeDescs$LWS, remapTypedArrays$LWS) {
    // Remove unforgeable descriptors that cannot be installed.
    ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'document');
    ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'location');
    ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'top');
    ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'window');
    // Remove other browser specific unforgeables.
    ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'chrome');
    // Crypto and typed arrays must be from the same global object
    if (remapTypedArrays$LWS === false) {
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'crypto');
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'Crypto');
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'SubtleCrypto');
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'Blob');
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'File');
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'FileReader');
      ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'URL');
    }
    return unsafeDescs$LWS;
  }
  /**
   * Initialization operation to capture and cache all unforgeable references
   * and their respective descriptor maps before any other code runs, this
   * usually help because this library runs before anything else that can poison
   * the environment.
   */
  getCachedGlobalObjectReferences$LWS(rootWindow$LWS);
  const IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS = 'allow-same-origin allow-scripts';
  const revoked$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
  const blueCreateHooksCallbackCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
  function createDetachableIframe$LWS(doc$LWS) {
    var _ReflectApply$LWS;
    const iframe$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, ['iframe']);
    // It is impossible to test whether the NodeProtoLastChildGetter branch is
    // reached in a normal Karma test environment.
    const parent$LWS = (_ReflectApply$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, [])) != null ? _ReflectApply$LWS : /* istanbul ignore next */ReflectApply$LWS(NodeProtoLastChildGetter$LWS, doc$LWS, []);
    const style$LWS = ReflectApply$LWS(HTMLElementProtoStyleGetter$LWS, iframe$LWS, []);
    style$LWS.display = 'none';
    ReflectApply$LWS(ElementProtoSetAttribute$LWS, iframe$LWS, ['sandbox', IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS]);
    ReflectApply$LWS(NodeProtoAppendChild$LWS, parent$LWS, [iframe$LWS]);
    return iframe$LWS;
  }
  function createIframeVirtualEnvironment$LWS(globalObject$LWS, providedOptions$LWS) {
    if (typeof globalObject$LWS !== 'object' || globalObject$LWS === null) {
      throw new TypeErrorCtor$LWS('Missing global object virtualization target.');
    }
    const blueRefs$LWS = getCachedGlobalObjectReferences$LWS(globalObject$LWS);
    if (typeof blueRefs$LWS !== 'object' || blueRefs$LWS === null) {
      throw new TypeErrorCtor$LWS('Invalid virtualization target.');
    }
    const {
      distortionCallback: distortionCallback$LWS,
      defaultPolicy: defaultPolicy$LWS,
      endowments: endowments$LWS,
      globalObjectShape: globalObjectShape$LWS,
      instrumentation: instrumentation$LWS,
      keepAlive: keepAlive$LWS = true,
      liveTargetCallback: liveTargetCallback$LWS,
      remapTypedArrays: remapTypedArrays$LWS = true,
      signSourceCallback: signSourceCallback$LWS
      // eslint-disable-next-line prefer-object-spread
    } = ObjectAssign$LWS({
      __proto__: null
    }, providedOptions$LWS);
    const iframe$LWS = createDetachableIframe$LWS(blueRefs$LWS.document);
    const redWindow$LWS = ReflectApply$LWS(HTMLIFrameElementProtoContentWindowGetter$LWS, iframe$LWS, []);
    const shouldUseDefaultGlobalOwnKeys$LWS = typeof globalObjectShape$LWS !== 'object' || globalObjectShape$LWS === null;
    const defaultGlobalOwnKeys$LWS = filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(redWindow$LWS, remapTypedArrays$LWS), remapTypedArrays$LWS);
    let blueConnector$LWS = blueCreateHooksCallbackCache$LWS.get(blueRefs$LWS.document);
    if (blueConnector$LWS === undefined) {
      blueConnector$LWS = createBlueConnector$LWS(globalObject$LWS);
      blueCreateHooksCallbackCache$LWS.set(blueRefs$LWS.document, blueConnector$LWS);
    }
    // Install default TrustedTypes policy in the virtual environment.
    // @ts-ignore trustedTypes does not exist on GlobalObject
    if (typeof redWindow$LWS.trustedTypes !== 'undefined' && isObject$LWS(defaultPolicy$LWS)) {
      // @ts-ignore trustedTypes does not exist on GlobalObject
      redWindow$LWS.trustedTypes.createPolicy('default', defaultPolicy$LWS);
    }
    const {
      eval: redIndirectEval$LWS
    } = redWindow$LWS;
    const env$LWS = new VirtualEnvironment$LWS({
      blueConnector: blueConnector$LWS,
      redConnector: createRedConnector$LWS(signSourceCallback$LWS ? sourceText$LWS => redIndirectEval$LWS(signSourceCallback$LWS(sourceText$LWS)) : redIndirectEval$LWS),
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: keepAlive$LWS ? revokedProxyCallback$LWS : undefined,
      signSourceCallback: signSourceCallback$LWS
    });
    linkIntrinsics$LWS(env$LWS, globalObject$LWS);
    // window
    // window.document
    // In browsers globalThis is === window.
    if (typeof globalThis === 'undefined') {
      // Support for globalThis was added in Chrome 71.
      // However, environments like Android emulators are running Chrome 69.
      env$LWS.link('window', 'document');
    } else {
      // document is === window.document.
      env$LWS.link('document');
    }
    // window.__proto__ (aka Window.prototype)
    // window.__proto__.__proto__ (aka WindowProperties.prototype)
    // window.__proto__.__proto__.__proto__ (aka EventTarget.prototype)
    env$LWS.link('__proto__', '__proto__', '__proto__');
    env$LWS.remapProto(blueRefs$LWS.document, blueRefs$LWS.DocumentProto);
    env$LWS.lazyRemapProperties(blueRefs$LWS.window, shouldUseDefaultGlobalOwnKeys$LWS ? defaultGlobalOwnKeys$LWS : filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(globalObjectShape$LWS), remapTypedArrays$LWS),
    // Chromium based browsers have a bug that nulls the result of `window`
    // getters in detached iframes when the property descriptor of `window.window`
    // is retrieved.
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
    keepAlive$LWS ? undefined : unforgeablePoisonedWindowKeys$LWS);
    if (endowments$LWS) {
      const filteredEndowments$LWS = {};
      assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(filteredEndowments$LWS, endowments$LWS, remapTypedArrays$LWS);
      removeWindowDescriptors$LWS(filteredEndowments$LWS, remapTypedArrays$LWS);
      env$LWS.remapProperties(blueRefs$LWS.window, filteredEndowments$LWS);
    }
    // We intentionally skip remapping Window.prototype because there is nothing
    // in it that needs to be remapped.
    env$LWS.lazyRemapProperties(blueRefs$LWS.EventTargetProto, blueRefs$LWS.EventTargetProtoOwnKeys);
    // We don't remap `blueRefs.WindowPropertiesProto` because it is "magical"
    // in that it provides access to elements by id.
    //
    // Once we get the iframe info ready, and all mapped, we can proceed to
    // detach the iframe only if `options.keepAlive` isn't true.
    if (keepAlive$LWS) {
      // @TODO: Temporary hack to preserve the document reference in Firefox.
      // https://bugzilla.mozilla.org/show_bug.cgi?id=543435
      const {
        document: redDocument$LWS
      } = redWindow$LWS;
      // Revoke the proxies of the redDocument and redWindow to prevent access.
      revoked$LWS.add(redDocument$LWS);
      revoked$LWS.add(redWindow$LWS);
      ReflectApply$LWS(DocumentProtoOpen$LWS, redDocument$LWS, []);
      ReflectApply$LWS(DocumentProtoClose$LWS, redDocument$LWS, []);
    } else {
      if (IS_OLD_CHROMIUM_BROWSER$LWS) {
        // For Chromium < v86 browsers we evaluate the `window` object to
        // kickstart the realm so that `window` persists when the iframe is
        // removed from the document.
        redIndirectEval$LWS('window');
      }
      ReflectApply$LWS(ElementProtoRemove$LWS, iframe$LWS, []);
    }
    return env$LWS;
  }
  function revokedProxyCallback$LWS(value$LWS) {
    return revoked$LWS.has(value$LWS);
  }

  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function createResourceLoadError$LWS(url$LWS) {
    return new Error(`lightning/platformResourceLoader encountered an error loading ${enquote$LWS(url$LWS)}.`);
  }
  const EMPTY_EVAL_HELPERS$LWS = {
    forAwaitOf: noop$LWS$1,
    genToAsync: noop$LWS$1,
    loadScript: noop$LWS$1,
    loadStyle: noop$LWS$1,
    makeRedGet: noop$LWS$1,
    makeRedSyncImports: noop$LWS$1,
    namespace: noop$LWS$1,
    spreadable: noop$LWS$1,
    super: noop$LWS$1
  };
  // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md
  // istanbul ignore next
  const EVAL_HELPERS_SOURCE_TEXT$LWS = `'use strict';
        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function redHelpersFactory$LWS(baseGenToAsync$LWS, forAwaitOf$LWS, loadScript$LWS, loadStyle$LWS) {
    const ArrayCtor$LWS = Array;
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    const {
      iterator: SymbolIterator$LWS
    } = Symbol;
    const {
      [SymbolIterator$LWS]: ArrayProtoIterator$LWS
    } = ArrayCtor$LWS.prototype;
    // The Generator prototype object is %GeneratorFunction.prototype.prototype%.
    // https://tc39.es/ecma262/#sec-generatorfunction.prototype.prototype
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    const GeneratorProto$LWS = function* () {}.constructor.prototype.prototype;
    const {
      next: GeneratorProtoNext$LWS,
      throw: GeneratorProtoThrow$LWS
    } = GeneratorProto$LWS;
    const {
      defineProperties: ObjectDefineProperties$LWS,
      freeze: ObjectFreeze$LWS
    } = Object;
    const {
      // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
      apply: ReflectApply$LWS,
      get: ReflectGet$LWS,
      getPrototypeOf: ReflectGetPrototypeOf$LWS,
      setPrototypeOf: ReflectSetPrototypeOf$LWS
    } = Reflect;
    function genToAsync$LWS(func$LWS, thisArg$LWS) {
      let gen$LWS;
      const wrapGenMethod$LWS = genMethod$LWS => value$LWS => {
        if (gen$LWS === undefined) {
          gen$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, []);
        }
        return ReflectApply$LWS(genMethod$LWS, gen$LWS, [value$LWS]);
      };
      return baseGenToAsync$LWS(wrapGenMethod$LWS(GeneratorProtoNext$LWS), wrapGenMethod$LWS(GeneratorProtoThrow$LWS));
    }
    function makeRedGet$LWS(...bindings$LWS) {
      const {
        length: length$LWS
      } = bindings$LWS;
      const redGet$LWS = ArrayCtor$LWS(length$LWS);
      const descriptors$LWS = {};
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        descriptors$LWS[i$LWS] = {
          __proto__: null,
          get: bindings$LWS[i$LWS]
        };
      }
      ObjectDefineProperties$LWS(redGet$LWS, descriptors$LWS);
      return redGet$LWS;
    }
    function makeRedSyncImports$LWS(bindings$LWS) {
      return function (...args$LWS) {
        for (let i$LWS = 0, {
            length: length$LWS
          } = bindings$LWS; i$LWS < length$LWS; i$LWS += 1) {
          try {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            bindings$LWS[i$LWS];
            // eslint-disable-next-line no-empty
          } catch (_unused35$LWS) {}
        }
        return spreadable$LWS(args$LWS);
      };
    }
    function namespace$LWS(object$LWS) {
      return ObjectFreeze$LWS(object$LWS);
    }
    function spreadable$LWS(array$LWS) {
      ReflectSetPrototypeOf$LWS(array$LWS, null);
      array$LWS[SymbolIterator$LWS] = ArrayProtoIterator$LWS;
      return array$LWS;
    }
    function superApplyOrGet$LWS(target$LWS, key$LWS, thisArgOrReceiver$LWS, args$LWS) {
      const superProto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      if (superProto$LWS === null) {
        return undefined;
      }
      return args$LWS ? ReflectApply$LWS(superProto$LWS[key$LWS], thisArgOrReceiver$LWS, args$LWS) : ReflectGet$LWS(superProto$LWS, key$LWS, thisArgOrReceiver$LWS);
    }
    return {
      forAwaitOf: forAwaitOf$LWS,
      genToAsync: genToAsync$LWS,
      loadScript: loadScript$LWS,
      loadStyle: loadStyle$LWS,
      makeRedGet: makeRedGet$LWS,
      makeRedSyncImports: makeRedSyncImports$LWS,
      namespace: namespace$LWS,
      spreadable: spreadable$LWS,
      super: superApplyOrGet$LWS
    };
  }})`;
  function createEvalHelpersFactoryArgs$LWS(record$LWS) {
    const {
      document: document$LWS,
      document: {
        head: head$LWS
      },
      distortions: distortions$LWS,
      globalObject: {
        HTMLScriptElement: HTMLScriptElement$LWS,
        HTMLScriptElement: {
          prototype: HTMLScriptElementProto$LWS
        }
      },
      root: root$LWS
    } = record$LWS;
    const isRootRecord$LWS = record$LWS === root$LWS;
    const forOfStateCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
    const resourcePromiseCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    const resourceStatusCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    const scriptSrcGetterDistortion$LWS = distortions$LWS.get(isRootRecord$LWS ? HTMLScriptElementProtoSrcGetter$LWS : ObjectLookupOwnGetter$LWS$1(HTMLScriptElementProto$LWS, 'src'));
    const scriptSrcSetterDistortion$LWS = distortions$LWS.get(isRootRecord$LWS ? HTMLScriptElementProtoSrcSetter$LWS : ObjectLookupOwnSetter$LWS(HTMLScriptElementProto$LWS, 'src'));
    // istanbul ignore next: deprecated code path unreachable via tests
    function genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genMethodWrapper$LWS, arg$LWS) {
      let info$LWS;
      let value$LWS;
      try {
        info$LWS = genMethodWrapper$LWS(arg$LWS);
        value$LWS = info$LWS.value;
      } catch (error) {
        reject$LWS(error);
        return;
      }
      if (info$LWS.done) {
        resolve$LWS(value$LWS);
      } else {
        ReflectApply$LWS$1(PromiseProtoThen$LWS, PromiseResolve$LWS(value$LWS), [next$LWS, thrower$LWS]);
      }
    }
    // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
    function loadPromise$LWS(element$LWS, urlAsString$LWS) {
      const promise$LWS = new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
        function onerror$LWS(event$LWS) {
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['error', onerror$LWS]);
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['load', onload$LWS]);
          ReflectApply$LWS$1(EventProtoStopPropagation$LWS, event$LWS, []);
          resourceStatusCache$LWS.set(element$LWS, 1 /* ResourceLoaderStatus.Errored */);
          reject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
        }
        function onload$LWS() {
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['error', onerror$LWS]);
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['load', onload$LWS]);
          resourceStatusCache$LWS.set(element$LWS, 3 /* ResourceLoaderStatus.Loaded */);
          // platformResourceLoader and ltng:require have to be synchronized in terms of
          // creating and loading scripts. This expando is used by ltng:require to know if a
          // script has been loaded by it or not. See W-13034908.
          if (element$LWS instanceof HTMLScriptElement$LWS) {
            // eslint-disable-next-line no-underscore-dangle
            element$LWS._ltngRequireLoaded = true;
          }
          resolve$LWS(undefined);
        }
        ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, element$LWS, ['load', onload$LWS]);
      });
      resourceStatusCache$LWS.set(element$LWS, 2 /* ResourceLoaderStatus.Loading */);
      resourcePromiseCache$LWS.set(element$LWS, promise$LWS);
      ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, head$LWS, [element$LWS]);
      return promise$LWS;
    }
    return [
    // This helper is used to wrap the bodies of async functions that are
    // transformed into generator functions. It's based on @babel/helpers
    // `helpers.asyncToGenerator()`:
    // https://github.com/babel/babel/blob/a967910/packages/babel-helpers/src/helpers.js#L255-L288
    // istanbul ignore next: deprecated code path unreachable via tests
    function baseGenToAsync$LWS(genNextWrapper$LWS, genThrowWrapper$LWS) {
      return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
        function next$LWS(value$LWS) {
          genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genNextWrapper$LWS, value$LWS);
        }
        function thrower$LWS(error) {
          genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genThrowWrapper$LWS, error);
        }
        next$LWS(undefined);
      });
    },
    // istanbul ignore next: deprecated code path unreachable via tests
    function forAwaitOf$LWS(index$LWS, stage$LWS, object$LWS) {
      if (stage$LWS === 0 /* init */) {
        let sync$LWS = false;
        let {
          [SymbolAsyncIterator$LWS]: iterator$LWS
        } = object$LWS;
        if (iterator$LWS === null || iterator$LWS === undefined) {
          sync$LWS = true;
          ({
            [SymbolIterator$LWS$1]: iterator$LWS
          } = object$LWS);
        }
        if (typeof iterator$LWS !== 'function') {
          throw new TypeErrorCtor$LWS$1('Object is not async iterable');
        }
        forOfStateCache$LWS.set(index$LWS, {
          iterable: ReflectApply$LWS$1(iterator$LWS, object$LWS, []),
          step: undefined,
          sync: sync$LWS
        });
        return undefined;
      }
      const state$LWS = forOfStateCache$LWS.get(index$LWS);
      if (stage$LWS === 1 /* step */) {
        const result$LWS = state$LWS.iterable.next();
        return state$LWS.sync ? new PromiseCtor$LWS(resolve$LWS => {
          state$LWS.step = result$LWS;
          resolve$LWS();
        }) : ReflectApply$LWS$1(PromiseProtoThen$LWS, result$LWS, [step$LWS => {
          state$LWS.step = step$LWS;
        }]);
      }
      if (stage$LWS === 2 /* value */) {
        return state$LWS.step.value;
      }
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false if execution has reached this line.
      if (stage$LWS === 3 /* done */) {
        const done$LWS = !!state$LWS.step.done;
        if (done$LWS) {
          forOfStateCache$LWS.delete(index$LWS);
        }
        return done$LWS;
      }
      // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
      return undefined;
    },
    // Functionality based on platformResourceLoader#loadScript (https://sfdc.co/7FuDU) but
    // adjusted for multiple sandboxes. This loadScript will create one <script> element in the
    // DOM per url per sandbox.
    // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
    function loadScript$LWS(_thisArg$LWS, url$LWS) {
      const urlAsString$LWS = toString$LWS(url$LWS);
      const resolvedURL$LWS = resolveURL$LWS(urlAsString$LWS);
      const scripts$LWS = ReflectApply$LWS$1(ElementProtoQuerySelectorAll$LWS, head$LWS, ['script']);
      for (let i$LWS = 0, {
          length: length$LWS
        } = scripts$LWS; i$LWS < length$LWS; i$LWS += 1) {
        var _resourceStatusCache$$LWS;
        const script$LWS = scripts$LWS[i$LWS];
        // Ensure that this <script> is actually in the resource cache for this sandbox.
        // Previously this check only looked at the <script>'s src, which would give a
        // false positive if more than one sandbox had loaded this resource.
        const status$LWS = (_resourceStatusCache$$LWS = resourceStatusCache$LWS.get(script$LWS)) != null ? _resourceStatusCache$$LWS : 0 /* ResourceLoaderStatus.None */;
        // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
        if (status$LWS && ReflectApply$LWS$1(scriptSrcGetterDistortion$LWS, script$LWS, []) === resolvedURL$LWS) {
          if (status$LWS === 3 /* ResourceLoaderStatus.Loaded */) {
            return PromiseResolve$LWS(undefined);
          }
          // istanbul ignore if: this status cannot be tested without navigating the page itself during the execution of the request.
          if (status$LWS === 1 /* ResourceLoaderStatus.Errored */) {
            return PromiseReject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
          }
          if (status$LWS === 2 /* ResourceLoaderStatus.Loading */) {
            return resourcePromiseCache$LWS.get(script$LWS);
          }
        }
      }
      const script$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document$LWS, ['script']);
      script$LWS.type = 'text/javascript';
      // platformResourceLoader and ltng:require have to be synchronized in terms of creating
      // and loading scripts. This expando is used by ltng:require to know if a script
      // has been created by it or not. See W-13034908.
      // eslint-disable-next-line no-underscore-dangle
      script$LWS._ltngRequireCreated = true;
      ReflectApply$LWS$1(scriptSrcSetterDistortion$LWS, script$LWS, [urlAsString$LWS]);
      return loadPromise$LWS(script$LWS, urlAsString$LWS);
    },
    // Functionality based on platformResourceLoader#loadStyle (http://sfdc.co/bIpMYB) but
    // adjusted for multiple sandboxes. This loadStyle will create one <link> element in the DOM
    // per url for all the sandboxes.
    // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
    function loadStyle$LWS(_thisArg$LWS, url$LWS) {
      const urlAsString$LWS = toString$LWS(url$LWS);
      let link$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, head$LWS, [`link[href=${enquote$LWS(urlAsString$LWS)}]`]);
      if (link$LWS) {
        var _resourceStatusCache$2$LWS;
        const status$LWS = (_resourceStatusCache$2$LWS = resourceStatusCache$LWS.get(link$LWS)) != null ? _resourceStatusCache$2$LWS : 0 /* ResourceLoaderStatus.None */;
        if (status$LWS === 0 /* ResourceLoaderStatus.None */ || status$LWS === 3 /* ResourceLoaderStatus.Loaded */) {
          return PromiseResolve$LWS(undefined);
        }
        // istanbul ignore if: this status cannot be tested without navigating the page itself during the execution of the request.
        if (status$LWS === 1 /* ResourceLoaderStatus.Errored */) {
          return PromiseReject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
        }
        const promise$LWS = status$LWS === 2 /* ResourceLoaderStatus.Loading */ ? resourcePromiseCache$LWS.get(link$LWS) : undefined;
        return promise$LWS != null ? promise$LWS : PromiseResolve$LWS(undefined);
      }
      link$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document$LWS, ['link']);
      link$LWS.type = 'text/css';
      link$LWS.rel = 'stylesheet';
      link$LWS.href = urlAsString$LWS;
      return loadPromise$LWS(link$LWS, urlAsString$LWS);
    }];
  }
  function toSourceText$LWS(value$LWS, sourceType$LWS) {
    let sourceText$LWS = typeof value$LWS === 'function' ? extractFunctionBodySource$LWS(value$LWS) : toString$LWS(value$LWS);
    // We workaround bundlers, like Rollup, aggressively stripping inline source
    // maps by compiling them with the name "sandboxMappingURL". At runtime the
    // name is changed so the inline source map is registered.
    sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [
    // This regexp looks involved, but it prevents browsers and developer
    // tools from mistaking the regexp or the replacement string for an
    // actual source mapping URL.
    /\/\/# sandbox(?=MappingURL=.*?\s*$)/, '//# source']);
    sourceText$LWS = `\n//# LWS Version = "0.21.7"\n${sourceText$LWS}`;
    return sourceType$LWS === 1 /* SourceType.Module */ && indexOfPragma$LWS(sourceText$LWS, 'use strict') === -1 ?
    // Append "'use strict'" to the extracted function body so it is
    // evaluated in strict mode.
    `'use strict';${sourceText$LWS}` : sourceText$LWS;
  }

  // Flag whether the iframe should remain connected to the DOM.
  const IFRAME_KEEP_ALIVE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS && !false;
  // Fast path non-configurable document, location, and window objects in the
  // virtual environment distortion callback by seeding them in the root window's
  // created distortion map.
  const rootDistortionMapSeedEntries$LWS = [[rootDocument$LWS, rootDocument$LWS], [rootWindowLocation$LWS, rootWindowLocation$LWS], [rootWindow$LWS$1, rootWindow$LWS$1]];
  const seenGlobalObjects$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  function createGetVirtualEnvironment$LWS(record$LWS) {
    let virtualEnvironment$LWS;
    return () => {
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
      if (virtualEnvironment$LWS === undefined) {
        virtualEnvironment$LWS = createVirtualEnvironment$LWS(record$LWS);
      }
      return virtualEnvironment$LWS;
    };
  }
  function createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS) {
    let virtualEnvironment$LWS;
    return sourceText$LWS => {
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
      if (virtualEnvironment$LWS === undefined) {
        virtualEnvironment$LWS = getVirtualEnvironment$LWS();
        // Stash the old eval context.
        const context$LWS = clearEvalContext$LWS();
        // Populate `record.helpers`.
        setEvalContext$LWS(redEvalHelpersFactory$LWS => {
          const helpers$LWS = ReflectApply$LWS$1(redEvalHelpersFactory$LWS, undefined, createEvalHelpersFactoryArgs$LWS(record$LWS));
          record$LWS.helpers = helpers$LWS;
          setEvalHelpers$LWS(helpers$LWS);
        });
        virtualEnvironment$LWS.evaluate(EVAL_HELPERS_SOURCE_TEXT$LWS);
        if (typeof context$LWS === 'object' && context$LWS !== null) {
          // Track the `context` object and its properties as a fast
          // targets because it may contain things like `blueGet` and
          // `blueSet` arrays.
          virtualEnvironment$LWS.trackAsFastTarget(context$LWS);
          const ownKeys$LWS = ReflectOwnKeys$LWS$1(context$LWS);
          for (let i$LWS = 0, {
              length: length$LWS
            } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
            const value$LWS = context$LWS[ownKeys$LWS[i$LWS]];
            if (typeof value$LWS === 'object' && value$LWS !== null) {
              virtualEnvironment$LWS.trackAsFastTarget(value$LWS);
            }
          }
        }
        // Restore the old eval context.
        setEvalContext$LWS(context$LWS);
      }
      return virtualEnvironment$LWS.evaluate(sourceText$LWS);
    };
  }
  function createSandboxEvaluator$LWS({
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
    document: document$LWS,
    globalObject: globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    type: type$LWS
  }) {
    return (sourceText$LWS, evalContext$LWS = EMPTY_OBJECT$LWS, evalGlobalObject$LWS = globalObject$LWS, evalDocument$LWS = document$LWS) => internalEvaluateInSandbox$LWS({
      context: evalContext$LWS,
      document: evalDocument$LWS,
      endowments: EMPTY_OBJECT$LWS,
      globalObject: evalGlobalObject$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      source: sourceText$LWS,
      sourceType: 0 /* SourceType.Script */,
      type: type$LWS,
      verboseInstrumentation: verboseInstrumentation$LWS
    });
  }
  function createVirtualEnvironment$LWS(record$LWS) {
    const {
      endowments: endowments$LWS,
      globalObject: globalObject$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      root: root$LWS,
      root: {
        distortions: distortions$LWS
      },
      type: type$LWS
    } = record$LWS;
    // only Omnistudio test namespaces 'devopsimpkg*' or exact 'omnistudio' name
    let remapTypedArrays$LWS = true;
    if (key$LWS === 'omnistudio') {
      remapTypedArrays$LWS = false;
    } else if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, ['devopsimpkg'])) {
      remapTypedArrays$LWS = false;
    }
    return createIframeVirtualEnvironment$LWS(globalObject$LWS, {
      defaultPolicy: {
        createScript:
        // istanbul ignore next: this is used to create a default in near-membrane
        dirty$LWS => dirty$LWS
      },
      distortionCallback(originalTarget$LWS) {
        const distortedTarget$LWS = distortions$LWS.get(originalTarget$LWS);
        if (distortedTarget$LWS) {
          return distortedTarget$LWS;
        }
        if (typeof originalTarget$LWS === 'function') {
          return originalTarget$LWS;
        }
        // Perform the first own property check in a try-catch to avoid
        // throwing an error on opaque, non-window, objects of a cross-origin
        // window.
        try {
          // The location property is the only common non-configurable
          // property between window and document, so it serves this check
          // very well.
          if (!ObjectHasOwn$LWS$1(originalTarget$LWS, 'location')) {
            return originalTarget$LWS;
          }
        } catch (_unused36$LWS) {
          // Likely an opaque object of a cross-origin window.
          // istanbul ignore next: an access of property iframe.contentWindow.location.href on an opaque window, that should reach this catch clause IS tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
          return originalTarget$LWS;
        }
        let originalTargetDocument$LWS;
        let originalTargetWindow$LWS;
        // Do the safe cross-origin window object check first to avoid
        // failure caused by touching non-cross-origin-safe properties.
        if (ObjectHasOwn$LWS$1(originalTarget$LWS, 'window') && originalTarget$LWS.window === originalTarget$LWS) {
          // Slower check to detect a window object.
          try {
            // `WindowDocumentGetter` will throw if `originalTarget` is
            // not a window object, or if it is an opaque cross-origin window.
            originalTargetDocument$LWS = ReflectApply$LWS$1(WindowDocumentGetter$LWS, originalTarget$LWS, []);
            originalTargetWindow$LWS = originalTarget$LWS;
          } catch (_unused37$LWS) {
            try {
              // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
              if (ReflectApply$LWS$1(WindowLocationGetter$LWS, originalTarget$LWS, [])) {
                createOpaqueSecondaryWindowSandboxRecord$LWS({
                  globalObject: originalTarget$LWS,
                  key: key$LWS,
                  type: type$LWS
                }, root$LWS);
                return originalTarget$LWS;
              }
              // eslint-disable-next-line no-empty
            } catch (_unused38$LWS) {}
          }
          // Check if originalTarget is a document and get its defaultView.
        } else if ('defaultView' in originalTarget$LWS) {
          // If the object doesn't appear to be a window, same or
          // cross-origin, then it may be a document for window that we
          // haven't seen yet, but can safely check non-cross-origin-safe
          // properties of, specifically `defaultView` which will give us
          // a window if one exists.
          let defaultView$LWS;
          try {
            // This will throw if `originalTarget` is not a document object.
            defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, originalTarget$LWS, []);
            // eslint-disable-next-line no-empty
          } catch (_unused39$LWS) {}
          if (defaultView$LWS) {
            originalTargetDocument$LWS = originalTarget$LWS;
            originalTargetWindow$LWS = defaultView$LWS;
          }
        }
        if (originalTargetWindow$LWS) {
          createSecondaryWindowSandboxRecord$LWS({
            context: EMPTY_OBJECT$LWS,
            document: originalTargetDocument$LWS,
            globalObject: originalTargetWindow$LWS,
            key: key$LWS,
            type: type$LWS
          }, root$LWS);
        }
        return originalTarget$LWS;
      },
      endowments: endowments$LWS && endowments$LWS !== EMPTY_OBJECT$LWS ?
      // Normalize the descriptors of the provided endowments object,
      // and the default endowments descriptors so they can be
      // accessible from inside the sandbox.
      ObjectAssign$LWS$1({}, DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS, ObjectGetOwnPropertyDescriptors$LWS(endowments$LWS)) : DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS,
      instrumentation: instrumentation$LWS,
      remapTypedArrays: remapTypedArrays$LWS,
      keepAlive: IFRAME_KEEP_ALIVE_FLAG$LWS,
      liveTargetCallback: isTargetLive$LWS,
      signSourceCallback: sourceText$LWS => trusted.createScript(sourceText$LWS)
    });
  }
  // istanbul ignore next: currently unreachable via tests
  function getDefaultType$LWS(key$LWS) {
    return key$LWS === CORE_SANDBOX_KEY$LWS ? 1 /* SandboxType.Internal */ : 0 /* SandboxType.External */;
  }

  function createRootWindowSandboxRecord$LWS({
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    context: context$LWS = EMPTY_OBJECT$LWS,
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    endowments: endowments$LWS = EMPTY_OBJECT$LWS,
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    instrumentation: instrumentation$LWS = EMPTY_OBJECT$LWS,
    key: key$LWS,
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    type: type$LWS = getDefaultType$LWS(key$LWS),
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    verboseInstrumentation: verboseInstrumentation$LWS = false
  }) {
    let record$LWS = rootSandboxRegistry$LWS[key$LWS];
    if (record$LWS) {
      return record$LWS;
    }
    const LOCKER_INSTRUMENTATION_FLAG$LWS =
    // In the future we can preface the LOCKER_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    instrumentation$LWS !== EMPTY_OBJECT$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
    const distortions$LWS = createDistortionMap$LWS(rootDistortionMapSeedEntries$LWS);
    record$LWS = {
      BASIC_INSTRUMENTATION_DATA: LOCKER_INSTRUMENTATION_FLAG$LWS ? {
        sandboxKey: key$LWS
      } : EMPTY_OBJECT$LWS,
      LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_INSTRUMENTATION_FLAG:
      // In the future we can preface the LOCKER_INSTRUMENTATION_FLAG
      // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
      // removed in minified production builds.
      verboseInstrumentation$LWS && LOCKER_INSTRUMENTATION_FLAG$LWS,
      UNCOMPILED_CONTEXT: ROOT_UNCOMPILED_CONTEXT$LWS,
      context: context$LWS,
      document: rootDocument$LWS,
      distortions: distortions$LWS,
      endowments: endowments$LWS,
      globalObject: rootWindow$LWS$1,
      helpers: EMPTY_EVAL_HELPERS$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      root: EMPTY_OBJECT$LWS,
      sandboxEvaluator: noop$LWS$1,
      type: type$LWS,
      virtualEnvironmentEvaluator: noop$LWS$1
    };
    const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(record$LWS);
    record$LWS.root = record$LWS;
    record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(record$LWS);
    record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS);
    const entries$LWS = createDistortionEntries$LWS(record$LWS, getDistortionFactories$LWS(record$LWS));
    // Add distortions to the root window's distortion map.
    for (let i$LWS = 0, {
        length: length$LWS
      } = entries$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const {
        0: entryKey$LWS,
        1: entryValue$LWS
      } = entries$LWS[i$LWS];
      distortions$LWS.set(entryKey$LWS, entryValue$LWS);
    }
    rootSandboxRegistry$LWS[key$LWS] = record$LWS;
    return record$LWS;
  }
  function createOpaqueSecondaryWindowSandboxRecord$LWS({
    globalObject: globalObject$LWS,
    key: key$LWS,
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    type: type$LWS = /* istannul ignore next: nothing works to ignore these */getDefaultType$LWS(key$LWS)
  }, root$LWS) {
    const sandboxRegistry$LWS = getOpaqueSandboxRegistry$LWS(globalObject$LWS);
    let record$LWS = sandboxRegistry$LWS[key$LWS];
    // istanbul ignore if: calls that would evaluate to true here ARE tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
    if (record$LWS) {
      return record$LWS;
    }
    const {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
      distortions: distortions$LWS,
      instrumentation: instrumentation$LWS
    } = root$LWS;
    record$LWS = {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
      UNCOMPILED_CONTEXT: EMPTY_OBJECT$LWS,
      context: EMPTY_OBJECT$LWS,
      document,
      distortions: EMPTY_DISTORTIONS_MAP$LWS,
      endowments: EMPTY_OBJECT$LWS,
      globalObject: globalObject$LWS,
      helpers: EMPTY_EVAL_HELPERS$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      root: root$LWS,
      sandboxEvaluator: noop$LWS$1,
      type: type$LWS,
      virtualEnvironmentEvaluator: noop$LWS$1
    };
    // Fast path non-configurable location and window objects in the virtual
    // environment distortion callback by adding them to the root window's
    // distortion map.
    const {
      location: location$LWS
    } = globalObject$LWS;
    distortions$LWS.set(location$LWS, location$LWS);
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (!seenGlobalObjects$LWS.has(globalObject$LWS)) {
      distortions$LWS.set(globalObject$LWS, globalObject$LWS);
    }
    // Add opaque window postMessage distortion for the child window to the root
    // window's distortion map.
    const opaqueWindowPostMessageDistortionFactory$LWS = getOpaqueWindowPostMessageDistortionFactory$LWS(record$LWS);
    const opaqueWindowPostMessageDistortionEntry$LWS = opaqueWindowPostMessageDistortionFactory$LWS(record$LWS);
    const originalOpaqueWindowPostMessage$LWS = opaqueWindowPostMessageDistortionEntry$LWS[0];
    distortions$LWS.set(originalOpaqueWindowPostMessage$LWS, proxyMaskFunctionDistortion$LWS(record$LWS, opaqueWindowPostMessageDistortionFactory$LWS, opaqueWindowPostMessageDistortionEntry$LWS[1], originalOpaqueWindowPostMessage$LWS));
    sandboxRegistry$LWS[key$LWS] = record$LWS;
    return record$LWS;
  }
  function createSecondaryWindowSandboxRecord$LWS({
    globalObject: globalObject$LWS,
    document: document$LWS,
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    context: context$LWS = /* istanbul ignore next: currently unreachable via tests */EMPTY_OBJECT$LWS,
    key: key$LWS,
    // istanbul ignore next: destructured default assignments are not correctly instrumented
    type: type$LWS = /* istanbul ignore next: currently unreachable via tests */getDefaultType$LWS(key$LWS)
  }, root$LWS) {
    const sandboxRegistry$LWS = getSandboxRegistry$LWS(document$LWS);
    let record$LWS = sandboxRegistry$LWS[key$LWS];
    if (record$LWS) {
      return record$LWS;
    }
    const {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
      distortions: distortions$LWS,
      instrumentation: instrumentation$LWS
    } = root$LWS;
    const {
      location: location$LWS,
      top: top$LWS
    } = globalObject$LWS;
    record$LWS = {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
      UNCOMPILED_CONTEXT: {
        [UNCOMPILED_LOCATION_NAME$LWS]: location$LWS,
        [UNCOMPILED_TOP_NAME$LWS]: top$LWS,
        // The following context entries are explicitly added because the
        // UNCOMPILED_*_NAME entries will only be added to the contextNames
        // via transforms when the fully qualified member expression is detected
        // in the code, eg. window.location, or window.top.
        // See complete explanation in packages/@locker/shared-dom/src/source-transformations.ts.
        location: location$LWS,
        top: top$LWS
      },
      context: context$LWS,
      document: document$LWS,
      distortions: EMPTY_DISTORTIONS_MAP$LWS,
      endowments: EMPTY_OBJECT$LWS,
      globalObject: globalObject$LWS,
      helpers: EMPTY_EVAL_HELPERS$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      root: root$LWS,
      sandboxEvaluator: noop$LWS$1,
      type: type$LWS,
      virtualEnvironmentEvaluator: noop$LWS$1
    };
    const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(record$LWS);
    record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(record$LWS);
    record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS);
    // Fast path non-configurable document, location, and window objects in the
    // virtual environment distortion callback by adding them to the root window's
    // distortion map.
    distortions$LWS.set(document$LWS, document$LWS);
    distortions$LWS.set(location$LWS, location$LWS);
    const seenGlobalObject$LWS = seenGlobalObjects$LWS.has(globalObject$LWS);
    if (!seenGlobalObject$LWS) {
      // WindowProxy object references don't change when the window location
      // changes.
      // https://developer.mozilla.org/en-US/docs/Glossary/WindowProxy
      distortions$LWS.set(globalObject$LWS, globalObject$LWS);
    }
    const entries$LWS = createDistortionEntries$LWS(record$LWS, getDistortionFactories$LWS(record$LWS));
    for (let i$LWS = 0, {
        length: length$LWS
      } = entries$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const {
        0: entryKey$LWS,
        1: entryValue$LWS
      } = entries$LWS[i$LWS];
      // Add distortion to the root window's distortion map.
      distortions$LWS.set(entryKey$LWS, entryValue$LWS);
    }
    sandboxRegistry$LWS[key$LWS] = record$LWS;
    if (seenGlobalObject$LWS) {
      return record$LWS;
    }
    seenGlobalObjects$LWS.add(globalObject$LWS);
    const onDOMContentLoadedOrWindowLoad$LWS = () => {
      try {
        // We don't need to use `WindowDocumentGetter()` because we know
        // this is a window object and the 'document' property is
        // non-configurable.
        const {
          document: newDocument$LWS
        } = globalObject$LWS;
        // Ensure the document has changed before attempting to create a
        // sandbox record.
        if (document$LWS !== newDocument$LWS) {
          createSecondaryWindowSandboxRecord$LWS({
            context: EMPTY_OBJECT$LWS,
            document: newDocument$LWS,
            globalObject: globalObject$LWS,
            key: key$LWS,
            type: type$LWS
          }, root$LWS);
        }
      } catch (_unused40$LWS) {
        // istanbul ignore next: this is a safety precaution that is unreachable via tests
        createOpaqueSecondaryWindowSandboxRecord$LWS({
          globalObject: globalObject$LWS,
          key: key$LWS,
          type: type$LWS
        }, root$LWS);
      }
    };
    const frameElement$LWS = ReflectApply$LWS$1(WindowFrameElementGetter$LWS, globalObject$LWS, []);
    if (frameElement$LWS) {
      // Create a new sandbox record when the iframe window location changes.
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, frameElement$LWS, ['load', onDOMContentLoadedOrWindowLoad$LWS,
      // useCapture
      true]);
    } else {
      // Create a new sandbox record when the opened window location changes.
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes
      //
      // The 'unload' event handler is okay to use here under the assumption
      // that most `window.open()` calls are not done with the 'noopener'
      // option, so the back/forward cache (i.e. bfcache) is likely being
      // skipped anyways.
      // https://web.dev/bfcache/#avoid-window.opener-references
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, globalObject$LWS, ['unload', function onWindowUnload$LWS() {
        WindowQueueMicrotask$LWS(() => {
          try {
            // Ensure the document has changed before adding event
            // listeners.
            const {
              document: newDocument$LWS
            } = globalObject$LWS;
            if (document$LWS === newDocument$LWS) {
              return;
            }
            // istanbul ignore next: currently unreachable via tests
            ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, globalObject$LWS, ['DOMContentLoaded', onDOMContentLoadedOrWindowLoad$LWS, true]);
            // istanbul ignore next: currently unreachable via tests
            ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, globalObject$LWS, ['unload', onWindowUnload$LWS, true]);
          } catch (_unused41$LWS) {
            // istanbul ignore next: this is a safety precaution that is unreachable via tests
            createOpaqueSecondaryWindowSandboxRecord$LWS({
              globalObject: globalObject$LWS,
              key: key$LWS,
              type: type$LWS
            }, root$LWS);
          }
        });
      },
      // useCapture
      true]);
    }
    return record$LWS;
  }
  function internalEvaluateInSandbox$LWS(evaluateOptions$LWS) {
    const {
      document: document$LWS,
      context: context$LWS,
      endowments: endowments$LWS,
      globalObject: globalObject$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      source: source$LWS,
      sourceType: sourceType$LWS,
      type: type$LWS,
      verboseInstrumentation: verboseInstrumentation$LWS
    } = evaluateOptions$LWS;
    if (typeof key$LWS !== 'string') {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    const {
      LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
      helpers: helpers$LWS,
      virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
    } = globalObject$LWS === rootWindow$LWS$1 ? createRootWindowSandboxRecord$LWS({
      context: context$LWS,
      endowments: endowments$LWS,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      type: type$LWS,
      verboseInstrumentation: verboseInstrumentation$LWS
    }) : createSecondaryWindowSandboxRecord$LWS({
      context: context$LWS,
      document: document$LWS,
      globalObject: globalObject$LWS,
      key: key$LWS,
      type: type$LWS
    }, rootSandboxRegistry$LWS[key$LWS]);
    // Setting the context before evaluating the sourceText so compiled code
    // can wire up import/exports from both sides of the membrane.
    if (context$LWS !== EMPTY_OBJECT$LWS) {
      setEvalContext$LWS(context$LWS);
    }
    if (helpers$LWS !== EMPTY_EVAL_HELPERS$LWS) {
      setEvalHelpers$LWS(helpers$LWS);
    }
    let result$LWS;
    const sourceText$LWS = toSourceText$LWS(source$LWS, sourceType$LWS);
    const activity$LWS = LOCKER_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS == null ? void 0 : instrumentation$LWS.startActivity('lws.evaluate') : undefined;
    try {
      // Protecting against errors during evaluation can guarantee the state
      // of the EvalContext to avoid leaking context values
      result$LWS = virtualEnvironmentEvaluator$LWS(sourceText$LWS);
      instrumentation$LWS == null || instrumentation$LWS.incrementCounter == null || instrumentation$LWS.incrementCounter('lws.evaluate', 1, false);
    } catch (error) {
      instrumentation$LWS == null || instrumentation$LWS.incrementCounter == null || instrumentation$LWS.incrementCounter('lws.evaluate', 1, true);
      activity$LWS == null || activity$LWS.error({
        sandboxKey: key$LWS,
        error
      });
      activity$LWS == null || activity$LWS.stop();
      throw error;
    } finally {
      clearEvalContext$LWS();
      clearEvalHelpers$LWS();
    }
    activity$LWS == null || activity$LWS.stop();
    return result$LWS;
  }
  function evaluateInSandbox$LWS(key$LWS, source$LWS, context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
    return internalEvaluateInSandbox$LWS({
      context: context$LWS,
      document: rootDocument$LWS,
      endowments: endowments$LWS,
      globalObject: rootWindow$LWS$1,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      source: source$LWS,
      sourceType: 1 /* SourceType.Module */,
      type: 0 /* SandboxType.External */,
      verboseInstrumentation: verboseInstrumentation$LWS
    });
  }
  // istanbul ignore next: currently unreachable via tests, exclusively used in AMD format mode
  function evaluateFunction$LWS(key$LWS, fn$LWS, scope$LWS = EMPTY_OBJECT$LWS, sourceURL$LWS = '', endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
    const argValues$LWS = toSafeArray$LWS$1([rootWindow$LWS$1.location, rootWindow$LWS$1.top]);
    const argNames$LWS = toSafeArray$LWS$1(['location', 'top']);
    const providedScopeNames$LWS = ObjectKeys$LWS$1(scope$LWS);
    for (let i$LWS = 0, {
        length: length$LWS
      } = providedScopeNames$LWS; i$LWS < length$LWS; i$LWS++) {
      const name$LWS = providedScopeNames$LWS[i$LWS];
      argNames$LWS.push(name$LWS);
      argValues$LWS.push(scope$LWS[name$LWS]);
    }
    return internalEvaluateInSandbox$LWS({
      context: EMPTY_OBJECT$LWS,
      document: rootDocument$LWS,
      endowments: endowments$LWS,
      globalObject: rootWindow$LWS$1,
      instrumentation: instrumentation$LWS,
      key: key$LWS,
      source: `((${argNames$LWS.join(',')}) => ${fn$LWS})\n${sourceURL$LWS}`,
      sourceType: 1 /* SourceType.Module */,
      type: 0 /* SandboxType.External */,
      verboseInstrumentation: verboseInstrumentation$LWS
    })(...argValues$LWS);
  }
  const sandboxDependencies$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const lprDepNames$LWS = toSafeSet$LWS(new SetCtor$LWS$1(['lightning/platformResourceLoader', 'lightning:platformResourceLoader', 'lightningmobileruntime/platformResourceLoader', 'lightningmobileruntime:platformResourceLoader']));
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function wrapDependency$LWS(dep$LWS, depName$LWS, key$LWS) {
    if (depName$LWS === 'lwc' || depName$LWS === '@lwc/engine-dom' || depName$LWS === '@lwc:engine-dom') {
      return wrapLWC$LWS(dep$LWS, key$LWS);
    }
    if (lprDepNames$LWS.has(depName$LWS)) {
      return wrapPlatformResourceLoader$LWS(dep$LWS, key$LWS);
    }
    return dep$LWS;
  }
  /**
   * Given an instance of 'lwc,' this returns a facade with a limited set
   * of exposed properties. These properties are safe to expose in the
   * sandbox. High privilege properties are not exposed.
   * @param {any} dep 'lwc' fv
   * @param {string} key sandbox key
   */
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function wrapLWC$LWS(dep$LWS, key$LWS) {
    let depRegistry$LWS = sandboxDependencies$LWS.get(key$LWS);
    if (depRegistry$LWS === undefined) {
      depRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      sandboxDependencies$LWS.set(key$LWS, depRegistry$LWS);
    }
    let secureDep$LWS = depRegistry$LWS.get(dep$LWS);
    if (secureDep$LWS) {
      return secureDep$LWS;
    }
    secureDep$LWS = ObjectAssign$LWS$1({}, dep$LWS);
    ReflectDefineProperty$LWS$1(secureDep$LWS, 'sanitizeAttribute', {
      __proto__: null,
      enumerable: true,
      configurable: true,
      writable: true,
      value(tag$LWS, _namespace$LWS, attrName$LWS, attrValue$LWS) {
        if ((attrName$LWS === 'href' || attrName$LWS === 'xlink:href') && ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tag$LWS, []) === 'use') {
          return sanitizeSvgHref$LWS(attrValue$LWS);
        }
        return attrValue$LWS;
      }
    });
    ReflectDefineProperty$LWS$1(secureDep$LWS, 'renderer', {
      __proto__: null,
      enumerable: true,
      configurable: true,
      get: function () {
        let renderer$LWS;
        return function () {
          if (renderer$LWS === undefined) {
            renderer$LWS = createRootWindowSandboxRecord$LWS({
              key: key$LWS
            }).virtualEnvironmentEvaluator(`'use strict';
                    (${ReflectApply$LWS$1(FunctionProtoToString$LWS, dep$LWS.rendererFactory, [])})`)(dep$LWS.renderer);
          }
          return renderer$LWS;
        };
      }(),
      set(_value$LWS) {}
    });
    depRegistry$LWS.set(dep$LWS, secureDep$LWS);
    return secureDep$LWS;
  }
  /**
   * Given an instance of 'lightning/platfromResourceLoader,' this returns
   * our secure versions of 'loadScript' and 'loadStyle' from the sandbox helpers.
   * @param {any} dep 'lightning/platfromResourceLoader'
   * @param {string} key sandbox key
   */
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function wrapPlatformResourceLoader$LWS(dep$LWS, key$LWS) {
    let depRegistry$LWS = sandboxDependencies$LWS.get(key$LWS);
    if (depRegistry$LWS === undefined) {
      depRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      sandboxDependencies$LWS.set(key$LWS, depRegistry$LWS);
    }
    let secureDep$LWS = depRegistry$LWS.get(dep$LWS);
    if (secureDep$LWS) {
      return secureDep$LWS;
    }
    secureDep$LWS = {
      loadScript: (thisArg$LWS, url$LWS, config$LWS) => {
        const sandbox$LWS = createRootWindowSandboxRecord$LWS({
          key: key$LWS
        });
        if (isGaterEnabledFeature$LWS('enableTrustedMode') && config$LWS != null && config$LWS.trustedMode) {
          const trustedGlobals$LWS = config$LWS.trustedGlobals;
          if ((trustedGlobals$LWS == null ? void 0 : trustedGlobals$LWS.length) > 0) {
            return dep$LWS.loadScript(thisArg$LWS, url$LWS).then(() => {
              const installGlobals$LWS = sandbox$LWS.virtualEnvironmentEvaluator(`(list) => list.forEach(([key, value]) => window[key] = value)`);
              const globals$LWS = [];
              for (let i$LWS = 0; i$LWS < trustedGlobals$LWS.length; i$LWS++) {
                globals$LWS.push([trustedGlobals$LWS[i$LWS], window[trustedGlobals$LWS[i$LWS]]]);
              }
              installGlobals$LWS(globals$LWS);
            });
          }
          return dep$LWS.loadScript(thisArg$LWS, url$LWS);
        }
        return sandbox$LWS.helpers.loadScript(thisArg$LWS, url$LWS);
      },
      loadStyle: (thisArg$LWS, url$LWS) => createRootWindowSandboxRecord$LWS({
        key: key$LWS
      }).helpers.loadStyle(thisArg$LWS, url$LWS)
    };
    depRegistry$LWS.set(dep$LWS, secureDep$LWS);
    return secureDep$LWS;
  }
  /*! version: 0.21.7 */

  let AuraInstance;
  let defaultNamespace;
  let getPublicMethodNames;
  let isSafeConfig;
  let runtimeNamespaces;
  function registerAuraAPI(api) {
    if (api) {
      AuraInstance = api.AuraInstance;
      defaultNamespace = api.defaultNamespace;
      getPublicMethodNames = api.getPublicMethodNames;
      isSafeConfig = api.isSafeConfig;
      runtimeNamespaces = api.runtimeNamespaces;
    }
  }

  // SecureUtil: creating a proxy for $A.util
  function SecureAuraUtil(AuraUtil, key) {
    const cache = getFromCache(AuraUtil, key);
    if (cache) {
      return cache;
    }
    const su = create$1(null);
    fastArrayForEach(['getBooleanValue', 'isArray', 'isObject', 'isUndefined', 'isUndefinedOrNull'], name => defineProperty(su, name, createFilteredMethod(su, AuraUtil, name)));

    // These methods in Util deal with raw objects like components, so mark them as such
    fastArrayForEach(['addClass', 'hasClass', 'removeClass', 'toggleClass', 'isEmpty'], name => defineProperty(su, name, createFilteredMethod(su, AuraUtil, name, RAW_ARGS)));
    seal(su);
    setRef(su, AuraUtil, key);
    addToCache(AuraUtil, su, key);
    registerProxy(su);
    return su;
  }

  // SecureLocalizationService: creating a proxy for $A.localizationService
  function SecureAuraLocalizationService(AuraLocalizationService, key) {
    const cache = getFromCache(AuraLocalizationService, key);
    if (cache) {
      return cache;
    }
    const sls = create$1(null);
    fastArrayForEach(['displayDuration', 'displayDurationInDays', 'displayDurationInHours', 'displayDurationInMilliseconds', 'displayDurationInMinutes', 'displayDurationInMonths', 'displayDurationInSeconds', 'duration', 'endOf', 'formatCurrency', 'formatDate', 'formatDateTime', 'formatDateTimeUTC', 'formatDateUTC', 'formatNumber', 'formatPercent', 'formatTime', 'formatTimeUTC', 'getDateStringBasedOnTimezone', 'getDaysInDuration', 'getDefaultCurrencyFormat', 'getDefaultNumberFormat', 'getDefaultPercentFormat', 'getHoursInDuration', 'getLocalizedDateTimeLabels', 'getMillisecondsInDuration', 'getMinutesInDuration', 'getMonthsInDuration', 'getNumberFormat', 'getSecondsInDuration', 'getToday', 'getYearsInDuration', 'isAfter', 'isBefore', 'isBetween', 'isPeriodTimeView', 'isSame', 'parseDateTime', 'parseDateTimeISO8601', 'parseDateTimeUTC', 'startOf', 'toISOString', 'translateFromLocalizedDigits', 'translateFromOtherCalendar', 'translateToLocalizedDigits', 'translateToOtherCalendar', 'UTCToWallTime', 'WallTimeToUTC'], name => defineProperty(sls, name, createFilteredMethod(sls, AuraLocalizationService, name)));
    seal(sls);
    setRef(sls, AuraLocalizationService, key);
    addToCache(AuraLocalizationService, sls, key);
    registerProxy(sls);
    return sls;
  }

  /**
   * Deep traverse an object and unfilter any Locker proxies. Isolate this logic here for the component
   * creation APIs rather than a more general solution to avoid overly aggressive unfiltering that may open
   * new security holes.
   * Legacy algorithm, remove when CRUC W-5895382 is enforced and can't be disabled.
   */
  function deepUnfilterArgs(key, baseObject, members) {
    let value;
    for (const property in members) {
      value = members[property];
      if (value !== undefined && value !== null) {
        if (isArray(value) || isPlainObject(value)) {
          const branchValue = baseObject[property];
          baseObject[property] = deepUnfilterArgs(key, branchValue, value);
          continue;
        }
      }
      if (isProxy(value)) {
        value = getRef(value, key);
      }
      baseObject[property] = value;
    }
    return baseObject;
  }

  /**
   * Deep clone followed by deep unfilter in two steps. Clone the attributes before
   * unfiltering so the caller does not see unfiltered results
   * Legacy algorithm, remove when CRUC W-XXXXX is enforced.
   */
  function deepUnfilteredCloneV1(attributes, key) {
    if (!AuraInstance.util.isObject(attributes)) {
      return attributes;
    }
    const attributesCopy = AuraInstance.util.apply({}, attributes, true, true);
    return deepUnfilterArgs(key, attributesCopy, attributes);
  }

  /**
   * Deep clone and unfilter in one step for Aura Component Attributes.
   * Additional protection to prevent FCVs.
   */
  function deepUnfilterClone(obj, key) {
    // handle undefined or null & return early
    if (obj === undefined || obj === null) {
      return obj;
    }

    // handle Array exotic objects & return early
    if (isArray(obj)) {
      const clone = [];
      // don't use fastArrayForEach here since this is customer
      // data and the array can be sparse
      ArrayForEach(obj, (value, index) => {
        clone[index] = deepUnfilterClone(value, key);
      });
      return clone;
    }

    // handle Object & return early
    if (isPlainObject(obj)) {
      const clone = {};
      for (const prop of ownKeys(obj)) {
        // Impose { <string> : <any> } as per the structured clone algorithm
        if (typeof prop === 'string') {
          let value = obj[prop];
          if (prop === 'exprType') {
            // Impose { exprType: <string> } to prevent TOCTOU
            // i.e. check is here, use is in Aura
            value = `${value}`;
            if (value === 'FUNCTION') {
              throw new error(`Cannot create component when attribute value contains { exprType: 'FUNCTION' }`);
            }
          }
          clone[prop] = deepUnfilterClone(value, key);
        }
      }
      return clone;
    }

    // handle proxied objects & return early
    if (isProxy(obj)) {
      return getRef(obj, key);
    }

    // Do nothing
    return obj;
  }
  function deepUnfilteredCloneV2(attributes, key) {
    return deepUnfilterClone(attributes, key);
  }
  function SecureAura(AuraInstance, key, options) {
    let o = getFromCache(AuraInstance, key);
    if (o) {
      return o;
    }
    const deepUnfilteredClone = isSafeConfig ? deepUnfilteredCloneV2 : deepUnfilteredCloneV1;
    o = create$1(null, {
      util: {
        writable: true,
        enumerable: true,
        value: SecureAuraUtil(AuraInstance['util'], key)
      },
      localizationService: {
        writable: true,
        enumerable: true,
        value: SecureAuraLocalizationService(AuraInstance['localizationService'], key)
      },
      toString: {
        value: function () {
          return `SecureAura: ${AuraInstance}{ key: ${JSON.stringify(key)} }`;
        }
      },
      createComponent: {
        enumerable: true,
        writable: true,
        value: function (type, attributes, callback) {
          const filteredArgs = deepUnfilteredClone(attributes, key);
          const fnReturnedValue = AuraInstance.createComponent(type, filteredArgs, filter(key, callback));
          return filter(key, fnReturnedValue);
        }
      },
      createComponents: {
        enumerable: true,
        writable: true,
        value: function (components, callback) {
          let filteredComponents = [];
          if (isArray(components)) {
            for (let i = 0; i < components.length; i++) {
              const filteredComponent = [];
              filteredComponent[0] = components[i][0];
              filteredComponent[1] = deepUnfilteredClone(components[i][1], key);
              filteredComponents.push(filteredComponent);
            }
          } else {
            filteredComponents = components;
          }
          const fnReturnedValue = AuraInstance.createComponents(filteredComponents, filter(key, callback));
          return filter(key, fnReturnedValue);
        }
      }
    });

    // SecureAura methods and properties
    fastArrayForEach(['enqueueAction'], name => defineProperty(o, name, createFilteredMethod(o, AuraInstance, name, RAW_ARGS)));
    fastArrayForEach(['get', 'getComponent', 'getReference', 'getRoot', 'log', 'reportError', 'warning'], name => defineProperty(o, name, createFilteredMethod(o, AuraInstance, name)));
    if (options.getCallbackPatch) {
      defineProperty(o, 'getCallback', createFilteredMethod(o, AuraInstance, 'getCallback'));
    } else {
      defineProperty(o, 'getCallback', {
        value: function (f) {
          // If the results of $A.getCallback() is wired up to an event handler, passed as an attribute or aura event attribute etc it will get
          // filtered and wrapped with the caller's perspective at that time.
          return AuraInstance.getCallback(f);
        }
      });
    }
    seal(o);
    setRef(o, AuraInstance, key);
    addToCache(AuraInstance, o, key);
    registerProxy(o);
    return o;
  }
  function SecureAuraAction(action, key) {
    let o = getFromCache(action, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureAction: ${action}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    defineProperties(o, {
      getName: createFilteredMethod(o, action, 'getName'),
      setCallback: createFilteredMethod(o, action, 'setCallback', {
        defaultKey: key
      }),
      setParams: createFilteredMethod(o, action, 'setParams', {
        defaultKey: key
      }),
      setParam: createFilteredMethod(o, action, 'setParam', {
        defaultKey: key
      }),
      getParams: createFilteredMethod(o, action, 'getParams'),
      getParam: createFilteredMethod(o, action, 'getParam'),
      getCallback: createFilteredMethod(o, action, 'getCallback'),
      getState: createFilteredMethod(o, action, 'getState'),
      getReturnValue: createFilteredMethod(o, action, 'getReturnValue', {
        defaultKey: key
      }),
      getError: createFilteredMethod(o, action, 'getError'),
      isBackground: createFilteredMethod(o, action, 'isBackground'),
      setBackground: createFilteredMethod(o, action, 'setBackground'),
      setAbortable: createFilteredMethod(o, action, 'setAbortable'),
      setStorable: createFilteredMethod(o, action, 'setStorable')
    });
    setRef(o, action, key);
    addToCache(action, o, key);
    registerProxy(o);
    return seal(o);
  }
  function SecureAuraEvent(event, key) {
    let o = getFromCache(event, key);
    if (o) {
      return o;
    }

    /**
     * Traverse all entries in the baseObject to unwrap any secure wrappers and wrap any functions as
     * SecureFunction. This ensures any non-Lockerized handlers of the event do not choke on the secure
     * wrappers, but any callbacks back into the original Locker have their arguments properly filtered.
     */
    function deepUnfilterMethodArguments(baseObject, members) {
      let value;
      for (const property in members) {
        value = members[property];
        if (isArray(value)) {
          value = deepUnfilterMethodArguments([], value);
        } else if (isPlainObject(value)) {
          value = deepUnfilterMethodArguments({}, value);
        } else if (typeof value !== 'function') {
          if (value) {
            const key = getKey(value);
            if (key) {
              value = getRef(value, key) || value;
            }
          }
          // If value is a plain object, we need to deep unfilter
          if (isPlainObject(value)) {
            value = deepUnfilterMethodArguments({}, value);
          }
        } else {
          value = filter(key, value, {
            defaultKey: key
          });
        }
        baseObject[property] = value;
      }
      return baseObject;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureAuraEvent: ${event}{ key: ${JSON.stringify(key)} }`;
        }
      },
      setParams: {
        writable: true,
        enumerable: true,
        value: function (config) {
          const unfiltered = deepUnfilterMethodArguments({}, config);
          event['setParams'](unfiltered);
          return o;
        }
      },
      setParam: {
        writable: true,
        enumerable: true,
        value: function (property, value) {
          const unfiltered = deepUnfilterMethodArguments({}, {
            value: value
          }).value;
          event['setParam'](property, unfiltered);
        }
      }
    });
    fastArrayForEach(['fire', 'getName', 'getParam', 'getParams', 'getPhase', 'getSource', 'getSourceEvent', 'pause', 'preventDefault', 'resume', 'stopPropagation', 'getType', 'getEventType'], name => defineProperty(o, name, createFilteredMethod(o, event, name)));
    setRef(o, event, key);
    addToCache(event, o, key);
    registerProxy(o);
    return seal(o);
  }
  function SecureAuraComponent(component, key) {
    let o = getFromCache(component, key);
    if (o) {
      return o;
    }

    // special methods that require some extra work
    o = create$1(null, {
      get: {
        writable: true,
        enumerable: true,
        value: function (name) {
          const path = name.split('.');
          // protection against `cmp.get('c')`
          if (typeof path[1] !== 'string' || path[1] === '') {
            throw new SyntaxError(`Invalid key ${name}`);
          }
          const value = component['get'](name);
          if (!value) {
            return value;
          }
          if (path[0] === 'c') {
            return SecureAuraAction(value, key);
          }
          return filter(key, value);
        }
      },
      getEvent: {
        writable: true,
        enumerable: true,
        value: function (name) {
          const event = component['getEvent'](name);
          if (!event) {
            return event;
          }
          return SecureAuraEvent(event, key);
        }
      },
      toString: {
        value: function () {
          return `SecureComponent: ${component}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    defineProperties(o, {
      // these four super* methods are exposed as a temporary solution until we figure how to re-arrange the render flow
      superRender: createFilteredMethod(o, component, 'superRender'),
      superAfterRender: createFilteredMethod(o, component, 'superAfterRender'),
      superRerender: createFilteredMethod(o, component, 'superRerender'),
      superUnrender: createFilteredMethod(o, component, 'superUnrender'),
      // component @platform methods
      isValid: createFilteredMethod(o, component, 'isValid'),
      isInstanceOf: createFilteredMethod(o, component, 'isInstanceOf'),
      addEventHandler: createFilteredMethod(o, component, 'addEventHandler', RAW_ARGS),
      addHandler: createFilteredMethod(o, component, 'addHandler'),
      addValueHandler: createFilteredMethod(o, component, 'addValueHandler'),
      addValueProvider: createFilteredMethod(o, component, 'addValueProvider'),
      destroy: createFilteredMethod(o, component, 'destroy'),
      isRendered: createFilteredMethod(o, component, 'isRendered'),
      getGlobalId: createFilteredMethod(o, component, 'getGlobalId'),
      getLocalId: createFilteredMethod(o, component, 'getLocalId'),
      getSuper: createFilteredMethod(o, component, 'getSuper'),
      getReference: createFilteredMethod(o, component, 'getReference'),
      getVersion: createFilteredMethod(o, component, 'getVersion'),
      clearReference: createFilteredMethod(o, component, 'clearReference'),
      autoDestroy: createFilteredMethod(o, component, 'autoDestroy'),
      isConcrete: createFilteredMethod(o, component, 'isConcrete'),
      getConcreteComponent: createFilteredMethod(o, component, 'getConcreteComponent'),
      find: createFilteredMethod(o, component, 'find'),
      set: createFilteredMethod(o, component, 'set', createOptions(RAW_ARGS, {
        defaultKey: key
      })),
      getElement: createFilteredMethod(o, component, 'getElement'),
      getElements: createFilteredMethod(o, component, 'getElements'),
      getName: createFilteredMethod(o, component, 'getName'),
      getType: createFilteredMethod(o, component, 'getType'),
      removeEventHandler: createFilteredMethod(o, component, 'removeEventHandler')
    });

    // The shape of the component depends on the methods exposed in the definitions:
    const methodsNames = getPublicMethodNames(component);
    if (methodsNames && methodsNames.length) {
      fastArrayForEach(methodsNames, methodName => addMethodIfSupported(o, component, methodName));
    }
    setRef(o, component, key);
    addToCache(component, o, key); // backpointer
    registerProxy(o);
    return o;
  }
  function SecureAuraComponentRef(component, key) {
    let o = getFromCache(component, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecureComponentRef: ${component}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    defineProperties(o, {
      addValueHandler: createFilteredMethod(o, component, 'addValueHandler'),
      addValueProvider: createFilteredMethod(o, component, 'addValueProvider'),
      destroy: createFilteredMethod(o, component, 'destroy'),
      getGlobalId: createFilteredMethod(o, component, 'getGlobalId'),
      getLocalId: createFilteredMethod(o, component, 'getLocalId'),
      getEvent: createFilteredMethod(o, component, 'getEvent'),
      isInstanceOf: createFilteredMethod(o, component, 'isInstanceOf'),
      isRendered: createFilteredMethod(o, component, 'isRendered'),
      isValid: createFilteredMethod(o, component, 'isValid'),
      set: createFilteredMethod(o, component, 'set', createOptions(RAW_ARGS, {
        defaultKey: key
      })),
      get: {
        writable: true,
        enumerable: true,
        value: function (name) {
          // protection against anything other then `cmp.get('v.something')`
          if (typeof name !== 'string' || name.length < 3 || name.indexOf('v.') !== 0 && name.indexOf('e.') !== 0) {
            throw new SyntaxError(`Invalid key ${name}`);
          }
          return filter(key, component['get'](name));
        }
      }
    });

    /**
     * Traverse all entries in the baseObject to unwrap any secure wrappers and wrap any functions as
     * SecureFunction. This ensures any non-Lockerized handlers of the event do not choke on the secure
     * wrappers, but any callbacks back into the original Locker have their arguments properly filtered.
     */
    function deepUnfilterMethodArguments(baseObject, members) {
      let value;
      for (const property in members) {
        value = members[property];
        if (isArray(value)) {
          value = deepUnfilterMethodArguments([], value);
        } else if (isPlainObject(value)) {
          value = deepUnfilterMethodArguments({}, value);
        } else if (typeof value !== 'function') {
          if (value) {
            const key = getKey(value);
            if (key) {
              value = getRef(value, key) || value;
            }
          }
          // If value is a plain object, we need to deep unfilter
          if (isPlainObject(value)) {
            value = deepUnfilterMethodArguments({}, value);
          }
        } else {
          value = filter(key, value, {
            defaultKey: key
          });
        }
        baseObject[property] = value;
      }
      return baseObject;
    }
    const methodsNames = getPublicMethodNames(component);
    if (methodsNames && methodsNames.length) {
      // If SecureAuraComponentRef is an unlockerized component, then let it
      // have access to raw arguments
      const methodOptions = {
        unfilterEverything: !component.getDef().isLockerRequired() ? function (args) {
          return deepUnfilterMethodArguments([], args);
        } : undefined
      };
      fastArrayForEach(methodsNames, methodName => addMethodIfSupported(o, component, methodName, methodOptions));
    }

    // DCHASMAN TODO Workaround for ui:button redefining addHandler using aura:method!!!
    if (!('addHandler' in o)) {
      addMethodIfSupported(o, component, 'addHandler', RAW_ARGS);
    }
    setRef(o, component, key);
    addToCache(component, o, key);
    registerProxy(o);
    return seal(o);
  }
  function SecureAuraPropertyReferenceValue(prv, key) {
    let o = getFromCache(prv, key);
    if (o) {
      return o;
    }
    o = create$1(null, {
      toString: {
        value: function () {
          return `SecurePropertyReferenceValue: ${prv} { key: ${JSON.stringify(key)} }`;
        }
      }
    });
    setRef(o, prv, key);
    addToCache(prv, o, key);
    registerProxy(o);
    return seal(o);
  }
  let AuraAction;
  let AuraComponent;
  let AuraEvent;
  let AuraPropertyReferenceValue;
  function registerAuraTypes(types) {
    if (types) {
      AuraAction = types.Action;
      AuraComponent = types.Component;
      AuraEvent = types.Event;
      AuraPropertyReferenceValue = types.PropertyReferenceValue;
    }
  }
  const namespaceToKey = new Map();
  function getKeyForNamespace(namespace) {
    let key = namespaceToKey.get(namespace);
    if (!key) {
      key = freeze({
        namespace
      });
      namespaceToKey.set(namespace, key);
    }
    return key;
  }
  const CANNOT_USE_RUNTIME_NAMESPACE = 'Cannot use runtime namespace';
  function cannotUseRuntimeNamespace(message, defDescriptor) {
    return `${CANNOT_USE_RUNTIME_NAMESPACE} ${message} in module ${defDescriptor.getNamespace()}-${defDescriptor.getName()}`;
  }
  const ACCESS_GLOBAL = 'G';
  function getRuntimeNamespaceKey(defDescriptor) {
    // Set the key of unsecured modules to system key.
    if (!defDescriptor.requireLocker) {
      return defaultKey;
    }

    // Use the sematic namespace if runtime namespace is not set.
    if (!defDescriptor.runtimeNamespace) {
      return getKeyForNamespace(defDescriptor.getNamespace());
    }

    // Only allow:
    // - running in allowed namespaces,
    // - from default namespace,
    // - when component is exposed.

    if (defDescriptor.access !== ACCESS_GLOBAL) {
      throw new error(cannotUseRuntimeNamespace('if not exposed', defDescriptor));
    }
    if (defDescriptor.getNamespace() !== defaultNamespace) {
      throw new error(cannotUseRuntimeNamespace('if not from default namespace', defDescriptor));
    }
    if (!runtimeNamespaces || !runtimeNamespaces.includes(defDescriptor.runtimeNamespace)) {
      throw new error(cannotUseRuntimeNamespace(`'${defDescriptor.runtimeNamespace}'`, defDescriptor));
    }
    return getKeyForNamespace(defDescriptor.runtimeNamespace);
  }

  // The Locker instrumentation instance.
  let lockerNextInstrumentation = null;
  let verboseInstrumentation = false;
  function createLockerInstrumentation(_AuraInstance, verboseMode) {
    verboseInstrumentation = verboseMode;
  }
  function wrapAuraObjectProperties(secureObject, propList, AuraObjectInstance) {
    for (let i = 0, {
        length
      } = propList; i < length; i += 1) {
      const prop = propList[i];
      // @TODO: W-12077805 update this to use LWS helper that returns original Aura source code
      //       use legacy helper for now.
      secureObject[prop] = maskToString((...args) => ReflectApply$LWS$1(AuraObjectInstance[prop], AuraObjectInstance, args), AuraObjectInstance[prop]);
    }
    return secureObject;
  }
  let wrappedAuraInstance;
  function wrapAuraInstance(AuraInstance) {
    if (wrappedAuraInstance) {
      return wrappedAuraInstance;
    }
    const auraProps = ['createComponent', 'createComponents', 'enqueueAction', 'get', 'getCallback', 'getComponent', 'getReference', 'getRoot', 'log', 'reportError', 'warning'];
    const auraUtilProps = ['addClass', 'getBooleanValue', 'hasClass', 'isArray', 'isEmpty', 'isObject', 'isUndefined', 'isUndefinedOrNull', 'removeClass', 'toggleClass'];
    const auraLocalizationServiceProps = ['displayDuration', 'displayDurationInDays', 'displayDurationInHours', 'displayDurationInMilliseconds', 'displayDurationInMinutes', 'displayDurationInMonths', 'displayDurationInSeconds', 'duration', 'endOf', 'formatCurrency', 'formatDate', 'formatDateTime', 'formatDateTimeUTC', 'formatDateUTC', 'formatNumber', 'formatPercent', 'formatTime', 'formatTimeUTC', 'getDateStringBasedOnTimezone', 'getDaysInDuration', 'getDefaultCurrencyFormat', 'getDefaultNumberFormat', 'getDefaultPercentFormat', 'getHoursInDuration', 'getLocalizedDateTimeLabels', 'getMillisecondsInDuration', 'getMinutesInDuration', 'getMonthsInDuration', 'getNumberFormat', 'getSecondsInDuration', 'getToday', 'getYearsInDuration', 'isAfter', 'isBefore', 'isBetween', 'isPeriodTimeView', 'isSame', 'parseDateTime', 'parseDateTimeISO8601', 'parseDateTimeUTC', 'startOf', 'toISOString', 'translateFromLocalizedDigits', 'translateFromOtherCalendar', 'translateToLocalizedDigits', 'translateToOtherCalendar', 'UTCToWallTime', 'WallTimeToUTC'];
    const o = {
      util: ObjectFreeze$LWS$1(wrapAuraObjectProperties({}, auraUtilProps, AuraInstance['util'])),
      localizationService: ObjectFreeze$LWS$1(wrapAuraObjectProperties({}, auraLocalizationServiceProps, AuraInstance['localizationService']))
    };
    wrapAuraObjectProperties(o, auraProps, AuraInstance);
    ObjectFreeze$LWS$1(o);
    wrappedAuraInstance = o;
    return o;
  }
  function evaluateModuleInSandbox(key, ctor, defDescriptor, endowments) {
    lockerNextInstrumentation = getInstrumentation$LWS();
    return evaluateFunction$LWS(key, ctor, undefined, defDescriptorToSourceURL(defDescriptor), endowments, lockerNextInstrumentation, verboseInstrumentation);
  }
  function evaluateInSandbox(key, source, providedContext, endowments) {
    lockerNextInstrumentation = getInstrumentation$LWS();
    return evaluateInSandbox$LWS(key, source, null, endowments, lockerNextInstrumentation, verboseInstrumentation);
  }

  // The order of `top` and `location` in the array is important.
  // `top` before `location` in order to match patterns like `window.top.location` properly.
  const transpileProperties = toSafeArray$LWS$1(['$A', '$Lightning', 'Aura', 'aura', 'Sfdc', 'sforce', 'location', 'top', '$$locker$$']);
  const transpiler = new Transpiler$LWS(transpileProperties);
  const getScopeForTranspiledCode = () => {
    const scope = toSafeArray$LWS$1([]);
    const $$locker$$ = {};
    for (let i = 0, {
        length
      } = transpileProperties; i < length; i++) {
      const prop = transpileProperties[i];
      switch (prop) {
        case '$$locker$$':
          {
            scope.push($$locker$$);
            break;
          }
        case '$A':
          {
            const secureA = wrapAuraInstance(window.$A);
            scope.push(secureA);
            $$locker$$['$A'] = secureA;
            break;
          }
        case 'location':
          {
            scope.push(window.location);
            ReflectDefineProperty$LWS$1($$locker$$, 'location', {
              get() {
                return window.location;
              },
              set(value) {
                window.location = value;
              }
            });
            $$locker$$.$$top$$ = {};
            ReflectDefineProperty$LWS$1($$locker$$.$$top$$, 'location', {
              get() {
                return window.top.location;
              },
              set(value) {
                window.top.location = value;
              }
            });
            break;
          }
        default:
          {
            scope.push(window[prop]);
            $$locker$$[prop] = window[prop];
          }
      }
    }
    return scope;
  };

  /**
   * Locker vNext for Aura component definitions
   * @param {*} sourceText component source code
   * @param {*} def the component definition
   * @param {*} sandboxSpecifier use the sandbox specifier to select in which vnext sandbox to run
   * @returns Function
   */
  function createForDefNext(sourceText, def) {
    const defDescriptor = def.getDescriptor();
    const namespace = defDescriptor.getNamespace();
    const name = defDescriptor.getName();
    const key = getKeyForNamespace(namespace);
    const sanitizedSourceURL = sanitizeURLForElement(`components/${namespace}/${name}.js`);
    const code = transpiler.compile(sourceText);
    const evalScope = getScopeForTranspiledCode();
    return evaluateInSandbox(key.namespace, `(function(${transpileProperties.join(',')}){${code}\n});\n//# sourceURL=${sanitizedSourceURL}`)(...evalScope);
  }
  function defDescriptorToSourceURL(defDescriptor) {
    const namespace = defDescriptor.getNamespace();
    const name = defDescriptor.getName();
    return `//# sourceURL=modules/${namespace}/${name}.js`;
  }
  function parseOptions(providedOptions) {
    if (typeof providedOptions === 'object' && providedOptions !== null) {
      const {
        lwsKey,
        targetElement
      } = providedOptions;
      if (typeof lwsKey !== 'string') {
        throw new TypeErrorCtor$LWS$1('lwsKey must be a string.');
      }
      if (!(targetElement instanceof HTMLScriptElement)) {
        throw new TypeErrorCtor$LWS$1('targetElement must be an instance of HTMLScriptElement.');
      }
      return {
        __proto__: null,
        lwsKey,
        targetElement
      };
    }
    throw new TypeErrorCtor$LWS$1('Options must be an object.');
  }

  // Define only createScriptURL hook for now.
  const lwsAuraPolicy = {
    createScriptURL: function (dirty, options) {
      const {
        lwsKey,
        targetElement
      } = parseOptions(options);
      const evaluator = sourceText => {
        const code = transpiler.compile(sourceText);
        const ownerDocument = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, targetElement, []);
        const globalObject = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDocument, []);
        const record = createRootWindowSandboxRecord$LWS({
          key: lwsKey
        });
        record.sandboxEvaluator(`(function(${transpileProperties.join(',')}){${code}\n})`, null, globalObject, ownerDocument)(...getScopeForTranspiledCode());
      };
      const trustedURL = lwsInternalPolicy$LWS.createScriptURL(dirty, evaluator, targetElement);
      const resolvedURL = resolveURL$LWS(dirty);
      ReflectDefineProperty$LWS$1(targetElement, 'src', {
        __proto__: null,
        configurable: true,
        get() {
          return resolvedURL;
        },
        set: function () {}
      });
      return trustedURL;
    }
  };

  // AuraLocker is a facade for Locker. Its role is to:
  // - implement methods not present on Locker (extends API).
  // - decouple the Locker API from the Aura API.
  let isLockerInitialized = false;
  const frozenLibRegistry = new WeakSet();
  const internalLibs = ['interop/navigation', 'interop/uiActionsApi', 'interop/uiListApi', 'interop/uiLookupsApi', 'interop/uiObjectInfoApi', 'interop/uiRecordApi', 'lightning/messageService', 'lightning/platformResourceLoader', 'lightning/platformUtilityBarApi', 'lightning/platformWorkspaceApi', 'force/navigation', 'securemoduletest/testUtil'];

  // Allow list of namespaces to access media devices (W-7829235)
  const allowMediaAccessNS = ['runtime_rtc_spark', 'runtime_rtc', 'runtime_hello_studio'];

  /**
   * Pre hook to allow aura to filter things with special behavior
   * @param {*} raw The object being accessed
   * @param {*} key locker key for the secure thing trying to access the raw object
   * @param {*} belongsToLocker Does the raw value and secure thing trying to access it belong to the same locker
   */
  function filterTypeHook(raw, key, belongsToLocker) {
    if (raw instanceof AuraAction) {
      return belongsToLocker ? SecureAuraAction(raw, key) : SecureObject(raw, key);
    }
    if (raw instanceof AuraComponent) {
      return belongsToLocker ? SecureAuraComponent(raw, key) : SecureAuraComponentRef(raw, key);
    }
    if (raw instanceof AuraEvent) {
      return SecureAuraEvent(raw, key);
    }
    if (raw instanceof AuraPropertyReferenceValue) {
      return SecureAuraPropertyReferenceValue(raw, key);
    }
    if (isNode(raw) && isAccessibleLWCNode(key, raw)) {
      // If the raw thing is an LWC node and it can be accessed with the give key,
      // then wrap it in SecureElement.
      return SecureElement(raw, key);
    }
    if (belongsToLocker && isUnfilteringDataProxy(raw)) {
      // If value holds a data proxy that belongs to this locker, give access to
      // the real data proxy, no need to filter.
      return getDataProxy(raw);
    }
    return null;
  }

  /**
   * Custom unfiltering logic for values that need special handling to be usable in system mode
   * @param {*} fromKey locker key for the secure thing that from where the value originated
   * @param {*} value value being unfiltered for system mode access
   */
  function deepUnfilteringTypeHook(fromKey, value) {
    if (!value) {
      return value;
    }
    if (isDataProxy(value)) {
      // If value is a wrapper over unfiltering data proxy, unwrap it
      if (isProxy(value)) {
        // If value is a wrapped object, use st's key to unwrap the value.
        return getRef(value, fromKey);
      }
      // preserve the proxy behavior, wrap with an unfiltering proxy
      return getUnfilteringDataProxy(fromKey, value);
    }
    return value;
  }
  function factoryWindowAddPropertiesHook(apiOptions) {
    return function windowAddPropertiesHook(st, raw, key) {
      const {
        namespace
      } = key;
      defineProperty(st, '$A', {
        enumerable: true,
        value: SecureAura(raw.$A, key, {
          getCallbackPatch: apiOptions.W7175026_auraGetCallbackLockerBypass
        })
      });
      // Salesforce API entry points (first phase) - W-3046191 is tracking adding a publish() API
      // enhancement where we will move these to their respective javascript/container architectures
      fastArrayForEach(['Sfdc', 'sforce'], name => addPropertyIfSupported(st, raw, name));
      // Add RTC related api only to specific namespaces
      if (allowMediaAccessNS.includes(namespace)) {
        fastArrayForEach(['RTCPeerConnection', 'webkitRTCPeerConnection'], name => {
          if (name in raw) {
            defineProperty(st, name, {
              enumerable: true,
              value: SecureRTCPeerConnection(raw[name], key)
            });
          }
        });
        addUnfilteredPropertyIfSupported(st, raw, 'MediaStream');
        // DOMParser and document.implementation is not currently supported in Locker due to W-4437359
        // enable only for RTC namespace until a better solution arises.
        addUnfilteredPropertyIfSupported(st, raw, 'DOMParser');
      }
    };
  }
  function isUnfilteredTypeHook(raw, key) {
    const {
      namespace
    } = key;
    const {
      MediaSteam
    } = window;
    if (MediaSteam && allowMediaAccessNS.includes(namespace)) {
      return raw instanceof MediaSteam;
    }
    return false;
  }
  function navigatorAddPropertiesHook(st, raw, key) {
    const {
      namespace
    } = key;
    if (allowMediaAccessNS.includes(namespace)) {
      fastArrayForEach(['mediaDevices', 'mozGetUserMedia', 'webkitGetUserMedia'], name => {
        addUnfilteredPropertyIfSupported(st, raw, name);
      });
    }
  }
  function create(src, key, sourceURL) {
    return {
      globals: getEnv$1(key),
      returnValue: evaluate(`(function(){${src}\n}())`, key, sourceURL)
    };
  }
  function createForClass(src, defDescriptor) {
    const namespace = defDescriptor.getNamespace();
    const name = defDescriptor.getName();
    const sourceURL = `components/${namespace}/${name}.js`;
    const key = getKeyForNamespace(namespace);
    const returnValue = evaluate(src, key, sourceURL);
    // Key this def so we can transfer the key to component instances
    setKey(returnValue, key);
    return returnValue;
  }

  // @deprecated
  function createForDef(src, def) {
    const defDescriptor = def.getDescriptor();
    const namespace = defDescriptor.getNamespace();
    const name = defDescriptor.getName();
    const sourceURL = `components/${namespace}/${name}.js`;
    const key = getKeyForNamespace(namespace);
    // Key this def so we can transfer the key to component instances
    setKey(def, key);
    return evaluate(
    // Accelerate the reference to $A
    `(function(){const{$A}=window;${src}\n}())`, key, sourceURL);
  }
  function lockerEvaluateModule(key, src, sourceURL) {
    const returnValue = evaluate(
    // Mute several globals for modules
    `(function(){const{$A,aura,Sfdc,sforce}={__proto__:null};return ${src}\n}())`, key, sourceURL);
    // Key the sanitized definition so we can transfer the key to interop component instances
    setKey(returnValue, key);
    return returnValue;
  }
  function createForModule(src, defDescriptor) {
    const namespace = defDescriptor.getNamespace();
    const name = defDescriptor.getName();
    const sourceURL = `modules/${namespace}/${name}.js`;
    const key = getRuntimeNamespaceKey(defDescriptor);
    return lockerEvaluateModule(key, src, sourceURL);
  }
  function getEnv(key) {
    return getEnv$1(key);
  }
  function getEnvForSecureObject(st) {
    const key = getKey(st);
    if (!key) {
      return undefined;
    }
    return getEnv$1(key);
  }
  function getRaw(value) {
    if (value) {
      const key = getKey(value);
      if (key) {
        value = getRef(value, key) || value;
      }
    }
    return value;
  }
  function initialize(types, api) {
    if (isLockerInitialized) {
      return;
    }
    const apiOptions = getAPIOptionsOverride(api.apiVersion);
    init({
      shouldFreeze: api.isFrozenRealm,
      notFrozenIntrinsicNames: api.notFrozenIntrinsicNames,
      unsafeGlobal: window,
      unsafeEval: window.eval,
      unsafeFunction: window.Function,
      apiOptions
    });
    registerAuraTypes(types);
    registerAuraAPI(api);
    registerGaterEnabledFeatures$LWS(api.lockerGaterEnabledFeatures);
    registerReportAPI(api);
    registerLightningElement(api.LightningElement);
    registerLWCAPI(api);
    registerFilterTypeHook(filterTypeHook);
    registerDeepUnfilteringTypeHook(deepUnfilteringTypeHook);
    registerIsUnfilteredTypeHook(isUnfilteredTypeHook);
    registerWindowAddPropertiesHook(factoryWindowAddPropertiesHook(apiOptions));
    registerNavigatorAddPropertiesHook(navigatorAddPropertiesHook);
    registerCustomElementHook(customElementHook);
    createLockerInstrumentation(api.AuraInstance, api.isNextInstrumentationEnabled);
    isLockerInitialized = true;
  }
  function isEnabled() {
    return true;
  }

  // @deprecated
  function instanceOf(value, type) {
    return value instanceof type;
  }
  function runScript(src, namespace) {
    const key = getKeyForNamespace(namespace);
    return evaluate(src, key);
  }
  function trust(from, thing) {
    return trust$1(from, thing);
  }
  function unwrap(from, st) {
    return unwrap$1(from, st);
  }
  function wrapComponent(component) {
    const key = getKey(component);
    const compDef = component.getDef();
    if (!key) {
      return component;
    }
    if (typeof component !== 'object') {
      return component;
    }
    return compDef.isLockerRequired() ? SecureAuraComponent(component, key) : component;
  }
  function wrapComponentEvent(component, event) {
    // if the component is not secure, return the event.
    const key = getKey(component);
    if (!key) {
      return event;
    }
    if (typeof component !== 'object' || typeof event !== 'object') {
      return event;
    }
    return event instanceof AuraEvent ? SecureAuraEvent(event, key) : SecureDOMEvent(event, key);
  }

  function wrapPlatformResourceLoader(resourceLoader, key) {
    let wrappedResourceLoader = getFromCache(resourceLoader, key);
    if (wrappedResourceLoader) {
      return wrappedResourceLoader;
    }
    wrappedResourceLoader = {
      loadScript: (cmp, url, config) => {
        if (config && config.trustedMode) {
          // To load a script in trusted mode (or system mode), we have to pass a mock 1st party (i.e. file system) component as the 1st parameter
          // of loadScript, because it gets the document to insert the script element from the template.ownerDocument of the component. For 2nd
          // and 3rd party components, ownerDocument is a SecureDocuments, but for 1sr party components, it is the actual global Document.
          const mock1stPartyCmp = {
            template: {
              ownerDocument: document // this is the actual global Document
            }
          };
          const loadScriptPromise = resourceLoader.loadScript(mock1stPartyCmp, url);
          return loadScriptPromise.then(() => {
            const {
              trustedGlobals
            } = config;
            if (trustedGlobals) {
              const src = `(list) => list.forEach(([key, get, set]) => Object.defineProperty(window, key, { get, set, configurable: true, enumerable: true }));`;
              const installGlobals = evaluate(src, key);
              const globals = trustedGlobals.map(globalName => [globalName, function get() {
                return window[globalName];
              }, function set(value) {
                window[globalName] = value;
              }]);
              installGlobals(globals);
            }
          });
        }
        // Here we pass the actual component, which could be 1st, 2nd or 3rd party.
        return resourceLoader.loadScript(cmp, url);
      },
      loadStyle: resourceLoader.loadStyle
    };
    setRef(wrappedResourceLoader, resourceLoader, key);
    addToCache(resourceLoader, wrappedResourceLoader, key);
    return wrappedResourceLoader;
  }
       
  /**
   * Wrap an object from origin module(exporter) to be used in the destination module(importer).
   * @param {*} thing Object being imported
   * @param {*} metaFrom Metadata about origin of 'thing'
   * @param {*} metaTo Metadata about destination where 'thing' is being used
   */
  function wrap(thing, metaFrom, metaTo, useLockerNext = false, isInternalNamespace = false) {
    const toKey = getRuntimeNamespaceKey(metaTo);
    const metaFromName = metaFrom.getFullName();

    // Locker vNext membrane handles wrapping the dependencies without the need
    // to create Secure Objects with the exception of LWC.
    if (useLockerNext) {
      const key = isInternalNamespace ? CORE_SANDBOX_KEY$LWS : toKey.namespace;
      return wrapDependency$LWS(thing, metaFromName, key);
    }
    if (['lwc', 'engine'].includes(metaFromName)) {
      return SecureLWC(thing, toKey);
    }

    // check against internalLibs that are allowed
    // they just need to be frozen
    const fromNamespace = `${metaFrom.getNamespace().toLowerCase()}`;
    const lwcModuleName = `${fromNamespace}/${metaFrom.getName()}`;
    if (internalLibs.includes(lwcModuleName)) {
      if (!frozenLibRegistry.has(thing)) {
        if (lwcModuleName === 'lightning/platformResourceLoader' ) {
          thing = wrapPlatformResourceLoader(thing, toKey);
        }
        shallowFreeze(thing);
        frozenLibRegistry.add(thing);
      }
      return thing;
    }
    const fromKey = getRuntimeNamespaceKey(metaFrom);

    // Prevent cross namespace(custom ns to custom ns) references in html/js
    if (fromKey !== defaultKey && toKey !== defaultKey && fromKey !== toKey && !['lockerlwc', 'securemoduletest', 'secureothernamespace', 'lockernexttest'].includes(fromNamespace)) {
      // Cross namespace reference is prohobited currently
      throw new error(`Attempting to reference cross-namespace module ${metaFrom.getNamespace()}-${metaFrom.getName()} in ${metaTo.getNamespace()}-${metaTo.getName()}`);
    }
    // class imports
    if (typeof thing === 'function') {
      return thing;
    }

    // begin wrapping module imports
    // there is no point in wrapping modules with same key and same security level
    // wrapping only occurs in these scenarios:
    //   -- Locker --> system
    //   -- system --> Locker
    //   -- Locker A --> Locker B (must be temporarily disabled)
    if (fromKey === toKey) {
      return thing;
    }
    return SecureLib(thing, fromKey, toKey);
  }

  exports.CORE_SANDBOX_KEY = CORE_SANDBOX_KEY$LWS;
  exports.create = create;
  exports.createForClass = createForClass;
  exports.createForDef = createForDef;
  exports.createForDefNext = createForDefNext;
  exports.createForModule = createForModule;
  exports.evaluateInSandbox = evaluateInSandbox;
  exports.evaluateModuleInSandbox = evaluateModuleInSandbox;
  exports.getEnv = getEnv;
  exports.getEnvForSecureObject = getEnvForSecureObject;
  exports.getKeyForNamespace = getKeyForNamespace;
  exports.getRaw = getRaw;
  exports.initialize = initialize;
  exports.injectO11yDependency = injectO11yDependency$LWS;
  exports.instanceOf = instanceOf;
  exports.isEnabled = isEnabled;
  exports.isSecureLightningElement = isSecureLightningElement;
  exports.lwsAuraPolicy = lwsAuraPolicy;
  exports.markLiveObject = markTargetAsLive$LWS;
  exports.registerGaterEnabledFeatures = registerGaterEnabledFeatures$LWS;
  exports.runScript = runScript;
  exports.trust = trust;
  exports.trusted = trusted;
  exports.unwrap = unwrap;
  exports.wrap = wrap;
  exports.wrapComponent = wrapComponent;
  exports.wrapComponentEvent = wrapComponentEvent;
  return exports;
}({}, DOMPurify);
return AuraLocker;
}();

} catch (e) {}
try {
/*!
 * Copyright (c) 2017-present, salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Bundle from @locker/aura-disabled
 * Generated: 2024-05-21
 * Version: 0.21.7
 */

var AuraLockerDisabled = function (exports) {
  'use strict';

  /*!
   * Copyright (C) 2023 salesforce.com, inc.
   */
  // @ts-ignore: Prevent cannot find name 'trustedTypes' error.
  const SUPPORTS_TRUSTED_TYPES = typeof trustedTypes !== 'undefined';
  function createTrustedTypesPolicy(name, options) {
    // @ts-ignore: Prevent cannot find name 'trustedTypes' error.
    return trustedTypes.createPolicy(name, options);
  }
  function createFallbackPolicy(_name, options) {
    return options;
  }
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types
  const createPolicy = SUPPORTS_TRUSTED_TYPES ? createTrustedTypesPolicy : createFallbackPolicy;
  const policyOptions = {
    createHTML(value) {
      return value;
    },
    createScript(value) {
      return value;
    },
    createScriptURL(value) {
      return value;
    }
  };
  // Temporarily surround in try-catch until migration to AMD run.
  try {
    // istanbul ignore next: this creates a special policy described here https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicyFactory/createPolicy
    createPolicy('default', {
      createHTML(dirty) {
        // Treat null & undefined separately
        if (dirty === 'null' || dirty === 'undefined') {
          return dirty;
        }
        return dirty;
      },
      // Ignore typescript type validation for this policy.
      // Returning `undefined` from a TT policy blocks usages
      // of specific DOM sinks affected by this hook.
      // We want to block eval and inline scripts.
      // @ts-ignore
      createScript(dirty) {
        // Treat null & undefined separately
        if (dirty === 'null' || dirty === 'undefined') {
          return dirty;
        }
        // Block script evaluation
        return undefined;
      },
      createScriptURL(dirty) {
        // Treat null & undefined separately
        if (dirty === 'null' || dirty === 'undefined') {
          return dirty;
        }
        return dirty;
      }
    });
  } catch (_unused) {
    // swallow
  }
  const trusted = createPolicy('trusted', policyOptions);
  /*! version: 0.21.7 */

  /* eslint-disable no-unused-vars, prefer-template */

  function evaluate(src) {
    return (0, eval)('(function(){\n' + src + '\n})()');
  }
  function create(src, key, sourceURL) {
    return {
      globals: window,
      returnValue: evaluate(src)
    };
  }
  function createForClass(src, defDescriptor) {
    return evaluate('return (\n' + src + '\n)');
  }

  // @deprecated
  function createForDef(src, def) {
    return evaluate(src);
  }
  function createForDefNext(src, def, sandboxSpecifier) {
    return evaluate(src);
  }
  function createForModule(src, defDescriptor) {
    return evaluate('return (\n' + src + '\n)');
  }
  function getEnv(key) {
    return window;
  }
  function getEnvForSecureObject(st) {
    return window;
  }
  function getKeyForNamespace(namespace) {
    /* Do Nothing */
  }
  function getRaw(value) {
    return value;
  }
  function initialize(types) {
    /* Do Nothing */
  }
  function isEnabled() {
    return false;
  }

  // @deprecated
  function instanceOf(value, type) {
    return value instanceof type;
  }
  function runScript(src, namespace) {
    return evaluate(src);
  }
  function trust(from, thing) {
    /* Do Nothing */
  }
  function unwrap(from, st) {
    return st;
  }
  function wrapComponent(component) {
    return component;
  }
  function wrapComponentEvent(component, event) {
    return event;
  }
  function wrap(thing, metaFrom, metaTo) {
    return thing;
  }
  function isSecureLightningElement() {
    /* nothing */
  }
  function markLiveObject() {
    /* nothing */
  }
  function trackAsLiveTarget() {
    /* nothing */
  }
  exports.create = create;
  exports.createForClass = createForClass;
  exports.createForDef = createForDef;
  exports.createForDefNext = createForDefNext;
  exports.createForModule = createForModule;
  exports.getEnv = getEnv;
  exports.getEnvForSecureObject = getEnvForSecureObject;
  exports.getKeyForNamespace = getKeyForNamespace;
  exports.getRaw = getRaw;
  exports.initialize = initialize;
  exports.instanceOf = instanceOf;
  exports.isEnabled = isEnabled;
  exports.isSecureLightningElement = isSecureLightningElement;
  exports.markLiveObject = markLiveObject;
  exports.runScript = runScript;
  exports.trackAsLiveTarget = trackAsLiveTarget;
  exports.trust = trust;
  exports.trusted = trusted;
  exports.unwrap = unwrap;
  exports.wrap = wrap;
  exports.wrapComponent = wrapComponent;
  exports.wrapComponentEvent = wrapComponentEvent;
  return exports;
}({});

} catch (e) {}

new function() {
var Aura = window["Aura"] || (window["Aura"] = {});
Aura.$Utils$ = {};
Aura.$Errors$ = {};
Aura.$Context$ = {};
Aura.$System$ = {};
Aura.$Style$ = {};
Aura.$Flavors$ = {};
Aura.$Value$ = {};
Aura.$Model$ = {};
Aura.$Component$ = {};
Aura.$Provider$ = {};
Aura.$Library$ = {};
Aura.$Event$ = {};
Aura.$Layouts$ = {};
Aura.$Controller$ = {};
Aura.$Attribute$ = {};
Aura.$Method$ = {};
Aura.$Services$ = {};
Aura.$Storage$ = {};
Aura.$Locker$ = {};
Aura.$SourceMap$ = {};
Aura.time = window.performance && window.performance.now ? window.performance.now.bind(window.performance) : function() {
  return Date.now()
};
Aura["bootstrap"] = Aura["bootstrap"] || {};
Aura["bootstrap"]["visibilityStateStart"] = document.visibilityState;
Aura.$bootstrapMark$ = function(mark, value) {
  if(window.console && window.console.timeStamp) {
    window.console.timeStamp(mark)
  }
  this["bootstrap"][mark] = value || this.time()
};
(function bootstrapRobustness() {
  function verifyBootstrap() {
    document.removeEventListener("DOMContentLoaded", verifyBootstrap);
    $A.$clientService$.$setAppBootstrapStatus$();
    var state = $A.$clientService$.$getBootstrapState$();
    var sidState = $A.$clientService$.$getSidTokenState$();
    var appCacheProgress = state["appcache"];
    var allFilesLoaded;
    if(appCacheProgress === -1) {
      allFilesLoaded = Object.keys(state).reduce(function(prev, curr) {
        return prev && state[curr]
      }, true);
      if(!allFilesLoaded) {
        if(retryCount < max_retries) {
          retryCount++;
          setTimeout(verifyBootstrap, 1E3)
        }else {
          $A.$clientService$.$dumpCachesAndReload$(true, {"cause":"Aura.verifyBootstrap: Failed bootstrap state: " + JSON.stringify(state)})
        }
      }
      return
    }
    if(state["inline.js"] && $A.$clientService$.$gvpsFromStorage$ === undefined || typeof appCacheProgress !== "undefined" && appCacheProgress >= 0 && appCacheProgress < 100) {
      setTimeout(verifyBootstrap, 1E3);
      return
    }
    if(!state["allCssLoaded"] && state["noCssError"]) {
      if(retryCount < max_retries) {
        retryCount++;
        setTimeout(verifyBootstrap, 1E3)
      }else {
        $A.$clientService$.$dumpCachesAndReload$(true, {"cause":"Aura.verifyBootstrap: Failed bootstrap state: " + JSON.stringify(state)})
      }
      return
    }
    if(sidState["isSidTokenEnabled"]) {
      if(!sidState["isSidTokenSet"]) {
        if(retryCount < max_retries) {
          retryCount++;
          setTimeout(verifyBootstrap, 1E3)
        }else {
          $A.$clientService$.$dumpCachesAndReload$(true, {"cause":"Aura.verifyBootstrap: Failed bootstrap state for SID token: " + JSON.stringify(sidState)})
        }
      }else {
        delete Aura["getSidToken"];
        delete Aura["setSidToken"]
      }
      return
    }
    allFilesLoaded = Object.keys(state).reduce(function(prev, curr) {
      return prev && state[curr]
    }, true);
    if(!allFilesLoaded) {
      $A.$clientService$.$dumpCachesAndReload$(true, {"cause":"Aura.verifyBootstrap: Failed bootstrap state: " + JSON.stringify(state)})
    }
  }
  var max_retries = 10;
  var retryCount = 0;
  document.addEventListener("DOMContentLoaded", verifyBootstrap)
})();
function noop() {
}
var Json = {};
Json.$ApplicationKey$ = {$ABSTRACT$:"ab", $ACCESS$:"xs", $ACTION$:"x", $AURACOMPONENTACCESSFIX$:"acaf", $AURARUNTIMESECUREEVAL$:"arse", $CUSTOMELEMENT$:"ce", $ACTIONGROUP$:"ag", $ACTIONS$:"xx", $ACTIONDEFS$:"ac", $ACTIONTYPE$:"at", $APIVERSION$:"av", $ATTRIBUTES$:"a", $ATTRIBUTEDEFS$:"ad", $BACKGROUND$:"b", $CABOOSE$:"ca", $CDN_HOST$:"ch", $CDN_PREFIX$:"cpr", $CLASSNAME$:"cl", $CLIENT_OUT_OF_SYNC$:"coos", $CODE$:"co", $CODE_AS_CODE$:"cac", $COMPAT$:"ct", $COMPONENTCLASS$:"cc", $COMPONENTDEF$:"c", 
$CONTROLLERDEF$:"cd", $CREATIONPATH$:"cp", $CSSPRELOADED$:"css", $DEFAULT$:"d", $DEFAULTFLAVOR$:"df", $DEFAULT_NAMESPACE$:"dns", $DEFTYPE$:"dt", $DESCRIPTOR$:"descriptor", $DEPENDENCIES$:"dp", $DOCUMENTPATCHINGBYPASS$:"dpbp", $DYNAMICALLYFLAVORABLE$:"dyf", $EVENTDEF$:"ed", $EVENTS$:"e", $ERROREXPERIENCEENABLED$:"eee", $FACETS$:"fa", $FLAVOR$:"fl", $FLAVORABLE$:"fb", $FLAVOREDSTYLEDEF$:"fst", $FLAVORABLECHILD$:"fc", $FLAVOROVERRIDES$:"fo", $FUNCTIONS$:"f", $HANDLERDEFS$:"hd", $HANDLERS$:"eh", $HASSERVERDEPENDENCIES$:"hs", 
$HELPERDEF$:"h", $INCLUDES$:"ic", $INCLUDEFACETS$:"if", $INTERFACES$:"i", $LOAD$:"lo", $LOCALID$:"lid", $LOCATIONCHANGEEVENTDEF$:"lc", $LOCATORDEFS$:"ld", $LOCKER_ENABLED$:"ls", $LOCKER_FROZEN_REALM$:"fr", $LOCKER_GATER_ENABLED_FEATURES$:"lgef", $LOCKER_NEXT$:"ln", $LOCKER_NEXT_INSTRUMENTATION$:"lni", $LOCKER_REFERENCE_INFO$:"lri", $LOCKER_RUNTIME_MANAGER_CONFIG_HASH$:"lrmc", $LOCKER_STRICT_CSP$:"csp", $LOCKER_API_VERSION$:"lav", $LOCKER_VERSION$:"lv", $LOCKER_VERSION_LEGACY$:"lvl", $LOCKER_VERSION_NEXT$:"lvn", 
$LOCKER_AURA_INCLUDED_RUNTIME_NAMESPACES$:"lairn", $LOCKER_AURA_EXCLUDED_RUNTIME_COMPONENTS$:"laerc", $LONGRUNNING$:"lr", $NAMESPACEACCESSIBLE$:"na", $MAXLONGRUNNINGACTIONS$:"mlr", $MEMBERS$:"mm", $MINVERSION$:"mv", $MODEL$:"m", $MODELDEF$:"md", $MODULENAMESPACEALIASES$:"mna", $METHODDEFS$:"med", $METHODS$:"me", "NAME":"n", $ORIGINAL$:"o", $PARAMS$:"pa", $PHASE$:"ph", $PROVIDE$:"p", $PROVIDERDEF$:"pd", $PUBLICCACHINGENABLED$:"pce", $PUBLICCACHINGEXPIRATION$:"pcex", $REGISTEREVENTDEFS$:"re", $RENDERERDEF$:"rd", 
$REQUIRED$:"rq", $REQUIREDVERSIONDEFS$:"rv", $REQUIRELOCKER$:"rl", $RUNTIME_NAMESPACE$:"rn", $RUNTIME_NAMESPACES$:"rns", $RETURNTYPE$:"rt", $SERIAL_ID$:"s", $SERIAL_REFID$:"r", $STORABLE$:"st", $STYLEDEF$:"st", $SUBDEFS$:"sb", $SUPERDEF$:"su", $TOKENS$:"tk", $TYPE$:"t", $URIADDRESSABLEDEFINITIONS$:"uad", $URIADDRESSABLEDEFINITIONSPARAMETERS$:"uadp", $VALUE$:"v", $VALUES$:"vv", $VALUEPROVIDER$:"vp", $PREVENTCONCURRENTDUMPANDRELOAD$:"pvcdr", $PROCESSINVALIDSESSIONERROR$:"pise", $SOURCEURL$:"sl", $LINE$:"li", 
$COLUMN$:"cn", $START$:"sa", $END$:"en", $MODULELOCATION$:"ml", $LANGUAGE$:"lang"};
Json.$decode$ = function(json, refSupport) {
  var obj;
  if(aura["util"].$isUndefinedOrNull$(json)) {
    return null
  }
  try {
    obj = JSON.parse(json)
  }catch(e) {
    var verboseMsg = "Unable to parse JSON response:" + json.slice(0, 1024);
    var auraErr = new $A.$auraError$(verboseMsg, e);
    auraErr.$setAdditionalStacktraceGen$("JSON parse");
    $A.$warning$(verboseMsg, e);
    throw auraErr;
  }
  return refSupport ? this.$resolveRefsObject$(obj) : obj
};
Json.$decodeString$ = function(value) {
  var valueType = typeof value;
  if(valueType === "function") {
    return value
  }else {
    if(valueType === "string") {
      var trustedScript = $A.$lockerService$.$trusted$["createScript"](value);
      return aura["util"].$globalEval$(trustedScript)
    }
  }
  return value
};
Json.$resolveRefsObject$ = function(obj) {
  var cmpDefCollector = [];
  $A["util"].apply(obj, {"context":{"componentDefs":[], "libraryDefs":[], "eventDefs":[]}}, false, true);
  this.$_resolveRefs$(obj, {}, null, null, cmpDefCollector);
  if(cmpDefCollector.length > 0) {
    var componentDefs = obj["context"]["componentDefs"];
    var lookup = {};
    var i;
    for(i = 0;i < cmpDefCollector.length;i++) {
      lookup[cmpDefCollector[i]["descriptor"]] = true
    }
    for(i = 0;i < componentDefs.length;i++) {
      if(!lookup[componentDefs[i]["descriptor"]]) {
        cmpDefCollector.push(componentDefs[i])
      }
    }
    obj["context"]["componentDefs"] = cmpDefCollector
  }
  return obj
};
Json.$resolveRefsArray$ = function(arr) {
  $A.assert($A["util"].isArray(arr), "arr needs to be an array");
  var cmpDefCollector = [];
  this.$_resolveRefs$(arr, {}, null, null, cmpDefCollector);
  arr.unshift.apply(arr, cmpDefCollector);
  return arr
};
Json.$_resolveRefs$ = function(config, cache, parent, property, collector) {
  if(typeof config === "object" && config !== null) {
    var value;
    var key;
    var v;
    var superCollector;
    if(aura["util"].isArray(config)) {
      for(var i = 0;i < config.length;i++) {
        value = config[i];
        if(typeof value === "object" && value !== null) {
          this.$_resolveRefs$(value, cache, config, i, collector)
        }
      }
    }else {
      var serRefId = config[Json.$ApplicationKey$.$SERIAL_REFID$];
      if(serRefId !== undefined) {
        if(cache[serRefId]["descriptor"] && !cache[serRefId]["members"] && !cache[serRefId]["actionDefs"] && !cache[serRefId]["type"] && !cache[serRefId]["actionType"]) {
          parent[property] = {"descriptor":cache[serRefId]["descriptor"]}
        }else {
          parent[property] = cache[serRefId]
        }
      }else {
        var serId = config[Json.$ApplicationKey$.$SERIAL_ID$];
        if(serId !== undefined && config.hasOwnProperty(Json.$ApplicationKey$.$VALUE$)) {
          value = config[Json.$ApplicationKey$.$VALUE$];
          if(typeof value === "object" && value !== null && (value[Json.$ApplicationKey$.$SERIAL_ID$] || value[Json.$ApplicationKey$.$SERIAL_REFID$])) {
            this.$_resolveRefs$(value, cache, parent, property, collector);
            value = parent[property]
          }else {
            if(value["descriptor"] && (value["componentClass"] || value["attributeDefs"])) {
              var newValueDef = {"descriptor":value["descriptor"]};
              cache[serId] = newValueDef;
              for(key in value) {
                v = value[key];
                if(typeof v === "object" && v !== null) {
                  superCollector = [];
                  this.$_resolveRefs$(v, cache, value, key, superCollector);
                  collector.push.apply(collector, superCollector)
                }
              }
              collector.push(value);
              value = newValueDef
            }
            parent[property] = value
          }
          cache[serId] = value
        }else {
          value = config
        }
        for(key in value) {
          v = value[key];
          if(typeof v === "object" && v !== null) {
            this.$_resolveRefs$(v, cache, value, key, collector)
          }
        }
      }
    }
  }
};
Json.$stringifyReplacer$ = function(key, value) {
  if(typeof value === "function") {
    return value + ""
  }
  if($A["util"].$isComponent$(value)) {
    return null
  }
  return value
};
Json.$encode$ = Json["encode"] = function(obj, replacer, whiteSpace) {
  if(typeof JSON !== "undefined") {
    var oldArrayToJSON = Array.prototype.toJSON;
    var oldComponentToJSON = Component.prototype.toJSON;
    try {
      delete Array.prototype.toJSON;
      delete Component.prototype.toJSON;
      if($A["util"].$isUndefinedOrNull$(replacer)) {
        return JSON.stringify(obj, Json.$stringifyReplacer$, whiteSpace)
      }else {
        return JSON.stringify(obj, replacer, whiteSpace)
      }
    }finally {
      if(oldArrayToJSON) {
        Array.prototype.toJSON = oldArrayToJSON
      }
      if(oldComponentToJSON) {
        Component.prototype.toJSON = oldComponentToJSON
      }
    }
  }
  if(obj === undefined) {
    return"null"
  }
  if(obj === null) {
    return"null"
  }
  if(!$A["util"].$isUndefined$(obj.toJSON)) {
    return arguments.callee(obj.toJSON())
  }
  switch(obj.constructor) {
    case String:
      return'"' + obj.replace(/\"/g, '\\"').replace(/\r|\n|\f/g, "\\n") + '"';
    case Array:
      var buf = [];
      for(var i = 0;i < obj.length;i++) {
        buf.push(arguments.callee(obj[i]))
      }
      return"[" + buf.join(",") + "]";
    case Object:
      var buf2 = [];
      for(var k in obj) {
        if(obj.hasOwnProperty(k)) {
          buf2.push(arguments.callee(k) + ":" + arguments.callee(obj[k]))
        }
      }
      return"{" + buf2.join(",") + "}";
    default:
      return obj.toString()
  }
};
Json.$orderedEncode$ = function() {
  var toString = Object.prototype.toString;
  var isArray = Array.isArray || function(a) {
    return toString.call(a) === "[object Array]"
  };
  var escMap = {'"':'\\"', "\\":"\\\\", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t"};
  var escFunc = function(m) {
    return escMap[m] || "\\u" + (m.charCodeAt(0) + 65536).toString(16).substr(1)
  };
  var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
  return function stringify(value) {
    if(value == null) {
      return"null"
    }else {
      if(typeof value === "number") {
        return isFinite(value) ? value.toString() : "null"
      }else {
        if(typeof value === "boolean") {
          return value.toString()
        }else {
          if(typeof value === "object") {
            if(typeof value.toJSON === "function") {
              return stringify(value.toJSON())
            }else {
              if(isArray(value)) {
                var res = "[";
                for(var i = 0;i < value.length;i++) {
                  res += (i ? ", " : "") + stringify(value[i])
                }
                return res + "]"
              }else {
                if(toString.call(value) === "[object Object]") {
                  var tmp = [];
                  var sortedKeys = Object.keys(value).sort();
                  var len = sortedKeys.length;
                  for(var j = 0;j < len;j++) {
                    var key = sortedKeys[j];
                    if(value[key] !== undefined) {
                      tmp.push(stringify(key) + ":" + stringify(value[key]))
                    }
                  }
                  return"{" + tmp.join(",") + "}"
                }
              }
            }
          }
        }
      }
    }
    return'"' + value.toString().replace(escRE, escFunc) + '"'
  }
}();
(function textEncoder$closure(global) {
  function inRange(a, min, max) {
    return min <= a && a <= max
  }
  function includes(array, item) {
    return array.indexOf(item) !== -1
  }
  function ToDictionary(o) {
    if(o === undefined) {
      return{}
    }
    if(o === Object(o)) {
      return o
    }
    throw TypeError("Could not convert argument to dictionary");
  }
  function stringToCodePoints(string) {
    var s = String(string);
    var n = s.length;
    var i = 0;
    for(var u = [];i < n;) {
      var c = s.charCodeAt(i);
      if(c < 55296 || c > 57343) {
        u.push(c)
      }else {
        if(56320 <= c && c <= 57343) {
          u.push(65533)
        }else {
          if(55296 <= c && c <= 56319) {
            if(i === n - 1) {
              u.push(65533)
            }else {
              var d = string.charCodeAt(i + 1);
              if(56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1
              }else {
                u.push(65533)
              }
            }
          }
        }
      }
      i += 1
    }
    return u
  }
  function codePointsToString(code_points) {
    var s = "";
    for(var i = 0;i < code_points.length;++i) {
      var cp = code_points[i];
      if(cp <= 65535) {
        s += String.fromCharCode(cp)
      }else {
        cp -= 65536;
        s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320)
      }
    }
    return s
  }
  function isASCIIByte(a) {
    return 0 <= a && a <= 127
  }
  function Stream(tokens) {
    this.$tokens$ = [].slice.call(tokens);
    this.$tokens$.reverse()
  }
  function decoderError(fatal, opt_code_point) {
    if(fatal) {
      throw TypeError("Decoder error");
    }
    return opt_code_point || 65533
  }
  function Decoder() {
  }
  function Encoder() {
  }
  function getEncoding(label) {
    label = String(label).trim().toLowerCase();
    if(Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label]
    }
    return null
  }
  function TextDecoder(label, options) {
    if(!(this instanceof TextDecoder)) {
      throw TypeError("Called as a function. Did you forget 'new'?");
    }
    label = label !== undefined ? String(label) : DEFAULT_ENCODING;
    options = ToDictionary(options);
    this.$_encoding$ = null;
    this.$_decoder$ = null;
    this.$_ignoreBOM$ = false;
    this.$_BOMseen$ = false;
    this.$_error_mode$ = "replacement";
    this.$_do_not_flush$ = false;
    var encoding = getEncoding(label);
    if(encoding === null || encoding.name === "replacement") {
      throw RangeError("Unknown encoding: " + label);
    }
    if(!decoders[encoding.name]) {
      throw Error("Decoder not present." + " Did you forget to include encoding-indexes.js?");
    }
    var dec = this;
    dec.$_encoding$ = encoding;
    if(Boolean(options["fatal"])) {
      dec.$_error_mode$ = "fatal"
    }
    if(Boolean(options["ignoreBOM"])) {
      dec.$_ignoreBOM$ = true
    }
    if(!Object.defineProperty) {
      this.encoding = dec.$_encoding$.name.toLowerCase();
      this.$fatal$ = dec.$_error_mode$ === "fatal";
      this.$ignoreBOM$ = dec.$_ignoreBOM$
    }
    return dec
  }
  function TextEncoder(label, options) {
    if(!(this instanceof TextEncoder)) {
      throw TypeError("Called as a function. Did you forget 'new'?");
    }
    options = ToDictionary(options);
    this.$_encoding$ = null;
    this.$_encoder$ = null;
    this.$_do_not_flush$ = false;
    this.$_fatal$ = Boolean(options["fatal"]) ? "fatal" : "replacement";
    var enc = this;
    if(Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
      label = label !== undefined ? String(label) : DEFAULT_ENCODING;
      var encoding = getEncoding(label);
      if(encoding === null || encoding.name === "replacement") {
        throw RangeError("Unknown encoding: " + label);
      }
      if(!encoders[encoding.name]) {
        throw Error("Encoder not present." + " Did you forget to include encoding-indexes.js?");
      }
      enc.$_encoding$ = encoding
    }else {
      enc.$_encoding$ = getEncoding("utf-8");
      if(label !== undefined && "console" in global) {
        console.warn("TextEncoder constructor called with encoding label, " + "which is ignored.")
      }
    }
    if(!Object.defineProperty) {
      this.encoding = enc.$_encoding$.name.toLowerCase()
    }
    return enc
  }
  function UTF8Decoder(options) {
    var fatal = options.$fatal$;
    var utf8_code_point = 0;
    var utf8_bytes_seen = 0;
    var utf8_bytes_needed = 0;
    var utf8_lower_boundary = 128;
    var utf8_upper_boundary = 191;
    this.$handler$ = function(stream, bite) {
      if(bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal)
      }
      if(bite === end_of_stream) {
        return finished
      }
      if(utf8_bytes_needed === 0) {
        if(inRange(bite, 0, 127)) {
          return bite
        }
        if(inRange(bite, 194, 223)) {
          utf8_bytes_needed = 1;
          utf8_code_point = bite - 192
        }else {
          if(inRange(bite, 224, 239)) {
            if(bite === 224) {
              utf8_lower_boundary = 160
            }
            if(bite === 237) {
              utf8_upper_boundary = 159
            }
            utf8_bytes_needed = 2;
            utf8_code_point = bite - 224
          }else {
            if(inRange(bite, 240, 244)) {
              if(bite === 240) {
                utf8_lower_boundary = 144
              }
              if(bite === 244) {
                utf8_upper_boundary = 143
              }
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240
            }else {
              return decoderError(fatal)
            }
          }
        }
        utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
        return null
      }
      if(!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        stream.$prepend$(bite);
        return decoderError(fatal)
      }
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      utf8_bytes_seen += 1;
      utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
      if(utf8_bytes_seen !== utf8_bytes_needed) {
        return null
      }
      var code_point = utf8_code_point;
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      return code_point
    }
  }
  function UTF8Encoder(options) {
    var fatal = options.$fatal$;
    this.$handler$ = function(stream, code_point) {
      if(code_point === end_of_stream) {
        return finished
      }
      if(inRange(code_point, 0, 127)) {
        return code_point
      }
      var count;
      var offset;
      if(inRange(code_point, 128, 2047)) {
        count = 1;
        offset = 192
      }else {
        if(inRange(code_point, 2048, 65535)) {
          count = 2;
          offset = 224
        }else {
          if(inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset = 240
          }
        }
      }
      for(var bytes = [(code_point >> 6 * count) + offset];count > 0;) {
        var temp = code_point >> 6 * (count - 1);
        bytes.push(128 | temp & 63);
        count -= 1
      }
      return bytes
    }
  }
  function convertCodeUnitToBytes(code_unit, utf16be) {
    var byte1 = code_unit >> 8;
    var byte2 = code_unit & 255;
    if(utf16be) {
      return[byte1, byte2]
    }
    return[byte2, byte1]
  }
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.$fatal$;
    var utf16_lead_byte = null;
    var utf16_lead_surrogate = null;
    this.$handler$ = function(stream, bite) {
      if(bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
        return decoderError(fatal)
      }
      if(bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
        return finished
      }
      if(utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null
      }
      var code_unit;
      if(utf16_be) {
        code_unit = (utf16_lead_byte << 8) + bite
      }else {
        code_unit = (bite << 8) + utf16_lead_byte
      }
      utf16_lead_byte = null;
      if(utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;
        if(inRange(code_unit, 56320, 57343)) {
          return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320)
        }
        stream.$prepend$(convertCodeUnitToBytes(code_unit, utf16_be));
        return decoderError(fatal)
      }
      if(inRange(code_unit, 55296, 56319)) {
        utf16_lead_surrogate = code_unit;
        return null
      }
      if(inRange(code_unit, 56320, 57343)) {
        return decoderError(fatal)
      }
      return code_unit
    }
  }
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.$fatal$;
    this.$handler$ = function(stream, code_point) {
      if(code_point === end_of_stream) {
        return finished
      }
      if(inRange(code_point, 0, 65535)) {
        return convertCodeUnitToBytes(code_point, utf16_be)
      }
      var lead = convertCodeUnitToBytes((code_point - 65536 >> 10) + 55296, utf16_be);
      var trail = convertCodeUnitToBytes((code_point - 65536 & 1023) + 56320, utf16_be);
      return lead.concat(trail)
    }
  }
  var end_of_stream = -1;
  Stream.prototype = {$endOfStream$:function() {
    return!this.$tokens$.length
  }, $read$:function() {
    if(!this.$tokens$.length) {
      return end_of_stream
    }
    return this.$tokens$.pop()
  }, $prepend$:function(token) {
    if(Array.isArray(token)) {
      for(var tokens = token;tokens.length;) {
        this.$tokens$.push(tokens.pop())
      }
    }else {
      this.$tokens$.push(token)
    }
  }, push:function(token) {
    if(Array.isArray(token)) {
      for(var tokens = token;tokens.length;) {
        this.$tokens$.unshift(tokens.shift())
      }
    }else {
      this.$tokens$.unshift(token)
    }
  }};
  var finished = -1;
  Decoder.prototype = {$handler$:function(stream, bite) {
  }};
  Encoder.prototype = {$handler$:function(stream, code_point) {
  }};
  var encodings = [{"encodings":[{"labels":["unicode-1-1-utf-8", "utf-8", "utf8"], "name":"UTF-8"}], "heading":"The Encoding"}, {"encodings":[{"labels":["utf-16be"], "name":"UTF-16BE"}, {"labels":["utf-16", "utf-16le"], "name":"UTF-16LE"}], "heading":"Legacy miscellaneous encodings"}];
  var label_to_encoding = {};
  encodings.forEach(function(category) {
    category["encodings"].forEach(function(encoding) {
      encoding["labels"].forEach(function(label) {
        label_to_encoding[label] = encoding
      })
    })
  });
  var encoders = {};
  var decoders = {};
  var DEFAULT_ENCODING = "utf-8";
  if(Object.defineProperty) {
    Object.defineProperty(TextDecoder.prototype, "encoding", {get:function() {
      return this.$_encoding$.name.toLowerCase()
    }});
    Object.defineProperty(TextDecoder.prototype, "fatal", {get:function() {
      return this.$_error_mode$ === "fatal"
    }});
    Object.defineProperty(TextDecoder.prototype, "ignoreBOM", {get:function() {
      return this.$_ignoreBOM$
    }})
  }
  TextDecoder.prototype.$decode$ = function decode(input, options) {
    function serializeStream(stream) {
      if(includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this.$_encoding$.name) && !this.$_ignoreBOM$ && !this.$_BOMseen$) {
        if(stream.length > 0 && stream[0] === 65279) {
          this.$_BOMseen$ = true;
          stream.shift()
        }else {
          if(stream.length > 0) {
            this.$_BOMseen$ = true
          }else {
          }
        }
      }
      return codePointsToString(stream)
    }
    var bytes;
    if(typeof input === "object" && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input)
    }else {
      if(typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
        bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength)
      }else {
        bytes = new Uint8Array(0)
      }
    }
    options = ToDictionary(options);
    if(!this.$_do_not_flush$) {
      this.$_decoder$ = decoders[this.$_encoding$.name]({$fatal$:this.$_error_mode$ === "fatal"});
      this.$_BOMseen$ = false
    }
    this.$_do_not_flush$ = Boolean(options["stream"]);
    var input_stream = new Stream(bytes);
    var output = [];
    for(var result;true;) {
      var token = input_stream.$read$();
      if(token === end_of_stream) {
        break
      }
      result = this.$_decoder$.$handler$(input_stream, token);
      if(result === finished) {
        break
      }
      if(result !== null) {
        if(Array.isArray(result)) {
          output.push.apply(output, result)
        }else {
          output.push(result)
        }
      }
    }
    if(!this.$_do_not_flush$) {
      do {
        result = this.$_decoder$.$handler$(input_stream, input_stream.$read$());
        if(result === finished) {
          break
        }
        if(result === null) {
          continue
        }
        if(Array.isArray(result)) {
          output.push.apply(output, result)
        }else {
          output.push(result)
        }
      }while(!input_stream.$endOfStream$());
      this.$_decoder$ = null
    }
    return serializeStream.call(this, output)
  };
  if(Object.defineProperty) {
    Object.defineProperty(TextEncoder.prototype, "encoding", {get:function() {
      return this.$_encoding$.name.toLowerCase()
    }})
  }
  TextEncoder.prototype.$encode$ = function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : "";
    options = ToDictionary(options);
    if(!this.$_do_not_flush$) {
      this.$_encoder$ = encoders[this.$_encoding$.name]({$fatal$:this.$_fatal$ === "fatal"})
    }
    this.$_do_not_flush$ = Boolean(options["stream"]);
    var input = new Stream(stringToCodePoints(opt_string));
    var output = [];
    for(var result;true;) {
      var token = input.$read$();
      if(token === end_of_stream) {
        break
      }
      result = this.$_encoder$.$handler$(input, token);
      if(result === finished) {
        break
      }
      if(Array.isArray(result)) {
        output.push.apply(output, result)
      }else {
        output.push(result)
      }
    }
    if(!this.$_do_not_flush$) {
      for(;true;) {
        result = this.$_encoder$.$handler$(input, input.$read$());
        if(result === finished) {
          break
        }
        if(Array.isArray(result)) {
          output.push.apply(output, result)
        }else {
          output.push(result)
        }
      }
      this.$_encoder$ = null
    }
    return new Uint8Array(output)
  };
  encoders["UTF-8"] = function(options) {
    return new UTF8Encoder(options)
  };
  decoders["UTF-8"] = function(options) {
    return new UTF8Decoder(options)
  };
  encoders["UTF-16BE"] = function(options) {
    return new UTF16Encoder(true, options)
  };
  decoders["UTF-16BE"] = function(options) {
    return new UTF16Decoder(true, options)
  };
  encoders["UTF-16LE"] = function(options) {
    return new UTF16Encoder(false, options)
  };
  decoders["UTF-16LE"] = function(options) {
    return new UTF16Decoder(false, options)
  };
  if(!global["TextEncoder"]) {
    TextEncoder.prototype["encode"] = TextEncoder.prototype.$encode$;
    global["TextEncoder"] = TextEncoder
  }
  if(!global["TextDecoder"]) {
    TextDecoder.prototype["decode"] = TextDecoder.prototype.$decode$;
    global["TextDecoder"] = TextDecoder
  }
})(window);
(function(root, factory) {
  root["StackFrame"] = factory()
})(this, function stackframe$factory() {
  function _isNumber(n) {
    return!isNaN(parseFloat(n)) && isFinite(n)
  }
  function _capitalize(str) {
    return str[0].toUpperCase() + str.substring(1)
  }
  function _getter(p) {
    return function() {
      return this[p]
    }
  }
  function StackFrame(obj) {
    if(obj instanceof Object) {
      for(var i = 0;i < props.length;i++) {
        if(obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
          this["set" + _capitalize(props[i])](obj[props[i]])
        }
      }
    }
  }
  var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
  var numericProps = ["columnNumber", "lineNumber"];
  var stringProps = ["fileName", "functionName", "source"];
  var arrayProps = ["args"];
  var props = booleanProps.concat(numericProps, stringProps, arrayProps);
  StackFrame.prototype["getArgs"] = function() {
    return this.$args$
  };
  StackFrame.prototype["setArgs"] = function(v) {
    if(Object.prototype.toString.call(v) !== "[object Array]") {
      throw new TypeError("Args must be an Array");
    }
    this.$args$ = v
  };
  StackFrame.prototype["getEvalOrigin"] = function() {
    return this.$evalOrigin$
  };
  StackFrame.prototype["setEvalOrigin"] = function(v) {
    if(v instanceof StackFrame) {
      this.$evalOrigin$ = v
    }else {
      if(v instanceof Object) {
        this.$evalOrigin$ = new StackFrame(v)
      }else {
        throw new TypeError("Eval Origin must be an Object or StackFrame");
      }
    }
  };
  StackFrame.prototype.toString = function() {
    var functionName = this["getFunctionName"]() || "{anonymous}";
    var args = "(" + (this["getArgs"]() || []).join(",") + ")";
    var fileName = this["getFileName"]() ? "@" + this["getFileName"]() : "";
    var lineNumber = _isNumber(this["getLineNumber"]()) ? ":" + this["getLineNumber"]() : "";
    var columnNumber = _isNumber(this["getColumnNumber"]()) ? ":" + this["getColumnNumber"]() : "";
    return functionName + args + fileName + lineNumber + columnNumber
  };
  for(var i$$0 = 0;i$$0 < booleanProps.length;i$$0++) {
    StackFrame.prototype["get" + _capitalize(booleanProps[i$$0])] = _getter(booleanProps[i$$0]);
    StackFrame.prototype["set" + _capitalize(booleanProps[i$$0])] = function(p) {
      return function(v) {
        this[p] = Boolean(v)
      }
    }(booleanProps[i$$0])
  }
  for(var j = 0;j < numericProps.length;j++) {
    StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
    StackFrame.prototype["set" + _capitalize(numericProps[j])] = function(p) {
      return function(v) {
        if(!_isNumber(v)) {
          throw new TypeError(p + " must be a Number");
        }
        this[p] = Number(v)
      }
    }(numericProps[j])
  }
  for(var k = 0;k < stringProps.length;k++) {
    StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
    StackFrame.prototype["set" + _capitalize(stringProps[k])] = function(p) {
      return function(v) {
        this[p] = String(v)
      }
    }(stringProps[k])
  }
  return StackFrame
});
Aura.$Errors$.$StackFrame$ = this["StackFrame"];
(function errorStackParser$closure(root, factory) {
  root["ErrorStackParser"] = factory(root["StackFrame"])
})(this, function ErrorStackParser(StackFrame) {
  function _map(array, fn, thisArg) {
    if(typeof Array.prototype.map === "function") {
      return array.map(fn, thisArg)
    }else {
      var output = new Array(array.length);
      for(var i = 0;i < array.length;i++) {
        output[i] = fn.call(thisArg, array[i])
      }
      return output
    }
  }
  function _filter(array, fn, thisArg) {
    if(typeof Array.prototype.filter === "function") {
      return array.filter(fn, thisArg)
    }else {
      var output = [];
      for(var i = 0;i < array.length;i++) {
        if(fn.call(thisArg, array[i])) {
          output.push(array[i])
        }
      }
      return output
    }
  }
  function _indexOf(array, target) {
    if(typeof Array.prototype.indexOf === "function") {
      return array.indexOf(target)
    }else {
      for(var i = 0;i < array.length;i++) {
        if(array[i] === target) {
          return i
        }
      }
      return-1
    }
  }
  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
  return{parse:function ErrorStackParser(error) {
    if(typeof error.$stacktrace$ !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
      return this.$parseOpera$(error)
    }else {
      if(error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.$parseV8OrIE$(error)
      }else {
        if(error.stack) {
          return this.$parseFFOrSafari$(error)
        }else {
          return[]
        }
      }
    }
  }, $extractLocation$:function ErrorStackParser(urlLike) {
    if(urlLike.indexOf(":") === -1) {
      return[urlLike]
    }
    var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
    var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ""));
    return[parts[1], parts[2] || undefined, parts[3] || undefined]
  }, $parseV8OrIE$:function ErrorStackParser(error) {
    var filtered = _filter(error.stack.split("\n"), function(line) {
      return!!line.match(CHROME_IE_STACK_REGEXP)
    }, this);
    return _map(filtered, function createStackFrameV8OrIE(line) {
      if(line.indexOf("(eval ") > -1) {
        line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, "")
      }
      var tokens = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").split(/\s+/).slice(1);
      var locationParts = this.$extractLocation$(tokens.pop());
      var functionName = tokens.join(" ") || undefined;
      var fileName = _indexOf(["eval", "\x3canonymous\x3e"], locationParts[0]) > -1 ? undefined : locationParts[0];
      return new StackFrame({functionName:functionName, $args$:undefined, fileName:fileName, lineNumber:locationParts[1], columnNumber:locationParts[2], source:line})
    }, this)
  }, $parseFFOrSafari$:function ErrorStackParser(error) {
    var filtered = _filter(error.stack.split("\n"), function(line) {
      return!line.match(SAFARI_NATIVE_CODE_REGEXP)
    }, this);
    return _map(filtered, function createStackFrameFFOrSafari(line) {
      if(line.indexOf(" \x3e eval") > -1) {
        line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ":$1")
      }
      if(line.indexOf("@") === -1 && line.indexOf(":") === -1) {
        return new StackFrame({functionName:line})
      }else {
        var tokens = line.split("@");
        var locationParts = this.$extractLocation$(tokens.pop());
        var functionName = tokens.join("@") || undefined;
        return new StackFrame({functionName:functionName, $args$:undefined, fileName:locationParts[0], lineNumber:locationParts[1], columnNumber:locationParts[2], source:line})
      }
    }, this)
  }, $parseOpera$:function ErrorStackParser(e) {
    if(!e.$stacktrace$ || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.$stacktrace$.split("\n").length) {
      return this.$parseOpera9$(e)
    }else {
      if(!e.stack) {
        return this.$parseOpera10$(e)
      }else {
        return this.$parseOpera11$(e)
      }
    }
  }, $parseOpera9$:function ErrorStackParser(e) {
    var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
    var lines = e.message.split("\n");
    var result = [];
    var i = 2;
    for(var len = lines.length;i < len;i += 2) {
      var match = lineRE.exec(lines[i]);
      if(match) {
        result.push(new StackFrame({functionName:undefined, $args$:undefined, fileName:match[2], lineNumber:match[1], columnNumber:undefined, source:lines[i]}))
      }
    }
    return result
  }, $parseOpera10$:function ErrorStackParser(e) {
    var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
    var lines = e.$stacktrace$.split("\n");
    var result = [];
    var i = 0;
    for(var len = lines.length;i < len;i += 2) {
      var match = lineRE.exec(lines[i]);
      if(match) {
        result.push(new StackFrame({functionName:match[3] || undefined, $args$:undefined, fileName:match[2], lineNumber:match[1], columnNumber:undefined, source:lines[i]}))
      }
    }
    return result
  }, $parseOpera11$:function ErrorStackParser(error) {
    var filtered = _filter(error.stack.split("\n"), function(line) {
      return!!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/)
    }, this);
    return _map(filtered, function createStackFrameOpera11(line) {
      var tokens = line.split("@");
      var locationParts = this.$extractLocation$(tokens.pop());
      var functionCall = tokens.shift() || "";
      var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^\)]*\)/g, "") || undefined;
      var argsRaw;
      if(functionCall.match(/\(([^\)]*)\)/)) {
        argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, "$1")
      }
      var args = argsRaw === undefined || argsRaw === "[arguments not available]" ? undefined : argsRaw.split(",");
      return new StackFrame({functionName:functionName, $args$:args, fileName:locationParts[0], lineNumber:locationParts[1], columnNumber:locationParts[2], source:line})
    }, this)
  }}
});
Aura.$Errors$.$StackParser$ = this["ErrorStackParser"];
var goog = {};
goog.global = this;
goog.$exportProperty$ = function(object, publicName, symbol) {
  object[publicName] = symbol
};
goog.$exportSymbol$ = function(publicPath, opt_object, opt_objectToExportTo) {
  var parts = publicPath.split(".");
  var cur = opt_objectToExportTo || goog.global;
  for(var part = parts.shift();part;part = parts.shift()) {
    if(!parts.length && opt_object !== undefined) {
      cur[part] = opt_object
    }else {
      if(cur[part]) {
        cur = cur[part]
      }else {
        cur = cur[part] = {}
      }
    }
  }
};
Aura.$Context$.$AuraContext$ = function AuraContext(config, initCallback) {
  this.mode = config["mode"];
  this.loaded = config["loaded"];
  if(this.loaded === undefined) {
    this.loaded = {}
  }
  this.$loadedOriginal$ = $A["util"].apply({}, this.loaded);
  this.$fwuid$ = config["fwuid"];
  this.$pathPrefix$ = config["pathPrefix"];
  this.$moduleServices$ = config["services"];
  this.$num$ = 0;
  this.$scriptNonce$ = config["scriptNonce"];
  this.$cooseAsWarningEnabled$ = config[Json.$ApplicationKey$.$CLIENT_OUT_OF_SYNC$];
  this.$renderNum$ = 0;
  this.transaction = 0;
  this.$transactionName$ = "";
  this.$lastGlobalId$ = 0;
  this.$componentConfigs$ = {};
  this.$app$ = config["app"];
  this.$cmp$ = config["cmp"];
  this.test = config["test"];
  this.$contextPath$ = config["contextPath"] || "";
  this.$allowedGlobals$ = config["allowedGlobals"];
  this.$globals$ = config["globals"];
  this.$tokens$ = {};
  this.$useCompatSource$ = !!config[Json.$ApplicationKey$.$COMPAT$];
  this.$moduleNamespaceAliases$ = config[Json.$ApplicationKey$.$MODULENAMESPACEALIASES$] || {};
  this.$actionPublicCachingEnabled$ = !!config["apce"];
  this.$maxLongRunningActionsCount$ = config[Json.$ApplicationKey$.$MAXLONGRUNNINGACTIONS$];
  if(this.$actionPublicCachingEnabled$) {
    this.$actionPublicCacheKey$ = config["apck"]
  }
  this.$uriAddressableDefsEnabled$ = !!config[Json.$ApplicationKey$.$URIADDRESSABLEDEFINITIONS$];
  this.$auraComponentAccessFixEnabled$ = !!config[Json.$ApplicationKey$.$AURACOMPONENTACCESSFIX$];
  this.$auraRuntimeSecureEvalEnabled$ = !!config[Json.$ApplicationKey$.$AURARUNTIMESECUREEVAL$];
  this.$errorExperienceEnabled$ = !!config[Json.$ApplicationKey$.$ERROREXPERIENCEENABLED$];
  this.$cdnHost$ = config[Json.$ApplicationKey$.$CDN_HOST$];
  this.$cdnPrefix$ = config[Json.$ApplicationKey$.$CDN_PREFIX$];
  this.$preventConcurrentDumpAndReloadEnabled$ = !!config[Json.$ApplicationKey$.$PREVENTCONCURRENTDUMPANDRELOAD$];
  this.$processInvalidSessionErrorEnabled$ = !!config[Json.$ApplicationKey$.$PROCESSINVALIDSESSIONERROR$];
  this.$lockerAuraRuntimeIncludedNamespaces$ = Object.freeze(config[Json.$ApplicationKey$.$LOCKER_AURA_INCLUDED_RUNTIME_NAMESPACES$] || []);
  this.$lockerAuraRuntimeExcludedComponents$ = Object.freeze(config[Json.$ApplicationKey$.$LOCKER_AURA_EXCLUDED_RUNTIME_COMPONENTS$] || []);
  this.language = config[Json.$ApplicationKey$.$LANGUAGE$];
  var that = this;
  this.$initGlobalValueProviders$(config["globalValueProviders"], function(gvps) {
    that.$globalValueProviders$ = gvps;
    that.$contextGlobals$ = that.$globalValueProviders$.$getValueProvider$("Global");
    that.$currentAction$ = new Action(null, "" + that.$num$, null, null, false, null, false);
    that.$saveDefinitionsToRegistry$(config);
    that.$joinComponentConfigs$(config["components"], that.$currentAction$.$getId$());
    if(initCallback) {
      initCallback(that)
    }
  })
};
goog.$exportSymbol$("Aura.Context.AuraContext", Aura.$Context$.$AuraContext$);
Aura.$Context$.$AuraContext$.$CLIENT_SESSION_ID$ = [window.$pageStartTime$, Math.round(Aura.time() * 1E6), Math.random().toString(16).substr(2)].join("").substring(0, 32);
Aura.$Context$.$AuraContext$.prototype.$initGlobalValueProviders$ = function(gvps, callback) {
  if($A["util"].isArray(gvps)) {
    var map = {};
    for(var i = 0;i < gvps.length;i++) {
      var gvp = gvps[i];
      var type = gvp["type"];
      var values = gvp["values"];
      map[type] = values
    }
    gvps = map
  }
  if(!gvps) {
    gvps = {}
  }
  this.$globalValueProviders$ = new Aura.$Provider$.$GlobalValueProviders$(gvps, callback)
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "initGlobalValueProviders", Aura.$Context$.$AuraContext$.prototype.$initGlobalValueProviders$);
Aura.$Context$.$AuraContext$.prototype.$getMode$ = function() {
  return this.mode
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getMode", Aura.$Context$.$AuraContext$.prototype.$getMode$);
Aura.$Context$.$AuraContext$.prototype.$getTokens$ = function() {
  return this.$tokens$
};
Aura.$Context$.$AuraContext$.prototype.$setTokens$ = function(tokens) {
  this.$tokens$ = tokens
};
Aura.$Context$.$AuraContext$.prototype.$addGlobalValueProvider$ = function(type, valueProvider) {
  this.$globalValueProviders$.$addValueProvider$(type, valueProvider)
};
Aura.$Context$.$AuraContext$.prototype.$getGlobalValueProvider$ = function(type) {
  return this.$globalValueProviders$.$getValueProvider$(type)
};
Aura.$Context$.$AuraContext$.prototype.$encodeForServer$ = function(includeDynamic, includeCacheKeyForCacheableXHR) {
  var contextToSend = {"mode":this.mode, "fwuid":this.$fwuid$};
  if(this.$app$) {
    contextToSend["app"] = this.$app$
  }else {
    contextToSend["cmp"] = this.$cmp$
  }
  if(this.test) {
    contextToSend["test"] = this.test
  }
  if(includeDynamic) {
    contextToSend["loaded"] = this.loaded;
    contextToSend["dn"] = $A.$services$.$component$.$getDynamicNamespaces$();
    contextToSend["globals"] = this.$globalValueProviders$.$getValueProvider$("$Global").$serializeForServer$()
  }else {
    contextToSend["loaded"] = this.$loadedOriginal$
  }
  if(includeCacheKeyForCacheableXHR) {
    contextToSend["apck"] = this.$actionPublicCacheKey$
  }
  if(this.$useCompatSource$) {
    contextToSend[Json.$ApplicationKey$.$COMPAT$] = 1
  }
  contextToSend[Json.$ApplicationKey$.$URIADDRESSABLEDEFINITIONS$] = this.$uriAddressableDefsEnabled$;
  if(this.language) {
    contextToSend["language"] = this.language
  }
  return $A["util"].$json$.$encode$(contextToSend)
};
Aura.$Context$.$AuraContext$.prototype.$mergeContext$ = function(otherContext, skipLoaded) {
  $A.$clientService$.$enableAccessChecks$ = otherContext["enableAccessChecks"];
  this.$moduleServices$ = otherContext["services"];
  try {
    this.$globalValueProviders$.$merge$(otherContext["globalValueProviders"])
  }finally {
    this.$saveDefinitionsToRegistry$(otherContext);
    this.$joinComponentConfigs$(otherContext["components"], "" + this.$getNum$());
    this.$joinLoaded$(otherContext["loaded"], skipLoaded)
  }
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "mergeContext", Aura.$Context$.$AuraContext$.prototype.$mergeContext$);
Aura.$Context$.$AuraContext$.prototype.$mergeGVPs$ = function(gvps, doNotPersist, overwrite) {
  this.$globalValueProviders$.$merge$(gvps, doNotPersist, overwrite)
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "mergeGVPs", Aura.$Context$.$AuraContext$.prototype.$mergeGVPs$);
Aura.$Context$.$AuraContext$.prototype.$getNum$ = function() {
  return this.$num$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getNum", Aura.$Context$.$AuraContext$.prototype.$getNum$);
Aura.$Context$.$AuraContext$.prototype.$incrementNum$ = function() {
  this.$num$ = this.$num$ + 1;
  this.$lastGlobalId$ = 0;
  return this.$num$
};
Aura.$Context$.$AuraContext$.prototype.$incrementRender$ = function() {
  this.$renderNum$ = this.$renderNum$ + 1;
  return this.$renderNum$
};
Aura.$Context$.$AuraContext$.prototype.$incrementTransaction$ = function() {
  this.transaction = this.transaction + 1;
  return this.transaction
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "incrementTransaction", Aura.$Context$.$AuraContext$.prototype.$incrementTransaction$);
Aura.$Context$.$AuraContext$.prototype.$getTransaction$ = function() {
  return this.transaction
};
Aura.$Context$.$AuraContext$.prototype.$updateTransactionName$ = function(_transactionName) {
  if(_transactionName) {
    this.$transactionName$ = this.$trasactionName$ !== "" ? this.$transactionName$ + "-" + _transactionName : _transactionName
  }
};
Aura.$Context$.$AuraContext$.prototype.$getTransactionName$ = function() {
  return this.$transactionName$
};
Aura.$Context$.$AuraContext$.prototype.$clearTransactionName$ = function() {
  this.$transactionName$ = ""
};
Aura.$Context$.$AuraContext$.prototype.$getNextGlobalId$ = function() {
  this.$lastGlobalId$ = this.$lastGlobalId$ + 1;
  return this.$lastGlobalId$
};
Aura.$Context$.$AuraContext$.prototype.$containsComponentConfig$ = function(creationPath) {
  return this.$componentConfigs$.hasOwnProperty(creationPath)
};
Aura.$Context$.$AuraContext$.prototype.$getComponentConfig$ = function(creationPath) {
  var componentConfigs = this.$componentConfigs$;
  var ret = componentConfigs[creationPath];
  return ret
};
Aura.$Context$.$AuraContext$.prototype.$removeComponentConfig$ = function(creationPath) {
  if(creationPath in this.$componentConfigs$) {
    delete this.$componentConfigs$[creationPath]
  }
};
Aura.$Context$.$AuraContext$.prototype.$saveDefinitionsToRegistry$ = function(config) {
  var i;
  var libraryDefs = config["libraryDefs"];
  var componentDefs = config["componentDefs"];
  var eventDefs = config["eventDefs"];
  var moduleDefs = config["moduleDefs"];
  if(libraryDefs) {
    for(i = 0;i < libraryDefs.length;i++) {
      $A.$componentService$.$saveLibraryConfig$(libraryDefs[i])
    }
  }
  if(componentDefs) {
    for(i = 0;i < componentDefs.length;i++) {
      if(componentDefs[i]["descriptor"]) {
        $A.$componentService$.$saveComponentConfig$(componentDefs[i])
      }
    }
  }
  if(eventDefs) {
    for(i = 0;i < eventDefs.length;i++) {
      $A.$eventService$.$saveEventConfig$(eventDefs[i])
    }
  }
  if(moduleDefs) {
    $A.$componentService$.$initModuleDefs$(moduleDefs)
  }
};
Aura.$Context$.$AuraContext$.prototype.$getApp$ = function() {
  return this.$app$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getApp", Aura.$Context$.$AuraContext$.prototype.$getApp$);
Aura.$Context$.$AuraContext$.prototype.$getCmp$ = function() {
  return this.$cmp$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getCmp", Aura.$Context$.$AuraContext$.prototype.$getCmp$);
Aura.$Context$.$AuraContext$.prototype.$joinComponentConfigs$ = function(otherComponentConfigs, actionId) {
  var cP;
  var idx;
  var config;
  var def;
  if(otherComponentConfigs) {
    for(idx = 0;idx < otherComponentConfigs.length;idx++) {
      config = otherComponentConfigs[idx];
      def = config["componentDef"];
      if(def && def["descriptor"]) {
        $A.$componentService$.$saveComponentConfig$(def)
      }
      cP = config["creationPath"];
      this.$componentConfigs$[actionId + cP] = config
    }
  }
};
Aura.$Context$.$AuraContext$.prototype.$clearComponentConfigs$ = function(actionId) {
  var count = 0;
  var removed = 0;
  var error = "";
  var prefix = actionId + "/";
  var len = prefix.length;
  var componentConfigs = this.$componentConfigs$;
  for(var config in componentConfigs) {
    if(componentConfigs.hasOwnProperty(config) && (config === actionId || config.substr(0, len) === prefix)) {
      removed += 1;
      if(error.length > 0) {
        error = error + ", "
      }
      error = error + config + JSON.stringify(componentConfigs[config]);
      delete componentConfigs[config]
    }else {
      count += 1
    }
  }
  if(error.length > 0) {
    var warningMessage = "unused configs for " + actionId;
    $A.$warning$(warningMessage)
  }
  if(count === 0) {
    this.$componentConfigs$ = {}
  }
  return removed
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "clearComponentConfigs", Aura.$Context$.$AuraContext$.prototype.$clearComponentConfigs$);
Aura.$Context$.$AuraContext$.prototype.$joinLoaded$ = function(loaded, dontOverride) {
  if(this.loaded === undefined) {
    this.loaded = {}
  }
  if(loaded) {
    for(var i in loaded) {
      if(loaded.hasOwnProperty(i) && !dontOverride && !$A["util"].$isFunction$(i)) {
        var newL = loaded[i];
        if(newL === "deleted") {
          delete this.loaded[i]
        }else {
          this.loaded[i] = newL
        }
      }
    }
  }
};
Aura.$Context$.$AuraContext$.prototype.$addLoaded$ = function(pair) {
  if(pair && !this.loaded[pair["key"]]) {
    this.loaded[pair["key"]] = pair["value"]
  }
};
Aura.$Context$.$AuraContext$.prototype.$findLoaded$ = function(descriptor, loaded) {
  var cmpDescriptor = "COMPONENT@" + descriptor;
  var appDescriptor = "APPLICATION@" + descriptor;
  loaded = loaded || this.loaded;
  if(loaded[cmpDescriptor]) {
    return{"key":cmpDescriptor, "value":loaded[cmpDescriptor]}
  }else {
    if(loaded[appDescriptor]) {
      return{"key":appDescriptor, "value":loaded[appDescriptor]}
    }
  }
  return null
};
Aura.$Context$.$AuraContext$.prototype.$getLoaded$ = function() {
  return this.loaded
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getLoaded", Aura.$Context$.$AuraContext$.prototype.$getLoaded$);
Aura.$Context$.$AuraContext$.prototype.$resetLoaded$ = function() {
  this.loaded = $A["util"].apply({}, this.$loadedOriginal$)
};
Aura.$Context$.$AuraContext$.prototype.$setCurrentAction$ = function(action) {
  var previous = this.$currentAction$;
  this.$currentAction$ = action;
  return previous
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "setCurrentAction", Aura.$Context$.$AuraContext$.prototype.$setCurrentAction$);
Aura.$Context$.$AuraContext$.prototype.$getCurrentAction$ = function() {
  return this.$currentAction$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getCurrentAction", Aura.$Context$.$AuraContext$.prototype.$getCurrentAction$);
Aura.$Context$.$AuraContext$.prototype.$getPathPrefix$ = function() {
  return this.$pathPrefix$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getPathPrefix", Aura.$Context$.$AuraContext$.prototype.$getPathPrefix$);
Aura.$Context$.$AuraContext$.prototype.$getContextPath$ = function() {
  return this.$contextPath$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getContextPath", Aura.$Context$.$AuraContext$.prototype.$getContextPath$);
Aura.$Context$.$AuraContext$.prototype.$setContextPath$ = function(path) {
  this.$contextPath$ = path
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "setContextPath", Aura.$Context$.$AuraContext$.prototype.$setContextPath$);
Aura.$Context$.$AuraContext$.prototype.$isActionPublicCachingEnabled$ = function() {
  return this.$actionPublicCachingEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isActionPublicCachingEnabled", Aura.$Context$.$AuraContext$.prototype.$isActionPublicCachingEnabled$);
Aura.$Context$.$AuraContext$.prototype.$getMaxLongRunningActionsCount$ = function() {
  return this.$maxLongRunningActionsCount$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getMaxLongRunningActionsCount", Aura.$Context$.$AuraContext$.prototype.$getMaxLongRunningActionsCount$);
Aura.$Context$.$AuraContext$.prototype.$getActionPublicCacheKey$ = function() {
  return this.$actionPublicCacheKey$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getActionPublicCacheKey", Aura.$Context$.$AuraContext$.prototype.$getActionPublicCacheKey$);
Aura.$Context$.$AuraContext$.prototype.$isURIAddressableDefsEnabled$ = function() {
  return this.$uriAddressableDefsEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isURIAddressableDefsEnabled", Aura.$Context$.$AuraContext$.prototype.$isURIAddressableDefsEnabled$);
Aura.$Context$.$AuraContext$.prototype.$isCDNEnabled$ = function() {
  return!$A["util"].$isUndefinedOrNull$(this.$cdnHost$)
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isCDNEnabled", Aura.$Context$.$AuraContext$.prototype.$isCDNEnabled$);
Aura.$Context$.$AuraContext$.prototype.$getCDNPrefix$ = function() {
  return this.$cdnPrefix$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getCDNPrefix", Aura.$Context$.$AuraContext$.prototype.$getCDNPrefix$);
Aura.$Context$.$AuraContext$.prototype.$isCompat$ = function() {
  return this.$useCompatSource$
};
Aura.$Context$.$AuraContext$.prototype.$isAuraRuntimeSecureEvalEnabled$ = function() {
  return this.$auraRuntimeSecureEvalEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isAuraRuntimeSecureEvalEnabled", Aura.$Context$.$AuraContext$.prototype.$isAuraRuntimeSecureEvalEnabled$);
Aura.$Context$.$AuraContext$.prototype.$isAuraComponentAccessFixEnabled$ = function() {
  return this.$auraComponentAccessFixEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isAuraComponentAccessFixEnabled", Aura.$Context$.$AuraContext$.prototype.$isAuraComponentAccessFixEnabled$);
Aura.$Context$.$AuraContext$.prototype.$isErrorExperienceEnabled$ = function() {
  return this.$errorExperienceEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isErrorExperienceEnabled", Aura.$Context$.$AuraContext$.prototype.$isErrorExperienceEnabled$);
Aura.$Context$.$AuraContext$.prototype.$isProcessInvalidSessionErrorEnabled$ = function() {
  return this.$processInvalidSessionErrorEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isProcessInvalidSessionErrorEnabled", Aura.$Context$.$AuraContext$.prototype.$isProcessInvalidSessionErrorEnabled$);
Aura.$Context$.$AuraContext$.prototype.$isCoosWarningEnabled$ = function() {
  return!!this.$cooseAsWarningEnabled$
};
Aura.$Utils$.$Style$ = function Style() {
  this.head = null
};
goog.$exportSymbol$("Aura.Utils.Style", Aura.$Utils$.$Style$);
Aura.$Utils$.$Style$.prototype.$getHead$ = function() {
  var ret = this.head;
  if(!ret) {
    this.head = document.getElementsByTagName("head")[0];
    ret = this.head
  }
  return ret
};
Aura.$Utils$.$Style$.prototype.apply = function(styleText) {
  var styleElement = document.createElement("style");
  styleElement.setAttribute("type", "text/css");
  if(styleElement.styleSheet) {
    styleElement.styleSheet.cssText = styleText
  }else {
    if(styleElement.textContent !== undefined) {
      styleElement.textContent = styleText
    }else {
      if(styleElement.innerText !== undefined) {
        styleElement.innerText = styleText
      }else {
        styleElement.innerHTML = styleText
      }
    }
  }
  this.$getHead$().appendChild(styleElement);
  return styleElement
};
Aura.$Utils$.$Style$.prototype.$include$ = function(href) {
  var styleElement = document.createElement("link");
  styleElement.setAttribute("href", href);
  styleElement.setAttribute("rel", "stylesheet");
  styleElement.setAttribute("type", "text/css");
  this.$getHead$().appendChild(styleElement);
  return styleElement
};
goog.$exportProperty$(Aura.$Utils$.$Style$.prototype, "include", Aura.$Utils$.$Style$.prototype.$include$);
Aura.$Utils$.$Style$.prototype.$getCSSProperty$ = function(el, cssprop) {
  if(window.getComputedStyle) {
    var style = window.getComputedStyle(el);
    return style && style.getPropertyValue(cssprop)
  }
  return el.currentStyle && el.currentStyle[cssprop]
};
goog.$exportProperty$(Aura.$Utils$.$Style$.prototype, "getCSSProperty", Aura.$Utils$.$Style$.prototype.$getCSSProperty$);
Aura.$Utils$.$Bitset$ = function Bitset(str) {
  if(typeof str !== "string") {
    str = ""
  }
  Aura.$Utils$.$Bitset$.$init$();
  this.data = str.split("");
  this.trim()
};
goog.$exportSymbol$("Aura.Utils.Bitset", Aura.$Utils$.$Bitset$);
Aura.$Utils$.$Bitset$.prototype.$testBit$ = function(n) {
  var i = Math.floor(n / 6);
  if(i >= this.data.length) {
    return false
  }else {
    return(Aura.$Utils$.$Bitset$.$codes$[this.data[i]] & 32 >> n % 6) !== 0
  }
};
goog.$exportProperty$(Aura.$Utils$.$Bitset$.prototype, "testBit", Aura.$Utils$.$Bitset$.prototype.$testBit$);
Aura.$Utils$.$Bitset$.prototype.$setBit$ = function(n) {
  var i = Math.floor(n / 6);
  this.$pad$(i);
  this.data[i] = Aura.$Utils$.$Bitset$.$alphabet$[Aura.$Utils$.$Bitset$.$codes$[this.data[i]] | 32 >> n % 6]
};
Aura.$Utils$.$Bitset$.prototype.$clearBit$ = function(n) {
  var i = Math.floor(n / 6);
  if(i < this.data.length) {
    this.data[i] = Aura.$Utils$.$Bitset$.$alphabet$[Aura.$Utils$.$Bitset$.$codes$[this.data[i]] & (255 ^ 32 >> n % 6)];
    this.trim()
  }
};
Aura.$Utils$.$Bitset$.prototype.toString = function() {
  return this.data.join("")
};
Aura.$Utils$.$Bitset$.prototype.trim = function() {
  for(var i = this.data.length - 1;i >= 0;i--) {
    if(this.data[i] !== Aura.$Utils$.$Bitset$.$alphabet$[0]) {
      break
    }
  }
  this.data.splice(i + 1, this.data.length)
};
Aura.$Utils$.$Bitset$.prototype.$pad$ = function(n) {
  var size = this.data.length;
  for(var i = 0;i <= n - size;i++) {
    this.data.push(Aura.$Utils$.$Bitset$.$alphabet$[0])
  }
};
Aura.$Utils$.$Bitset$.prototype.length = function() {
  return this.data.length
};
Aura.$Utils$.$Bitset$.$initialized$ = false;
Aura.$Utils$.$Bitset$.$init$ = function() {
  if(!Aura.$Utils$.$Bitset$.$initialized$) {
    Aura.$Utils$.$Bitset$.$initialized$ = true;
    Aura.$Utils$.$Bitset$.$alphabet$ = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
    Aura.$Utils$.$Bitset$.$codes$ = [];
    for(var i = 0;i < Aura.$Utils$.$Bitset$.$alphabet$.length;i++) {
      Aura.$Utils$.$Bitset$.$codes$[Aura.$Utils$.$Bitset$.$alphabet$[i]] = i
    }
  }
};
Aura.$Utils$.$DateTimeFormat$ = function(formatString, locale) {
  function parseFormatStringToTokens() {
    var tokens = [];
    var splits = formatString.split(/(\[[^\[\]]*\]|LTS?)/g);
    for(var i = 0;i < splits.length;i++) {
      var str = splits[i];
      if(str) {
        if(str.charAt(0) === "[" && str.slice(-1) === "]") {
          if(str.length > 2) {
            var value = str.substring(1, str.length - 1);
            tokens.push({"literal":true, "value":value})
          }
        }else {
          if(str === "LT" || str === "LTS") {
            tokens.push({"literal":false, "value":str})
          }else {
            var currentChar = null;
            var currentStr = "";
            for(var n = 0;n < str.length;n++) {
              var c = str.charAt(n);
              if(c === currentChar) {
                currentStr += c
              }else {
                if(currentStr.length > 0) {
                  tokens.push({"literal":false, "value":currentStr})
                }
                currentStr = c;
                currentChar = c
              }
            }
            if(currentStr.length > 0) {
              tokens.push({"literal":false, "value":currentStr})
            }
          }
        }
      }
    }
    return tokens
  }
  function getNumberFieldValue(token, date) {
    switch(token["field"]) {
      case "quarter":
        return $A.$localizationService$.$quarterInYear$(date);
      case "weekInYear":
        return $A.$localizationService$.$weekInYear$(date);
      case "weekday":
        return date.getDay();
      case "year":
        var year = date.getFullYear();
        if(token["style"] === "2-digit") {
          year = year % 100
        }
        return year;
      case "month":
        return date.getMonth() + 1;
      case "day":
        return date.getDate();
      case "hour":
        var hour = date.getHours();
        var hourCycle = token["hourCycle"];
        if(hourCycle !== undefined) {
          if(hourCycle === "h24") {
            return hour === 0 ? 24 : hour
          }else {
            if(hourCycle === "h12") {
              hour = hour % 12;
              return hour === 0 ? 12 : hour
            }
          }
        }
        return hour;
      case "minute":
        return date.getMinutes();
      case "second":
        return date.getSeconds();
      case "millisecond":
        return date.getMilliseconds();
      default:
        throw new Error("Unexpected field, " + token["field"]);
    }
  }
  function isGregorianCalendar(localeName) {
    return localeName.indexOf("th") !== 0
  }
  function canUseConfig(field, setting) {
    return this.$supportFormatToParts$ === true && (this.$config$[field] === undefined || this.$config$[field] === setting)
  }
  function hydrateTokensAndConfig(tokens, config, localeName) {
    for(var i = 0;i < tokens.length;i++) {
      var token = tokens[i];
      if(token["literal"] === true) {
        continue
      }
      switch(token["value"]) {
        case "y":
        ;
        case "Y":
        ;
        case "yyyy":
        ;
        case "YYYY":
          token["field"] = "year";
          if(canUseConfig("year", "numeric") && isGregorianCalendar(localeName)) {
            config["year"] = "numeric";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["minDigits"] = token["value"].length;
          token["localized"] = true;
          break;
        case "yy":
        ;
        case "YY":
          token["field"] = "year";
          if(canUseConfig("year", "2-digit") && isGregorianCalendar(localeName)) {
            config["year"] = "2-digit";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["style"] = "2-digit";
          token["minDigits"] = 2;
          token["localized"] = true;
          break;
        case "M":
          token["field"] = "month";
          if(canUseConfig("month", "numeric")) {
            config["month"] = "numeric";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["localized"] = true;
          break;
        case "MM":
          token["field"] = "month";
          if(canUseConfig("month", "2-digit")) {
            config["month"] = "2-digit";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["minDigits"] = 2;
          token["localized"] = true;
          break;
        case "MMM":
          token["field"] = "month";
          if(canUseConfig("month", "short")) {
            config["month"] = "short";
            token["useConfig"] = true
          }
          token["type"] = "string";
          token["style"] = "short";
          break;
        case "MMMM":
          token["field"] = "month";
          if(canUseConfig("month", "long")) {
            config["month"] = "long";
            token["useConfig"] = true
          }
          token["type"] = "string";
          token["style"] = "long";
          break;
        case "d":
        ;
        case "D":
          token["field"] = "day";
          if(canUseConfig("day", "numeric")) {
            config["day"] = "numeric";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["localized"] = true;
          break;
        case "dd":
        ;
        case "DD":
          token["field"] = "day";
          if(canUseConfig("day", "2-digit")) {
            config["day"] = "2-digit";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["minDigits"] = 2;
          token["localized"] = true;
          break;
        case "H":
          token["field"] = "hour";
          token["type"] = "number";
          token["localized"] = true;
          break;
        case "HH":
          token["field"] = "hour";
          if(canUseConfig("hour", "2-digit")) {
            config["hour"] = "2-digit";
            config["hour12"] = false;
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["minDigits"] = 2;
          token["localized"] = true;
          break;
        case "h":
          token["field"] = "hour";
          if(canUseConfig("hour", "numeric")) {
            config["hour"] = "numeric";
            config["hour12"] = true;
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["hourCycle"] = "h12";
          token["localized"] = true;
          break;
        case "hh":
          token["field"] = "hour";
          token["type"] = "number";
          token["minDigits"] = 2;
          token["hourCycle"] = "h12";
          token["localized"] = true;
          config["hour"] = "2-digit";
          config["hour12"] = true;
          break;
        case "k":
          token["field"] = "hour";
          token["type"] = "number";
          token["hourCycle"] = "h24";
          token["localized"] = true;
          config["hour"] = "numeric";
          break;
        case "kk":
          token["field"] = "hour";
          token["type"] = "number";
          token["minDigits"] = 2;
          token["hourCycle"] = "h24";
          token["localized"] = true;
          config["hour"] = "2-digit";
          break;
        case "m":
          token["field"] = "minute";
          if(canUseConfig("minute", "numeric")) {
            config["minute"] = "numeric";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["localized"] = true;
          break;
        case "mm":
          token["field"] = "minute";
          token["type"] = "number";
          token["minDigits"] = 2;
          token["localized"] = true;
          config["minute"] = "2-digit";
          break;
        case "s":
          token["field"] = "second";
          if(canUseConfig("second", "numeric")) {
            config["second"] = "numeric";
            token["useConfig"] = true
          }
          token["type"] = "number";
          break;
        case "ss":
          token["field"] = "second";
          if(canUseConfig("second", "2-digit")) {
            config["second"] = "2-digit";
            token["useConfig"] = true
          }
          token["type"] = "number";
          token["minDigits"] = 2;
          break;
        case "S":
          token["field"] = "millisecond";
          token["type"] = "number";
          break;
        case "SS":
          token["field"] = "millisecond";
          token["type"] = "number";
          token["minDigits"] = 2;
          break;
        case "SSS":
          token["field"] = "millisecond";
          token["type"] = "number";
          token["minDigits"] = 3;
          break;
        case "a":
        ;
        case "A":
          token["field"] = "dayPeriod";
          if(canUseConfig("hour12", true)) {
            config["hour12"] = true;
            config["hour"] = "numeric";
            token["useConfig"] = true
          }
          token["type"] = "string";
          break;
        case "b":
        ;
        case "B":
          token["field"] = "dayPeriod";
          if(canUseConfig("dayPeriod", "short")) {
            config["dayPeriod"] = "short";
            token["useConfig"] = true
          }
          token["type"] = "string";
          break;
        case "Z":
          token["field"] = "offset";
          token["delimiter"] = true;
          break;
        case "ZZ":
          token["field"] = "offset";
          token["delimiter"] = false;
          break;
        case "z":
          token["field"] = "offset";
          token["zone"] = "UTC";
          break;
        case "E":
          token["field"] = "weekday";
          token["type"] = "number";
          token["localized"] = true;
          break;
        case "EE":
          token["field"] = "weekday";
          if(canUseConfig("weekday", "narrow")) {
            config["weekday"] = "narrow";
            token["useConfig"] = true
          }
          token["type"] = "string";
          token["style"] = "narrow";
          break;
        case "EEE":
          token["field"] = "weekday";
          if(canUseConfig("weekday", "short")) {
            config["weekday"] = "short";
            token["useConfig"] = true
          }
          token["type"] = "string";
          token["style"] = "short";
          break;
        case "EEEE":
          token["field"] = "weekday";
          if(canUseConfig("weekday", "long")) {
            config["weekday"] = "long";
            token["useConfig"] = true
          }
          token["type"] = "string";
          token["style"] = "long";
          break;
        case "Q":
          token["field"] = "quarter";
          token["type"] = "number";
          break;
        case "w":
          token["field"] = "weekInYear";
          token["type"] = "number";
          token["localized"] = true;
          break;
        case "ww":
          token["field"] = "weekInYear";
          token["type"] = "number";
          token["minDigits"] = 2;
          token["localized"] = true;
          break;
        case "LT":
          token["type"] = "localizedFormat";
          token["config"] = {"hour":"numeric", "minute":"numeric"};
          break;
        case "LTS":
          token["type"] = "localizedFormat";
          token["config"] = {"hour":"numeric", "minute":"numeric", "second":"numeric"};
          break;
        case "L":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"2-digit", "day":"2-digit"};
          break;
        case "l":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"numeric", "day":"numeric"};
          break;
        case "LL":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"long", "day":"numeric"};
          break;
        case "ll":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"short", "day":"numeric"};
          break;
        case "LLL":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"long", "day":"numeric", "hour":"numeric", "minute":"numeric"};
          break;
        case "lll":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"short", "day":"numeric", "hour":"numeric", "minute":"numeric"};
          break;
        case "LLLL":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"long", "day":"numeric", "hour":"numeric", "minute":"numeric", "weekday":"long"};
          break;
        case "llll":
          token["type"] = "localizedFormat";
          token["config"] = {"year":"numeric", "month":"short", "day":"numeric", "hour":"numeric", "minute":"numeric", "weekday":"short"};
          break;
        default:
          token["literal"] = true
      }
    }
  }
  $A.assert(!$A["util"].$isUndefinedOrNull$(formatString), "[Assertion failed] - 'formatString' argument is required; it must not be null or undefined");
  $A.assert(!$A["util"].$isUndefinedOrNull$(locale), "[Assertion failed] - 'locale' argument is required; it must not be null or undefined");
  this.locale = locale;
  this.$localeName$ = locale.getName();
  this.$supportFormatToParts$ = $A.$localizationService$.$canFormatToParts$();
  this.$tokens$ = parseFormatStringToTokens();
  this.$config$ = {};
  hydrateTokensAndConfig(this.$tokens$, this.$config$, this.$localeName$);
  this["format"] = function(date, utcOffset) {
    var parts;
    if(this.$supportFormatToParts$ === true && date.getFullYear() >= 1970) {
      if(this.$dateTimeFormat$ === undefined) {
        this.$dateTimeFormat$ = new Intl["DateTimeFormat"](this.$localeName$, this.$config$);
        this.$resolvedOptions$ = this.$dateTimeFormat$["resolvedOptions"] && this.$dateTimeFormat$["resolvedOptions"]()
      }
      parts = this.$dateTimeFormat$["formatToParts"](date)
    }
    var dateTimeString = "";
    for(var i = 0;i < this.$tokens$.length;i++) {
      var token = this.$tokens$[i];
      if(token["literal"] === true) {
        dateTimeString += token["value"];
        continue
      }
      if(token["useConfig"] === true && parts) {
        var field = token["field"];
        var option = this.$resolvedOptions$ && this.$resolvedOptions$[field];
        if(option === this.$config$[field]) {
          dateTimeString += $A.$localizationService$.$findField$(parts, field);
          continue
        }else {
          token["useConfig"] = false
        }
      }
      if(token["type"] === "number") {
        var value = getNumberFieldValue(token, date);
        dateTimeString += this.$formatNumberField$(value, token["minDigits"] || 1, token["localized"])
      }else {
        if(token["type"] === "string") {
          switch(token["field"]) {
            case "dayPeriod":
              if(token["value"] === "B" || token["value"] === "b") {
                dateTimeString += this.locale.$getDayPeriod$(date.getHours())
              }else {
                dateTimeString += this.locale.$getMeridiem$(date.getHours())
              }
              break;
            case "month":
              dateTimeString += this.locale.getMonth(date.getMonth(), token["style"]);
              break;
            case "weekday":
              dateTimeString += this.locale.$getWeekday$(date.getDay(), token["style"]);
              break
          }
        }else {
          if(token["type"] === "localizedFormat") {
            var dateTimeFormat = new Intl["DateTimeFormat"](this.$localeName$, token["config"]);
            dateTimeString += $A.$localizationService$.$format$(dateTimeFormat, date)
          }else {
            if(token["field"] === "offset") {
              if(utcOffset === undefined) {
                utcOffset = date.getTimezoneOffset() * -1 || 0
              }
              if(token["zone"] !== undefined) {
                if(utcOffset === 0) {
                  dateTimeString += token["zone"]
                }
              }else {
                dateTimeString += this.$formatOffset$(utcOffset, token["delimiter"])
              }
            }
          }
        }
      }
    }
    return dateTimeString
  }
};
Aura.$Utils$.$DateTimeFormat$.$Token$;
Aura.$Utils$.$DateTimeFormat$.prototype.parse = function(dateTimeString, strictParsing, isUTC) {
  var config = {};
  for(var i = 0;i < this.$tokens$.length && dateTimeString.length > 0;i++) {
    var token = this.$tokens$[i];
    var value = token["value"];
    var parsedString;
    if(token["field"] === "hour" && value.length === 1) {
      var nextToken = this.$tokens$[i + 1];
      if(nextToken && nextToken["value"] === "mm") {
        value = value + "mm";
        i += 1;
        nextToken = this.$tokens$[i + 1];
        if(nextToken && nextToken["value"] === "ss") {
          value = value + "ss";
          i += 1
        }
      }
    }
    if(token["literal"] === true || token["type"] === "localizedFormat") {
      parsedString = value
    }else {
      var pattern = this.$getRegExpPattern$(value, strictParsing);
      if(!pattern) {
        return null
      }
      var match = dateTimeString.match(pattern);
      if(match) {
        if(strictParsing && match["index"] !== 0) {
          return null
        }
        parsedString = match[0];
        switch(token["field"]) {
          case "offset":
            config["offset"] = $A.$localizationService$.$parseOffset$(parsedString);
            break;
          case "month":
            if(token["type"] === "number") {
              config["month"] = parseInt(parsedString, 10)
            }else {
              config["month"] = this.locale.$parseMonth$(parsedString, token["style"]) + 1
            }
            break;
          case "dayPeriod":
            if(token["value"] === "B" || token["value"] === "b") {
              config["isPM"] = this.locale.$isAfterNoonDayPeriod$(parsedString)
            }else {
              config["isPM"] = this.locale.$isPM$(parsedString)
            }
            break;
          case "weekday":
            if(token["type"] === "number") {
              config["weekday"] = parseInt(parsedString, 10)
            }else {
              config["weekday"] = this.locale.$parseWeekday$(parsedString, token["style"])
            }
            break;
          case "hour":
            if(match.length > 1) {
              config["hour"] = parseInt(match[1], 10);
              config["minute"] = parseInt(match[2], 10);
              if(match.length === 4) {
                config["second"] = parseInt(match[3], 10)
              }
            }else {
              config["hour"] = parseInt(parsedString, 10)
            }
            break;
          default:
            config[token["field"]] = parseInt(parsedString, 10)
        }
      }else {
        if(strictParsing) {
          return null
        }
        parsedString = value
      }
    }
    var matchStart = dateTimeString.indexOf(parsedString);
    if(matchStart < 0 || strictParsing === true && matchStart !== 0) {
      return null
    }
    var remainingStart = matchStart + parsedString.length;
    dateTimeString = dateTimeString.substring(remainingStart)
  }
  if(strictParsing && (i !== this.$tokens$.length || dateTimeString.length > 0)) {
    return null
  }
  var date = new Date;
  var year = config["year"] || date.getFullYear();
  var month = config["month"] || date.getMonth() + 1;
  var day = config["day"] || date.getDate();
  if(!$A.$localizationService$.$isValidDate$(year, month, day)) {
    return null
  }
  var hour = config["hour"] || 0;
  if(config["isPM"]) {
    hour = hour % 12 + 12
  }
  var minute = config["minute"] || 0;
  var second = config["second"] || 0;
  var millisecond = config["millisecond"] || 0;
  if(!$A.$localizationService$.$isValidTime$(hour, minute, second, millisecond)) {
    return null
  }
  var utcOffset = config["offset"];
  if(utcOffset === null) {
    return null
  }else {
    if(utcOffset) {
      minute -= utcOffset
    }
  }
  if(isUTC || utcOffset !== undefined) {
    date.setUTCFullYear(year, month - 1, day);
    date.setUTCHours(hour, minute, second, millisecond)
  }else {
    date.setFullYear(year, month - 1, day);
    date.setHours(hour, minute, second, millisecond)
  }
  return date
};
Aura.$Utils$.$DateTimeFormat$.prototype.$getRegExpPattern$ = function(tokenString, strictParsing) {
  switch(tokenString) {
    case "y":
    ;
    case "Y":
      return $A.$localizationService$.$UNSIGNED_NUMBER$;
    case "E":
      return $A.$localizationService$.$DIGIT1$;
    case "M":
    ;
    case "d":
    ;
    case "D":
    ;
    case "H":
    ;
    case "h":
    ;
    case "k":
    ;
    case "m":
    ;
    case "s":
      return $A.$localizationService$.$DIGIT1_2$;
    case "yy":
    ;
    case "YY":
    ;
    case "MM":
    ;
    case "dd":
    ;
    case "DD":
    ;
    case "HH":
    ;
    case "hh":
    ;
    case "kk":
    ;
    case "mm":
    ;
    case "ss":
      return strictParsing ? $A.$localizationService$.$DIGIT2$ : $A.$localizationService$.$DIGIT1_2$;
    case "yyyy":
    ;
    case "YYYY":
      return strictParsing ? $A.$localizationService$.$DIGIT4$ : $A.$localizationService$.$DIGIT1_4$;
    case "MMM":
      return this.locale.$getShortMonthPattern$();
    case "MMMM":
      return this.locale.$getLongMonthPattern$();
    case "EE":
      return this.locale.$getNarrowWeekdayPattern$();
    case "EEE":
      return this.locale.$getShortWeekdayPattern$();
    case "EEEE":
      return this.locale.$getLongWeekdayPattern$();
    case "Hmm":
    ;
    case "hmm":
    ;
    case "kmm":
      return $A.$localizationService$.$HOUR_MIN$;
    case "Hmmss":
    ;
    case "hmmss":
    ;
    case "kmmss":
      return $A.$localizationService$.$HOUR_MIN_SEC$;
    case "S":
      return strictParsing ? $A.$localizationService$.$DIGIT1$ : $A.$localizationService$.$DIGIT1_3$;
    case "SS":
      return strictParsing ? $A.$localizationService$.$DIGIT2$ : $A.$localizationService$.$DIGIT1_3$;
    case "SSS":
      return strictParsing ? $A.$localizationService$.$DIGIT3$ : $A.$localizationService$.$DIGIT1_3$;
    case "a":
    ;
    case "A":
      return this.locale.$getMeridiemPattern$();
    case "b":
    ;
    case "B":
      return this.locale.$getDayPeriodPattern$();
    case "Z":
    ;
    case "ZZ":
      return $A.$localizationService$.$ISO_OFFSET_PATTERN$
  }
  throw new Error("Unexpected tokenString, " + tokenString);
};
Aura.$Utils$.$DateTimeFormat$.prototype.$formatNumberField$ = function(num, minDigits, localized) {
  if(localized && !this.$formatErrorFromIntl$) {
    try {
      return this.locale.$formatNumber$(num, minDigits, 0)
    }catch(e) {
      this.$formatErrorFromIntl$ = true
    }
  }
  var numString = num.toString();
  if(numString.length < minDigits) {
    return(Array(minDigits).join("0") + numString).slice(-minDigits)
  }
  return numString.toString()
};
Aura.$Utils$.$DateTimeFormat$.prototype.$formatOffset$ = function(offsetInMinute, delimiter) {
  var offsetString;
  if(offsetInMinute < 0) {
    offsetString = "-";
    offsetInMinute *= -1
  }else {
    offsetString = "+"
  }
  offsetString += this.$formatNumberField$(Math.floor(offsetInMinute / 60), 2);
  if(delimiter === true) {
    offsetString += ":"
  }
  return offsetString + this.$formatNumberField$(offsetInMinute % 60, 2)
};
Aura.$Utils$.$Duration$ = function Duration(num, unit, moment) {
  this.$momentDuration$ = moment["duration"](num, unit);
  this.$isValid$ = true;
  if(typeof num !== "number") {
    this.$isValid$ = false;
    return
  }
  unit = unit ? $A.$localizationService$.$normalizeDateTimeUnit$(unit) : "millisecond";
  var milliseconds;
  var days;
  var months;
  switch(unit) {
    case "millisecond":
      milliseconds = num;
      break;
    case "second":
      milliseconds = num * 1E3;
      break;
    case "minute":
      milliseconds = num * 6E4;
      break;
    case "hour":
      milliseconds = num * 36E5;
      break;
    case "day":
      days = num;
      break;
    case "week":
      days = num * 7;
      break;
    case "month":
      months = num;
      break;
    case "year":
      months = num * 12
  }
  this.duration = {"millisecond":milliseconds || 0, "day":days || 0, "month":months || 0};
  this.data = undefined
};
goog.$exportSymbol$("Aura.Utils.Duration", Aura.$Utils$.$Duration$);
Aura.$Utils$.$Duration$.prototype.$displayDuration$ = function(withSuffix) {
  return this.$momentDuration$["humanize"](withSuffix)
};
Aura.$Utils$.$Duration$.prototype.$asUnit$ = function(unit) {
  if(!this.$isValid$) {
    return NaN
  }
  unit = unit ? $A.$localizationService$.$normalizeDateTimeUnit$(unit) : "millisecond";
  var days;
  var milliseconds = this.duration["millisecond"];
  if(unit === "month" || unit === "year") {
    days = this.duration["day"] + milliseconds / 864E5;
    var months = this.duration["month"] + this.$daysToMonths$(days);
    return unit === "month" ? months : months / 12
  }else {
    days = this.duration["day"];
    if(this.duration["month"]) {
      days += Math.round(this.$monthsToDays$(this.duration["month"]))
    }
    switch(unit) {
      case "week":
        return days / 7 + milliseconds / 6048E5;
      case "day":
        return days + milliseconds / 864E5;
      case "hour":
        return days * 24 + milliseconds / 36E5;
      case "minute":
        return days * 1440 + milliseconds / 6E4;
      case "second":
        return days * 86400 + milliseconds / 1E3;
      case "millisecond":
        return Math.floor(days * 864E5) + milliseconds;
      default:
        return NaN
    }
  }
};
Aura.$Utils$.$Duration$.prototype.$getUnit$ = function(unit) {
  if(!this.$isValid$) {
    return NaN
  }
  if(this.data === undefined) {
    this.data = {};
    var milliseconds = this.duration["millisecond"];
    this.data["millisecond"] = milliseconds % 1E3;
    var seconds = this.$absFloor$(milliseconds / 1E3);
    this.data["second"] = seconds % 60;
    var minutes = this.$absFloor$(seconds / 60);
    this.data["minute"] = minutes % 60;
    var hours = this.$absFloor$(minutes / 60);
    this.data["hour"] = hours % 24;
    var days = this.$absFloor$(hours / 24);
    days += this.duration["day"];
    var months = this.$absFloor$(this.$daysToMonths$(days)) + this.duration["month"];
    this.data["day"] = days - this.$absCeil$(this.$monthsToDays$(months));
    this.data["month"] = months % 12;
    this.data["year"] = this.$absFloor$(months / 12)
  }
  unit = unit ? $A.$localizationService$.$normalizeDateTimeUnit$(unit) : "millisecond";
  var num = this.data[unit];
  return num === undefined ? NaN : num
};
Aura.$Utils$.$Duration$.prototype.$daysToMonths$ = function(days) {
  return days * 4800 / 146097
};
Aura.$Utils$.$Duration$.prototype.$monthsToDays$ = function(months) {
  return months * 146097 / 4800
};
Aura.$Utils$.$Duration$.prototype.$absCeil$ = function(number) {
  return number < 0 ? Math.floor(number) : Math.ceil(number)
};
Aura.$Utils$.$Duration$.prototype.$absFloor$ = function(number) {
  return number < 0 ? Math.ceil(number) || 0 : Math.floor(number)
};
Aura.$Utils$.$Duration$.prototype.$humanize$ = function(withSuffix) {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", null, "Duration.humanize");
  return this.$momentDuration$["humanize"](withSuffix)
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "humanize", Aura.$Utils$.$Duration$.prototype.$humanize$);
Aura.$Utils$.$Duration$.prototype.$milliseconds$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.getMillisecondsInDuration()'", "Duration.milliseconds");
  return this.$momentDuration$["milliseconds"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "milliseconds", Aura.$Utils$.$Duration$.prototype.$milliseconds$);
Aura.$Utils$.$Duration$.prototype.$asMilliseconds$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInMilliseconds()'", "Duration.asMilliseconds");
  return this.$momentDuration$["asMilliseconds"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asMilliseconds", Aura.$Utils$.$Duration$.prototype.$asMilliseconds$);
Aura.$Utils$.$Duration$.prototype.$seconds$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationSerivce.displayDurationInSeconds()'", "Duration.seconds");
  return this.$momentDuration$["seconds"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "seconds", Aura.$Utils$.$Duration$.prototype.$seconds$);
Aura.$Utils$.$Duration$.prototype.$asSeconds$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInSeconds()'", "Duration.asSeconds");
  return this.$momentDuration$["asSeconds"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asSeconds", Aura.$Utils$.$Duration$.prototype.$asSeconds$);
Aura.$Utils$.$Duration$.prototype.$minutes$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.getMinutesInDuration()", "Duration.minutes");
  return this.$momentDuration$["minutes"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "minutes", Aura.$Utils$.$Duration$.prototype.$minutes$);
Aura.$Utils$.$Duration$.prototype.$asMinutes$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInMinutes()'", "Duration.asMinutes");
  return this.$momentDuration$["asMinutes"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asMinutes", Aura.$Utils$.$Duration$.prototype.$asMinutes$);
Aura.$Utils$.$Duration$.prototype.$hours$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.getHoursInDuration()'", "Duration.hours");
  return this.$momentDuration$["hours"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "hours", Aura.$Utils$.$Duration$.prototype.$hours$);
Aura.$Utils$.$Duration$.prototype.$asHours$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInHours()'", "Duration.asHours");
  return this.$momentDuration$["asHours"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asHours", Aura.$Utils$.$Duration$.prototype.$asHours$);
Aura.$Utils$.$Duration$.prototype.$days$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.getDaysInDuration()'", "Duration.days");
  return this.$momentDuration$["days"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "days", Aura.$Utils$.$Duration$.prototype.$days$);
Aura.$Utils$.$Duration$.prototype.$asDays$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInDays()'", "Duration.asDays");
  return this.$momentDuration$["asDays"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asDays", Aura.$Utils$.$Duration$.prototype.$asDays$);
Aura.$Utils$.$Duration$.prototype.$weeks$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", null, "Duration.weeks");
  return this.$momentDuration$["weeks"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "weeks", Aura.$Utils$.$Duration$.prototype.$weeks$);
Aura.$Utils$.$Duration$.prototype.$asWeeks$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", null, "Duration.asWeeks");
  return this.$momentDuration$["asWeeks"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asWeeks", Aura.$Utils$.$Duration$.prototype.$asWeeks$);
Aura.$Utils$.$Duration$.prototype.$months$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.getMonthsInDuration()'", "Duration.months");
  return this.$momentDuration$["months"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "months", Aura.$Utils$.$Duration$.prototype.$months$);
Aura.$Utils$.$Duration$.prototype.$asMonths$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInMonths()'", "Duration.asMonths");
  return this.$momentDuration$["asMonths"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asMonths", Aura.$Utils$.$Duration$.prototype.$asMonths$);
Aura.$Utils$.$Duration$.prototype.$years$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.getYearsInDuration()'", "Duration.years");
  return this.$momentDuration$["years"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "years", Aura.$Utils$.$Duration$.prototype.$years$);
Aura.$Utils$.$Duration$.prototype.$asYears$ = function() {
  $A.$deprecated$("This method is not officially supported by framework and will be removed in upcoming release.", "Use '$A.localizationService.displayDurationInYears()'", "Duration.asYears");
  return this.$momentDuration$["asYears"]()
};
goog.$exportProperty$(Aura.$Utils$.$Duration$.prototype, "asYears", Aura.$Utils$.$Duration$.prototype.$asYears$);
Aura.$Utils$.$Locale$ = function(localeName) {
  this.$intlLocale$ = $A.$localizationService$.$normalizeToIntlLocale$(localeName);
  this.$monthNames$ = {};
  this.$weekdayNames$ = {};
  this.$meridiemNames$ = undefined;
  this.$dayPeriodStrings$ = undefined;
  this.$monthNamesParse$ = {};
  this.$weekdayNamesParse$ = {};
  this.$meridiemNamesParse$ = undefined;
  this.$dayPeriodStringsParse$ = undefined;
  this.$meridiemPattern$ = undefined;
  this.$dayPeriodPattern$ = undefined;
  this.$numberFormats$ = {}
};
Aura.$Utils$.$Locale$.prototype.getName = function() {
  return this.$intlLocale$
};
Aura.$Utils$.$Locale$.prototype.$getMonths$ = function(style) {
  if(this.$monthNames$[style] === undefined) {
    this.$createMonthNames$(style)
  }
  return this.$monthNames$[style]
};
Aura.$Utils$.$Locale$.prototype.getMonth = function(month, style) {
  var months = this.$getMonths$(style);
  return months[month]
};
Aura.$Utils$.$Locale$.prototype.$parseMonth$ = function(monthString, style) {
  if(!style) {
    style = "long"
  }
  if(this.$monthNamesParse$[style] === undefined) {
    this.$createMonthNames$(style)
  }
  return this.$monthNamesParse$[style].indexOf(monthString.toLowerCase())
};
Aura.$Utils$.$Locale$.prototype.$getShortMonthPattern$ = function() {
  if(this.$shortMonthPattern$ === undefined) {
    var months = this.$getMonths$("short");
    this.$shortMonthPattern$ = new RegExp("^(" + months.join("|") + ")", "i")
  }
  return this.$shortMonthPattern$
};
Aura.$Utils$.$Locale$.prototype.$getLongMonthPattern$ = function() {
  if(this.$longMonthPattern$ === undefined) {
    var months = this.$getMonths$("long");
    this.$longMonthPattern$ = new RegExp("^(" + months.join("|") + ")", "i")
  }
  return this.$longMonthPattern$
};
Aura.$Utils$.$Locale$.prototype.$createMonthNames$ = function(style) {
  var monthFormat = new Intl["DateTimeFormat"](this.$intlLocale$, {"month":style});
  var date = new Date(2014, 0, 1);
  var monthNames = [];
  var monthNamesParse = [];
  for(var i = 0;i < 12;i++) {
    date.setMonth(i);
    var month = $A.$localizationService$.$format$(monthFormat, date);
    if(!month) {
      continue
    }
    monthNames.push(month);
    monthNamesParse.push(month.toLowerCase())
  }
  this.$monthNames$[style] = monthNames;
  this.$monthNamesParse$[style] = monthNamesParse
};
Aura.$Utils$.$Locale$.prototype.$isPM$ = function(meridiemString) {
  if(this.$meridiemNamesParse$ === undefined) {
    this.$createMeridiemNames$()
  }
  return this.$meridiemNamesParse$[1] === meridiemString.toLowerCase()
};
Aura.$Utils$.$Locale$.prototype.$getMeridiem$ = function(hour) {
  var meridiems = this.$getMeridiems$();
  return hour < 12 ? meridiems[0] : meridiems[1]
};
Aura.$Utils$.$Locale$.prototype.$getMeridiems$ = function() {
  if(this.$meridiemNames$ === undefined) {
    this.$createMeridiemNames$()
  }
  return this.$meridiemNames$
};
Aura.$Utils$.$Locale$.prototype.$getMeridiemPattern$ = function() {
  if(this.$meridiemPattern$ === undefined) {
    var meridiems = this.$getMeridiems$();
    this.$meridiemPattern$ = new RegExp("^(" + meridiems.join("|") + ")", "i")
  }
  return this.$meridiemPattern$
};
Aura.$Utils$.$Locale$.prototype.$createMeridiemNames$ = function() {
  var meridiemFormat = new Intl["DateTimeFormat"](this.$intlLocale$, {"hour12":true, "hour":"2-digit", "minute":"2-digit"});
  var amDate = new Date(2012, 11, 20, 11, 11);
  var pmDate = new Date(2012, 11, 20, 23, 11);
  var am;
  var pm;
  if($A.$localizationService$.$canFormatToParts$() === true) {
    am = $A.$localizationService$.$getLocalizedDateTimeField$(amDate, meridiemFormat, "dayperiod");
    pm = $A.$localizationService$.$getLocalizedDateTimeField$(pmDate, meridiemFormat, "dayperiod")
  }else {
    var timeString = $A.$localizationService$.$format$(meridiemFormat, amDate);
    am = timeString && timeString.replace(".", "").replace(/ ?.{2}:.{2} ?/, "") || "AM";
    timeString = $A.$localizationService$.$format$(meridiemFormat, pmDate);
    pm = timeString && timeString.replace(".", "").replace(/ ?.{2}:.{2} ?/, "") || "PM"
  }
  this.$meridiemNames$ = [am, pm];
  this.$meridiemNamesParse$ = [am.toLowerCase(), pm.toLowerCase()]
};
Aura.$Utils$.$Locale$.prototype.$isAfterNoonDayPeriod$ = function(dayPeriodString) {
  if(this.$dayPeriodStringsParse$ === undefined) {
    this.$createDayPeriodStrings$()
  }
  return this.$dayPeriodStringsParse$.indexOf(dayPeriodString.toLowerCase()) >= 12
};
Aura.$Utils$.$Locale$.prototype.$getDayPeriod$ = function(hour) {
  var dayPeriodStrings = this.$getDayPeriods$();
  return dayPeriodStrings[hour]
};
Aura.$Utils$.$Locale$.prototype.$getDayPeriods$ = function() {
  if(this.$dayPeriodStrings$ === undefined) {
    this.$createDayPeriodStrings$()
  }
  return this.$dayPeriodStrings$
};
Aura.$Utils$.$Locale$.prototype.$getDayPeriodPattern$ = function() {
  if(this.$dayPeriodPattern$ === undefined) {
    var dayPeriods = this.$getDayPeriods$();
    this.$dayPeriodPattern$ = new RegExp("^(" + dayPeriods.join("|") + ")", "i")
  }
  return this.$dayPeriodPattern$
};
Aura.$Utils$.$Locale$.prototype.$createDayPeriodStrings$ = function() {
  var dayPeriodFormat = new Intl["DateTimeFormat"](this.$intlLocale$, {"dayPeriod":"short"});
  var dayPeriodArray = [];
  if($A.$localizationService$.$canFormatToParts$() === true) {
    for(var hour = 0;hour < 24;hour++) {
      var date = new Date(2012, 11, 20, hour, 0, 0);
      dayPeriodArray.push($A.$localizationService$.$getLocalizedDateTimeField$(date, dayPeriodFormat, "dayperiod"))
    }
  }else {
    for(hour = 0;hour < 24;hour++) {
      date = new Date(2012, 11, 20, hour, 0, 0);
      dayPeriodArray.push(dayPeriodFormat["format"](date))
    }
  }
  this.$dayPeriodStrings$ = dayPeriodArray;
  this.$dayPeriodStringsParse$ = dayPeriodArray.map(function(dayPeriod) {
    return dayPeriod.toLowerCase()
  })
};
Aura.$Utils$.$Locale$.prototype.$getWeekday$ = function(weekday, style) {
  var weekdays = this.$getWeekdays$(style);
  return weekdays[weekday]
};
Aura.$Utils$.$Locale$.prototype.$getWeekdays$ = function(style) {
  if(this.$weekdayNames$[style] === undefined) {
    this.$createWeekdayNames$(style)
  }
  return this.$weekdayNames$[style]
};
Aura.$Utils$.$Locale$.prototype.$parseWeekday$ = function(weekdayString, style) {
  if(!style) {
    style = "long"
  }
  if(this.$weekdayNamesParse$[style] === undefined) {
    this.$createWeekdayNames$(style)
  }
  return this.$weekdayNamesParse$[style].indexOf(weekdayString.toLowerCase())
};
Aura.$Utils$.$Locale$.prototype.$getNarrowWeekdayPattern$ = function() {
  if(this.$narrowWeekdayPattern$ === undefined) {
    var weekdays = this.$getWeekdays$("narrow");
    this.$narrowWeekdayPattern$ = new RegExp("^(" + weekdays.join("|") + ")", "i")
  }
  return this.$narrowWeekdayPattern$
};
Aura.$Utils$.$Locale$.prototype.$getShortWeekdayPattern$ = function() {
  if(this.$shortWeekdayPattern$ === undefined) {
    var weekdays = this.$getWeekdays$("short");
    this.$shortWeekdayPattern$ = new RegExp("^(" + weekdays.join("|") + ")", "i")
  }
  return this.$shortWeekdayPattern$
};
Aura.$Utils$.$Locale$.prototype.$getLongWeekdayPattern$ = function() {
  if(this.$longWeekdayPattern$ === undefined) {
    var weekdays = this.$getWeekdays$("long");
    this.$longWeekdayPattern$ = new RegExp("^(" + weekdays.join("|") + ")", "i")
  }
  return this.$longWeekdayPattern$
};
Aura.$Utils$.$Locale$.prototype.$createWeekdayNames$ = function(style) {
  var weekdayFormat = new Intl["DateTimeFormat"](this.$intlLocale$, {"weekday":style});
  var date = new Date(2018, 3, 1);
  var weekdayNames = [];
  var weekdayNamesParse = [];
  for(var i = 1;i < 8;i++) {
    date.setDate(i);
    var weekday = $A.$localizationService$.$format$(weekdayFormat, date);
    if(!weekday) {
      continue
    }
    weekdayNames.push(weekday);
    weekdayNamesParse.push(weekday.toLowerCase())
  }
  this.$weekdayNames$[style] = weekdayNames;
  this.$weekdayNamesParse$[style] = weekdayNamesParse
};
Aura.$Utils$.$Locale$.prototype.$formatNumber$ = function(num, minIntegerDigits, maxFractionDigits) {
  var key = minIntegerDigits + ":" + maxFractionDigits;
  var numberFormat = this.$numberFormats$[key];
  if(numberFormat === undefined) {
    numberFormat = new Intl["NumberFormat"](this.$intlLocale$, {"useGrouping":false, "minimumIntegerDigits":minIntegerDigits, "maximumFractionDigits":maxFractionDigits});
    this.$numberFormats$[key] = numberFormat
  }
  return $A.$localizationService$.$translateToLocalizedDigits$(numberFormat["format"](num))
};
Aura.$Utils$.$NumberFormat$ = function NumberFormat(format, symbols) {
  this.$originalFormat$ = format;
  this.$symbols$ = symbols || {"decimalSeparator":$A.get("$Locale.decimal"), "groupingSeparator":$A.get("$Locale.grouping"), "currency":$A.get("$Locale.currency"), "currencyCode":$A.get("$Locale.currencyCode"), "zeroDigit":$A.get("$Locale.zero")};
  this.$zeroCharCodeOffset$ = this.$symbols$["zeroDigit"].charCodeAt(0) - Aura.$Utils$.$NumberFormat$.ZERO.charCodeAt(0);
  this.$hasCurrency$ = false;
  this.$multiplier$ = 0;
  this.$minDigits$ = 1;
  this.$positiveGroupingDigits$ = [];
  this.$minFractionDigits$ = 0;
  this.$maxFractionDigits$ = 0;
  this.prefix = null;
  this.$suffix$ = null;
  this.$hasNegativePattern$ = false;
  this.$negativePrefix$ = null;
  this.$negativeSuffix$ = null;
  var parsePhase = 0;
  var prefixEnd = 0;
  var suffixStart = format.length;
  var zeros = 0;
  var leftNumber = false;
  var rightNumbers = 0;
  var group = -1;
  var decimal = false;
  var posPattern;
  var negPattern;
  var split = format.indexOf(";");
  if(split !== -1) {
    posPattern = format.substring(0, split);
    negPattern = format.substring(split + 1)
  }else {
    posPattern = format
  }
  for(var i = 0;i < posPattern.length;i++) {
    var c = posPattern.charAt(i);
    switch(parsePhase) {
      case 0:
        if(c === "#" || c === Aura.$Utils$.$NumberFormat$.ZERO || c === "." || c === ",") {
          parsePhase = 1;
          prefixEnd = i;
          i--;
          break
        }else {
          this.$checkForSpecialChar$(c)
        }
        break;
      case 1:
        switch(c) {
          case "#":
            if(zeros > 0 || decimal) {
              rightNumbers++
            }else {
              leftNumber = true
            }
            if(group >= 0 && !decimal) {
              group++
            }
            break;
          case Aura.$Utils$.$NumberFormat$.ZERO:
            if(rightNumbers > 0) {
              this.parseError("'0's must be sequential")
            }
            zeros++;
            if(group >= 0 && !decimal) {
              group++
            }
            break;
          case ",":
            if(!leftNumber && !zeros) {
              this.parseError("there must be a number before the grouping separator")
            }
            if(decimal) {
              this.parseError("grouping separator found after the decimal separator")
            }
            if(group > 0) {
              this.$positiveGroupingDigits$.unshift(group)
            }
            group = 0;
            break;
          case ".":
            if(decimal) {
              this.parseError("too many decimal separators")
            }
            this.$minDigits$ = zeros;
            zeros = 0;
            decimal = true;
            break;
          default:
            suffixStart = i--;
            parsePhase = 2;
            break
        }
        break;
      case 2:
        this.$checkForSpecialChar$(c);
        break
    }
  }
  if(group > 0) {
    this.$positiveGroupingDigits$.unshift(group)
  }
  if(group === 0) {
    this.parseError("grouping cannot be 0")
  }
  if(!decimal) {
    this.$minDigits$ = zeros;
    this.$minFractionDigits$ = 0;
    this.$maxFractionDigits$ = 0
  }else {
    this.$minFractionDigits$ = zeros;
    this.$maxFractionDigits$ = this.$minFractionDigits$ + rightNumbers
  }
  if(this.$minDigits$ === this.$minFractionDigits$ === 0) {
    this.$minDigits$ = 1
  }
  var innerPattern = posPattern;
  if(prefixEnd) {
    this.prefix = posPattern.substring(0, prefixEnd);
    innerPattern = innerPattern.substring(prefixEnd)
  }
  if(suffixStart < posPattern.length) {
    this.$suffix$ = posPattern.substring(suffixStart);
    innerPattern = innerPattern.substring(0, suffixStart)
  }
  if(negPattern) {
    this.$hasNegativePattern$ = true;
    var inner = negPattern.indexOf(innerPattern);
    if(inner === -1) {
      this.parseError("negative pattern doesn't contain identical number format")
    }
    if(inner !== 0) {
      this.$negativePrefix$ = negPattern.substring(0, inner)
    }
    if(inner + innerPattern.length < negPattern.length) {
      this.$negativeSuffix$ = negPattern.substring(inner + innerPattern.length)
    }
  }
  this.$replaceCurrencies$()
};
goog.$exportSymbol$("Aura.Utils.NumberFormat", Aura.$Utils$.$NumberFormat$);
Aura.$Utils$.$NumberFormat$.ZERO = "0";
Aura.$Utils$.$NumberFormat$.prototype.parseError = function(s) {
  throw new Error("Invalid pattern: " + this.$originalFormat$ + "\n" + s);
};
Aura.$Utils$.$NumberFormat$.prototype.$checkForSpecialChar$ = function(c) {
  var mult;
  switch(c) {
    case "\u00a4":
      this.$hasCurrency$ = true;
      break;
    case "%":
      mult = 2;
      break;
    case "\u2030":
      mult = 3;
      break;
    case "\u2031":
      mult = 4;
      break
  }
  if(mult) {
    if(this.$multiplier$ !== 0) {
      this.parseError("too many percentage symbols")
    }else {
      this.$multiplier$ = mult
    }
  }
};
Aura.$Utils$.$NumberFormat$.prototype.$replaceCurrencies$ = function() {
  if(this.$hasCurrency$) {
    this.prefix = this.$replaceCurrency$(this.prefix);
    this.$suffix$ = this.$replaceCurrency$(this.$suffix$);
    this.$negativePrefix$ = this.$replaceCurrency$(this.$negativePrefix$);
    this.$negativeSuffix$ = this.$replaceCurrency$(this.$negativeSuffix$)
  }
};
Aura.$Utils$.$NumberFormat$.prototype.$replaceCurrency$ = function(str) {
  if(str) {
    return str.replace(/\u00a4\u00a4/g, this.$symbols$["currencyCode"]).replace(/\u00a4/g, this.$symbols$["currency"])
  }
  return str
};
Aura.$Utils$.$NumberFormat$.prototype.$translateDigits$ = function(charArray) {
  if(this.$zeroCharCodeOffset$) {
    for(var i = 0;i < charArray.length;i++) {
      charArray[i] = String.fromCharCode(charArray[i].charCodeAt(0) + this.$zeroCharCodeOffset$)
    }
  }
  return charArray
};
Aura.$Utils$.$NumberFormat$.prototype.$format$ = function(number) {
  if($A["util"].$isString$(number)) {
    if(number.charAt(0) === "+") {
      number = number.substring(1)
    }
  }else {
    if(!$A["util"].$isFiniteNumber$(number)) {
      throw new Error('Unable to format. Not a valid number, "' + number + '"');
    }else {
      number = (+number).toString()
    }
  }
  if(number.indexOf("e") > -1 || number.indexOf("E") > -1) {
    number = number.replace(/^(-)?(\d+)\.?(\d*)e([+\-]?\d+)$/i, function normalizeExponential(match, sign, integer, decimal, exponential) {
      exponential = Number(exponential);
      var isExpontnetialNegative = exponential < 0;
      var normalizedIntegerLength = integer.length + exponential;
      var length = (isExpontnetialNegative ? integer : decimal).length;
      exponential = Math.abs(exponential);
      exponential = exponential >= length ? exponential - length + isExpontnetialNegative : 0;
      var paddingZeros = (new Array(exponential + 1)).join("0");
      var floatingNumber = isExpontnetialNegative ? paddingZeros + (integer + decimal) : integer + decimal + paddingZeros;
      normalizedIntegerLength += isExpontnetialNegative ? paddingZeros.length : 0;
      sign = sign || "";
      return sign + floatingNumber.substr(0, normalizedIntegerLength) + (normalizedIntegerLength < floatingNumber.length ? "." + floatingNumber.substr(normalizedIntegerLength) : "")
    })
  }
  var charArray = number.split("");
  var negative = false;
  if(charArray[0] === "-") {
    negative = true;
    charArray.shift()
  }
  var decimalPos = charArray.indexOf(".");
  if(decimalPos === -1) {
    decimalPos = charArray.length
  }else {
    charArray.splice(decimalPos, 1)
  }
  for(decimalPos += this.$multiplier$;decimalPos > charArray.length;) {
    charArray.push(Aura.$Utils$.$NumberFormat$.ZERO)
  }
  for(;charArray[0] === Aura.$Utils$.$NumberFormat$.ZERO;) {
    charArray.shift();
    decimalPos--
  }
  if(this.$maxFractionDigits$ < charArray.length - decimalPos) {
    var rounderIndex = decimalPos + this.$maxFractionDigits$;
    if(rounderIndex >= 0) {
      var round = charArray[rounderIndex] >= "5";
      for(charArray = charArray.slice(0, rounderIndex);round && rounderIndex > 0;) {
        var c = charArray[--rounderIndex];
        if(c !== "9") {
          charArray[rounderIndex] = String.fromCharCode(c.charCodeAt(0) + 1);
          round = false
        }else {
          charArray[rounderIndex] = Aura.$Utils$.$NumberFormat$.ZERO
        }
      }
      if(round) {
        charArray.unshift("1");
        decimalPos++
      }
    }else {
      charArray = [];
      if(-decimalPos > this.$minFractionDigits$) {
        decimalPos = -this.$minFractionDigits$
      }
    }
  }
  var prefix = this.prefix;
  var suffix = this.$suffix$;
  if(negative && this.$hasNegativePattern$) {
    prefix = this.$negativePrefix$;
    suffix = this.$negativeSuffix$
  }
  var result = [];
  if(negative && !this.$hasNegativePattern$) {
    result.push("-")
  }
  if(prefix) {
    result.push(prefix)
  }
  var zeroPad = this.$minDigits$ - decimalPos;
  for(var i = 0;i < zeroPad;i++) {
    charArray.unshift(Aura.$Utils$.$NumberFormat$.ZERO);
    decimalPos++
  }
  if(this.$positiveGroupingDigits$.length === 0 || decimalPos <= this.$positiveGroupingDigits$[0]) {
    result = result.concat(this.$translateDigits$(charArray.slice(0, decimalPos)))
  }else {
    var intChars = [];
    var parsedIndex = decimalPos;
    for(var groupIndex = 0;parsedIndex > 0;) {
      var currentGroupingDigits = this.$positiveGroupingDigits$[groupIndex];
      if(groupIndex + 1 < this.$positiveGroupingDigits$.length) {
        groupIndex++
      }
      var nextParsedIndex = parsedIndex - currentGroupingDigits < 0 ? 0 : parsedIndex - currentGroupingDigits;
      intChars = this.$translateDigits$(charArray.slice(nextParsedIndex, parsedIndex)).concat(intChars);
      if(nextParsedIndex > 0) {
        intChars.unshift(this.$symbols$["groupingSeparator"])
      }
      parsedIndex = nextParsedIndex
    }
    result = result.concat(intChars)
  }
  var fracLength = charArray.length - decimalPos;
  if(fracLength > 0 || this.$minFractionDigits$ > 0) {
    result.push(this.$symbols$["decimalSeparator"]);
    if(fracLength > 0) {
      result = result.concat(this.$translateDigits$(charArray.slice(decimalPos)))
    }
    for(i = fracLength;i < this.$minFractionDigits$;i++) {
      result.push(this.$symbols$["zeroDigit"])
    }
    for(i = fracLength;i > this.$minFractionDigits$ && result[result.length - 1] === "0";i--) {
      result.pop()
    }
    if(result[result.length - 1] === this.$symbols$["decimalSeparator"]) {
      result.pop()
    }
  }
  if(suffix) {
    result.push(suffix)
  }
  return result.join("")
};
goog.$exportProperty$(Aura.$Utils$.$NumberFormat$.prototype, "format", Aura.$Utils$.$NumberFormat$.prototype.$format$);
Aura.$Utils$.$Mutex$ = function Mutex() {
  this.$queue$ = [];
  this.$lockAvailable$ = true
};
goog.$exportSymbol$("Aura.Utils.Mutex", Aura.$Utils$.$Mutex$);
Aura.$Utils$.$Mutex$.$SET_MUTEX_WAIT$ = 15;
Aura.$Utils$.$Mutex$.$RETRY_WAIT$ = 15;
Aura.$Utils$.$Mutex$.$MAX_LOCK_TIME$ = 8E3;
Aura.$Utils$.$Mutex$.$CLIENT_ID$ = Aura.$Context$.$AuraContext$.$CLIENT_SESSION_ID$;
Aura.$Utils$.$Mutex$.$GLOBAL_KEY$ = "global";
Aura.$Utils$.$Mutex$.$MUTEX_X_KEY$ = "__MUTEX_X";
Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$ = "__MUTEX_Y";
Aura.$Utils$.$Mutex$.prototype.$getClientId$ = function() {
  return Aura.$Utils$.$Mutex$.$CLIENT_ID$
};
goog.$exportProperty$(Aura.$Utils$.$Mutex$.prototype, "getClientId", Aura.$Utils$.$Mutex$.prototype.$getClientId$);
Aura.$Utils$.$Mutex$.prototype.$lock$ = function() {
  var xargs = Array.prototype.slice.call(arguments);
  var key = typeof arguments[0] === "string" ? xargs.shift() : Aura.$Utils$.$Mutex$.$GLOBAL_KEY$;
  var callback = xargs.shift();
  var timeout = xargs.shift() || Aura.$Utils$.$Mutex$.$MAX_LOCK_TIME$;
  $A.assert(typeof callback === "function", "Mutex needs a function to execute");
  if(this.$lockAvailable$ && !this.$queue$.length) {
    this.$lockAvailable$ = false;
    window.requestAnimationFrame(this.$_lockPriv$.bind(this, key, callback, timeout))
  }else {
    this.$queue$.push({key:key, $callback$:callback, timeout:timeout})
  }
};
goog.$exportProperty$(Aura.$Utils$.$Mutex$.prototype, "lock", Aura.$Utils$.$Mutex$.prototype.$lock$);
Aura.$Utils$.$Mutex$.prototype.$_lockPriv$ = function(key, callback, timeout) {
  this.$_setX$(key, function() {
    if(!this.$_isLockAvailable$(key, timeout)) {
      this.$_retry$(key, callback, timeout);
      return
    }
    this.$_setY$(key, function() {
      if(this.$_getX$(key) !== Aura.$Utils$.$Mutex$.$CLIENT_ID$) {
        setTimeout(function retryOrExecuteDefered() {
          if(!this.$hasLock$(key)) {
            this.$_retry$(key, callback, timeout)
          }else {
            this.$_execute$(key, callback)
          }
        }.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$RETRY_WAIT$)
      }else {
        this.$_execute$(key, callback)
      }
    })
  })
};
Aura.$Utils$.$Mutex$.prototype.$hasLock$ = function(key) {
  return this.$_getY$(key) === Aura.$Utils$.$Mutex$.$CLIENT_ID$
};
Aura.$Utils$.$Mutex$.prototype.$_execute$ = function(key, callback) {
  setTimeout(function executeCallbackDefered() {
    callback(this.$_clearLock$.bind(this, key))
  }.bind(this), 0)
};
Aura.$Utils$.$Mutex$.prototype.$_clearLock$ = function(key) {
  window.localStorage.removeItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$);
  var lockTask = this.$queue$.shift();
  if(lockTask) {
    window.requestAnimationFrame(this.$_lockPriv$.bind(this, lockTask.key, lockTask.$callback$, lockTask.timeout))
  }else {
    this.$lockAvailable$ = true
  }
};
Aura.$Utils$.$Mutex$.prototype.$_retry$ = function(key, callback, timeout) {
  window.setTimeout(function retryLockPrivDefered() {
    this.$_lockPriv$(key, callback, timeout)
  }.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$RETRY_WAIT$)
};
Aura.$Utils$.$Mutex$.prototype.$_isLockAvailable$ = function(key, timeout) {
  var item = window.localStorage.getItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$);
  var token = item && item.split("|");
  var mutex_y_TS = token && parseInt(token[1], 10);
  if(!token || Date.now() > mutex_y_TS + timeout) {
    return true
  }
};
Aura.$Utils$.$Mutex$.prototype.$_getX$ = function(key) {
  var item = window.localStorage.getItem(key + Aura.$Utils$.$Mutex$.$MUTEX_X_KEY$);
  return item && item.split("|")[0]
};
Aura.$Utils$.$Mutex$.prototype.$_setX$ = function(key, callback) {
  window.localStorage.setItem(key + Aura.$Utils$.$Mutex$.$MUTEX_X_KEY$, Aura.$Utils$.$Mutex$.$CLIENT_ID$ + "|" + Date.now());
  window.setTimeout(callback.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$SET_MUTEX_WAIT$)
};
Aura.$Utils$.$Mutex$.prototype.$_getY$ = function(key) {
  var item = window.localStorage.getItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$);
  return item && item.split("|")[0]
};
Aura.$Utils$.$Mutex$.prototype.$_setY$ = function(key, callback) {
  window.localStorage.setItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$, Aura.$Utils$.$Mutex$.$CLIENT_ID$ + "|" + Date.now());
  window.setTimeout(callback.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$SET_MUTEX_WAIT$)
};
Aura.$Utils$.$DocLevelHandler$ = function DocLevelHandler(eventName, callback, component) {
  this.$eventName$ = eventName;
  this.$component$ = component;
  this.enabled = false;
  var that = this;
  this.$callback$ = function(eventObj) {
    if(that.$component$.$isValid$() && that.$component$.$isRendered$()) {
      callback(eventObj)
    }
  }
};
goog.$exportSymbol$("Aura.Utils.DocLevelHandler", Aura.$Utils$.$DocLevelHandler$);
Aura.$Utils$.$DocLevelHandler$.prototype.$setEnabled$ = function(enable) {
  if(enable) {
    if(!this.enabled) {
      this.enabled = true;
      $A["util"].$on$(document.body, this.$eventName$, this.$callback$)
    }
  }else {
    if(this.enabled) {
      this.enabled = false;
      $A["util"].$removeOn$(document.body, this.$eventName$, this.$callback$)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$DocLevelHandler$.prototype, "setEnabled", Aura.$Utils$.$DocLevelHandler$.prototype.$setEnabled$);
var SizeEstimator = function SizeEstimator() {
};
SizeEstimator.$CHARACTER_SIZE$ = 2;
SizeEstimator.$NUMBER_SIZE$ = 8;
SizeEstimator.$BOOLEAN_SIZE$ = 4;
SizeEstimator.$POINTER_SIZE$ = 8;
SizeEstimator.prototype.hasOwnProperty = Object.prototype.hasOwnProperty;
SizeEstimator.prototype.$estimateSize$ = function(value) {
  if(value === null || value === undefined) {
    return 0
  }
  var type = typeof value;
  if(type === "object") {
    try {
      return $A["util"].$json$.$encode$(value).length
    }catch(e) {
      $A.log("Error during size estimate, using 0: " + e);
      return 0
    }
  }
  switch(type) {
    case "string":
      return this.$sizeOfString$(value);
    case "number":
      return SizeEstimator.$NUMBER_SIZE$;
    case "boolean":
      return SizeEstimator.$BOOLEAN_SIZE$;
    default:
      return SizeEstimator.$POINTER_SIZE$
  }
};
SizeEstimator.prototype.$sizeOfString$ = function(value) {
  return value.length * SizeEstimator.$CHARACTER_SIZE$
};
Aura.$Utils$.$SizeEstimator$ = SizeEstimator;
Aura.$Utils$.$SecureFilters$ = function() {
  function jsSlashEncoder(charStr) {
    var code = charStr.charCodeAt(0);
    var hex = code.toString(16).toUpperCase();
    if(code < 128) {
      if(hex.length === 1) {
        return"\\x0" + hex
      }else {
        return"\\x" + hex
      }
    }else {
      switch(hex.length) {
        case 2:
          return"\\u00" + hex;
        case 3:
          return"\\u0" + hex;
        case 4:
          return"\\u" + hex;
        default:
          return"\\uFFFD"
      }
    }
  }
  var secureFilters = {};
  var QUOT = /\x22/g;
  var APOS = /\x27/g;
  var AST = /\*/g;
  var TILDE = /~/g;
  var BANG = /!/g;
  var LPAREN = /\(/g;
  var RPAREN = /\)/g;
  var CDATA_CLOSE = /\]\](?:>|\\x3E|\\u003E)/gi;
  var JS_NOT_ALLOWLISTED = /[^,\-\.0-9A-Z_a-z]/g;
  var JSON_NOT_ALLOWLISTED = /[^\x22,\-\.0-9:A-Z\[\x5C\]_a-z{}]/g;
  var HTML_CONTROL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g;
  var HTML_NOT_ALLOWLISTED = /[^\t\n\v\f\r ,\.0-9A-Z_a-z\-\u00A0-\uFFFF]/g;
  var CSS_NOT_ALLOWLISTED = /[^a-zA-Z0-9\uD800-\uDFFF]/g;
  secureFilters.$html$ = function(val) {
    var str = String(val);
    str = str.replace(HTML_CONTROL, " ");
    return str.replace(HTML_NOT_ALLOWLISTED, function(match) {
      var code = match.charCodeAt(0);
      switch(code) {
        case 34:
          return"\x26quot;";
        case 38:
          return"\x26amp;";
        case 60:
          return"\x26lt;";
        case 62:
          return"\x26gt;";
        default:
          if(code < 100) {
            var dec = code.toString(10);
            return"\x26#" + dec + ";"
          }else {
            var hex = code.toString(16).toUpperCase();
            return"\x26#x" + hex + ";"
          }
      }
    })
  };
  secureFilters.$js$ = function(val) {
    var str = String(val);
    return str.replace(JS_NOT_ALLOWLISTED, jsSlashEncoder)
  };
  secureFilters.$jsAttr$ = function(val) {
    return secureFilters.$html$(secureFilters.$js$(val))
  };
  secureFilters.uri = function(val) {
    var encode = encodeURIComponent(String(val));
    return encode.replace(BANG, "%21").replace(QUOT, "%27").replace(APOS, "%27").replace(LPAREN, "%28").replace(RPAREN, "%29").replace(AST, "%2A").replace(TILDE, "%7E")
  };
  secureFilters.$jsObj$ = function(val) {
    return JSON.stringify(val).replace(JSON_NOT_ALLOWLISTED, jsSlashEncoder).replace(CDATA_CLOSE, "\\x5D\\x5D\\x3E")
  };
  secureFilters.$css$ = function(val) {
    var str = String(val);
    return str.replace(CSS_NOT_ALLOWLISTED, function(match) {
      var code = match.charCodeAt(0);
      if(code === 0) {
        return"\\fffd "
      }else {
        var hex = code.toString(16).toLowerCase();
        return"\\" + hex + " "
      }
    })
  };
  secureFilters.style = function(val) {
    return secureFilters.$html$(secureFilters.$css$(val))
  };
  return secureFilters
}();
Aura.$Utils$.$Util$ = function Util() {
  this.$trashcan$ = document.createDocumentFragment();
  this.$trash$ = [];
  this.$json$ = Json;
  this["json"] = this.$json$;
  this.style = new Aura.$Utils$.$Style$;
  this["style"] = this.style;
  this["Bitset"] = Aura.$Utils$.$Bitset$;
  this["NumberFormat"] = Aura.$Utils$.$NumberFormat$;
  this.$objToString$ = Object.prototype.toString;
  this.$trashedComponentQueue$ = [];
  this.$dataAttributeCache$ = {};
  this.$debugToolWindow$ = undefined;
  this.$sizeEstimator$ = new Aura.$Utils$.$SizeEstimator$;
  this.$Mutex$ = new Aura.$Utils$.$Mutex$;
  this["Mutex"] = this.$Mutex$;
  this.$sourceComment$ = "//# sourceURL\x3d" + (window.location ? location.origin : "")
};
goog.$exportSymbol$("Aura.Utils.Util", Aura.$Utils$.$Util$);
Aura.$Utils$.$Util$.prototype.$isIE$ = navigator.userAgent.indexOf("MSIE") !== -1 || navigator.userAgent.indexOf("Trident/") !== -1;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isIE", Aura.$Utils$.$Util$.prototype.$isIE$);
Promise.prototype.$then$ = Promise.prototype["then"];
Aura.$Utils$.$Util$.prototype.$isLocalStorageEnabled$ = function() {
  if(this.$localStorageEnabled$ === undefined) {
    this.$localStorageEnabled$ = false;
    try {
      if(window.localStorage) {
        window.localStorage.setItem("__AURA_LOCAL_STORAGE_ENABLED_TEST", "");
        window.localStorage.removeItem("__AURA_LOCAL_STORAGE_ENABLED_TEST");
        this.$localStorageEnabled$ = true
      }
    }catch(ignore) {
    }
  }
  return this.$localStorageEnabled$
};
Aura.$Utils$.$Util$.prototype.$isSessionStorageEnabled$ = function() {
  if(this.$sessionStorageEnabled$ === undefined) {
    this.$sessionStorageEnabled$ = false;
    try {
      if(window.sessionStorage) {
        window.sessionStorage.setItem("__AURA_SESSION_STORAGE_ENABLED_TEST", "");
        window.sessionStorage.removeItem("__AURA_SESSION_STORAGE_ENABLED_TEST");
        this.$sessionStorageEnabled$ = true
      }
    }catch(ignore) {
    }
  }
  return this.$sessionStorageEnabled$
};
Aura.$Utils$.$Util$.prototype["setCookie"] = function(key, value, duration) {
  $A.assert(typeof key === "string", "key must be a string");
  $A.assert(typeof value === "string", "value must be a string");
  $A.assert(duration === undefined || typeof duration === "number", "duration must be a number");
  duration = duration || 1E3 * 60 * 60 * 24 * 7;
  var expiration = new Date((new Date).getTime() + duration);
  document.cookie = key + "\x3d" + value + "; expires\x3d" + expiration.toUTCString()
};
Aura.$Utils$.$Util$.prototype.$getCookie$ = function(key) {
  $A.assert(typeof key === "string", "key must be a string");
  var cookies = "; " + document.cookie + ";";
  key = "; " + key + "\x3d";
  var begin = cookies.indexOf(key);
  if(begin === -1) {
    return undefined
  }
  var end = cookies.indexOf(";", begin + key.length);
  var value = cookies.substring(begin + key.length, end);
  return value
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getCookie", Aura.$Utils$.$Util$.prototype.$getCookie$);
Aura.$Utils$.$Util$.prototype.$clearCookie$ = function(key, path, secure) {
  $A.assert(typeof key === "string", "key must be a string");
  var cookie = key + "\x3dtrue; expires\x3dThu, 01 Jan 1970 00:00:00 GMT";
  if(path) {
    cookie += "; path\x3d" + path
  }
  if(secure) {
    cookie += "; secure"
  }
  document.cookie = cookie
};
Aura.$Utils$.$Util$.prototype.$isIOSWebView$ = function() {
  if(this.$_isIOSWebView$ === undefined) {
    var ua = window.navigator.userAgent;
    this.$_isIOSWebView$ = /(iPad|iPhone|iPod);.*CPU.*OS 7_\d.*AppleWebKit/i.test(ua) && ua.indexOf("Safari") === -1
  }
  return this.$_isIOSWebView$
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isIOSWebView", Aura.$Utils$.$Util$.prototype.$isIOSWebView$);
var winTrustedTypes = typeof trustedTypes === "undefined" ? undefined : trustedTypes;
Aura.$Utils$.$Util$.prototype.$globalEval$ = function(src, descriptor, type) {
  var isTrusted = winTrustedTypes ? winTrustedTypes["isScript"](src) : false;
  src = "(function s(){return(" + src + ")})()";
  if(typeof descriptor === "string") {
    var name = descriptor.split("://").pop();
    src += this.$sourceComment$ + (type === "lib" ? "/libraries/" + name.replace(".", "/") : "/components/" + name.replace(":", "/")) + ".js"
  }
  return(0, eval)(isTrusted ? $A.$lockerService$.$trusted$["createScript"](src) : src)
};
Aura.$Utils$.$Util$.prototype.$getType$ = function(arg) {
  return arg === null ? "null" : typeof arg
};
Aura.$Utils$.$Util$.prototype.isArray = typeof Array.isArray === "function" ? Array.isArray : function(arg) {
  return Object.prototype.toString.call(arg) === "[object Array]"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isArray", Aura.$Utils$.$Util$.prototype.isArray);
Aura.$Utils$.$Util$.prototype.$isObject$ = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isObject", Aura.$Utils$.$Util$.prototype.$isObject$);
Aura.$Utils$.$Util$.prototype.$isPlainObject$ = function(o) {
  return Object.prototype.toString.call(o) === "[object Object]" && (o.constructor === Object || typeof o.constructor === "function" && o.constructor.name === "Object")
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isPlainObject", Aura.$Utils$.$Util$.prototype.$isPlainObject$);
Aura.$Utils$.$Util$.prototype.$isError$ = function(obj) {
  return!!obj && this.$objToString$.apply(obj) === "[object Error]"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isError", Aura.$Utils$.$Util$.prototype.$isError$);
Aura.$Utils$.$Util$.prototype.$isFunction$ = function(val) {
  return typeof val === "function"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isFunction", Aura.$Utils$.$Util$.prototype.$isFunction$);
Aura.$Utils$.$Util$.prototype.$isString$ = function(obj) {
  return typeof obj === "string"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isString", Aura.$Utils$.$Util$.prototype.$isString$);
Aura.$Utils$.$Util$.prototype.$isNumber$ = function(obj) {
  return typeof obj === "number"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isNumber", Aura.$Utils$.$Util$.prototype.$isNumber$);
Aura.$Utils$.$Util$.prototype.$isFiniteNumber$ = function(obj) {
  return this.$isNumber$(obj) && isFinite(obj)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isFiniteNumber", Aura.$Utils$.$Util$.prototype.$isFiniteNumber$);
Aura.$Utils$.$Util$.prototype.$isBoolean$ = function(obj) {
  return typeof obj === "boolean"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isBoolean", Aura.$Utils$.$Util$.prototype.$isBoolean$);
Aura.$Utils$.$Util$.prototype.$isUndefined$ = function(obj) {
  return obj === undefined
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isUndefined", Aura.$Utils$.$Util$.prototype.$isUndefined$);
Aura.$Utils$.$Util$.prototype.$isUndefinedOrNull$ = function(obj) {
  return obj === undefined || obj === null
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isUndefinedOrNull", Aura.$Utils$.$Util$.prototype.$isUndefinedOrNull$);
Aura.$Utils$.$Util$.prototype.$isEmpty$ = function(obj) {
  if(obj === undefined || obj === null || obj === "") {
    return true
  }
  if(Array.isArray(obj)) {
    return obj.length === 0
  }else {
    if(typeof obj === "object" && Object.prototype.toString.call(obj) === "[object Object]") {
      return Object.keys(obj).length === 0
    }
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isEmpty", Aura.$Utils$.$Util$.prototype.$isEmpty$);
Aura.$Utils$.$Util$.prototype.$getBooleanValue$ = function(val) {
  return val !== undefined && val !== null && val !== false && val !== 0 && val !== "false" && val !== "" && val !== "f"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getBooleanValue", Aura.$Utils$.$Util$.prototype.$getBooleanValue$);
Aura.$Utils$.$Util$.prototype.$createHtmlElement$ = function(tagName, attributes) {
  var node = document.createElement(tagName);
  for(var attributeName in attributes) {
    var value = attributes[attributeName];
    if(!this.$isUndefinedOrNull$(value)) {
      if(this.$isString$(value) && value.indexOf("/auraFW") === 0) {
        value = $A.getContext().$getContextPath$() + value
      }
      node.setAttribute(attributeName, value)
    }
  }
  return node
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "createHtmlElement", Aura.$Utils$.$Util$.prototype.$createHtmlElement$);
Aura.$Utils$.$Util$.prototype.$clearNode$ = function(node) {
  for(var last = node.lastChild;last;) {
    node.removeChild(last);
    last = node.lastChild
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "clearNode", Aura.$Utils$.$Util$.prototype.$clearNode$);
Aura.$Utils$.$Util$.prototype.$sanitizeDOM$ = function(dirty, config) {
  return DOMPurify["sanitize"](dirty, config)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeDOM", Aura.$Utils$.$Util$.prototype.$sanitizeDOM$);
Aura.$Utils$.$Util$.prototype.$hasJavascriptProtocol$ = function(url) {
  var el = document.createElement("a");
  el.href = url;
  return el.protocol === "javascript:"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "hasJavascriptProtocol", Aura.$Utils$.$Util$.prototype.$hasJavascriptProtocol$);
Aura.$Utils$.$Util$.prototype.$sanitizeHtml$ = Aura.$Utils$.$SecureFilters$.$html$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeHtml", Aura.$Utils$.$Util$.prototype.$sanitizeHtml$);
Aura.$Utils$.$Util$.prototype.$sanitizeJs$ = Aura.$Utils$.$SecureFilters$.$js$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeJs", Aura.$Utils$.$Util$.prototype.$sanitizeJs$);
Aura.$Utils$.$Util$.prototype.$sanitizeJsAttr$ = Aura.$Utils$.$SecureFilters$.$jsAttr$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeJsAttr", Aura.$Utils$.$Util$.prototype.$sanitizeJsAttr$);
Aura.$Utils$.$Util$.prototype.$sanitizeUri$ = Aura.$Utils$.$SecureFilters$.uri;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeUri", Aura.$Utils$.$Util$.prototype.$sanitizeUri$);
Aura.$Utils$.$Util$.prototype.$sanitizeJsObj$ = Aura.$Utils$.$SecureFilters$.$jsObj$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeJsObj", Aura.$Utils$.$Util$.prototype.$sanitizeJsObj$);
Aura.$Utils$.$Util$.prototype.$sanitizeCSS$ = Aura.$Utils$.$SecureFilters$.$css$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeCSS", Aura.$Utils$.$Util$.prototype.$sanitizeCSS$);
Aura.$Utils$.$Util$.prototype.$sanitizeStyle$ = Aura.$Utils$.$SecureFilters$.style;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeStyle", Aura.$Utils$.$Util$.prototype.$sanitizeStyle$);
Aura.$Utils$.$Util$.prototype.$getElement$ = function(id) {
  return document.getElementById(id)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getElement", Aura.$Utils$.$Util$.prototype.$getElement$);
Aura.$Utils$.$Util$.prototype.$equals$ = function(expected, actual) {
  if(expected === actual) {
    return true
  }
  if(!expected || !actual) {
    return false
  }
  if(this.$isObject$(expected)) {
    if(!this.$isObject$(actual)) {
      return false
    }
    for(var x in expected) {
      if(expected.hasOwnProperty(x)) {
        if(!actual.hasOwnProperty(x)) {
          return false
        }
        if(!this.$equals$(expected[x], actual[x])) {
          return false
        }
      }
    }
    return true
  }
  if(this.isArray(expected)) {
    if(!this.isArray(actual) || expected.length !== actual.length) {
      return false
    }
    for(var i = 0;i < expected.length;i++) {
      if(!this.$equals$(expected[i], actual[i])) {
        return false
      }
    }
    return true
  }
  return false
};
Aura.$Utils$.$Util$.prototype.$hasClass$ = function(element, className) {
  var oldClass = "";
  if(this.$isComponent$(element)) {
    if(element.$isInstanceOf$("ui:elementInterface") || element.$isInstanceOf$("ui:visible")) {
      oldClass = element.get("v.class")
    }else {
      if(element.$isInstanceOf$("aura:html")) {
        oldClass = element.get("v.HTMLAttributes.class")
      }else {
        element = element.$getElement$()
      }
    }
  }
  if(element && element.tagName) {
    oldClass = element["className"]
  }
  return(" " + oldClass + " ").indexOf(" " + className + " ") > -1
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "hasClass", Aura.$Utils$.$Util$.prototype.$hasClass$);
Aura.$Utils$.$Util$.prototype.$addClass$ = function(element, newClass) {
  this.$setClass$(element, newClass, false)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "addClass", Aura.$Utils$.$Util$.prototype.$addClass$);
Aura.$Utils$.$Util$.prototype.$removeClass$ = function(element, newClass) {
  this.$setClass$(element, newClass, true)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "removeClass", Aura.$Utils$.$Util$.prototype.$removeClass$);
Aura.$Utils$.$Util$.prototype.$toggleClass$ = function(element, className, condition) {
  if(condition === undefined) {
    condition = !this.$hasClass$(element, className)
  }
  if(condition) {
    this.$addClass$(element, className);
    return true
  }else {
    this.$removeClass$(element, className);
    return false
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "toggleClass", Aura.$Utils$.$Util$.prototype.$toggleClass$);
Aura.$Utils$.$Util$.prototype.$swapClass$ = function(element, oldClass, newClass) {
  oldClass = this.isArray(oldClass) ? oldClass : [oldClass];
  newClass = this.isArray(newClass) ? newClass : [newClass];
  for(var i = 0;i < oldClass.length;i++) {
    this.$removeClass$(element, oldClass[i])
  }
  for(i = 0;i < newClass.length;i++) {
    this.$addClass$(element, newClass[i])
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "swapClass", Aura.$Utils$.$Util$.prototype.$swapClass$);
Aura.$Utils$.$Util$.prototype.$setClass$ = function(element, newClass, remove) {
  var constructedClass = "";
  if(this.$isComponent$(element)) {
    var attribute = null;
    if(element.$isInstanceOf$("ui:elementInterface") || element.$isInstanceOf$("ui:visible")) {
      attribute = "v.class"
    }else {
      if(element.$isInstanceOf$("aura:html")) {
        attribute = "v.HTMLAttributes.class"
      }else {
        element = element.$getElement$()
      }
    }
    if(attribute) {
      var useShadowClass = false;
      var oldClass = element.$getShadowAttribute$(attribute);
      if(oldClass != undefined) {
        useShadowClass = true
      }else {
        oldClass = element.get(attribute) || ""
      }
      constructedClass = this.$buildClass$(oldClass, newClass, remove);
      if(oldClass !== constructedClass) {
        if(useShadowClass) {
          element.$setShadowAttribute$(attribute, constructedClass ? " " + constructedClass : "")
        }else {
          element.set(attribute, constructedClass)
        }
      }
    }
  }
  if(element && element.tagName) {
    if(element.tagName === "svg") {
      constructedClass = this.$buildClass$(element.getAttribute("class") || "", newClass, remove);
      if(element.getAttribute("class") !== constructedClass) {
        element.setAttribute("class", constructedClass)
      }
    }else {
      constructedClass = this.$buildClass$(element["className"] || "", newClass, remove);
      if(element["className"] !== constructedClass) {
        element["className"] = constructedClass
      }
    }
  }
};
Aura.$Utils$.$Util$.prototype.$buildClass$ = function(oldClass, newClass, remove) {
  if(this.$isUndefinedOrNull$(oldClass)) {
    oldClass = ""
  }
  if(this.$isUndefinedOrNull$(newClass)) {
    return oldClass
  }
  newClass = this.trim(newClass);
  oldClass = this.trim(oldClass);
  var found = (" " + oldClass + " ").indexOf(" " + newClass + " ") > -1;
  if(remove) {
    if(!found) {
      return oldClass
    }
    return this.trim((" " + oldClass + " ").split(" " + newClass + " ").join(" "))
  }else {
    if(oldClass) {
      if(!found) {
        return oldClass + " " + newClass
      }else {
        return oldClass
      }
    }else {
      return newClass
    }
  }
};
Aura.$Utils$.$Util$.prototype.$buildFlavorClass$ = function(cmp, flavor) {
  if($A["util"].$isFunction$(cmp.$getDef$)) {
    cmp = cmp.$getDef$()
  }
  $A.assert(!this.$isUndefinedOrNull$(cmp.$getStyleDef$()), "Missing StyleDef for component " + cmp.$getDescriptor$() + " (required for flavors)");
  if(this.$isEmpty$(flavor)) {
    return""
  }
  var base = cmp.$getStyleDef$().$getClassName$();
  var split = flavor.split(",");
  var clz = "";
  var i = 0;
  for(var len = split.length;i < len;i++) {
    if(i !== 0) {
      clz += " "
    }
    clz += base + "--" + this.trim(split[i])
  }
  return clz
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "buildFlavorClass", Aura.$Utils$.$Util$.prototype.$buildFlavorClass$);
Aura.$Utils$.$Util$.prototype.$createElementsFromMarkup$ = function(markup) {
  if(!this.$isUndefinedOrNull$(markup)) {
    var tmpNode = document.createElement("span");
    tmpNode.innerHTML = markup;
    return this.$toArray$(tmpNode.childNodes)
  }
  return[]
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "createElementsFromMarkup", Aura.$Utils$.$Util$.prototype.$createElementsFromMarkup$);
Aura.$Utils$.$Util$.prototype.$insertFirst$ = function(newEl, referenceEl) {
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      this.$insertFirst$(newEl[0], referenceEl);
      return
    }
    var frag = document.createDocumentFragment();
    this.appendChild(newEl, frag);
    this.$insertFirst$(frag, referenceEl);
    return
  }
  var firstChild = referenceEl.firstChild;
  if(firstChild) {
    referenceEl.insertBefore(newEl, firstChild)
  }else {
    referenceEl.appendChild(newEl)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "insertFirst", Aura.$Utils$.$Util$.prototype.$insertFirst$);
Aura.$Utils$.$Util$.prototype.insertBefore = function(newEl, referenceEl) {
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      this.insertBefore(newEl[0], referenceEl);
      return
    }
    var frag = document.createDocumentFragment();
    this.appendChild(newEl, frag);
    this.insertBefore(frag, referenceEl);
    return
  }
  var parent = referenceEl.parentNode;
  if(parent) {
    parent.insertBefore(newEl, referenceEl)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "insertBefore", Aura.$Utils$.$Util$.prototype.insertBefore);
Aura.$Utils$.$Util$.prototype.$insertAfter$ = function(newEl, referenceEl) {
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      this.$insertAfter$(newEl[0], referenceEl);
      return
    }
    var frag = document.createDocumentFragment();
    this.appendChild(newEl, frag);
    this.$insertAfter$(frag, referenceEl);
    return
  }
  var parent = referenceEl.parentNode;
  if(parent) {
    if(parent.lastChild === referenceEl) {
      parent.appendChild(newEl)
    }else {
      parent.insertBefore(newEl, referenceEl.nextSibling)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "insertAfter", Aura.$Utils$.$Util$.prototype.$insertAfter$);
Aura.$Utils$.$Util$.prototype.appendChild = function(newEl, referenceEl) {
  if(referenceEl.canHaveChildren === false) {
    return
  }
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      referenceEl.appendChild(newEl[0]);
      return
    }
    var frag = document.createDocumentFragment();
    var len = newEl.length;
    for(var i = 0;i < len;i++) {
      if(newEl[i]) {
        frag.appendChild(newEl[i])
      }
    }
    newEl = frag
  }
  referenceEl.appendChild(newEl)
};
Aura.$Utils$.$Util$.prototype.$removeElement$ = function(element) {
  if(!element) {
    return
  }
  if(element.$__customElement$ && element.parentElement) {
    element.parentElement.removeChild(element);
    return
  }
  if(!(element.parentNode === this.$trashcan$)) {
    if(element.parentNode) {
      if(element.nodeType !== 3 && element.nodeType !== 8) {
        $A.assert(this.$isUndefined$(element["aura_deleted"]), "Element was reused after delete");
        element["aura_deleted"] = true
      }
      this.$trashcan$.appendChild(element)
    }else {
      this.$trash$.push(element)
    }
    if(!this.$gcPending$) {
      this.$gcPending$ = true;
      var that = this;
      setTimeout(function deleteNodes() {
        for(var trashcan = that.$trashcan$;trashcan.hasChildNodes();) {
          var node = trashcan.lastChild;
          if(node.nodeType !== 3 && node.nodeType !== 8) {
            try {
              delete node["aura_deleted"]
            }catch(e) {
              node.removeAttribute("aura_deleted")
            }
          }
          trashcan.removeChild(node)
        }
        var i = 0;
        for(var len = that.$trash$.length;i < len;i++) {
          that.$trash$[i] = null
        }
        that.$trash$ = [];
        that.$gcPending$ = false
      }, 1E3)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "removeElement", Aura.$Utils$.$Util$.prototype.$removeElement$);
Aura.$Utils$.$Util$.prototype.$generateUrl$ = function(url, params, encoded) {
  if(this.$isString$(url) && this.$isObject$(params)) {
    var hashPairs;
    var map = {};
    var pieces = url.split("?");
    var query = pieces[1] || "";
    if(query.length > 1) {
      hashPairs = query.split("#");
      if(hashPairs.length > 1) {
        query = hashPairs[0]
      }
    }else {
      hashPairs = pieces[0].split("#");
      if(hashPairs.length > 1) {
        pieces[0] = hashPairs[0]
      }
    }
    var pairs = query.split("\x26");
    for(var i = 0;i < pairs.length;i++) {
      if(pairs[i] > "") {
        var pair = pairs[i].split("\x3d");
        map[pair[0]] = pair[1]
      }
    }
    for(var k1 in params) {
      if(params.hasOwnProperty(k1)) {
        var v1 = params[k1];
        if(v1 > "") {
          map[k1] = encoded ? params[k1] : encodeURIComponent(params[k1])
        }else {
          delete map[k1]
        }
      }
    }
    pairs = [];
    for(var k2 in map) {
      if(map.hasOwnProperty(k2)) {
        var v2 = map[k2];
        pairs.push(k2 + "\x3d" + v2)
      }
    }
    query = pairs.join("\x26");
    pieces[1] = query;
    if(hashPairs.length > 1) {
      hashPairs.shift();
      return pieces.join("?") + "#" + hashPairs.join("#")
    }else {
      return pieces.join("?")
    }
  }
  return url
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "generateUrl", Aura.$Utils$.$Util$.prototype.$generateUrl$);
Aura.$Utils$.$Util$.prototype.trim = function(value) {
  return(value || "").replace(/^\s+|\s+$/g, "")
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "trim", Aura.$Utils$.$Util$.prototype.trim);
Aura.$Utils$.$Util$.prototype.$format$ = function(formatString, arg1, arg2, argN) {
  $A.assert($A["util"].$isString$(formatString), "$A.util.format(): 'formatString' must be a String.");
  var formatArguments = Array.prototype.slice.call(arguments, 1);
  return formatString.replace(/\{(\d+)\}/gm, function(match, index) {
    var substitution = formatArguments[index];
    if(substitution === undefined) {
      return match
    }
    return substitution + ""
  })
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "format", Aura.$Utils$.$Util$.prototype.$format$);
Aura.$Utils$.$Util$.prototype.truncate = function(st, len, ellipsis, truncateByWord) {
  ellipsis = !!ellipsis;
  truncateByWord = !!truncateByWord;
  if(!st || !len) {
    return""
  }
  st = st.toString();
  if(len > 0 && st.length > len) {
    if(ellipsis) {
      len = len - 3 < 1 ? 1 : len - 3
    }
    if(truncateByWord === false) {
      return this.trim(st.substring(0, len)) + (ellipsis ? "..." : "")
    }else {
      st = st.substring(0, len + 1);
      var st2 = st.replace(/\w+$/, "");
      if(st2.length === 0 || st2.length > len) {
        st2 = st.substring(0, len)
      }
      return this.trim(st2) + (ellipsis ? "..." : "")
    }
  }else {
    return st
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "truncate", Aura.$Utils$.$Util$.prototype.truncate);
Aura.$Utils$.$Util$.prototype.$createTimeoutCallback$ = function(callback, toleranceMillis) {
  function timeoutCallback() {
    var currentDuration = new Date - rtime;
    $A.assert(currentDuration >= 0);
    if(currentDuration < toleranceMillis) {
      setTimeout(timeoutCallback, toleranceMillis - currentDuration)
    }else {
      timeout = false;
      rtime = null;
      callback()
    }
  }
  $A.assert(!$A["util"].$isUndefinedOrNull$(callback) && $A["util"].$isFunction$(callback), "Invalid callback");
  $A.assert(toleranceMillis > 0, "Must use a positive tolerance period.");
  var rtime = null;
  var timeout = false;
  return function() {
    rtime = new Date;
    if(timeout === false) {
      timeout = true;
      setTimeout(timeoutCallback, toleranceMillis)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "createTimeoutCallback", Aura.$Utils$.$Util$.prototype.$createTimeoutCallback$);
Aura.$Utils$.$Util$.prototype.$on$ = function() {
  if(window["addEventListener"]) {
    return function(element, eventName, handler, useCapture, timeout) {
      var originalHandler = handler;
      if(timeout) {
        handler = this.$createTimeoutCallback$(handler, timeout)
      }
      if(element) {
        originalHandler.$registeredAuraHandler$ = handler;
        element["addEventListener"](eventName, handler, useCapture)
      }
    }
  }else {
    var preventDefault = function() {
      this.returnValue = false
    };
    var stopPropagation = function() {
      this.cancelBubble = true
    };
    return function attachEventWrapper(element, eventName, handler, useCapture, timeout) {
      if(!element) {
        return
      }
      var originalHandler = handler;
      var handlerCache = element["handlerCache"];
      if(!handlerCache) {
        element["handlerCache"] = handlerCache = {}
      }
      var handlers = handlerCache[eventName];
      if(handlers) {
        for(var n = 0;n < handlers.length;n++) {
          if(handlers[n] === handler) {
            return
          }
        }
        handlers.push(handler)
      }else {
        handlerCache[eventName] = [handler]
      }
      if(timeout) {
        handler = $A["util"].$createTimeoutCallback$(handler, timeout)
      }
      var newHandler = function(event) {
        event.currentTarget = element;
        event.target = event.srcElement;
        event.which = event.keyCode;
        event.preventDefault = preventDefault;
        event.stopPropagation = stopPropagation;
        handler.call(element, event || window.event);
        event.currentTarget = event.target = event.which = event.preventDefault = event.stopPropagation = null
      };
      originalHandler.$registeredAuraHandler$ = newHandler;
      element["attachEvent"]("on" + eventName, newHandler, false)
    }
  }
}();
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "on", Aura.$Utils$.$Util$.prototype.$on$);
Aura.$Utils$.$Util$.prototype.$removeOn$ = function(element, eventName, listener, useCapture) {
  $A.assert(element, "try to remove an event listener from a no-longer-exist DOM element");
  if(this.$isUndefined$(listener)) {
    return
  }
  if(listener.$registeredAuraHandler$) {
    listener = listener.$registeredAuraHandler$
  }
  if(window["removeEventListener"]) {
    element.removeEventListener(eventName, listener, useCapture)
  }else {
    if(window["detachEvent"]) {
      element.detachEvent("on" + eventName, listener)
    }else {
      $A.assert(false, "user agent must support either removeEventListener or detachEvent to remove an event handler.")
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "removeOn", Aura.$Utils$.$Util$.prototype.$removeOn$);
Aura.$Utils$.$Util$.prototype.$formToMap$ = function(form) {
  var map = {};
  for(var i = 0;i < form.length;i++) {
    var element = form[i];
    var name = element.name;
    var value = null;
    if(name) {
      if(element.tagName === "INPUT") {
        var type = element.type;
        if(type === "button" || type === "submit") {
        }else {
          if(type === "checkbox") {
            if(element.checked) {
              value = element.value
            }
          }else {
            if(type === "radio") {
              if(element.checked && element.value && element.value !== "") {
                value = element.value
              }
            }else {
              value = element.value
            }
          }
        }
      }else {
        if(element.tagName === "SELECT") {
          value = this.$getSelectValue$(element)
        }else {
          if(element.tagName === "TEXTAREA") {
            value = element.value
          }
        }
      }
      if(value !== null && value !== undefined) {
        this.$addValueToMap$(map, name, value)
      }
    }
  }
  return map
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "formToMap", Aura.$Utils$.$Util$.prototype.$formToMap$);
Aura.$Utils$.$Util$.prototype.$getSelectValue$ = function(select) {
  if(select.options.length === 0) {
    return null
  }
  if(!select.multiple) {
    return select.options[select.selectedIndex].value
  }else {
    var list = [];
    var options = select.options;
    for(var i = 0;i < options.length;i++) {
      var option = options[i];
      if(option.selected) {
        list[list.length] = option.value
      }
    }
    return list
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getSelectValue", Aura.$Utils$.$Util$.prototype.$getSelectValue$);
Aura.$Utils$.$Util$.prototype.$addValueToMap$ = function(inputMap, key, value) {
  if(key.indexOf(".") > 0) {
    var inputName = key.substring(0, key.indexOf("."));
    var subMapKey = key.substring(key.indexOf(".") + 1, key.length);
    this.$addMapValueToMap$(inputMap, inputName, value, subMapKey);
    return
  }else {
    var ix = key.indexOf("00N");
    if(ix === 0 || ix === 2) {
      this.$addMapValueToMap$(inputMap, "properties", value, key);
      return
    }
  }
  var oldVal = inputMap[key];
  if(!oldVal) {
    inputMap[key] = value
  }else {
    if(!this.isArray(oldVal)) {
      var valArray = [];
      valArray[0] = oldVal;
      valArray[1] = value;
      inputMap[key] = valArray
    }else {
      oldVal.push(value)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "addValueToMap", Aura.$Utils$.$Util$.prototype.$addValueToMap$);
Aura.$Utils$.$Util$.prototype.$addMapValueToMap$ = function(inputMap, key, value, subMapKey) {
  var subMap = inputMap[key];
  if(!subMap) {
    subMap = {};
    inputMap[key] = subMap
  }
  subMap[subMapKey] = value
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "addMapValueToMap", Aura.$Utils$.$Util$.prototype.$addMapValueToMap$);
Aura.$Utils$.$Util$.prototype.$isSubDef$ = function(def, qname) {
  for(;def;) {
    if(def.$getDescriptor$().$getQualifiedName$() === qname) {
      return true
    }
    def = def.$getSuperDef$()
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isSubDef", Aura.$Utils$.$Util$.prototype.$isSubDef$);
Aura.$Utils$.$Util$.prototype.apply = function(to, from, forceCopy, deepCopy, ownOnly) {
  if(deepCopy) {
    return Array.isArray(from) ? this.$applyArray$(to, from, forceCopy, ownOnly) : this.$applyObject$(to, from, forceCopy, ownOnly)
  }
  var key;
  if(Array.isArray(from)) {
    for(key = forceCopy ? 0 : to.length;key < from.length;key++) {
      to[key] = from[key]
    }
  }else {
    if(forceCopy) {
      if(ownOnly) {
        Object.assign(to, from)
      }else {
        for(key in from) {
          to[key] = from[key]
        }
      }
    }else {
      if(ownOnly) {
        for(key in from) {
          if(from.hasOwnProperty(key) && !to.hasOwnProperty(key)) {
            to[key] = from[key]
          }
        }
      }else {
        for(key in from) {
          if(!to.hasOwnProperty(key)) {
            to[key] = from[key]
          }
        }
      }
    }
  }
  return to
};
Aura.$Utils$.$Util$.prototype.$applyObject$ = function(to, from, forceCopy, ownOnly) {
  var key;
  var child;
  for(key in from) {
    if(ownOnly && !from.hasOwnProperty(key)) {
      continue
    }
    child = from[key];
    if(typeof child === "object" && child !== null) {
      if(Array.isArray(child)) {
        to[key] = to[key] ? this.$applyArray$(to[key], child, forceCopy, ownOnly) : this.$copyArray$(child, ownOnly);
        continue
      }else {
        if(this.$isPlainObject$(child)) {
          to[key] = to[key] ? this.$applyObject$(to[key], child, forceCopy, ownOnly) : this.$copyObject$(child, ownOnly);
          continue
        }
      }
    }
    if(forceCopy || !to.hasOwnProperty(key)) {
      to[key] = child
    }
  }
  return to
};
Aura.$Utils$.$Util$.prototype.$applyArray$ = function(to, from, forceCopy, ownOnly) {
  var index;
  var child;
  for(index = 0;index < from.length;index++) {
    child = from[index];
    if(typeof child === "object" && child !== null) {
      if(Array.isArray(child)) {
        to[index] = to[index] ? this.$applyArray$(to[index], child, forceCopy, ownOnly) : this.$copyArray$(child, ownOnly);
        continue
      }else {
        if(this.$isPlainObject$(child)) {
          to[index] = to[index] ? this.$applyObject$(to[index], child, forceCopy, ownOnly) : this.$copyObject$(child, ownOnly);
          continue
        }
      }
    }
    if(forceCopy || to.length <= index) {
      to[index] = child
    }
  }
  return to
};
Aura.$Utils$.$Util$.prototype.copy = function(value) {
  if(Array.isArray(value)) {
    return value.slice()
  }else {
    if(typeof value === "object" && value !== null) {
      return this.apply({}, value, true)
    }
  }
  return value
};
Aura.$Utils$.$Util$.prototype.$copyObject$ = function(object, ownOnly) {
  var copy = {};
  var key;
  var child;
  for(key in object) {
    if(ownOnly && !object.hasOwnProperty(key)) {
      continue
    }
    child = object[key];
    if(typeof child === "object" && child !== null) {
      if(Array.isArray(child)) {
        copy[key] = this.$copyArray$(child, ownOnly);
        continue
      }else {
        if(this.$isPlainObject$(child)) {
          copy[key] = this.$copyObject$(child, ownOnly);
          continue
        }
      }
    }
    copy[key] = child
  }
  return copy
};
Aura.$Utils$.$Util$.prototype.$copyArray$ = function(array, ownOnly) {
  var copy = new Array(array.length);
  var index;
  var child;
  for(index = 0;index < array.length;index++) {
    child = array[index];
    if(typeof child === "object" && child !== null) {
      if(Array.isArray(child)) {
        copy[index] = this.$copyArray$(child, ownOnly);
        continue
      }else {
        if(this.$isPlainObject$(child)) {
          copy[index] = this.$copyObject$(child, ownOnly);
          continue
        }
      }
    }
    copy[index] = child
  }
  return copy
};
Aura.$Utils$.$Util$.prototype.$CAMEL_CASE_TO_HYPHENS_REGEX$ = /([A-Z])/g;
Aura.$Utils$.$Util$.prototype.$camelCaseToHyphens$ = function(str) {
  return str.replace(this.$CAMEL_CASE_TO_HYPHENS_REGEX$, "-$1").toLowerCase()
};
Aura.$Utils$.$Util$.prototype.$hyphensToCamelCase$ = function(str) {
  function hyphensToCamelCaseHelper(s, group) {
    return group.toUpperCase()
  }
  return str.replace(/-([a-z])/gi, hyphensToCamelCaseHelper)
};
Aura.$Utils$.$Util$.prototype.$toCamelCase$ = function(str) {
  return str.replace(/(?:^\w|[A-Z]|\b\w|\s+|[^\w]+)/g, function(match, index) {
    if(/\s+|[^\w]+/.test(match)) {
      return""
    }
    return index === 0 ? match.toLowerCase() : match.toUpperCase()
  })
};
Aura.$Utils$.$Util$.prototype.$noData$ = {"embed":true, "object":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", "applet":true, "#text":true};
Aura.$Utils$.$Util$.prototype.$acceptsData$ = function(element) {
  if(!this.$isHTMLElement$(element)) {
    return false
  }
  if(element.nodeName) {
    var match = this.$noData$[element.nodeName.toLowerCase()];
    if(match) {
      return!(match === true || element.getAttribute("classid") !== match)
    }
  }
  return true
};
Aura.$Utils$.$Util$.prototype.$getElementAttributeValue$ = function(element, attributeName) {
  var attrValue = element.getAttribute(attributeName);
  if($A["util"].$isUndefinedOrNull$(attrValue)) {
    attrValue = element.attributes[attributeName];
    if(!$A["util"].$isUndefinedOrNull$(attrValue)) {
      attrValue = attrValue.nodeValue
    }else {
      if(!$A["util"].$isUndefinedOrNull$(element[attributeName])) {
        attrValue = element[attributeName]
      }else {
        attrValue = null
      }
    }
  }
  return attrValue
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getElementAttributeValue", Aura.$Utils$.$Util$.prototype.$getElementAttributeValue$);
Aura.$Utils$.$Util$.prototype.$setFocus$ = function(target) {
  if(this.$isComponent$(target)) {
    if(!target.focus) {
      target = target.$getElement$()
    }
  }
  if(target && target.focus) {
    try {
      target.focus()
    }catch(e) {
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "setFocus", Aura.$Utils$.$Util$.prototype.$setFocus$);
Aura.$Utils$.$Util$.prototype.$getDataAttribute$ = function(element, key) {
  if(!this.$acceptsData$(element) || this.$isUndefined$(key)) {
    return null
  }
  key = this.$getDataAttributeName$(key);
  return element.getAttribute(key)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getDataAttribute", Aura.$Utils$.$Util$.prototype.$getDataAttribute$);
Aura.$Utils$.$Util$.prototype.$setDataAttribute$ = function(element, key, value) {
  if(!this.$acceptsData$(element) || this.$isUndefined$(key)) {
    return null
  }
  key = this.$getDataAttributeName$(key);
  if(!this.$isUndefined$(value)) {
    return element.setAttribute(key, value)
  }
  return element.removeAttribute(key)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "setDataAttribute", Aura.$Utils$.$Util$.prototype.$setDataAttribute$);
Aura.$Utils$.$Util$.prototype.$getDataAttributeName$ = function(key) {
  var name = this.$dataAttributeCache$[key];
  if(!name) {
    name = "data-" + this.$camelCaseToHyphens$(key);
    this.$dataAttributeCache$[key] = name
  }
  return name
};
Aura.$Utils$.$Util$.prototype.$hasDataAttribute$ = function(element, key) {
  return!this.$isUndefinedOrNull$(this.$getDataAttribute$(element, key))
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "hasDataAttribute", Aura.$Utils$.$Util$.prototype.$hasDataAttribute$);
Aura.$Utils$.$Util$.prototype.$isHTMLElement$ = function(obj) {
  if(typeof HTMLElement === "object") {
    return obj instanceof HTMLElement
  }else {
    return obj && obj.nodeType === 1 && typeof obj.nodeName === "string"
  }
};
Aura.$Utils$.$Util$.prototype.$isSVGElement$ = function(obj) {
  return!!(obj instanceof SVGElement || obj && obj.$correspondingUseElement$ instanceof SVGElement)
};
Aura.$Utils$.$Util$.prototype.$attachToDocumentBody$ = function(element) {
  if(element) {
    var body = document.getElementsByTagName("body")[0];
    body.appendChild(element)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "attachToDocumentBody", Aura.$Utils$.$Util$.prototype.$attachToDocumentBody$);
Aura.$Utils$.$Util$.prototype.$stringEndsWith$ = function(fullstr, substr) {
  var lastIndex = fullstr.lastIndexOf(substr);
  return lastIndex !== -1 && lastIndex + substr.length === fullstr.length
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "stringEndsWith", Aura.$Utils$.$Util$.prototype.$stringEndsWith$);
if(Function.prototype.bind) {
  Aura.$Utils$.$Util$.bind = function(method) {
    var args = Array.prototype.slice.call(arguments, 1);
    return Function.prototype.bind.apply(method, args)
  }
}else {
  Aura.$Utils$.$Util$.bind = function(method) {
    var args = Array.prototype.slice.call(arguments, 1);
    var that = args.shift();
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.bind called on non-function.");
    }
    if(arguments.length === 1) {
      return method
    }
    return function() {
      var remainingArgs = Array.prototype.slice.call(arguments);
      var combined = util.$merge$([], args, remainingArgs);
      return method.apply(that, combined)
    }
  }
}
Aura.$Utils$.$Util$.prototype.bind = Aura.$Utils$.$Util$.bind;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "bind", Aura.$Utils$.$Util$.prototype.bind);
Aura.$Utils$.$Util$.prototype.$lookup$ = function(value) {
  var args = arguments;
  var len = args.length;
  for(var i = 0;value !== undefined && value !== null && ++i < len;) {
    value = value[args[i]]
  }
  return value
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "lookup", Aura.$Utils$.$Util$.prototype.$lookup$);
Aura.$Utils$.$Util$.prototype.$merge$ = function(first) {
  var arrays = Array.prototype.slice.call(arguments, 1);
  var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
  if(!arrays) {
    return first
  }
  if(!util.isArray(first)) {
    throw"Merge takes only arrays as arguments.";
  }
  util.forEach(arrays, function(array) {
    if(!util.isArray(array)) {
      throw"Merge takes only arrays as arguments.";
    }
  });
  util.forEach(arrays, function(array) {
    util.forEach(array, function(element) {
      first.push(element)
    })
  });
  return first
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "merge", Aura.$Utils$.$Util$.prototype.$merge$);
if(Array.prototype.forEach) {
  Aura.$Utils$.$Util$.forEach = function(array, method, that) {
    array.forEach(method, that)
  }
}else {
  Aura.$Utils$.$Util$.forEach = function(array, method, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.forEach called on non-array.");
    }
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.forEach called with non-function callback.");
    }
    var index;
    for(index = 0;index < array.length;index++) {
      method.call(that, array[index], index)
    }
  }
}
Aura.$Utils$.$Util$.prototype.forEach = Aura.$Utils$.$Util$.forEach;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "forEach", Aura.$Utils$.$Util$.prototype.forEach);
if(Array.prototype.map) {
  Aura.$Utils$.$Util$.map = function(array, method, that) {
    return array.map(method, that)
  }
}else {
  Aura.$Utils$.$Util$.map = function(array, method, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.map called on non-array.");
    }
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.map called with non-function callback.");
    }
    var index;
    var result = [];
    for(index = 0;index < array.length;index++) {
      result.push(method.call(that, array[index], index))
    }
    return result
  }
}
Aura.$Utils$.$Util$.prototype.map = Aura.$Utils$.$Util$.map;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "map", Aura.$Utils$.$Util$.prototype.map);
if(Array.prototype.reduce) {
  Aura.$Utils$.$Util$.reduce = function(array, method, initial) {
    return array.reduce(method, initial)
  }
}else {
  Aura.$Utils$.$Util$.reduce = function(array, method, initial) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.reduce called on non-array.");
    }
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.reduce called with non-function callback.");
    }
    var index;
    var result = initial;
    for(index = 0;index < array.length;index++) {
      result = method.call(this, result, array[index], index)
    }
    return result
  }
}
Aura.$Utils$.$Util$.prototype.reduce = Aura.$Utils$.$Util$.reduce;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "reduce", Aura.$Utils$.$Util$.prototype.reduce);
if(Array.prototype.every) {
  Aura.$Utils$.$Util$.every = function(array, predicate, that) {
    return array.every(predicate, that)
  }
}else {
  Aura.$Utils$.$Util$.every = function(array, predicate, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.every called on non-array.");
    }
    if(!util.$isFunction$(predicate)) {
      throw new TypeError("$A.util.every called with non-function predicate.");
    }
    var index;
    for(index = 0;index < array.length;index++) {
      if(!predicate.call(that, array[index], index)) {
        return false
      }
    }
    return true
  }
}
Aura.$Utils$.$Util$.prototype.every = Aura.$Utils$.$Util$.every;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "every", Aura.$Utils$.$Util$.prototype.every);
if(Array.prototype.some) {
  Aura.$Utils$.$Util$.some = function(array, predicate, that) {
    return array.some(predicate, that)
  }
}else {
  Aura.$Utils$.$Util$.some = function(array, predicate, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.some called on non-array.");
    }
    if(!util.$isFunction$(predicate)) {
      throw new TypeError("$A.util.some called with non-function predicate.");
    }
    var index;
    for(index = 0;index < array.length;index++) {
      if(predicate.call(that, array[index], index)) {
        return true
      }
    }
    return false
  }
}
Aura.$Utils$.$Util$.prototype.some = Aura.$Utils$.$Util$.some;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "some", Aura.$Utils$.$Util$.prototype.some);
if(Array.prototype.filter) {
  Aura.$Utils$.$Util$.filter = function(array, predicate, that) {
    return array.filter(predicate, that)
  }
}else {
  Aura.$Utils$.$Util$.filter = function(array, predicate, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.filter called on non-array.");
    }
    if(!util.$isFunction$(predicate)) {
      throw new TypeError("$A.util.filter called with non-function predicate.");
    }
    var index;
    var result = [];
    for(index = 0;index < array.length;index++) {
      if(predicate.call(that, array[index], index)) {
        result.push(array[index])
      }
    }
    return result
  }
}
Aura.$Utils$.$Util$.prototype.filter = Aura.$Utils$.$Util$.filter;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "filter", Aura.$Utils$.$Util$.prototype.filter);
Aura.$Utils$.$Util$.prototype.$destroyAsync$ = function(cmp) {
  if(this.$componentGCProcessing$) {
    if(cmp && cmp.$finishDestroy$) {
      cmp.$finishDestroy$()
    }
  }else {
    this.$trashedComponentQueue$.push(cmp);
    if(!this.$componentGCPending$) {
      this.$componentGCPending$ = true;
      var that = this;
      setTimeout(function deferedEmptyComponentTrash() {
        try {
          that.$componentGCProcessing$ = true;
          that.$emptyComponentTrash$()
        }finally {
          that.$componentGCProcessing$ = false
        }
      }, 3E3)
    }
  }
};
Aura.$Utils$.$Util$.prototype.$instanceOf$ = function(instance, constructor) {
  if(instance === null || instance === undefined || constructor === null || constructor === undefined) {
    return false
  }
  if(instance instanceof constructor) {
    return true
  }
  if(instance.$superclass$) {
    for(var superCtor = instance.$superclass$.constructor;superCtor;) {
      if(superCtor === constructor) {
        return true
      }
      superCtor = superCtor.$superclass$ ? superCtor.constructor : undefined
    }
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "instanceOf", Aura.$Utils$.$Util$.prototype.$instanceOf$);
Aura.$Utils$.$Util$.prototype.$emptyComponentTrash$ = function() {
  var length = this.$trashedComponentQueue$.length;
  if(length > 0) {
    for(var i = 0;i < length;i++) {
      var cmp = this.$trashedComponentQueue$[i];
      if(cmp && cmp.$finishDestroy$) {
        cmp.$finishDestroy$()
      }
    }
    this.$trashedComponentQueue$ = []
  }
  this.$componentGCPending$ = false
};
Aura.$Utils$.$Util$.prototype.contains = function(container, element) {
  $A.assert($A["util"].$isHTMLElement$(container) || $A["util"].$isSVGElement$(container), "$A.util.conatins(): 'container' must be HTMLElement or SVGElement: " + container);
  for($A.assert($A["util"].$isHTMLElement$(element) || $A["util"].$isSVGElement$(element), "$A.util.conatins(): 'element' must be HTMLElement or SVGElement: " + element);element;) {
    if(element === container) {
      return true
    }
    if(element.nodeType === 11) {
      element = element.host
    }else {
      element = element.parentNode
    }
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "contains", Aura.$Utils$.$Util$.prototype.contains);
Aura.$Utils$.$Util$.prototype.$squash$ = function(event, preventDefault) {
  event = event || window.event;
  if(event.stopPropagation) {
    event.stopPropagation()
  }
  event.cancelBubble = true;
  if(preventDefault) {
    if(event.preventDefault) {
      event.preventDefault()
    }
    event.returnValue = false
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "squash", Aura.$Utils$.$Util$.prototype.$squash$);
Aura.$Utils$.$Util$.prototype.$stripTags$ = function(input, tags) {
  if(this.$isUndefinedOrNull$(input) || this.$isEmpty$(input)) {
    return""
  }
  var div = document.createElement("div");
  div.innerHTML = input;
  if(!this.isArray(tags)) {
    tags = [tags]
  }
  for(var j = 0;j < tags.length;j++) {
    var elems = div.getElementsByTagName(tags[j]);
    for(var i = elems.length;i--;) {
      elems[i].parentNode.removeChild(elems[i])
    }
  }
  var result = div.innerHTML;
  this.$removeElement$(div);
  return result
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "stripTags", Aura.$Utils$.$Util$.prototype.$stripTags$);
Aura.$Utils$.$Util$.prototype.$getWindowSize$ = function() {
  return{width:window.innerWidth || document.body.clientWidth || 0, height:window.innerHeight || document.body.clientHeight || 0}
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getWindowSize", Aura.$Utils$.$Util$.prototype.$getWindowSize$);
Aura.$Utils$.$Util$.prototype.$isComponent$ = function(obj) {
  return obj instanceof Component
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isComponent", Aura.$Utils$.$Util$.prototype.$isComponent$);
Aura.$Utils$.$Util$.prototype.$isExpression$ = function(obj) {
  return obj instanceof PropertyReferenceValue || obj instanceof FunctionCallValue
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isExpression", Aura.$Utils$.$Util$.prototype.$isExpression$);
Aura.$Utils$.$Util$.prototype.$isValue$ = function(obj) {
  return obj instanceof PropertyReferenceValue || obj instanceof FunctionCallValue || obj instanceof PassthroughValue
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isValue", Aura.$Utils$.$Util$.prototype.$isValue$);
Aura.$Utils$.$Util$.prototype.$isAction$ = function(obj) {
  return obj instanceof Action
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isAction", Aura.$Utils$.$Util$.prototype.$isAction$);
Aura.$Utils$.$Util$.prototype.$isEvent$ = function(obj) {
  return obj instanceof Aura.$Event$.$Event$
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isEvent", Aura.$Utils$.$Util$.prototype.$isEvent$);
Aura.$Utils$.$Util$.prototype.$supportsTouchEvents$ = function() {
  if($A["util"].$isUndefined$(this.$supportsTouchEvents$.$cache$)) {
    this.$supportsTouchEvents$.$cache$ = (($A.get("$Browser.formFactor") !== "DESKTOP" || $A.get("$Browser.isIOS") || $A.get("$Browser.isAndroid")) && "ontouchstart" in window || $A.get("$Browser.isWindowsPhone") && (window["navigator"]["pointerEnabled"] || window["navigator"]["msPointerEnabled"]) || $A.get("$Browser.formFactor") !== "DESKTOP" && (window["navigator"]["msMaxTouchPoints"] > 0 || window["navigator"]["maxTouchPoints"] > 0)) && $A.getContext().$getMode$() !== "PTEST" && $A.getContext().$getMode$() !== 
    "CADENCE" && $A.getContext().$getMode$() !== "SELENIUM" && $A.getContext().$getMode$() !== "STATS" && $A.getContext().$getMode$() !== "SELENIUMDEBUG"
  }
  return this.$supportsTouchEvents$.$cache$
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "supportsTouchEvents", Aura.$Utils$.$Util$.prototype.$supportsTouchEvents$);
Aura.$Utils$.$Util$.prototype.$estimateSize$ = function(obj) {
  return this.$sizeEstimator$.$estimateSize$(obj)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "estimateSize", Aura.$Utils$.$Util$.prototype.$estimateSize$);
Aura.$Utils$.$Util$.prototype.$toArray$ = function(collection) {
  if(this.$isUndefinedOrNull$(collection)) {
    return[]
  }
  try {
    return Array.prototype.slice.call(collection)
  }catch(e) {
    var length = collection.length;
    var newCollection = new Array(length);
    for(var c = 0;c < length;c++) {
      newCollection[c] = collection[c]
    }
    return newCollection
  }
};
Aura.$Utils$.$Util$.prototype.$setText$ = function(node, text) {
  if(node.textContent !== undefined) {
    node.textContent = text
  }else {
    if(node.innerText !== undefined) {
      node.innerText = text
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "setText", Aura.$Utils$.$Util$.prototype.$setText$);
Aura.$Utils$.$Util$.prototype.postMessage = function(targetWindow, argsArray) {
  if(targetWindow && targetWindow["postMessage"]) {
    targetWindow["postMessage"].apply(targetWindow, argsArray)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "postMessage", Aura.$Utils$.$Util$.prototype.postMessage);
Aura.$Utils$.$Util$.prototype.$getComponentHierarchy$ = function(component) {
  if(this.$isUndefinedOrNull$(component)) {
    return""
  }
  var ret = ["[" + component.$getType$() + "]"];
  for(var owner = component.$getOwner$();!this.$isUndefinedOrNull$(owner) && owner !== owner.$getOwner$();) {
    ret.push("[" + owner.$getType$() + "]");
    owner = owner.$getOwner$()
  }
  if(!this.$isUndefinedOrNull$(owner)) {
    ret.push("[" + owner.$getType$() + "]")
  }
  return ret.reverse().join("\x3e")
};
Aura.$Utils$.$Util$.prototype.$hasSourceURL$ = function() {
  if(this.$sourceURLsupported$ === undefined) {
    try {
      var trustedScript = $A.$lockerService$.$trusted$["createScript"]("null.x");
      this.$globalEval$(trustedScript, "markup://x")
    }catch(e) {
      this.$sourceURLsupported$ = e.stack.indexOf("/x.js") > -1
    }
  }
  return this.$sourceURLsupported$
};
Aura.$Utils$.$Util$.prototype.$getHashCode$ = function(value) {
  var hash = 0;
  if(!value || !value.length) {
    return hash
  }
  for(var i = 0;i < value.length;i++) {
    hash = (hash << 5) - hash + value.charCodeAt(i);
    hash = hash & hash
  }
  return hash
};
Aura.$Utils$.$Util$.prototype.$getO11yMetricRecordingFunction$ = function(moduleString) {
  return function o11yRecordingFunction(functionName, args) {
    $A.$clientService$.$notifyListeners$("O11Y", moduleString + "." + functionName, args)
  }
};
var lastReportedMap = {};
var SECOND_MS = 1E3;
var MINUTE_MS = 6E4;
var HOUR_MS = 36E5;
var SECOND_LIMIT = 4;
var MINUTE_LIMIT = 20;
var HOUR_LIMIT = 250;
function Logger() {
  this.$subscribers$ = [];
  this.$INFO$ = "INFO";
  this.$WARNING$ = "WARNING";
  this.$ASSERT$ = "ASSERT";
  this.$ERROR$ = "ERROR";
  this.$subscriptions$ = {};
  this.$subscriptions$[this.$INFO$] = 0;
  this.$subscriptions$[this.$WARNING$] = 0;
  this.$subscriptions$[this.$ASSERT$] = 0;
  this.$subscriptions$[this.$ERROR$] = 0
}
goog.$exportSymbol$("Logger", Logger);
Logger.prototype.info = function(info, error) {
  this.log(this.$INFO$, info, error)
};
goog.$exportProperty$(Logger.prototype, "info", Logger.prototype.info);
Logger.prototype.$warning$ = function(warning, error) {
  this.log(this.$WARNING$, warning, error)
};
goog.$exportProperty$(Logger.prototype, "warning", Logger.prototype.$warning$);
Logger.prototype.$logError$ = function(msg, e) {
  var logMsg = msg || "";
  if(!e) {
    e = undefined
  }else {
    if(!(e instanceof Error) && !$A["util"].$isError$(e)) {
      if($A["util"].$isObject$(e) && e.message) {
        var stk = e.stack;
        e = new Error("caught " + e.message);
        if(stk) {
          e.stack = stk
        }
      }else {
        e = new Error("caught " + $A["util"].$json$.$encode$(e))
      }
    }
  }
  if(e && !$A["util"].$isUndefinedOrNull$(e.message) && e.message !== "") {
    if(logMsg.length) {
      logMsg = logMsg + " : " + e.message
    }else {
      logMsg = e.message
    }
  }
  var stack = this.$getStackTrace$(e, 1);
  if(stack && !e) {
    e = new $A.$auraError$(msg);
    e.name = Error.prototype.name;
    e.stack = stack;
    e.$stackTrace$ = e.stack
  }
  if(!$A.$initialized$) {
    $A["hasErrors"] = true
  }
  this.log(this.$ERROR$, logMsg, e)
};
Logger.prototype.$reportError$ = function(e, action, level, foreground) {
  if(!e || e["reported"]) {
    return
  }
  if(!level || !this.$isValidLevel$(level)) {
    level = this.$ERROR$
  }
  var errorAction = action || e.action;
  var actionDescriptor = undefined;
  if(errorAction && errorAction.$getDef$) {
    var actionDef = errorAction.$getDef$();
    if(actionDef) {
      actionDescriptor = actionDef.$getDescriptor$()
    }
  }
  if(!(e instanceof $A.$auraError$)) {
    e = new $A.$auraError$(null, e)
  }
  if(!e["component"] || !e["stacktraceIdGen"]) {
    var component = e["component"] || e.$findComponentFromStackTrace$();
    e.$setComponent$(component)
  }
  var errorContext;
  if(typeof this.$errorContextProvider$ === "function") {
    try {
      errorContext = this.$errorContextProvider$()
    }catch(providerError) {
      errorContext = null
    }
    e.$setAdditionalContext$(errorContext)
  }
  var errorContainerContext;
  if(typeof this.$errorContainerContextProvider$ === "function") {
    try {
      errorContainerContext = this.$errorContainerContextProvider$()
    }catch(providerError$$0) {
      errorContainerContext = null
    }
    e.$setAdditionalContainerContext$(errorContainerContext)
  }
  var additionalErrorData = {};
  for(var key in this.$errorAdditionalDataProvider$) {
    var provider = this.$errorAdditionalDataProvider$[key];
    if(typeof provider === "function") {
      try {
        additionalErrorData[key] = provider()
      }catch(providerError$$1) {
        additionalErrorData[key] = null
      }
    }
  }
  e.$setAdditionalData$(additionalErrorData);
  var lastReportedTimes = lastReportedMap[e.id] || [];
  var now = Date.now();
  var oneSecondAgo = now - SECOND_MS;
  var oneMinuteAgo = now - MINUTE_MS;
  for(var oneHourAgo = now - HOUR_MS;lastReportedTimes.length && lastReportedTimes[lastReportedTimes.length - 1] < oneHourAgo;) {
    lastReportedTimes.pop()
  }
  if(lastReportedTimes.length >= HOUR_LIMIT) {
    return
  }
  var secondRate = 0;
  var minuteRate = 0;
  for(var i = 0;i < lastReportedTimes.length;i++) {
    var timestamp = lastReportedTimes[i];
    if(timestamp > oneSecondAgo) {
      secondRate++;
      minuteRate++
    }else {
      if(timestamp > oneMinuteAgo) {
        minuteRate++
      }else {
        break
      }
    }
  }
  if(secondRate >= SECOND_LIMIT || minuteRate >= MINUTE_LIMIT) {
    return
  }
  lastReportedTimes.unshift(now);
  lastReportedMap[e.id] = lastReportedTimes;
  var reportAction = $A.get("c.aura://ComponentController.reportFailedAction");
  if(!foreground) {
    reportAction.$setCaboose$()
  }
  reportAction.$setParams$({"failedAction":actionDescriptor || e["component"], "failedId":e.id && e.id.toString(), "clientError":e.toString(), "additionalContext":e["additionalContext"], "additionalContainerContext":e["additionalContainerContext"], "additionalData":JSON.stringify(e["additionalData"]), "clientStack":(e.$stackTrace$ || e.stack || "").toString().substr(0, Aura.$Utils$.$Logger$.$MAX_STACKTRACE_SIZE$), "componentStack":e["componentStack"] || "", "stacktraceIdGen":e["stacktraceIdGen"], 
  "level":level});
  reportAction.$setCallback$(this, function() {
  });
  $A.$clientService$.$enqueueAction$(reportAction);
  e["reported"] = true
};
Logger.prototype.$setErrorContextProvider$ = function(provider) {
  this.$errorContextProvider$ = provider
};
goog.$exportProperty$(Logger.prototype, "setErrorContextProvider", Logger.prototype.$setErrorContextProvider$);
Logger.prototype.$setErrorContainerContextProvider$ = function(provider) {
  this.$errorContainerContextProvider$ = provider
};
goog.$exportProperty$(Logger.prototype, "setErrorContainerContextProvider", Logger.prototype.$setErrorContainerContextProvider$);
Logger.prototype.$setErrorAdditionalDataProvider$ = function(key, provider) {
  if(!this.$errorAdditionalDataProvider$) {
    this.$errorAdditionalDataProvider$ = {}
  }
  this.$errorAdditionalDataProvider$[key] = provider
};
goog.$exportProperty$(Logger.prototype, "setErrorAdditionalDataProvider", Logger.prototype.$setErrorAdditionalDataProvider$);
Logger.prototype.$isExternalError$ = function(e) {
  if(!e) {
    return false
  }
  var errorframes = this.$generateStackFrames$(e);
  for(var i = 0;i < errorframes.length;i++) {
    var fileName = errorframes[i].fileName;
    if(!fileName) {
      continue
    }
    if(fileName.indexOf("chrome-extension://") > -1) {
      return true
    }
    if(this.$isAuraFile$(fileName)) {
      return false
    }
  }
  return true
};
Logger.prototype.$isExternalRaisedError$ = function(e) {
  if(!e) {
    return false
  }
  var errorframes = this.$generateStackFrames$(e);
  var fileName = errorframes[0] && errorframes[0].fileName;
  return!this.$isAuraFile$(fileName)
};
Logger.prototype.$generateStackFrames$ = function(e) {
  if(e instanceof $A.$auraError$) {
    return e.$stackFrames$
  }
  return Aura.$Errors$.$StackParser$.parse(e)
};
Logger.prototype.$isAuraFile$ = function(fileName) {
  if(!fileName) {
    return false
  }
  var ctx = $A.getContext();
  var appSubString = ctx && ctx.$app$ && ctx.$app$.replace(":", "/") + ".app";
  return fileName.match(/aura_[^\.]+\.js$/gi) || fileName.indexOf("engine.js") > -1 || fileName.indexOf("engine.min.js") > -1 || fileName.indexOf("/components/") > -1 || fileName.indexOf("/modules/") > -1 || fileName.indexOf("/libraries/") > -1 || fileName.indexOf("/jslibrary/") > -1 || fileName.indexOf("/projRes/") > -1 || fileName.indexOf("/auraFW/resources/") > -1 || fileName.indexOf("bootstrap.js") > -1 || fileName.indexOf("appcore.js") > -1 || fileName.indexOf("app.js") > -1 || fileName.match(/apppart\d+\-\d+\.js$/) || 
  $A.$initialized$ && $A.get("$Browser.isIOS") && $A.get("$Browser.S1Features.isBootstrapManagementEnabled") && fileName.indexOf(appSubString) > -1
};
Logger.prototype.log = function(level, message, error) {
  if(this.$hasSubscriptions$(level)) {
    this.$notify$(level, message, error)
  }
};
Logger.prototype.$notify$ = function(level, msg, error) {
  var subsLength = this.$subscribers$.length;
  for(var i = 0;i < subsLength;i++) {
    var sub = this.$subscribers$[i];
    if(sub.$level$ === level) {
      sub.$fn$.apply(undefined, [level, msg, error])
    }
  }
};
Logger.prototype.$getStackTrace$ = function(e, remove) {
  if(e && e instanceof $A.$auraError$) {
    return e.$stackTrace$
  }
  var stack = undefined;
  if(!remove) {
    remove = 0
  }
  if(!e || !e.stack) {
    try {
      throw new Error("foo");
    }catch(f) {
      e = f;
      remove += 2
    }
  }
  if(e) {
    stack = e.stack
  }
  var chromeStart = "Error: " + e.message;
  if(stack && stack.indexOf(chromeStart) === 0) {
    stack = stack.substring(chromeStart.length + 1)
  }
  if(stack) {
    var ret = stack.replace(/(?:\n@:0)?\s+$/m, "");
    ret = ret.replace(new RegExp("^\\(", "gm"), "{anonymous}(");
    ret = ret.split("\n");
    if(remove !== 0) {
      ret.splice(0, remove)
    }
    return ret.join("\n")
  }
  return null
};
Logger.prototype.$stringVersion$ = function(logMsg, error, trace) {
  var stringVersion = !$A["util"].$isUndefinedOrNull$(logMsg) ? logMsg : "";
  if(!$A["util"].$isUndefinedOrNull$(error) && !$A["util"].$isUndefinedOrNull$(error.message)) {
    stringVersion += " : " + error.message
  }
  if(!$A["util"].$isUndefinedOrNull$(trace)) {
    stringVersion += "\nStack: " + trace.join("\n")
  }
  return stringVersion
};
Logger.prototype.$subscribe$ = function(level, callback) {
  level = level.toUpperCase();
  this.$validateSubscriber$(level, callback);
  this.$subscribers$.push({$level$:level, $fn$:callback});
  this.$subscriptions$[level] += 1
};
goog.$exportProperty$(Logger.prototype, "subscribe", Logger.prototype.$subscribe$);
Logger.prototype.$unsubscribe$ = function(level, callback) {
  level = level.toUpperCase();
  this.$validateSubscriber$(level, callback);
  var subsLength = this.$subscribers$.length;
  for(var i = subsLength - 1;i >= 0;i--) {
    var sub = this.$subscribers$[i];
    if(sub.$level$ === level && sub.$fn$ === callback) {
      this.$subscribers$.splice(i, 1);
      this.$subscriptions$[level] -= 1
    }
  }
};
goog.$exportProperty$(Logger.prototype, "unsubscribe", Logger.prototype.$unsubscribe$);
Logger.prototype.$isValidLevel$ = function(level) {
  return level === this.$INFO$ || level === this.$WARNING$ || level === this.$ASSERT$ || level === this.$ERROR$
};
Logger.prototype.$validateSubscriber$ = function(level, callback) {
  if(!this.$isValidLevel$(level)) {
    throw new Error("Please specify valid log level: 'INFO', 'WARNING', 'ASSERT', 'ERROR'");
  }
  if(typeof callback !== "function") {
    throw new Error("Logging callback must be a function");
  }
};
Logger.prototype.$hasSubscriptions$ = function(level) {
  level = level.toUpperCase();
  return this.$isValidLevel$(level) && this.$subscriptions$[level] > 0
};
Aura.$Utils$.$Logger$ = Logger;
Aura.$Utils$.$Logger$.$MAX_STACKTRACE_SIZE$ = 25E3;
Aura.$Utils$.$Override$ = function Override(instance, orig, proto, replace, restore) {
  $A.assert($A["util"].$isObject$(instance) || instance === null, "Override: instance must be an object or null");
  $A.assert($A["util"].$isFunction$(orig), "Override: orig argument must be a function");
  $A.assert(proto === true || proto === false, "Override: Proto argument must be supplied");
  $A.assert($A["util"].$isFunction$(replace), "Override: replace must be a function");
  $A.assert($A["util"].$isFunction$(restore), "Override: restore must be a function");
  $A.assert(!instance === proto, "OverrideMapDef: instance argument must match !proto");
  this.$instance$ = instance;
  this.$orig$ = orig;
  this.$proto$ = proto;
  this.replace = replace;
  this.restore = restore;
  this.$chain$ = [];
  this.$currentInstance$ = instance
};
Aura.$Utils$.$Override$.prototype.$install$ = function(fn, scope, priority) {
  var obj = {};
  var i;
  var posn;
  obj.scope = scope;
  obj.$fn$ = fn;
  obj.$priority$ = priority;
  if(this.$chain$.length === 0) {
    var bound;
    if(this.$proto$) {
      var that = this;
      bound = function() {
        var config = {"self":this};
        config.$that$ = that;
        config.$walkIndex$ = 0;
        that.$continuation$.apply(config, arguments)
      }
    }else {
      bound = this.start.bind(this)
    }
    this.replace(bound)
  }
  for(i = 0;i < this.$chain$.length;i++) {
    if(this.$chain$.$priority$ > priority) {
      posn = i;
      break
    }
  }
  if(posn !== undefined) {
    this.$chain$.splice(posn, 0, obj)
  }else {
    this.$chain$.push(obj)
  }
};
Aura.$Utils$.$Override$.prototype.$uninstall$ = function(fn) {
  var i;
  for(i = 0;i < this.$chain$.length;i++) {
    if(this.$chain$[i].$fn$ === fn) {
      this.$chain$.splice(i, 1);
      break
    }
  }
  if(this.$chain$.length === 0) {
    var bound;
    if(this.$instance$) {
      bound = this.$orig$.bind(this.$instance$)
    }
    this.restore(this.$orig$, bound);
    return true
  }
  return false
};
Aura.$Utils$.$Override$.prototype.start = function() {
  var config = {"self":this.$instance$};
  config.$that$ = this;
  config.$walkIndex$ = 0;
  return this.$continuation$.apply(config, arguments)
};
Aura.$Utils$.$Override$.prototype.$continuation$ = function() {
  var next;
  var keepGoing = true;
  var config = this;
  var that = config.$that$;
  if(config.$walkIndex$ < that.$chain$.length) {
    next = that.$chain$[config.$walkIndex$++];
    keepGoing = config.$walkIndex$ < that.$chain$.length || that.$last$
  }else {
    next = that.$last$;
    keepGoing = false
  }
  if(keepGoing) {
    config["scope"] = config;
    config["fn"] = that.$continuation$
  }else {
    config["scope"] = config["self"];
    config["fn"] = that.$orig$
  }
  Array.prototype.unshift.call(arguments, config);
  return next.$fn$.apply(next.scope, arguments)
};
function AuraError(message, innerError, severity) {
  function getStackFrames(e) {
    var remove = 0;
    if(!e || !e.stack) {
      try {
        throw new Error("foo");
      }catch(f) {
        e = f;
        remove += 3
      }
    }
    return Aura.$Errors$.$StackParser$.parse(e).slice(remove)
  }
  function getStackTrace(frames) {
    var filtered = [];
    var nonFrameworkStackFrameExist = false;
    var isNonFrameworkStackFrame = false;
    for(var i = 0;i < frames.length;i++) {
      isNonFrameworkStackFrame = !frames[i].fileName || frames[i].fileName.match(/aura_[^\.]+\.js$/gi) === null;
      if(!nonFrameworkStackFrameExist) {
        filtered.push(frames[i]);
        nonFrameworkStackFrameExist = isNonFrameworkStackFrame
      }else {
        if(isNonFrameworkStackFrame) {
          filtered.push(frames[i])
        }
      }
    }
    return filtered.join("\n")
  }
  function sourceMapUnfurl(frames, sourceMapRegistry) {
    var delimeter = "://";
    if(frames && sourceMapRegistry) {
      var regex = /app(?:part\d+\-\d+|core)?\.js|auraCmpDef.*/;
      for(var idx = 0;idx < frames.length;idx++) {
        var frame = frames[idx];
        var isBundledFile = frame.fileName && frame.fileName.match(regex) !== null;
        if(isBundledFile) {
          var moduleRef = sourceMapRegistry.$getModule$(frame.fileName, frame.lineNumber, frame.columnNumber);
          if(moduleRef && moduleRef.$descriptor$.indexOf(delimeter) >= 0) {
            frame.lineNumber = frame.lineNumber - moduleRef.start.$line$ + 1;
            if(frame.lineNumber === 1) {
              frame.columnNumber = frame.columnNumber - moduleRef.start.$column$
            }
            var pathArray = frame.fileName.split("/");
            var baseUrl = frame.fileName.indexOf("http") === 0 ? pathArray[0] + "//" + pathArray[2] : pathArray[0];
            var moduleName = moduleRef.$descriptor$.substring(moduleRef.$descriptor$.indexOf(delimeter) + delimeter.length);
            var type = moduleRef.type === "library" ? "libraries" : moduleRef.type + "s";
            var modulePath = moduleRef.type === "library" ? moduleName.replace(/\./g, "/") : moduleName.replace(/:/g, "/");
            frame.fileName = baseUrl + "/" + type + "/" + modulePath + ".js"
          }
        }
      }
    }
  }
  this["component"] = "";
  this["componentStack"] = "";
  if(innerError && innerError["wcStack"]) {
    this["componentStack"] += this.$formatLwcComponentStack$(innerError["wcStack"])
  }
  this.action = null;
  if(message == null) {
    message = ""
  }
  this.name = innerError ? innerError.name : "AuraError";
  this.message = message + (innerError ? " [" + (innerError.message || innerError.toString()) + "]" : "");
  this.$stackFrames$ = getStackFrames(innerError);
  if(typeof $A !== "undefined" && $A.$componentService$ && $A.$componentService$.$sourceMapRegistry$) {
    var structuredCloneOrPolyfill = typeof structuredClone === "function" ? structuredClone : function structuredClonePolyfill(object) {
      return JSON.parse(JSON.stringify(object))
    };
    this["originalStackFrames"] = structuredCloneOrPolyfill(this.$stackFrames$);
    sourceMapUnfurl(this.$stackFrames$, $A.$componentService$.$sourceMapRegistry$)
  }
  this.$stackTrace$ = getStackTrace(this.$stackFrames$);
  this.severity = innerError ? innerError.severity || severity : severity;
  this.stack = innerError && innerError.stack !== null && innerError.stack !== undefined ? innerError.stack : this.stack;
  this["handled"] = innerError ? innerError["handled"] || false : false;
  this["reported"] = innerError ? innerError["reported"] || false : false;
  this["additionalData"] = innerError ? innerError["additionalData"] || {} : {};
  this["name"] = this.name;
  this["message"] = this.message;
  this["stackTrace"] = this.$stackTrace$;
  this["severity"] = this.severity;
  this["stack"] = this.stack;
  this["data"] = null;
  this["stackFrames"] = this.$stackFrames$;
  this["stacktraceIdGen"] = "";
  this["stacktraceIdGenModifier"] = null;
  this["id"] = "";
  var stackComponent = this.$findComponentFromStackTrace$();
  if(stackComponent) {
    this.$setComponent$(stackComponent)
  }
  if(typeof $A !== "undefined" && $A.$clientService$) {
    var currentAccess = $A.$clientService$.$getCurrentAccessName$();
    if(currentAccess) {
      if(!stackComponent) {
        this.$setComponent$(currentAccess)
      }
      var auraComponentStack = $A.$clientService$.$getAccessStackHierarchy$();
      this["componentStack"] = this["componentStack"].length > 0 ? this.$mergeAuraLwcComponentStack$(auraComponentStack, this["componentStack"]) : auraComponentStack
    }
  }
}
Aura.$Errors$.$MurmurHash3$ = {$mul32$:function(m, n) {
  var nlo = n & 65535;
  var nhi = n - nlo;
  return(nhi * m | 0) + (nlo * m | 0) | 0
}, $hashString$:function(data) {
  var c1 = 3432918353;
  var c2 = 461845907;
  var h1 = 0;
  var len = data.length;
  for(var i = 1;i < len;i += 2) {
    var k1 = data.charCodeAt(i - 1) | data.charCodeAt(i) << 16;
    k1 = this.$mul32$(k1, c1);
    k1 = (k1 & 131071) << 15 | k1 >>> 17;
    k1 = this.$mul32$(k1, c2);
    h1 ^= k1;
    h1 = (h1 & 524287) << 13 | h1 >>> 19;
    h1 = h1 * 5 + 3864292196 | 0
  }
  if(len % 2 === 1) {
    k1 = data.charCodeAt(len - 1);
    k1 = this.$mul32$(k1, c1);
    k1 = (k1 & 131071) << 15 | k1 >>> 17;
    k1 = this.$mul32$(k1, c2);
    h1 ^= k1
  }
  h1 ^= len << 1;
  h1 ^= h1 >>> 16;
  h1 = this.$mul32$(h1, 2246822507);
  h1 ^= h1 >>> 13;
  h1 = this.$mul32$(h1, 3266489909);
  h1 ^= h1 >>> 16;
  return h1
}};
Aura.$Errors$.$GenerateErrorId$ = function(hashGen) {
  return Aura.$Errors$.$MurmurHash3$.$hashString$(hashGen)
};
Aura.$Errors$.$GenerateErrorIdHashGen$ = function(componentName, stackFrames, message, stacktraceIdGenModifier) {
  var hashGen = componentName;
  var fileUrl;
  var functionName;
  for(var i = 0;i < stackFrames.length;i++) {
    var frame = stackFrames[i];
    if(!frame.fileName || frame.fileName.match(/aura_[^\.]+\.js$/gi) === null) {
      functionName = frame.functionName;
      fileUrl = frame.fileName;
      break
    }
  }
  if(functionName !== undefined) {
    hashGen += "$" + functionName
  }
  if((functionName === undefined || functionName === "eval()") && fileUrl !== undefined) {
    var parts = fileUrl.split("/");
    var file = parts.slice(Math.max(parts.length - 2, 0)).join("/");
    hashGen += "$/" + file
  }
  if(stacktraceIdGenModifier) {
    hashGen += "$" + stacktraceIdGenModifier
  }else {
    if(hashGen !== "" && message) {
      hashGen += "$" + message.substring(0, Math.min(message.length, 25))
    }
  }
  return hashGen
};
Aura.$Errors$.$isDisplayableError$ = function(error) {
  return error && error.$isDisplayableError$ && error.$isDisplayableError$()
};
AuraError.prototype = new Error;
AuraError.prototype.constructor = AuraError;
AuraError.prototype.toString = function() {
  return this.message || Error.prototype.toString()
};
AuraError.prototype.$setStackTrace$ = function(trace) {
  this.$stackTrace$ = trace
};
AuraError.prototype.$findComponentFromStackTrace$ = function() {
  for(var i = 0;i < this.$stackFrames$.length;i++) {
    var frame = this.$stackFrames$[i];
    var fileName = frame.fileName;
    if(fileName && fileName.match(/aura_[^\.]+\.js$/gi) === null) {
      var pathParts = fileName.replace(".js", "").split("/");
      var componentsOrModulesPart = pathParts[pathParts.length - 3];
      if(componentsOrModulesPart === "components" || componentsOrModulesPart === "modules") {
        return"markup://" + pathParts.slice(-2).join(":")
      }
      if(pathParts[pathParts.length - 4] === "libraries") {
        pathParts = pathParts.slice(-3);
        return"js://" + pathParts[0] + ":" + pathParts[1] + "." + pathParts[2]
      }
      if(pathParts[pathParts.length - 2] === "components") {
        var moduleName = pathParts[pathParts.length - 1];
        pathParts = moduleName.split(/-(.+)/);
        return pathParts[0] + ":" + $A["util"].$hyphensToCamelCase$(pathParts[1])
      }
    }
  }
  return""
};
AuraError.prototype.$setAdditionalContext$ = function(errorContext) {
  this["additionalContext"] = errorContext
};
AuraError.prototype.$getAdditionalContext$ = function() {
  return this["additionalContext"]
};
AuraError.prototype.$setAdditionalContainerContext$ = function(errorContext) {
  this["additionalContainerContext"] = errorContext
};
AuraError.prototype.$getAdditionalContainerContext$ = function() {
  return this["additionalContainerContext"]
};
AuraError.prototype.$setAdditionalData$ = function(additionalData) {
  Object.assign(this["additionalData"], additionalData)
};
AuraError.prototype.$getAdditionalData$ = function() {
  return this["additionalData"]
};
AuraError.prototype.$setSeverity$ = function(severity) {
  var severityExists = !!$A.severity[severity];
  if(severityExists) {
    this["severity"] = severity
  }
};
AuraError.prototype.$setComponent$ = function(component) {
  this["component"] = component;
  this["stacktraceIdGen"] = Aura.$Errors$.$GenerateErrorIdHashGen$(component, this.$stackFrames$, this["message"], this["stacktraceIdGenModifier"]);
  this["id"] = Aura.$Errors$.$GenerateErrorId$(this["stacktraceIdGen"])
};
AuraError.prototype.$isDisplayableError$ = function() {
  var ctx = $A.getContext();
  if(ctx && ctx.$isErrorExperienceEnabled$() && !$A.$isCustomerError$(this)) {
    return!!(this["id"] && this["severity"] === $A.severity.$FATAL$)
  }
  return!!(this["id"] && this["severity"] !== $A.severity.$QUIET$)
};
AuraError.prototype.$setAdditionalStacktraceGen$ = function(modifier) {
  this["stacktraceIdGenModifier"] = modifier;
  this["stacktraceIdGen"] = Aura.$Errors$.$GenerateErrorIdHashGen$(this["component"], this.$stackFrames$, this["message"], modifier);
  this["id"] = Aura.$Errors$.$GenerateErrorId$(this["stacktraceIdGen"])
};
AuraError.prototype.$formatLwcComponentStack$ = function(wcStack) {
  return wcStack.split("\n").map(function(line) {
    var elementName = line.trim().slice(1, -1);
    var moduleDescriptor = $A.$componentService$.$getModuleDescriptorForElementName$(elementName);
    if(moduleDescriptor !== undefined) {
      return"[" + moduleDescriptor.slice(9) + "]"
    }else {
      var name = "unknown";
      var namespace = "unknown";
      var delimiterIndex = elementName.indexOf("-");
      if(delimiterIndex > 0) {
        namespace = elementName.slice(0, delimiterIndex);
        name = $A["util"].$hyphensToCamelCase$(elementName.slice(delimiterIndex + 1))
      }
      return"[" + namespace + ":" + name + "]"
    }
  }).join(AuraError.$COMPONENT_STACK_SEPARATOR$)
};
AuraError.prototype.$mergeAuraLwcComponentStack$ = function(auraStack, lwcStack) {
  var auraStackArray = auraStack.split(AuraError.$COMPONENT_STACK_SEPARATOR$);
  var lwcStackArray = lwcStack.split(AuraError.$COMPONENT_STACK_SEPARATOR$);
  if(lwcStackArray[0] === auraStackArray[auraStackArray.length - 1]) {
    lwcStackArray = lwcStackArray.slice(1)
  }
  return auraStackArray.concat(lwcStackArray).join(AuraError.$COMPONENT_STACK_SEPARATOR$)
};
AuraError.$COMPONENT_STACK_SEPARATOR$ = " \x3e ";
Aura.$Errors$.$AuraError$ = AuraError;
Aura.$Errors$.$AuraFriendlyError$ = function AuraFriendlyError() {
  Aura.$Errors$.$AuraError$.apply(this, arguments);
  this.name = "AuraFriendlyError"
};
Aura.$Errors$.$AuraFriendlyError$.prototype = new Aura.$Errors$.$AuraError$;
Aura.$Errors$.$AuraFriendlyError$.prototype.constructor = Aura.$Errors$.$AuraFriendlyError$;
Aura.$Errors$.$AuraFriendlyError$.prototype.toString = function() {
  var ret = Error.prototype.toString.apply(this);
  if(this["data"]) {
    ret = ret + "\n\t[custom data: " + JSON.stringify(this["data"]) + "]"
  }
  return ret
};
function DefDescriptor(descriptor) {
  var prefix = DefDescriptor.normalize(descriptor).split("://");
  var namespace = prefix[1].split(/[:.]/);
  var hasNamespace = namespace.length > 1;
  var separator = hasNamespace ? prefix[1].indexOf(":") > -1 ? ":" : "." : "";
  this.prefix = prefix[0];
  this.$namespace$ = hasNamespace ? namespace[0] : "";
  this.name = namespace[hasNamespace ? 1 : 0];
  this.$fullName$ = this.$namespace$ + separator + this.name;
  this.$qualifiedName$ = this.prefix + "://" + this.$fullName$
}
goog.$exportSymbol$("DefDescriptor", DefDescriptor);
DefDescriptor.$DESCRIPTOR$ = "descriptor";
DefDescriptor.normalize = function(descriptor) {
  if(descriptor && descriptor.hasOwnProperty(DefDescriptor.$DESCRIPTOR$)) {
    descriptor = descriptor[DefDescriptor.$DESCRIPTOR$]
  }
  if(!descriptor) {
    throw new $A.$auraError$("DefDescriptor.normalize(): 'descriptor' must be a valid config Object or String.", null, $A.severity.$QUIET$);
  }
  if((descriptor + "").indexOf("://") < 0) {
    descriptor = "markup://" + descriptor
  }
  return descriptor
};
DefDescriptor.prototype.$getQualifiedName$ = function() {
  return this.$qualifiedName$
};
goog.$exportProperty$(DefDescriptor.prototype, "getQualifiedName", DefDescriptor.prototype.$getQualifiedName$);
DefDescriptor.prototype.$getFullName$ = function() {
  return this.$fullName$
};
goog.$exportProperty$(DefDescriptor.prototype, "getFullName", DefDescriptor.prototype.$getFullName$);
DefDescriptor.prototype.$getNamespace$ = function() {
  return this.$namespace$
};
goog.$exportProperty$(DefDescriptor.prototype, "getNamespace", DefDescriptor.prototype.$getNamespace$);
DefDescriptor.prototype.getName = function() {
  return this.name
};
goog.$exportProperty$(DefDescriptor.prototype, "getName", DefDescriptor.prototype.getName);
DefDescriptor.prototype.$getPrefix$ = function() {
  return this.prefix
};
goog.$exportProperty$(DefDescriptor.prototype, "getPrefix", DefDescriptor.prototype.$getPrefix$);
DefDescriptor.prototype.toString = function() {
  return this.$getQualifiedName$()
};
goog.$exportProperty$(DefDescriptor.prototype, "toString", DefDescriptor.prototype.toString);
Aura.$System$.$DefDescriptor$ = DefDescriptor;
function StyleDef(config) {
  this.code = config[Json.$ApplicationKey$.$CODE$];
  this.className = config[Json.$ApplicationKey$.$CLASSNAME$];
  this.$descriptor$ = new DefDescriptor(config[Json.$ApplicationKey$.$DESCRIPTOR$]);
  this.$preloaded$ = $A["util"].$isUndefinedOrNull$(this.code)
}
StyleDef.prototype.apply = function() {
  var element = this.element;
  var code = this.code;
  if(!element && code) {
    element = aura["util"].style.apply(code);
    this.element = element
  }
  delete this.code
};
StyleDef.prototype.remove = function() {
};
StyleDef.prototype.$getClassName$ = function() {
  return this.className
};
StyleDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportSymbol$("StyleDef.prototype.getDescriptor", StyleDef.prototype.$getDescriptor$);
StyleDef.prototype.$isPreloaded$ = function() {
  return this.$preloaded$
};
Aura.$Style$.$StyleDef$ = StyleDef;
function FlavorDefaultDef(config) {
  this.map = {};
  if(!$A["util"].$isUndefinedOrNull$(config["removeAll"])) {
    this.$removeAll$ = config["removeAll"]
  }else {
    for(var key in config) {
      if(config.hasOwnProperty(key)) {
        this.map[key] = {$flavor$:config[key]["flavor"]}
      }
    }
  }
}
FlavorDefaultDef.prototype.$getFlavor$ = function(componentDescriptor) {
  if(!$A["util"].$isUndefinedOrNull$(this.$removeAll$)) {
    if(this.$removeAll$ === "*" || this.$removeAll$ === componentDescriptor.$getNamespace$()) {
      return"{!remove}"
    }
  }
  var entry = this.map[componentDescriptor.$getQualifiedName$()];
  if(entry) {
    return entry.$flavor$
  }
  return null
};
Aura.$Flavors$.$FlavorDefaultDef$ = FlavorDefaultDef;
function FlavorsDef(config) {
  this.$flavors$ = [];
  this.$cache$ = {};
  var flavorDefaultDefs = config["flavorDefaultDefs"];
  for(var i = flavorDefaultDefs.length - 1;i >= 0;i--) {
    this.$flavors$.push(new FlavorDefaultDef(flavorDefaultDefs[i]))
  }
}
FlavorsDef.prototype.$getFlavor$ = function(componentDescriptor) {
  var qn = componentDescriptor.$getQualifiedName$();
  if($A["util"].$isUndefined$(this.$cache$[qn])) {
    var found;
    var i = 0;
    for(var len = this.$flavors$.length;i < len && !found;i++) {
      found = this.$flavors$[i].$getFlavor$(componentDescriptor)
    }
    this.$cache$[qn] = found || null
  }
  return this.$cache$[qn]
};
Aura.$Flavors$.$FlavorsDef$ = FlavorsDef;
function PropertyReferenceValue(path, valueProvider) {
  var isArray = $A["util"].isArray(path);
  this.path = isArray ? path : path.split(".");
  this.$expression$ = isArray ? path.join(".") : path;
  this.$isGlobal$ = this.$expression$.charAt(0) === "$";
  this.$valueProvider$ = this.$isGlobal$ ? null : valueProvider;
  this.$context$ = this.$isGlobal$ ? null : valueProvider instanceof PassthroughValue ? valueProvider : $A.$clientService$.$currentAccess$;
  this.$lastResult$ = null;
  this.$isValid$ = true
}
goog.$exportSymbol$("PropertyReferenceValue", PropertyReferenceValue);
PropertyReferenceValue.prototype.evaluate = function(valueProvider) {
  if(this.$isValid$) {
    if(this.$isGlobal$) {
      this.$lastResult$ = aura.get(this.$expression$);
      return this.$lastResult$
    }
    if(!valueProvider) {
      valueProvider = this.$valueProvider$
    }
    $A.$clientService$.$setCurrentAccess$(this.$context$);
    try {
      var result = valueProvider.get(this.$expression$);
      this.$lastResult$ = result;
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
};
PropertyReferenceValue.prototype.set = function(value) {
  if(this.$isValid$) {
    if(this.$isGlobal$) {
      return aura.set(this.$expression$, value)
    }
    $A.$clientService$.$setCurrentAccess$(this.$context$);
    try {
      var result = this.$valueProvider$.set(this.$expression$, value);
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
};
PropertyReferenceValue.prototype.$addChangeHandler$ = function(cmp, key, method, rebind) {
  if(this.$isGlobal$) {
    $A.$expressionService$.$addExpressionListener$(this, key, cmp);
    return
  }
  var valueProvider = this.$valueProvider$;
  var expression = this.$expression$;
  if(valueProvider.$addChangeHandler$ && (valueProvider !== cmp || expression !== key)) {
    var cmpId = cmp.$getGlobalId$();
    if(!method) {
      method = function PropertyReferenceValue$changeHandler(event) {
        var component = $A.$getComponent$(this.$handler$.id);
        if(!component || !component.$isValid$()) {
          return
        }
        $A.$renderingService$.$addDirtyValue$(key, component);
        if(rebind) {
          component.set(key, event.$getParam$("value"), true)
        }
        component.$fireChangeEvent$(key, event.$getParam$("oldValue"), event.$getParam$("value"), event.$getParam$("index"))
      }
    }
    method.id = cmpId;
    method.key = key;
    var config = {"event":"change", "value":expression, "method":method, "cmp":cmp};
    this.$valueProvider$.$addChangeHandler$(config)
  }
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "addChangeHandler", PropertyReferenceValue.prototype.$addChangeHandler$);
PropertyReferenceValue.prototype.$removeChangeHandler$ = function(cmp, key) {
  if(this.$isGlobal$) {
    $A.$expressionService$.$removeExpressionListener$(this, key, cmp);
    return
  }
  var valueProvider = this.$valueProvider$;
  var expression = this.$expression$;
  if(!valueProvider) {
    return
  }
  for(;valueProvider instanceof PassthroughValue;) {
    expression = valueProvider.getExpression(expression);
    valueProvider = valueProvider.$getComponent$()
  }
  if(valueProvider && valueProvider.$removeValueHandler$ && (valueProvider !== cmp || this.$expression$ !== key)) {
    valueProvider.$removeValueHandler$({"event":"change", "value":this.$expression$, "id":cmp.$getGlobalId$(), "key":key})
  }
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "removeChangeHandler", PropertyReferenceValue.prototype.$removeChangeHandler$);
PropertyReferenceValue.prototype.getExpression = function() {
  return this.$expression$
};
PropertyReferenceValue.prototype.$getIsGlobal$ = function() {
  return this.$isGlobal$
};
PropertyReferenceValue.prototype.$getReference$ = function(path) {
  if(!path) {
    return this
  }
  var valueProvider = this.$valueProvider$;
  for(var expression = this.$expression$;valueProvider instanceof PassthroughValue;) {
    expression = valueProvider.getExpression(expression);
    valueProvider = valueProvider.$getComponent$()
  }
  return valueProvider ? valueProvider.$getReference$(expression + "." + path) : null
};
PropertyReferenceValue.prototype.$equals$ = function(target) {
  return target instanceof PropertyReferenceValue && target.$valueProvider$ === this.$valueProvider$ && target.$expression$ === this.$expression$
};
PropertyReferenceValue.prototype.$isDirty$ = function() {
  var valueProvider = this.$valueProvider$;
  for(var expression = this.$expression$;valueProvider instanceof PassthroughValue;) {
    expression = valueProvider.getExpression(expression);
    valueProvider = valueProvider.$getComponent$()
  }
  return $A.$renderingService$.$isDirtyValue$(expression, valueProvider)
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "isDirty", PropertyReferenceValue.prototype.$isDirty$);
PropertyReferenceValue.prototype.$destroy$ = function() {
  this.$valueProvider$ = this.$context$ = null;
  this.$isValid$ = false
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "destroy", PropertyReferenceValue.prototype.$destroy$);
PropertyReferenceValue.prototype.toString = function() {
  return"{!" + this.$expression$ + "}"
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "toString", PropertyReferenceValue.prototype.toString);
PropertyReferenceValue.prototype.toJSON = function() {
  return this.evaluate()
};
Aura.$Value$.$PropertyReferenceValue$ = PropertyReferenceValue;
function FunctionCallValue(config, valueProvider) {
  this.$valueProvider$ = valueProvider;
  this.$byValue$ = config["byValue"];
  if(!(config["code"] instanceof Function)) {
    config["code"] = (0, eval)($A.$lockerService$.$trusted$["createScript"]("(" + config["code"] + ")"))
  }
  this.code = config["code"];
  this.$context$ = $A.$clientService$.$currentAccess$;
  this.$args$ = [];
  for(var i = 0;i < config["args"].length;i++) {
    this.$args$.push(valueFactory.create(config["args"][i], valueProvider))
  }
}
FunctionCallValue.prototype.$expressionFunctions$ = new ExpressionFunctions;
FunctionCallValue.prototype.$isDirty$ = function() {
  for(var i = 0;i < this.$args$.length;i++) {
    var arg = this.$args$[i];
    if($A["util"].$isExpression$(arg) && arg.$isDirty$()) {
      return true
    }
  }
  return false
};
FunctionCallValue.prototype.evaluate = function(valueProvider) {
  $A.$clientService$.$setCurrentAccess$(this.$context$);
  try {
    var result = this.code(valueProvider || this.$valueProvider$, this.$expressionFunctions$);
    if(!this.hasOwnProperty("result")) {
      this["result"] = result
    }
    return result
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
};
FunctionCallValue.prototype.$addChangeHandler$ = function(cmp, key, fcv) {
  if(this.$byValue$) {
    return
  }
  for(var i = 0;i < this.$args$.length;i++) {
    var arg = this.$args$[i];
    if($A["util"].$isExpression$(arg)) {
      if(arg instanceof PropertyReferenceValue) {
        arg.$addChangeHandler$(cmp, key, fcv ? fcv : this.$getChangeHandler$(cmp, key, this))
      }else {
        arg.$addChangeHandler$(cmp, key, fcv || this)
      }
    }
  }
};
FunctionCallValue.prototype.$getChangeHandler$ = function(cmp, key, fcv) {
  return function FunctionCallValue$getChangeHandler() {
    var result = fcv.evaluate();
    if(fcv["result"] !== result) {
      var oldValue = fcv["result"];
      fcv["result"] = result;
      $A.$renderingService$.$addDirtyValue$(key, cmp);
      cmp.$fireChangeEvent$(key, oldValue, result)
    }
  }
};
FunctionCallValue.prototype.$removeChangeHandler$ = function(cmp, key) {
  if(this.$byValue$) {
    return
  }
  for(var i = 0;i < this.$args$.length;i++) {
    var arg = this.$args$[i];
    if($A["util"].$isExpression$(arg)) {
      arg.$removeChangeHandler$(cmp, key)
    }
  }
};
FunctionCallValue.prototype.$destroy$ = function() {
  this.$args$ = this.code = this.$valueProvider$ = null
};
FunctionCallValue.prototype.toString = function() {
  return this.code.toString()
};
Aura.$Value$.$FunctionCallValue$ = FunctionCallValue;
function PassthroughValue(primaryProviders, component) {
  this.$primaryProviders$ = primaryProviders;
  this.$component$ = component;
  this.$references$ = {};
  this.$handlers$ = {}
}
goog.$exportSymbol$("PassthroughValue", PassthroughValue);
PassthroughValue.prototype.$addValueHandler$ = function(config) {
  var path = config.value.split(".");
  if(!this.$primaryProviders$.hasOwnProperty(path[0])) {
    this.$component$.$addValueHandler$(config);
    return
  }
  this.$addChangeHandler$(config)
};
goog.$exportProperty$(PassthroughValue.prototype, "addValueHandler", PassthroughValue.prototype.$addValueHandler$);
PassthroughValue.prototype.$addChangeHandler$ = function(config) {
  var path = config.value.split(".");
  if(!this.$primaryProviders$.hasOwnProperty(path[0])) {
    this.$component$.$addChangeHandler$(config);
    return
  }
  var provider = this.$primaryProviders$[path[0]];
  if($A["util"].$isExpression$(provider)) {
    var reference = path.length > 1 ? provider.$getReference$(path.slice(1).join(".")) : provider;
    if(reference) {
      reference.$addChangeHandler$(config["cmp"], reference.getExpression(), config["method"]);
      return
    }
  }
  var event = config["event"];
  var handlers = this.$handlers$[event];
  if(!handlers) {
    handlers = this.$handlers$[event] = {}
  }
  var expression = config["value"];
  if($A["util"].$isExpression$(expression)) {
    expression = expression.getExpression()
  }
  if(!handlers[expression]) {
    handlers[expression] = []
  }
  for(var i = 0;i < handlers[expression].length;i++) {
    if(handlers[expression][i] === config["method"] || config["id"] && config["key"] && handlers[expression][i]["id"] === config["id"] && handlers[expression][i]["key"] === config["key"]) {
      return
    }
  }
  handlers[expression].push(config["method"])
};
PassthroughValue.prototype.$deIndex$ = function() {
  for(var valueProvider = this.$getComponent$();valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  if(!valueProvider) {
    return
  }
  valueProvider.$deIndex$.apply(valueProvider, arguments)
};
goog.$exportProperty$(PassthroughValue.prototype, "deIndex", PassthroughValue.prototype.$deIndex$);
PassthroughValue.prototype.$fireChangeEvent$ = function(key, oldValue, value, index) {
  var handlers = this.$handlers$["change"];
  var observers = [];
  var keypath = key + ".";
  for(var handler in handlers) {
    if(handler === key || handler.indexOf(keypath) === 0 || key.indexOf(handler + ".") === 0) {
      observers = observers.concat(handlers[handler])
    }
  }
  if(observers.length) {
    var eventDef = $A.get("e").$getEventDef$("aura:valueChange");
    var dispatcher = {};
    dispatcher[eventDef.$getDescriptor$().$getQualifiedName$()] = {"default":observers};
    var changeEvent = new Aura.$Event$.$Event$({"eventDef":eventDef, "eventDispatcher":dispatcher});
    changeEvent.$setParams$({"expression":key, "value":value, "oldValue":oldValue, "index":index});
    changeEvent.$fire$()
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "fireChangeEvent", PassthroughValue.prototype.$fireChangeEvent$);
PassthroughValue.prototype.get = function(key) {
  if(!$A["util"].$isString$(key)) {
    var msg = "The provided key (" + key + ") is not a string and cannot be used to look up values for the current component.";
    throw new $A.$auraError$(msg);
  }
  var path = key.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    var value = null;
    if(path.length > 1) {
      value = $A.$expressionService$.$resolve$(key, this.$primaryProviders$)
    }else {
      value = this.$primaryProviders$[key]
    }
    for(;$A["util"].$isExpression$(value);) {
      value = value.evaluate()
    }
    return value
  }else {
    return this.$component$.get(key)
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "get", PassthroughValue.prototype.get);
PassthroughValue.prototype.$getComponent$ = function() {
  return this.$component$
};
goog.$exportProperty$(PassthroughValue.prototype, "getComponent", PassthroughValue.prototype.$getComponent$);
PassthroughValue.prototype.$getPrimaryProviderKeys$ = function() {
  return Object.keys(this.$primaryProviders$)
};
goog.$exportProperty$(PassthroughValue.prototype, "getPrimaryProviderKeys", PassthroughValue.prototype.$getPrimaryProviderKeys$);
PassthroughValue.prototype.$getDef$ = function() {
  for(var valueProvider = this;valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  return valueProvider.$getDef$()
};
PassthroughValue.prototype.getExpression = function(expression) {
  var path = $A["util"].isArray(expression) ? expression : expression.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    var provider = this.$primaryProviders$[path[0]];
    if(provider instanceof PassthroughValue) {
      return provider.getExpression(path)
    }
    if(provider instanceof PropertyReferenceValue) {
      path.splice(0, 1, provider.getExpression());
      return path.join(".")
    }
  }
  return expression
};
PassthroughValue.prototype.$getReference$ = function(key) {
  key = aura.$expressionService$.normalize(key);
  var path = key.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    if(!this.$references$.hasOwnProperty(key)) {
      this.$references$[key] = new PropertyReferenceValue(key, this)
    }
    return this.$references$[key]
  }else {
    return this.$component$.$getReference$(key)
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "getReference", PassthroughValue.prototype.$getReference$);
PassthroughValue.prototype.index = function() {
  for(var valueProvider = this.$getComponent$();valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  if(!valueProvider) {
    return
  }
  valueProvider.index.apply(valueProvider, arguments)
};
goog.$exportProperty$(PassthroughValue.prototype, "index", PassthroughValue.prototype.index);
PassthroughValue.prototype.$removeValueHandler$ = function(config) {
  var path = config.value.split(".");
  if(!this.$primaryProviders$.hasOwnProperty(path[0])) {
    this.$component$.$removeValueHandler$(config);
    return
  }
  var provider = this.$primaryProviders$[path[0]];
  if($A["util"].$isExpression$(provider)) {
    var reference = provider.$getReference$(path.slice(1).join("."));
    if(reference) {
      reference.$removeChangeHandler$($A.$getCmp$(config["id"]), reference.getExpression());
      return
    }
  }
  var event = config["event"];
  var handlers = this.$handlers$[event];
  if(handlers) {
    var expression = config["value"];
    if($A["util"].$isExpression$(expression)) {
      expression = expression.getExpression()
    }
    if(handlers[expression]) {
      for(var i = 0;i < handlers[expression].length;i++) {
        var method = handlers[expression][i];
        if(method === config["method"] || config["id"] && config["key"] && method["id"] === config["id"] && method["key"] === config["key"]) {
          handlers[expression].splice(i--, 1)
        }
      }
    }
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "removeValueHandler", PassthroughValue.prototype.$removeValueHandler$);
PassthroughValue.prototype.set = function(key, value, ignoreChanges) {
  if(typeof key !== "string") {
    throw new $A.$auraError$("PassthroughValue.set: 'key' must be a string. Found " + key);
  }
  var path = key.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    var provider = this.$primaryProviders$[path[0]];
    var fullPath = this.getExpression(key);
    var target = this.$primaryProviders$;
    var subKey = path.slice(1).join(".");
    key = path[path.length - 1];
    if(path.length > 1 && $A["util"].$isExpression$(provider)) {
      var reference = provider.$getReference$(subKey);
      if(reference) {
        reference.set(value);
        return undefined
      }
    }
    if(path.length > 1) {
      target = $A.$expressionService$.$resolve$(path.slice(0, path.length - 1), target)
    }
    if(!target) {
      return undefined
    }
    var oldValue = target[key];
    target[key] = value;
    if(!ignoreChanges) {
      for(var valueProvider = this.$component$;valueProvider instanceof PassthroughValue;) {
        valueProvider = valueProvider.$getComponent$()
      }
      valueProvider.$fireChangeEvent$(fullPath, oldValue, value, fullPath);
      valueProvider.$markDirty$(fullPath);
      this.$fireChangeEvent$(key, oldValue, value, key)
    }
    return value
  }
  return this.$component$.set(key, value, ignoreChanges)
};
goog.$exportProperty$(PassthroughValue.prototype, "set", PassthroughValue.prototype.set);
PassthroughValue.prototype.$isValid$ = function() {
  for(var valueProvider = this.$getComponent$();valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  if($A["util"].$isComponent$(valueProvider)) {
    return valueProvider.$isValid$()
  }
  return false
};
var valueFactory = {create:function create(valueConfig, component) {
  if(!valueConfig) {
    return valueConfig
  }
  if(typeof valueConfig === "object" && aura["util"].$isPlainObject$(valueConfig)) {
    if(valueConfig["exprType"] === "PROPERTY") {
      var isGlobal = valueConfig["path"].charAt(0) === "$";
      if(valueConfig["byValue"]) {
        return(isGlobal ? $A : component).get(valueConfig["path"])
      }
      if(isGlobal) {
        return $A.$expressionService$.$getReference$(valueConfig["path"], component)
      }else {
        if($A["util"].$isComponent$(component)) {
          return component.$getReference$(valueConfig["path"], component)
        }
      }
      return new PropertyReferenceValue(valueConfig["path"], component)
    }else {
      if(valueConfig["exprType"] === "FUNCTION") {
        return new FunctionCallValue(valueConfig, component)
      }else {
        var childConfig = {};
        for(var key in valueConfig) {
          childConfig[key] = valueFactory.create(valueConfig[key], component)
        }
        valueConfig = childConfig
      }
    }
  }else {
    if(aura["util"].$isString$(valueConfig) && valueConfig.charAt(0) === "{" && component) {
      if(valueConfig.charAt(1) === "!" || valueConfig.charAt(1) === "#") {
        $A.log("Aura ValueFactory: String expressions are no longer supported.")
      }
    }
  }
  return valueConfig
}};
Aura.$Value$.$ValueFactory$ = valueFactory;
function ExpressionFunctions() {
}
goog.$exportSymbol$("ExpressionFunctions", ExpressionFunctions);
ExpressionFunctions.prototype.$eq$ = function(a, b) {
  if(a === undefined || a === null) {
    return b === undefined || b === null
  }
  return a === b
};
goog.$exportProperty$(ExpressionFunctions.prototype, "eq", ExpressionFunctions.prototype.$eq$);
ExpressionFunctions.prototype.$ne$ = function(a, b) {
  if(a === undefined || a === null) {
    return b !== undefined && b !== null
  }
  return a !== b
};
goog.$exportProperty$(ExpressionFunctions.prototype, "ne", ExpressionFunctions.prototype.$ne$);
ExpressionFunctions.prototype.add = function(a, b) {
  if(a === undefined || a === null) {
    if(typeof b === "string") {
      return b
    }else {
      if(b === undefined || b === null) {
        return""
      }
    }
  }
  if(b === undefined || b === null) {
    if(typeof a === "string") {
      return a
    }
  }
  return a + b
};
goog.$exportProperty$(ExpressionFunctions.prototype, "add", ExpressionFunctions.prototype.add);
ExpressionFunctions.prototype.empty = Aura.$Utils$.$Util$.prototype.$isEmpty$;
goog.$exportProperty$(ExpressionFunctions.prototype, "empty", ExpressionFunctions.prototype.empty);
ExpressionFunctions.prototype.$format$ = function() {
  if(arguments.length === 0) {
    return""
  }
  var a0 = arguments[0];
  if(a0 === undefined || a0 === null || !$A["util"].$isFunction$(a0.toString)) {
    return""
  }
  if(arguments.length === 1) {
    return a0 + ""
  }
  var formatArguments = [];
  for(var i = 0;i < arguments.length;i++) {
    var ai = arguments[i];
    formatArguments[i] = ai === undefined || ai === null ? "" : ai
  }
  return $A["util"].$format$.apply($A["util"], formatArguments)
};
goog.$exportProperty$(ExpressionFunctions.prototype, "format", ExpressionFunctions.prototype.$format$);
ExpressionFunctions.prototype.$token$ = function(token) {
  try {
    return $A.$getToken$(token)
  }catch(e) {
    var message = e["message"] || "ExpressionFunctions token error";
    $A.$warning$(message, e)
  }
  return""
};
goog.$exportProperty$(ExpressionFunctions.prototype, "token", ExpressionFunctions.prototype.$token$);
ExpressionFunctions.prototype.join = function(separator) {
  var params = [];
  for(var i = 1;i < arguments.length;i++) {
    if(!this.empty(arguments[i])) {
      params.push(arguments[i])
    }
  }
  return params.join(separator)
};
goog.$exportProperty$(ExpressionFunctions.prototype, "join", ExpressionFunctions.prototype.join);
Aura.$Value$.$ExpressionFunctions$ = ExpressionFunctions;
function ValueDef(config) {
  this.name = config["name"]
}
ValueDef.prototype.getName = function() {
  return this.name
};
Aura.$Model$.$ValueDef$ = ValueDef;
function ModelDef(config) {
  this.$descriptor$ = new DefDescriptor(config["descriptor"]);
  this.$members$ = [];
  for(var i = 0;i < config["members"].length;i++) {
    var m = config["members"][i];
    this.$members$.push(new ValueDef(m))
  }
}
goog.$exportSymbol$("ModelDef", ModelDef);
ModelDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
ModelDef.prototype.$newInstance$ = function(config) {
  return new Model(this, config)
};
ModelDef.prototype.$getMembers$ = function() {
  return this.$members$
};
Aura.$Model$.$ModelDef$ = ModelDef;
function Model(def, data) {
  this.$def$ = def;
  this.data = $A["util"].apply({}, data, true, true);
  if(def) {
    var members = def.$getMembers$();
    for(var i = 0;i < members.length;i++) {
      var name = members[i].getName();
      if(!this.data.hasOwnProperty(name)) {
        this.data[name] = null
      }
    }
  }
}
Model.prototype.get = function(key) {
  var value = undefined;
  if(key.indexOf(".") < 0) {
    value = this.data[key]
  }else {
    value = aura.$expressionService$.$resolve$(key, this.data)
  }
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  return value
};
Model.prototype.set = function(key, value) {
  var oldValue;
  var target = this.data;
  var step = key;
  if(key.indexOf(".") >= 0) {
    var path = key.split(".");
    target = aura.$expressionService$.$resolve$(path.slice(0, path.length - 1), target);
    $A.assert(target, "Model.set: unable to resolve '" + key + "'.");
    step = path[path.length - 1]
  }
  oldValue = target[step];
  if(oldValue instanceof PropertyReferenceValue) {
    oldValue.set(value)
  }else {
    target[step] = value
  }
};
Model.prototype.$destroy$ = function() {
  for(var x in this.data) {
    if(this.data.hasOwnProperty(x)) {
      this.data[x] = undefined
    }
  }
};
Aura.$Model$.$Model$ = Model;
function ComponentClassRegistry() {
  this.$classExporter$ = {};
  this.$classConstructors$ = {}
}
ComponentClassRegistry.prototype.$customConstructorMap$ = {"aura$text":TextComponent, "aura$html":HtmlComponent, "aura$expression":ExpressionComponent, "aura$if":IfComponent, "aura$iteration":IterationComponent, "aura$component":BaseComponent};
ComponentClassRegistry.prototype.$hasComponentClass$ = function(descriptor) {
  return descriptor in this.$classExporter$ || descriptor in this.$classConstructors$
};
ComponentClassRegistry.prototype.$addComponentClass$ = function(descriptor, exporter) {
  $A.assert($A["util"].$isString$(descriptor), "Component class descriptor is invalid: " + descriptor);
  $A.assert($A["util"].$isFunction$(exporter), "Component class exporter is not a function: " + descriptor);
  if(!this.$hasComponentClass$(descriptor)) {
    this.$classExporter$[descriptor] = exporter
  }
};
goog.$exportSymbol$("ComponentClassRegistry.prototype.addComponentClass", ComponentClassRegistry.prototype.$addComponentClass$);
ComponentClassRegistry.prototype.$getComponentClass$ = function(descriptor, def) {
  var storedConstructor = this.$classConstructors$[descriptor];
  if(!storedConstructor) {
    var exporter = this.$classExporter$[descriptor];
    if(exporter) {
      var componentProperties = exporter();
      storedConstructor = this.$buildComponentClass$(componentProperties);
      this.$classConstructors$[descriptor] = storedConstructor;
      this.$classExporter$[descriptor] = null
    }else {
      if(def && def.$interop$) {
        return this.$buildInteropComponentClass$(descriptor, def)
      }
    }
  }
  return storedConstructor
};
goog.$exportSymbol$("ComponentClassRegistry.prototype.getComponentClass", ComponentClassRegistry.prototype.$getComponentClass$);
ComponentClassRegistry.prototype.$buildInteropComponentClass$ = function(descriptor, def) {
  var interopClass = Aura.$Component$.$InteropModule$;
  if(def.$hasElementConstructor$()) {
    interopClass = Aura.$Component$.$InteropComponent$
  }
  var interopCmpClass = this.$buildConstructor$({"interopClass":def.$interopClass$, "interopCtor":def.$interopCtor$}, def.$interopClassName$, interopClass);
  this.$classConstructors$[descriptor] = interopCmpClass;
  return interopCmpClass
};
ComponentClassRegistry.prototype.$buildComponentClass$ = function(componentProperties) {
  this.$buildInheritance$(componentProperties);
  this.$buildLibraries$(componentProperties);
  var componentConstructor = this.$buildConstructor$(componentProperties);
  return componentConstructor
};
ComponentClassRegistry.prototype.$buildInheritance$ = function(componentProperties) {
  var superDescriptor = componentProperties["meta"]["extends"];
  var superConstructor = this.$getComponentClass$(superDescriptor);
  componentProperties["controller"] = componentProperties["controller"] || {};
  var superController = superConstructor && superConstructor.prototype["controller"];
  if(superController) {
    componentProperties["controller"] = Object.assign(Object.create(superController), componentProperties["controller"])
  }
  componentProperties["helper"] = componentProperties["helper"] || {};
  var superHelper = superConstructor && superConstructor.prototype["helper"];
  if(superHelper) {
    componentProperties["helper"] = Object.assign(Object.create(superHelper), componentProperties["helper"])
  }
};
ComponentClassRegistry.prototype.$buildLibraries$ = function(componentProperties) {
  var componentImports = componentProperties["meta"]["imports"];
  if(componentImports) {
    var helper = componentProperties["helper"];
    for(var property in componentImports) {
      var descriptor = componentImports[property];
      var library = $A.$componentService$.$getLibrary$(descriptor);
      if(!library) {
        try {
          library = $A.$componentService$.$evaluateModuleDef$(descriptor)
        }catch(e) {
        }
      }
      var isModuleWithOnlyDefaultExport = library !== undefined && Object.getOwnPropertyNames(library).length === 2 && Object.prototype.hasOwnProperty.call(library, "default") && library["__esModule"];
      helper[property] = isModuleWithOnlyDefaultExport ? library["default"] : library
    }
    componentProperties["helper"] = helper
  }
};
ComponentClassRegistry.prototype.$buildConstructor$ = function(componentProperties, name, Ctor) {
  var componentConstructor;
  var className = name || componentProperties["meta"]["name"];
  Ctor = Ctor || this.$customConstructorMap$[className] || Component;
  componentConstructor = function(config) {
    Ctor.call(this, config)
  };
  componentConstructor.prototype = Object.create(Ctor.prototype);
  componentConstructor.prototype.constructor = componentConstructor;
  var constructorPrototype = componentConstructor.prototype;
  for(var key in componentProperties) {
    if(constructorPrototype[key] === undefined) {
      constructorPrototype[key] = componentProperties[key]
    }
  }
  return componentConstructor
};
Aura.$Component$.$ComponentClassRegistry$ = ComponentClassRegistry;
function ComponentDefLoader() {
  this.$pending$ = null;
  this.$loading$ = 0;
  this.$counter$ = 0;
  this.$scriptTagCounter$ = 0;
  this.$requestedDescriptors$ = {};
  this.$lastURIComponentDefinitionsParameterName$;
  this.$lastURIComponentDefinitionsParameterNameAuth$
}
ComponentDefLoader.$STYLE_param$ = "_style";
ComponentDefLoader.$DESCRIPTOR_param$ = "_def";
ComponentDefLoader.$UID_param$ = "_uid";
ComponentDefLoader.$APPUID_param$ = "_au";
ComponentDefLoader.$AURA_APP_param$ = "aura.app";
ComponentDefLoader.$AURA_MODE_param$ = "aura.mode";
ComponentDefLoader.$UID_default$ = "LATEST";
ComponentDefLoader.$MARKUP$ = "markup://";
ComponentDefLoader.$RESTRICTED_KEY$ = "restricted";
ComponentDefLoader.$UNRESTRICTED_KEY$ = "unrestricted";
ComponentDefLoader.$UNKNOWN_ERROR_MESSAGE_PREFIX$ = "An unknown error occurred attempting to fetch definitions at: ";
ComponentDefLoader.$MARK_NS$ = "transport";
ComponentDefLoader["MARK_NAME"] = "request";
ComponentDefLoader.prototype.$getURIComponentDefinitionParameters$ = function() {
  var uri = this.$getBaseURI$();
  if(this.$lastURIComponentDefinitionsParameterName$ === undefined) {
    var startNameIndex = uri.lastIndexOf("\x26") + 1;
    var endNameIndex = uri.indexOf("\x3d", startNameIndex);
    this.$lastURIComponentDefinitionsParameterName$ = uri.substr(startNameIndex, endNameIndex - startNameIndex)
  }
  return uri
};
ComponentDefLoader.prototype.$getURIComponentDefinitionParametersAuth$ = function() {
  var uri = this.$getBaseURIAuth$();
  if(uri && this.$lastURIComponentDefinitionsParameterNameAuth$ === undefined) {
    var startNameIndex = uri.lastIndexOf("\x26") + 1;
    var endNameIndex = uri.indexOf("\x3d", startNameIndex);
    this.$lastURIComponentDefinitionsParameterNameAuth$ = uri.substr(startNameIndex, endNameIndex - startNameIndex)
  }
  return uri
};
ComponentDefLoader.prototype.$getBaseURI$ = function() {
  return $A.$clientService$.$getAuraCmpDefBaseURI$()
};
ComponentDefLoader.prototype.$getBaseURIAuth$ = function() {
  return $A.$clientService$.$getAuraCmpDefBaseURIAuth$()
};
ComponentDefLoader.prototype.$processRequested$ = function() {
  for(var descriptor in this.$requestedDescriptors$) {
    if($A.$componentService$.$hasCacheableDefinitionOfAnyType$(descriptor)) {
      for(var i = 0;i < this.$requestedDescriptors$[descriptor].length;i++) {
        this.$requestedDescriptors$[descriptor][i].$finalize$()
      }
      delete this.$requestedDescriptors$[descriptor]
    }
  }
};
ComponentDefLoader.prototype.$rejectPendingRequestedDescriptor$ = function(descriptor, error_message) {
  if(this.$requestedDescriptors$[descriptor]) {
    for(var j = 0;j < this.$requestedDescriptors$[descriptor].length;j++) {
      this.$requestedDescriptors$[descriptor][j].error(error_message)
    }
    delete this.$requestedDescriptors$[descriptor]
  }
};
ComponentDefLoader.prototype.$getDescriptorsFromURI$ = function(uri) {
  var queryString = uri.slice(uri.indexOf("?") + 1);
  var parameters = queryString.split("\x26");
  var results = [];
  for(var p = 0;p < parameters.length;p++) {
    var parts = parameters[p].split("\x3d");
    if(parts.length === 2) {
      var paramName = parts[0];
      if(paramName === ComponentDefLoader.$DESCRIPTOR_param$) {
        results.push(parts[1])
      }else {
        if(paramName !== ComponentDefLoader.$AURA_APP_param$ && paramName !== ComponentDefLoader.$AURA_MODE_param$ && paramName[0] !== "_") {
          var names = parts[1].split(",");
          for(var n = 0;n < names.length;n++) {
            results.push(ComponentDefLoader.$MARKUP$ + paramName + ":" + names[n])
          }
        }
      }
    }
  }
  return results
};
ComponentDefLoader.prototype.$rejectPendingRequested$ = function(uri, error_message) {
  var descriptors = this.$getDescriptorsFromURI$(uri);
  for(var i = 0;i < descriptors.length;i++) {
    this.$rejectPendingRequestedDescriptor$(descriptors[i], error_message)
  }
};
ComponentDefLoader.prototype.$buildBundleComponentNamespace$ = function(descriptors, descriptorMap, existingRequested) {
  if(!$A["util"].isArray(descriptors)) {
    return{}
  }
  var cdnAvailable = !!$A.getContext().$cdnHost$;
  var namespaceMap = {};
  namespaceMap[ComponentDefLoader.$RESTRICTED_KEY$] = {};
  if(cdnAvailable) {
    namespaceMap[ComponentDefLoader.$UNRESTRICTED_KEY$] = {}
  }
  for(var i = 0;i < descriptors.length;i++) {
    if($A.$componentService$.$hasCacheableDefinitionOfAnyType$(descriptors[i])) {
      continue
    }
    if($A["util"].isArray(this.$requestedDescriptors$[descriptors[i]])) {
      this.$requestedDescriptors$[descriptors[i]].push(existingRequested);
      existingRequested.$counter$++;
      continue
    }
    this.$requestedDescriptors$[descriptors[i]] = [];
    var descriptor = new Aura.$System$.$DefDescriptor$(descriptors[i]);
    var namespace = descriptor.$getNamespace$();
    var name = descriptor.getName();
    var isRestrictedNamespace = !$A.$clientService$.$isInternalNamespace$(namespace);
    var restrictedKey = isRestrictedNamespace || !cdnAvailable ? ComponentDefLoader.$RESTRICTED_KEY$ : ComponentDefLoader.$UNRESTRICTED_KEY$;
    if(!(namespace in namespaceMap[restrictedKey])) {
      namespaceMap[restrictedKey][namespace] = {}
    }
    if($A["util"].$isUndefinedOrNull$(namespaceMap[restrictedKey][namespace][name])) {
      namespaceMap[restrictedKey][namespace][name] = descriptorMap[descriptors[i]]
    }
  }
  return namespaceMap
};
ComponentDefLoader.prototype.$buildBundleComponentUri$ = function(descriptorMap) {
  descriptorMap = this.$updateDescriptorMapWithPrefetchedUids$(descriptorMap);
  var descriptors = Object.keys(descriptorMap);
  var existingRequested = {$counter$:0, $finalize$:function() {
    this.$counter$--;
    if(this.$counter$ <= 0) {
      this.$resolve$()
    }
  }, error:function(msg) {
    this.$reject$(msg)
  }};
  var namespaceMap = this.$buildBundleComponentNamespace$(descriptors, descriptorMap, existingRequested);
  var baseURI = this.$getURIComponentDefinitionParameters$();
  var baseURIAuth = this.$getURIComponentDefinitionParametersAuth$();
  var maxLength;
  if($A["util"].$isIE$) {
    maxLength = 1800
  }else {
    maxLength = 5E3
  }
  var uris = [];
  var restrictedKeys = [ComponentDefLoader.$RESTRICTED_KEY$, ComponentDefLoader.$UNRESTRICTED_KEY$];
  for(var keyIdx = 0;keyIdx < restrictedKeys.length;keyIdx++) {
    var restrictedKey = restrictedKeys[keyIdx];
    var uri = "";
    var numberOfDescriptorsInUid = 0;
    var uid = "";
    var namespaceMapEntries = namespaceMap[restrictedKey];
    if(!namespaceMapEntries) {
      continue
    }
    var namespaces = Object.keys(namespaceMapEntries).sort();
    if(namespaces.length === 0) {
      continue
    }
    var hasRestrictedNamespaces = restrictedKey === ComponentDefLoader.$RESTRICTED_KEY$;
    for(var i = 0;i < namespaces.length;i++) {
      var namespace = namespaces[i];
      var name;
      var names = Object.keys(namespaceMapEntries[namespace]).sort();
      if(namespaces.length === 1 && names.length === 1) {
        name = names[0];
        uri = "\x26" + ComponentDefLoader.$DESCRIPTOR_param$ + "\x3d" + ComponentDefLoader.$MARKUP$ + namespace + ":" + name;
        if($A["util"].$isString$(namespaceMapEntries[namespace][name])) {
          uid = namespaceMapEntries[namespace][name];
          numberOfDescriptorsInUid++
        }
        uris.push([uri, uid, hasRestrictedNamespaces, numberOfDescriptorsInUid]);
        uri = "";
        break
      }
      var additionalURI = "\x26" + namespace + "\x3d" + names.join(",");
      if(additionalURI.length + uri.length > maxLength) {
        if(additionalURI.length > maxLength) {
          additionalURI = "\x26" + namespace + "\x3d" + names[0];
          var additional_def_uid = namespaceMapEntries[namespace][names[0]];
          if($A["util"].$isString$(additional_def_uid)) {
            if(additional_def_uid.length === 0) {
              numberOfDescriptorsInUid = -1E3
            }
            uid += additional_def_uid;
            numberOfDescriptorsInUid++
          }
          for(var name_idx = 1;name_idx < names.length;name_idx++) {
            name = names[name_idx];
            if(additionalURI.length + name.length + uri.length > maxLength) {
              uri += additionalURI;
              uris.push([uri, uid, hasRestrictedNamespaces, numberOfDescriptorsInUid]);
              numberOfDescriptorsInUid = 0;
              if($A["util"].$isString$(namespaceMapEntries[namespace][name])) {
                uid = namespaceMapEntries[namespace][name];
                numberOfDescriptorsInUid++
              }else {
                uid = "";
                numberOfDescriptorsInUid = -1E3
              }
              additionalURI = "\x26" + namespace + "\x3d" + name;
              uri = ""
            }else {
              additionalURI += "," + name;
              additional_def_uid = namespaceMapEntries[namespace][name];
              if($A["util"].$isString$(additional_def_uid)) {
                if(additional_def_uid.length === 0) {
                  numberOfDescriptorsInUid = -1E3
                }
                uid += additional_def_uid;
                numberOfDescriptorsInUid++
              }
            }
          }
          uri = additionalURI;
          names.length = 0
        }else {
          uris.push([uri, uid, hasRestrictedNamespaces, numberOfDescriptorsInUid]);
          uid = "";
          uri = additionalURI;
          numberOfDescriptorsInUid = 0
        }
      }else {
        uri += additionalURI
      }
      for(var j = 0;j < names.length;j++) {
        var def_uid = namespaceMapEntries[namespace][names[j]];
        if($A["util"].$isString$(def_uid)) {
          uid += def_uid;
          numberOfDescriptorsInUid++
        }
      }
    }
    if(uri !== "") {
      uris.push([uri, uid, hasRestrictedNamespaces, numberOfDescriptorsInUid])
    }
  }
  var processedURI = [];
  if(existingRequested.$counter$ > 0) {
    processedURI.push(new Promise(function(resolve, reject) {
      existingRequested.$resolve$ = resolve;
      existingRequested.$reject$ = reject
    }))
  }
  var appIsNotRestricted = $A.$clientService$.$isInternalNamespace$($A.$getRoot$().$getDef$().$getDescriptor$().$getNamespace$());
  var cdnEnabledForLatestDefRequest = $A.$clientService$.$isCdnEnabledForLatestDefRequest$();
  var isLiveEnabledForRestrictedDefRequest = $A.$clientService$.$isLiveEnabledForRestrictedDefRequest$();
  var def = 0;
  for(var pathPrefix;def < uris.length;def++) {
    var finalURI = this.$buildURIString$(uris[def][0], uris[def][1], isLiveEnabledForRestrictedDefRequest && uris[def][2], uris[def][3]);
    var host = $A.$clientService$.$_host$;
    if(!uris[def][2] && (cdnEnabledForLatestDefRequest || uris[def][1].length) && appIsNotRestricted) {
      pathPrefix = baseURI;
      host = $A.getContext().$cdnHost$ || host
    }else {
      pathPrefix = baseURIAuth ? baseURIAuth : baseURI
    }
    processedURI.push(host + pathPrefix + finalURI.$uriString$)
  }
  return processedURI
};
ComponentDefLoader.prototype.$buildURIString$ = function(uri, uid, needsIsLiveFlag, numberOfDescriptorsInUid) {
  var liveParam;
  if(!uid.length) {
    this.$counter$++;
    uid = ComponentDefLoader.$UID_default$;
    if(needsIsLiveFlag) {
      liveParam = "\x26aura.live\x3d1"
    }
  }else {
    if(numberOfDescriptorsInUid > 1) {
      uid = $A["util"].$getHashCode$(uid)
    }
  }
  return{$uriString$:uri + "\x26" + ComponentDefLoader.$UID_param$ + "\x3d" + uid + (liveParam || ""), uid:uid}
};
ComponentDefLoader.prototype.$updateDescriptorMapWithPrefetchedUids$ = function(descriptorMap) {
  var componentUids = $A.$clientService$.$getComponentUids$();
  if(componentUids && Object.keys(componentUids).length > 0 && descriptorMap) {
    var newDescriptorMap = {};
    for(var key in descriptorMap) {
      var uid = null;
      if(descriptorMap[key]) {
        uid = descriptorMap[key]
      }else {
        if(componentUids[key]) {
          uid = componentUids[key].uid
        }
      }
      if(uid) {
        newDescriptorMap[key] = uid
      }else {
        newDescriptorMap = {};
        break
      }
    }
    if(Object.keys(newDescriptorMap).length > 0 && Object.keys(newDescriptorMap).length == Object.keys(descriptorMap).length) {
      return newDescriptorMap
    }
  }
  return descriptorMap
};
ComponentDefLoader.prototype.$getScriptPromises$ = function(descriptorMap) {
  var scriptPromises = [];
  var URIs;
  if($A.$clientService$.$isAuraBundlingDisabled$()) {
    URIs = [];
    for(var key in descriptorMap) {
      if(Object.prototype.hasOwnProperty.call(descriptorMap, key)) {
        var value = descriptorMap[key];
        var obj = {};
        obj[key] = value;
        Array.prototype.push.apply(URIs, this.$buildBundleComponentUri$(obj))
      }
    }
  }else {
    URIs = this.$buildBundleComponentUri$(descriptorMap)
  }
  for(var idx = 0;idx < URIs.length;) {
    if(!$A["util"].$isString$(URIs[idx])) {
      scriptPromises.push(URIs[idx])
    }else {
      scriptPromises.push(this.$generateScriptTag$(URIs[idx]))
    }
    idx++
  }
  return scriptPromises
};
ComponentDefLoader.prototype.$retrievePending$ = function(pending) {
  var scriptPromises = this.$getScriptPromises$(pending.$descriptorMap$);
  var that = this;
  Promise["all"](scriptPromises)["then"](function retrievePendingSuccess() {
    for(var j = 0;j < pending.$callbacks$.length;j++) {
      var scope = {$idx$:j, total:pending.$callbacks$.length, $remaining$:pending.$callbacks$.length - j - 1};
      try {
        pending.$callbacks$[j].call(scope)
      }catch(e) {
        var errorMessage = e.message ? e.message : "Error in callback provided to component creation.";
        $A.$reportError$(errorMessage, e)
      }
    }
  }, function retrievePendingError(e) {
    if($A["util"].$isObject$(e) && e.hasOwnProperty("event")) {
      try {
        $A.$clientService$.$setCurrentAccess$(pending.$access$);
        $A.$clientService$.$parseAndFireEvent$(e.event)
      }catch(e1) {
      }finally {
        $A.$clientService$.$releaseCurrentAccess$()
      }
    }
    var j = 0;
    for(var p_length = pending.$callbacks$.length;j < p_length;j++) {
      try {
        pending.$callbacks$[j](e)
      }catch(callbackError) {
        var errorMessage = callbackError.message ? callbackError.message : "Error in callback provided to component creation.";
        if(e && e.message) {
          errorMessage += "\nAdditional exception on component load: " + e.message
        }
        $A.$reportError$(errorMessage, callbackError)
      }
    }
    if(pending.$callbacks$.length === 0) {
      $A.$reportError$("Error loading component definitions", e)
    }
  })
};
ComponentDefLoader.prototype.$loadingComplete$ = function(hasError) {
};
ComponentDefLoader.prototype.getError = function(uri) {
  var startIndex = uri.indexOf("\x26", uri.indexOf(this.$lastURIComponentDefinitionsParameterName$) + this.$lastURIComponentDefinitionsParameterName$.length);
  var endIndex = uri.indexOf("\x26" + ComponentDefLoader.$UID_param$ + "\x3d");
  var loaderErrorString = uri.substr(startIndex, endIndex - startIndex);
  if(loaderErrorString.indexOf("\x26_def\x3d") === 0) {
    loaderErrorString = loaderErrorString.substr(6)
  }
  if(Aura["componentDefLoaderError"][loaderErrorString] && Aura["componentDefLoaderError"][loaderErrorString].length > 0) {
    return Aura["componentDefLoaderError"][loaderErrorString].pop()
  }
  return undefined
};
ComponentDefLoader.prototype.$createScriptElement$ = function(uri, onload, onerror) {
  var that = this;
  var counter = this.$scriptTagCounter$++;
  var startMark = $A.$metricsService$.$markStart$(ComponentDefLoader.$MARK_NS$, ComponentDefLoader["MARK_NAME"], {"defLoaderId":counter});
  this.$loading$++;
  var script = document.createElement("script");
  script["type"] = "text/javascript";
  script["src"] = uri;
  script["onload"] = function() {
    var endMark = $A.$metricsService$.$markEnd$(ComponentDefLoader.$MARK_NS$, ComponentDefLoader["MARK_NAME"]);
    var endMarkContext = $A.$metricsService$.$findAndSummarizeResourcePerfInfo$(uri, startMark["ts"], endMark["ts"]) || {};
    endMarkContext["defLoaderId"] = counter;
    delete endMarkContext["name"];
    endMarkContext["defs"] = that.$getDescriptorsFromURI$(uri).slice(0, 10);
    endMark["context"] = endMarkContext;
    that.$loading$--;
    that.$loadingComplete$();
    onload();
    script["onload"] = script["onerror"] = undefined;
    document.head.removeChild(script)
  };
  script["onerror"] = function() {
    that.$loading$--;
    that.$loadingComplete$(true);
    onerror();
    script["onload"] = script["onerror"] = undefined;
    document.head.removeChild(script)
  };
  script["nonce"] = $A.getContext().$scriptNonce$;
  document.head.appendChild(script)
};
ComponentDefLoader.prototype.$setScriptGenerator$ = function(method) {
  ComponentDefLoader.prototype.$createScriptElement$ = method
};
ComponentDefLoader.prototype.$generateScriptTag$ = function(uri) {
  if(!uri) {
    return Promise["resolve"]()
  }
  var that = this;
  return new Promise(function(resolve, reject) {
    that.$createScriptElement$(uri, function generateScriptTagOnload() {
      var error = that.getError(uri);
      if(error === undefined) {
        resolve();
        that.$processRequested$()
      }else {
        reject(error);
        that.$rejectPendingRequested$(uri)
      }
    }, function generateScriptTagOnerror() {
      var error = that.getError(uri);
      if(error === undefined) {
        $A.$clientService$.$setConnected$(false);
        if($A.getContext().$isCDNEnabled$()) {
          that.$reportCmpDefUriFailure$(uri)["then"](function(xhrData) {
            var err = that.$createScriptTagError$(uri, xhrData);
            that.$rejectPendingRequested$(uri);
            reject(err)
          })["catch"](function(err) {
            err = err || that.$createScriptTagError$(uri);
            that.$rejectPendingRequested$(uri);
            reject(err)
          })
        }else {
          var err = that.$createScriptTagError$(uri);
          that.$rejectPendingRequested$(uri);
          reject(err)
        }
      }else {
        reject(error);
        that.$rejectPendingRequested$(uri)
      }
    })
  })
};
ComponentDefLoader.prototype.$createScriptTagError$ = function(uri, data) {
  data = data || {};
  data["online"] = window["navigator"]["onLine"];
  data["cdnEnabled"] = $A.getContext().$isCDNEnabled$();
  data["descriptors"] = this.$getDescriptorsFromURI$(uri);
  var message = ComponentDefLoader.$UNKNOWN_ERROR_MESSAGE_PREFIX$ + uri;
  var auraErr = new $A.$auraError$(message);
  auraErr.$setAdditionalData$(data);
  return auraErr
};
ComponentDefLoader.prototype.$reportCmpDefUriFailure$ = function(uri) {
  return new Promise(function(resolve) {
    var xhr = $A.$clientService$.$createXHR$();
    xhr.onreadystatechange = function() {
      if(xhr.readyState === 4) {
        var xhrData = {status:xhr.status, statusText:xhr.statusText, uri:uri, $responseURL$:xhr["responseURL"]};
        resolve(xhrData)
      }
    };
    xhr.open("GET", uri, true);
    xhr.send()
  })
};
ComponentDefLoader.prototype.$loadComponentDef$ = function(descriptor, uid, callback) {
  var descriptorMap = {};
  descriptorMap[descriptor] = uid;
  this.$loadComponentDefs$(descriptorMap, callback)
};
ComponentDefLoader.prototype.$loadComponentDefs$ = function(descriptorMap, callback) {
  if(!callback || typeof callback !== "function") {
    return
  }
  if(this.$pending$ === null) {
    this.$pending$ = {$callbacks$:[callback], $descriptorMap$:Object.assign({}, descriptorMap), $access$:$A.$clientService$.$currentAccess$};
    if(!Aura["componentDefLoaderError"]) {
      Aura["componentDefLoaderError"] = {}
    }
    var that = this;
    var retrievePending = function() {
      that.$retrievePending$.call(that, that.$pending$);
      that.$pending$ = null
    };
    if($A.$clientService$.$isAuraBundlingDisabled$() && $A.$getRoot$()) {
      retrievePending()
    }else {
      window.setTimeout(retrievePending, 0)
    }
  }else {
    this.$pending$.$callbacks$.push(callback);
    Object.assign(this.$pending$.$descriptorMap$, descriptorMap)
  }
};
function ComponentDefLoaderParameter(name, valueMethod) {
  if(!$A["util"].$isString$(name)) {
    throw new AuraError("paramter name must be a string, but was: " + typeof name);
  }
  this.name = name;
  if(typeof valueMethod !== "function") {
    throw new AuraError("valueMethod must be a function, but was: " + typeof valueMethod);
  }
  this.$getValue$ = valueMethod
}
Aura.$Component$.$ComponentDefLoader$ = ComponentDefLoader;
Aura.$Component$.$ComponentDefLoaderParameter$ = ComponentDefLoaderParameter;
function ComponentDefStorage() {
}
ComponentDefStorage.prototype.$STORAGE_NAME$ = "ComponentDefStorage";
ComponentDefStorage.prototype.$EVICTION_TARGET_LOAD$ = 0.75;
ComponentDefStorage.prototype.$EVICTION_HEADROOM$ = 0.1;
ComponentDefStorage.prototype.$BROKEN_GRAPH_COOKIE$ = "auraBrokenDefGraph";
ComponentDefStorage.prototype.$MUTEX_KEY$ = ComponentDefStorage.prototype.$STORAGE_NAME$;
ComponentDefStorage.prototype.$mutexUnlock$ = undefined;
ComponentDefStorage.prototype.$queue$ = undefined;
ComponentDefStorage.prototype.$defsToStore$ = undefined;
ComponentDefStorage.prototype.$useDefStore$ = undefined;
ComponentDefStorage.prototype.$storage$ = undefined;
ComponentDefStorage.prototype.$useDefinitionStorage$ = function() {
  if(this.$useDefStore$ === undefined) {
    this.$setupDefinitionStorage$()
  }
  return this.$useDefStore$
};
ComponentDefStorage.prototype.$setupDefinitionStorage$ = function() {
  if(this.$useDefStore$ === undefined) {
    this.$useDefStore$ = false;
    var actionStorage = $A.$clientService$.$getActionStorage$();
    if(actionStorage.$isStoragePersistent$()) {
      var storage = $A.$storageService$.$getStorage$(this.$STORAGE_NAME$);
      var removeStorage = false;
      if(!storage) {
        removeStorage = true;
        storage = $A.$storageService$.$initStorage$({"name":this.$STORAGE_NAME$, "persistent":true, "secure":false, "maxSize":4096E3, "expiration":10886400, "debugLogging":true, "clearOnInit":false})
      }
      if(storage.$isPersistent$()) {
        this.$storage$ = storage;
        this.$storage$.$suspendSweeping$();
        this.$useDefStore$ = true
      }else {
        if(removeStorage) {
          $A.$storageService$.$deleteStorage$(this.$STORAGE_NAME$)
        }
      }
    }
  }
};
ComponentDefStorage.prototype.$getStorage$ = function() {
  if(this.$useDefinitionStorage$()) {
    return this.$storage$
  }
};
ComponentDefStorage.prototype.$storeDefs$ = function(cmpConfigs, libConfigs, evtConfigs, moduleConfigs, context) {
  if(!this.$useDefinitionStorage$() || !cmpConfigs.length && !libConfigs.length && !evtConfigs.length && !moduleConfigs.length) {
    return Promise["resolve"]()
  }
  var toStore = {};
  var descriptor;
  var encodedConfig;
  var i;
  for(i = 0;i < cmpConfigs.length;i++) {
    descriptor = cmpConfigs[i]["descriptor"];
    cmpConfigs[i]["uuid"] = context.$findLoaded$(descriptor);
    encodedConfig = $A["util"].$json$.$encode$(cmpConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  for(i = 0;i < libConfigs.length;i++) {
    descriptor = libConfigs[i]["descriptor"];
    encodedConfig = $A["util"].$json$.$encode$(libConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  for(i = 0;i < evtConfigs.length;i++) {
    descriptor = evtConfigs[i]["descriptor"];
    encodedConfig = $A["util"].$json$.$encode$(evtConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  for(i = 0;i < moduleConfigs.length;i++) {
    descriptor = moduleConfigs[i]["descriptor"];
    encodedConfig = $A["util"].$json$.$encode$(moduleConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  if(this.$defsToStore$) {
    $A["util"].apply(this.$defsToStore$, toStore, false, false);
    return Promise["resolve"]()
  }
  this.$defsToStore$ = toStore;
  var that = this;
  return this.$enqueue$(function(resolve$$0, reject$$0) {
    var values = that.$defsToStore$;
    that.$defsToStore$ = undefined;
    return that.$storage$.$setAll$(values)["then"](function resolve() {
      $A.log("ComponentDefStorage: successfully stored " + Object.keys(toStore).length + " defs")
    }, function reject(e) {
      $A.$warning$("ComponentDefStorage: error storing " + Object.keys(toStore).length + " defs", e);
      that.$setBrokenGraphCookie$();
      throw e;
    })["then"](resolve$$0, reject$$0)
  })
};
ComponentDefStorage.prototype.$removeDefs$ = function(descriptors) {
  if(!this.$useDefinitionStorage$() || !descriptors.length) {
    return Promise["resolve"]()
  }
  var that = this;
  return this.$storage$.$removeAll$(descriptors)["then"](function removeDefsSuccess() {
    $A.log("ComponentDefStorage: Successfully removed " + descriptors.length + " descriptors")
  }, function removeDefsError(e) {
    $A.log("ComponentDefStorage: Error removing  " + descriptors.length + " descriptors", e);
    that.$setBrokenGraphCookie$();
    throw e;
  })
};
ComponentDefStorage.prototype.$getAll$ = function() {
  if(!this.$useDefinitionStorage$()) {
    return Promise["resolve"]({})
  }
  if(this.$getBrokenGraphCookie$()) {
    var metricsPayload = {"cause":"getAll", "error":"broken def graph cookie"};
    return this.clear(metricsPayload)
  }
  return this.$storage$.$getAll$([], true)["then"](function getItems(items) {
    var result = {};
    for(var key in items) {
      var config;
      var error;
      try {
        config = $A["util"].$json$.$decode$(items[key])
      }catch(e) {
        config = null;
        error = e
      }
      if(config === null) {
        throw new $A.$auraError$("Error decoding definition from storage: " + key, error, $A.severity.$QUIET$);
      }
      result[key] = config
    }
    return result
  })
};
ComponentDefStorage.prototype.$restoreAll$ = function(context) {
  return this.$getAll$()["then"](function getAllProcessItems(items) {
    var libCount = 0;
    var cmpCount = 0;
    var evtCount = 0;
    var moduleDefs = [];
    for(var key in items) {
      var config = items[key];
      if(config[Json.$ApplicationKey$.$TYPE$]) {
        if(!$A.$eventService$.$getEventDef$(config)) {
          $A.$eventService$.$saveEventConfig$(config)
        }
        evtCount++
      }else {
        if(config["includes"]) {
          if(!$A.$componentService$.$hasLibrary$(config["descriptor"])) {
            $A.$componentService$.$saveLibraryConfig$(config)
          }
          libCount++
        }else {
          if(config[Json.$ApplicationKey$["NAME"]] && config[Json.$ApplicationKey$.$CODE$]) {
            moduleDefs.push(config)
          }else {
            if(config["uuid"]) {
              context.$addLoaded$(config["uuid"])
            }
            if(!$A.$componentService$.$getComponentDef$(config)) {
              $A.$componentService$.$saveComponentConfig$(config)
            }
            cmpCount++
          }
        }
      }
    }
    if(moduleDefs.length > 0) {
      $A.$componentService$.$initModuleDefs$(moduleDefs)
    }
    $A.log("ComponentDefStorage: restored " + cmpCount + " components, " + libCount + " libraries, " + evtCount + " events, " + moduleDefs.length + " modules from storage into registry")
  })["then"](undefined, function getAllError(e) {
    $A.$warning$("ComponentDefStorage: error during restore from storage, no component, library or event defs restored", e);
    throw e;
  })
};
ComponentDefStorage.prototype.$enqueue$ = function(execute) {
  function executeQueue() {
    if(!that.$queue$) {
      return
    }
    var next = that.$queue$.pop();
    if(next) {
      $A.log("ComponentDefStorage.enqueue: " + (that.$queue$.length + 1) + " items in queue, running next");
      $A["util"].$Mutex$.$lock$(that.$MUTEX_KEY$, function(unlock) {
        that.$mutexUnlock$ = unlock;
        next["execute"](next["resolve"], next["reject"])
      })
    }else {
      that.$queue$ = undefined
    }
  }
  var that = this;
  var promise = new Promise(function(resolve, reject) {
    if(that.$queue$) {
      that.$queue$.push({"execute":execute, "resolve":resolve, "reject":reject});
      return
    }
    that.$queue$ = [{"execute":execute, "resolve":resolve, "reject":reject}];
    executeQueue()
  });
  promise["then"](function enqueueSuccess() {
    try {
      that.$mutexUnlock$()
    }catch(ignore) {
    }
    executeQueue()
  }, function enqueueError() {
    try {
      that.$mutexUnlock$()
    }catch(ignore) {
    }
    executeQueue()
  });
  return promise
};
ComponentDefStorage.prototype.clear = function(metricsPayload) {
  if(!this.$useDefinitionStorage$()) {
    this.$clearBrokenGraphCookie$();
    return Promise["resolve"]()
  }
  var that = this;
  return new Promise(function(resolve, reject) {
    metricsPayload = $A["util"].apply({}, metricsPayload);
    metricsPayload["evicted"] = "all";
    $A.$metricsService$.$transactionStart$("aura", "performance:evictedDefs", {"context":{"attributes":metricsPayload}});
    $A.$clientService$.$runWhenXHRIdle$(function() {
      $A.$warning$("ComponentDefStorage.clear: clearing all defs and actions");
      $A.$context$.$resetLoaded$();
      that.$enqueue$(function(enqueueResolve) {
        var errorDuringClear = false;
        var actionClear;
        var actionStorage = $A.$clientService$.$getActionStorage$();
        if(actionStorage.$isStoragePersistent$()) {
          actionClear = actionStorage.clear()["then"](undefined, function actionStorageClearError(e) {
            $A.$warning$("ComponentDefStorage.clear: failure clearing actions store", e);
            metricsPayload["actionsError"] = true;
            errorDuringClear = true
          })
        }else {
          actionClear = Promise["resolve"]()
        }
        var defClear = that.$storage$.clear()["then"](undefined, function storageClearError(e) {
          $A.$warning$("ComponentDefStorage.clear: failure clearing cmp def store", e);
          metricsPayload["componentDefStorageError"] = true;
          errorDuringClear = true
        });
        var promise = Promise["all"]([actionClear, defClear])["then"](function afterClearSuccess() {
          $A.$metricsService$.$transactionEnd$("aura", "performance:evictedDefs");
          if(!errorDuringClear) {
            that.$clearBrokenGraphCookie$()
          }
        });
        enqueueResolve(promise)
      })["then"](resolve, reject)
    })
  })
};
ComponentDefStorage.prototype.$getBrokenGraphCookie$ = function() {
  var cookie = $A["util"].$getCookie$(this.$BROKEN_GRAPH_COOKIE$);
  return cookie === "true"
};
ComponentDefStorage.prototype.$setBrokenGraphCookie$ = function() {
  var duration = 1E3 * 60 * 60 * 24 * 7;
  $A["util"]["setCookie"](this.$BROKEN_GRAPH_COOKIE$, "true", duration)
};
ComponentDefStorage.prototype.$clearBrokenGraphCookie$ = function() {
  $A["util"].$clearCookie$(this.$BROKEN_GRAPH_COOKIE$)
};
Aura.$Component$.$ComponentDefStorage$ = ComponentDefStorage;
function Component(config, localCreation) {
  var context = $A.getContext();
  this[Symbol["for"]("@@lockerLiveValue")] = true;
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.type = "";
  this.$_marker$ = null;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  try {
    this.$setupGlobalId$(config["globalId"], localCreation);
    var partialConfig;
    if(this.$creationPath$ && this.$creationPath$ !== "client created") {
      partialConfig = context.$getComponentConfig$(this.$creationPath$);
      context.$removeComponentConfig$(this.$creationPath$)
    }
    if(partialConfig) {
      this.$validatePartialConfig$(config, partialConfig);
      this.$partialConfig$ = partialConfig
    }
    if(config["rendering"]) {
      this.$rendering$ = config["rendering"]
    }else {
      if(partialConfig && partialConfig["rendering"]) {
        this.$rendering$ = this.$partialConfig$["rendering"]
      }
    }
    $A.$componentService$.$indexComponent$(this);
    this.$setupComponentDef$(this.$partialConfig$ || config);
    this.$isRootComponent$ = $A["util"].$isUndefinedOrNull$(this["meta"] && this["meta"]["extends"]) && this.$isInstanceOf$("aura:rootComponent");
    var configAttributes = {"values":{}};
    if(config["attributes"]) {
      $A["util"].apply(configAttributes["values"], config["attributes"]["values"], true);
      configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
    }
    if(partialConfig && partialConfig["attributes"]) {
      $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
    }
    if(!configAttributes["facetValueProvider"]) {
      configAttributes["facetValueProvider"] = this
    }
    this.$attributeValueProvider$ = configAttributes["valueProvider"];
    this.$facetValueProvider$ = configAttributes["facetValueProvider"];
    this.$setupModel$(config["model"]);
    this.$setupValueProviders$(config["valueProviders"]);
    this.$setupAttributes$(configAttributes);
    this.$injectComponent$(config, localCreation);
    this.$setupMethods$(config);
    this.$setupComponentEvents$(this, configAttributes);
    this.$setupSuper$(configAttributes, localCreation);
    this.$setupApplicationEventHandlers$();
    this.$doIndex$(this);
    this.$setupValueEventHandlers$(this);
    this.$setupFlavors$(config, configAttributes);
    this.$partialConfig$ = undefined;
    if(forcedPath && act && this.$creationPath$) {
      act.$releaseCreationPath$(this.$creationPath$)
    }
    if(this.$getDef$().$hasInit$()) {
      this.$fire$("init")
    }
  }catch(e) {
    var auraError = e;
    if(!(e instanceof $A.$auraError$)) {
      auraError = new $A.$auraError$("Failed to initialize a component", e);
      auraError.$setAdditionalStacktraceGen$(e.message)
    }
    if(!auraError["component"]) {
      auraError.$setComponent$(config && config["componentDef"] && config["componentDef"]["descriptor"])
    }
    auraError.$setAdditionalStacktraceGen$("Component init failed");
    throw auraError;
  }
}
goog.$exportSymbol$("Component", Component);
Component.prototype.$setContainerComponentId$ = function(containerComponentId) {
  this.$containerComponentId$ = containerComponentId
};
Component.$currentComponentId$ = 0;
Component.prototype.$nextGlobalId$ = function(localCreation) {
  if(!localCreation) {
    var context = $A.getContext();
    var currentAction = context.$getCurrentAction$();
    var id;
    var suffix;
    if(currentAction) {
      id = currentAction.$getNextGlobalId$();
      suffix = currentAction.$getId$()
    }else {
      id = context.$getNextGlobalId$();
      suffix = "g"
    }
    return suffix ? id + ":" + suffix : id
  }else {
    return Component.$currentComponentId$++ + ":c"
  }
};
Component.prototype.$setupGlobalId$ = function(globalId, localCreation) {
  globalId = globalId || this.$nextGlobalId$(localCreation);
  if($A.$componentService$.get(globalId)) {
    $A.log("Component.setupGlobalId: globalId already in use: '" + globalId + "'.")
  }
  this.$globalId$ = globalId
};
Component.prototype.getName = function() {
  if(!this.name) {
    this.name = $A["util"].$toCamelCase$(this.$getType$())
  }
  return this.name
};
goog.$exportProperty$(Component.prototype, "getName", Component.prototype.getName);
Component.prototype.$getType$ = function() {
  if(!this.type) {
    this.type = this.$getDef$().$getDescriptor$().$getFullName$()
  }
  return this.type
};
goog.$exportProperty$(Component.prototype, "getType", Component.prototype.$getType$);
Component.prototype.$getDef$ = function() {
  return this.$componentDef$
};
goog.$exportProperty$(Component.prototype, "getDef", Component.prototype.$getDef$);
Component.prototype.index = function(localId, globalId) {
  var index = this.$localIndex$;
  var existing = index[localId];
  if(existing) {
    if(!$A["util"].isArray(existing)) {
      if(existing !== globalId) {
        index[localId] = [existing, globalId]
      }else {
        $A.$warning$("Component.index():'Invalid redundant use of component.index().'")
      }
    }else {
      var found = false;
      for(var i = 0;i < existing.length;i++) {
        if(existing[i] === globalId) {
          found = true;
          $A.$warning$("Component.index():'Invalid redundant use of component.index().'");
          break
        }
      }
      if(!found) {
        existing.push(globalId)
      }
    }
  }else {
    index[localId] = globalId
  }
  return null
};
goog.$exportProperty$(Component.prototype, "index", Component.prototype.index);
Component.prototype.$deIndex$ = function(localId, globalId) {
  if(this.$localIndex$) {
    if(globalId) {
      var index = this.$localIndex$[localId];
      if(index) {
        if($A["util"].isArray(index)) {
          for(var i = 0;i < index.length;i++) {
            if(index[i] === globalId) {
              index.splice(i--, 1)
            }
          }
          if(index.length === 0) {
            delete this.$localIndex$[localId]
          }
        }else {
          if(index === globalId) {
            delete this.$localIndex$[localId]
          }
        }
      }
    }else {
      delete this.$localIndex$[localId]
    }
  }
  return null
};
goog.$exportProperty$(Component.prototype, "deIndex", Component.prototype.$deIndex$);
Component.prototype.find = function(name) {
  if($A["util"].$isObject$(name)) {
    var type = name["instancesOf"];
    var instances = [];
    this.$findInstancesOf$(type, instances, this);
    return instances
  }else {
    var index = this.$localIndex$;
    if(index) {
      var globalId = index[name];
      if(globalId) {
        if($A["util"].isArray(globalId)) {
          var ret = [];
          var found;
          for(var i = 0;i < globalId.length;i++) {
            found = $A.$componentService$.get(globalId[i]);
            if(found !== null && found !== undefined) {
              ret.push(found)
            }
          }
          return ret
        }
        return $A.$componentService$.get(globalId)
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "find", Component.prototype.find);
Component.prototype.$findInstancesOf$ = function(type, ret, cmp) {
  cmp = cmp || this.$getSuperest$();
  var body = null;
  if(cmp.$getDef$().$getAttributeDefs$().$getDef$("body")) {
    body = cmp.get("v.body")
  }else {
    if(cmp.$isInstanceOf$("aura:expression")) {
      var value = cmp.get("v.value");
      if($A["util"].isArray(value)) {
        body = value
      }
    }
  }
  if(body) {
    for(var i = 0;i < body.length;i++) {
      cmp = body[i];
      if(cmp.$findInstanceOf$) {
        var inst = cmp.$findInstanceOf$(type);
        if(inst) {
          ret.push(inst)
        }else {
          cmp.$findInstancesOf$(type, ret)
        }
      }
    }
  }
};
Component.prototype.$getSuperest$ = function() {
  var superComponent = this.$getSuper$();
  if(superComponent) {
    return superComponent.$getSuperest$() || superComponent
  }else {
    return this
  }
};
Component.prototype.$findInstanceOf$ = function(type) {
  if(this.$getType$() === type) {
    return this
  }else {
    var superComponent = this.$getSuper$();
    if(superComponent) {
      return superComponent.$findInstanceOf$(type)
    }else {
      return null
    }
  }
};
Component.prototype.$isInstanceOf$ = function(name) {
  return this.$componentDef$.$isInstanceOf$(name)
};
goog.$exportProperty$(Component.prototype, "isInstanceOf", Component.prototype.$isInstanceOf$);
Component.prototype.$implementsDirectly$ = function(type) {
  return this.$componentDef$.$implementsDirectly$(type)
};
Component.prototype.$addEventHandler$ = function(event, handler, phase, includeFacets) {
  if(this.$destroyed$) {
    return
  }
  if($A["util"].$isExpression$(handler)) {
    var reference = handler;
    handler = $A.$eventService$.$expressionHandler$.bind($A.$eventService$, handler);
    handler.$reference$ = reference
  }
  if(!$A["util"].$isFunction$(handler)) {
    throw new Error("Component.addEventHandler: 'handler' must be a valid Function or a reference to a controller action, e.g., 'cmp.getReference(\"c.myAction\");'");
  }
  var def = this.$componentDef$.$getEventDef$(event) || $A.$eventService$.$getEventDef$(event);
  if(def && def.type === "APPLICATION") {
    $A.$eventService$.$addEventHandler$(this, def, handler, phase, includeFacets);
    return
  }
  phase = AuraEventService.$validatePhase$(phase, AuraEventService.$Phase$.$BUBBLE$);
  var dispatcher = this.$getEventDispatcher$();
  var handlers = dispatcher[event];
  if(!handlers) {
    handlers = dispatcher[event] = {}
  }
  var phaseHandlers = handlers[phase];
  if(!phaseHandlers) {
    handlers[phase] = phaseHandlers = []
  }
  if(includeFacets) {
    handler.$includeFacets$ = true
  }
  for(var i = 0;i < phaseHandlers.length;i++) {
    if(phaseHandlers[i] === handler || phaseHandlers[i].$reference$ && phaseHandlers[i].$reference$ === handler.$reference$) {
      return
    }
  }
  phaseHandlers.push(handler)
};
goog.$exportProperty$(Component.prototype, "addEventHandler", Component.prototype.$addEventHandler$);
Component.prototype.$addHandler$ = function(eventName, valueProvider, actionExpression, insert, phase, includeFacets) {
  if(this.$destroyed$) {
    return
  }
  var dispatcher = this.$getEventDispatcher$();
  if(!phase) {
    phase = "bubble"
  }
  var handlers = dispatcher[eventName];
  if(!handlers) {
    handlers = dispatcher[eventName] = {}
  }
  var phasedHandlers = handlers[phase];
  if(!phasedHandlers) {
    handlers[phase] = phasedHandlers = []
  }
  var actionCaller = this.$getActionCaller$(valueProvider, actionExpression);
  if($A["util"].$getBooleanValue$(includeFacets)) {
    actionCaller.$includeFacets$ = true
  }
  if(insert === true) {
    phasedHandlers.unshift(actionCaller)
  }else {
    phasedHandlers.push(actionCaller)
  }
};
goog.$exportProperty$(Component.prototype, "addHandler", Component.prototype.$addHandler$);
Component.prototype.$removeEventHandler$ = function(event, handler, phase) {
  var def = this.$componentDef$.$getEventDef$(event) || $A.$eventService$.$getEventDef$(event);
  if(def && def.type === "APPLICATION") {
    $A.$eventService$.$removeEventHandler$(this, def, handler, phase);
    return
  }
  phase = AuraEventService.$validatePhase$(phase, AuraEventService.$Phase$.$BUBBLE$);
  var dispatcher = this.$getEventDispatcher$();
  var handlers = null;
  if(dispatcher !== null) {
    handlers = dispatcher[event]
  }
  if(handlers !== null) {
    var phaseHandlers = handlers[phase];
    if(phaseHandlers) {
      for(var i = 0;i < phaseHandlers.length;i++) {
        if(phaseHandlers[i] === handler || phaseHandlers[i].$reference$ === handler) {
          phaseHandlers.splice(i, 1);
          break
        }
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "removeEventHandler", Component.prototype.$removeEventHandler$);
Component.prototype.$addValueHandler$ = function(config) {
  var expression = config["value"];
  if($A["util"].$isExpression$(expression)) {
    expression = expression.getExpression()
  }
  expression = expression + "";
  var component = this.$getConcreteComponent$();
  if(expression.indexOf("v.") === 0) {
    var attribute = expression.split(".")[1];
    var defs = AttributeSet.$getDef$(attribute, this);
    if(!$A.$clientService$.$allowAccess$(defs[0], defs[1])) {
      var message = "Access Check Failed! Component.addValueHandler(): attribute '" + attribute + "' of component '" + component + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        return
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
  }
  if(config["method"]) {
    config["method"] = $A.$getCallback$(config["method"])
  }
  this.$addChangeHandler$(config)
};
goog.$exportProperty$(Component.prototype, "addValueHandler", Component.prototype.$addValueHandler$);
Component.prototype.$addChangeHandler$ = function(config) {
  var expression = config["value"];
  var component = this.$getConcreteComponent$();
  if($A["util"].$isExpression$(expression)) {
    expression = expression.getExpression()
  }
  if(config["action"] && !config["method"]) {
    config["method"] = this.$getActionCaller$(this, config["action"].getExpression())
  }
  var event = config["event"];
  var handlers = component.$handlers$[event];
  if(!handlers) {
    handlers = component.$handlers$[event] = {}
  }
  if(!handlers[expression]) {
    handlers[expression] = []
  }
  for(var i = 0;i < handlers[expression].length;i++) {
    if(handlers[expression][i] === config["method"] || config["id"] && config["key"] && handlers[expression][i]["id"] === config["id"] && handlers[expression][i]["key"] === config["key"]) {
      return
    }
  }
  handlers[expression].push(config["method"])
};
Component.prototype.$removeValueHandler$ = function(config) {
  var component = this.$getConcreteComponent$();
  var event = config["event"];
  var handlers = component.$handlers$[event];
  if(handlers) {
    var expression = config["value"];
    if($A["util"].$isExpression$(expression)) {
      expression = expression.getExpression()
    }
    if(handlers[expression]) {
      for(var i = 0;i < handlers[expression].length;i++) {
        var method = handlers[expression][i];
        if(method === config["method"] || config["id"] && config["key"] && method["id"] === config["id"] && method["key"] === config["key"]) {
          handlers[expression].splice(i--, 1)
        }
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "removeValueHandler", Component.prototype.$removeValueHandler$);
Component.prototype.$addDocumentLevelHandler$ = function(eventName, callback, autoEnable) {
  var dlh = new Aura.$Utils$.$DocLevelHandler$(eventName, callback, this);
  if(!this.$docLevelHandlers$) {
    this.$docLevelHandlers$ = {}
  }
  $A.assert(this.$docLevelHandlers$[eventName] === undefined, "Same doc level event set twice");
  this.$docLevelHandlers$[eventName] = dlh;
  dlh.$setEnabled$(autoEnable);
  return dlh
};
goog.$exportProperty$(Component.prototype, "addDocumentLevelHandler", Component.prototype.$addDocumentLevelHandler$);
Component.prototype.$removeDocumentLevelHandler$ = function(dlh) {
  if(dlh && dlh.$setEnabled$) {
    dlh.$setEnabled$(false);
    this.$docLevelHandlers$[dlh.$eventName$] = undefined
  }
};
goog.$exportProperty$(Component.prototype, "removeDocumentLevelHandler", Component.prototype.$removeDocumentLevelHandler$);
Component.prototype.$destroy$ = function() {
  if(arguments.length) {
    $A.$warning$("Deprecation warning: Component.destroy() no longer supports asynchronous destruction. Please remove any arguments passed to destroy().")
  }
  if(this.$destroyed$) {
    return
  }
  if(this.$concreteComponentId$) {
    var concrete = this.$getConcreteComponent$();
    if(concrete && concrete !== this && !concrete.$destroyed$) {
      concrete.$destroy$();
      return
    }
  }
  var cmpProfilerName;
  if(AuraProfilerServiceProfilerEnabled) {
    cmpProfilerName = this.$getType$();
    AuraProfilerServiceLogOperationStart(5, cmpProfilerName, this)
  }
  this.$destroyed$ = -1;
  this.$fire$("destroy");
  if(this.$docLevelHandlers$ !== undefined) {
    for(var handler in this.$docLevelHandlers$) {
      if(this.$docLevelHandlers$.hasOwnProperty(handler)) {
        this.$docLevelHandlers$[handler].$setEnabled$(false)
      }
    }
    this.$docLevelHandlers$ = undefined
  }
  $A.$renderingService$.$unrender$(this);
  if(this.$_marker$) {
    $A.$renderingService$.$removeMarkerReference$(this.$_marker$, this.$getGlobalId$());
    $A.$renderingService$.$removeElement$(this.$_marker$, this.$getContainer$());
    this.$_marker$ = null
  }
  this.elements = undefined;
  this.$allElements$ = undefined;
  if(this.$attributeSet$ && !this.$superComponent$) {
    var expressions = this.$attributeSet$.$destroy$();
    for(var x in expressions) {
      expressions[x].$removeChangeHandler$(this, "v." + x)
    }
    this.$attributeSet$ = null
  }
  var references = this.$references$;
  for(var key in references) {
    if(references[key]) {
      for(var access in references[key]) {
        references[key][access].$destroy$();
        delete references[key][access]
      }
    }
    delete references[key]
  }
  if(this.$model$) {
    this.$model$.$destroy$()
  }
  $A.$eventService$.$removeHandlersByComponentId$(this.$globalId$);
  var componentDef = this.$getDef$();
  var handlerDefs = componentDef.$getAppHandlerDefs$();
  if(handlerDefs) {
    for(var i = 0;i < handlerDefs.length;i++) {
      var handlerDef = handlerDefs[i];
      var handlerConfig = {};
      handlerConfig["globalId"] = this.$globalId$;
      handlerConfig["event"] = handlerDef["eventDef"].$getDescriptor$().$getQualifiedName$();
      $A.$eventService$.$removeHandler$(handlerConfig)
    }
  }
  var eventDispatcher = this.$getEventDispatcher$();
  if(eventDispatcher) {
    for(var event in eventDispatcher) {
      var vals = eventDispatcher[event];
      if(vals) {
        for(var phase in vals) {
          var arr = vals[phase];
          if(arr) {
            for(var j = 0;j < arr.length;j++) {
              delete arr[j]
            }
          }
        }
        delete eventDispatcher[event]
      }
    }
    this.$eventValueProvider$ = null
  }
  this.$doDeIndex$();
  $A.$componentService$.$deIndex$(this.$globalId$);
  this.$attributeValueProvider$ = null;
  if(this.$superComponent$) {
    this.$superComponent$.$destroy$()
  }
  var vp = this.$valueProviders$;
  if(vp) {
    for(var k in vp) {
      var v = vp[k];
      if(v && v !== this) {
        vp[k] = null
      }
    }
  }
  var handlers = this.$handlers$;
  if(handlers) {
    for(var h in handlers) {
      handlers[h] = null
    }
    handlers = null
  }
  var defs = this.$componentDef$.$methodDefs$;
  if(defs) {
    for(var def = 0;def < defs.length;def++) {
      var methodDef = defs[def].name.indexOf(":") > -1 ? defs[def].name.split(":")[1] : defs[def].name;
      if(this[methodDef]) {
        this[methodDef] = noop
      }
    }
  }
  this.$destroyed$ = 1;
  if(AuraProfilerServiceProfilerEnabled) {
    AuraProfilerServiceLogOperationStop(5, cmpProfilerName, this)
  }
};
goog.$exportProperty$(Component.prototype, "destroy", Component.prototype.$destroy$);
Component.prototype.$superRender$ = function() {
  if(this.$superComponent$) {
    return this.$superComponent$["render"]()
  }
};
goog.$exportProperty$(Component.prototype, "superRender", Component.prototype.$superRender$);
Component.prototype.$superAfterRender$ = function() {
  if(this.$superComponent$) {
    this.$superComponent$["afterRender"]()
  }
};
goog.$exportProperty$(Component.prototype, "superAfterRender", Component.prototype.$superAfterRender$);
Component.prototype.$superRerender$ = function() {
  if(this.$superComponent$) {
    return this.$superComponent$["rerender"]()
  }
};
goog.$exportProperty$(Component.prototype, "superRerender", Component.prototype.$superRerender$);
Component.prototype.$superUnrender$ = function() {
  if(this.$superComponent$) {
    this.$superComponent$["unrender"]()
  }
};
goog.$exportProperty$(Component.prototype, "superUnrender", Component.prototype.$superUnrender$);
Component.prototype.$isRendered$ = function() {
  return this.$rendered$
};
goog.$exportProperty$(Component.prototype, "isRendered", Component.prototype.$isRendered$);
Component.prototype.$setUnrendering$ = function(unrendering) {
  this.$inUnrender$ = unrendering
};
Component.prototype.$isUnrendering$ = function() {
  return this.$inUnrender$
};
Component.prototype.$setRendered$ = function(rendered) {
  this.$rendered$ = rendered
};
Component.prototype.$getRenderer$ = function() {
  return this["renderer"]
};
goog.$exportProperty$(Component.prototype, "getRenderer", Component.prototype.$getRenderer$);
Component.prototype.$getRenderable$ = function() {
  return this["renderer"].$renderable$
};
goog.$exportProperty$(Component.prototype, "getRenderable", Component.prototype.$getRenderable$);
Component.prototype.$getGlobalId$ = function() {
  return this.$concreteComponentId$ || this.$globalId$
};
goog.$exportProperty$(Component.prototype, "getGlobalId", Component.prototype.$getGlobalId$);
Component.prototype.$getLocalId$ = function() {
  return this.$localId$
};
goog.$exportProperty$(Component.prototype, "getLocalId", Component.prototype.$getLocalId$);
Component.prototype.$getRendering$ = function() {
  var concrete = this.$getConcreteComponent$();
  if(this !== concrete) {
    return concrete.$getRendering$()
  }else {
    return this.$rendering$
  }
};
goog.$exportProperty$(Component.prototype, "getRendering", Component.prototype.$getRendering$);
Component.prototype.$getSuper$ = function() {
  return this.$superComponent$
};
goog.$exportProperty$(Component.prototype, "getSuper", Component.prototype.$getSuper$);
Component.prototype.$associateElement$ = function(element) {
  var concrete = this.$getConcreteComponent$();
  if(concrete !== this) {
    concrete.$associateElement$(element)
  }else {
    if(this.$isConcrete$()) {
      if(!this.elements) {
        this.elements = []
      }
      if(!this.$allElements$) {
        this.$allElements$ = []
      }
      this.$allElements$.push(element);
      if(!element.$aura_marker$) {
        this.elements.push(element);
        this.$associateRenderedBy$(this, element)
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "associateElement", Component.prototype.$associateElement$);
Component.prototype.$disassociateElements$ = function() {
  var concrete = this.$getConcreteComponent$();
  if(concrete !== this) {
    concrete.$disassociateElements$()
  }else {
    if(this.elements) {
      this.elements.length = 0
    }
    if(this.$allElements$) {
      this.$allElements$.length = 0
    }
  }
};
goog.$exportProperty$(Component.prototype, "disassociateElements", Component.prototype.$disassociateElements$);
Component.prototype.$getElements$ = function() {
  var concrete = this.$getConcreteComponent$();
  if(concrete !== this) {
    return concrete.$getElements$()
  }else {
    return this.elements && this.elements.slice(0) || []
  }
};
goog.$exportProperty$(Component.prototype, "getElements", Component.prototype.$getElements$);
Component.prototype.$getElement$ = function() {
  var elements = this.$getElements$();
  if(elements) {
    for(var i = 0;i < elements.length;i++) {
      if(elements[i]) {
        return elements[i]
      }
    }
  }
  return null
};
goog.$exportProperty$(Component.prototype, "getElement", Component.prototype.$getElement$);
Component.prototype.$getReference$ = function(key) {
  if(this.$destroyed$ === 1) {
    return null
  }
  key = $A.$expressionService$.normalize(key);
  var access = $A.$clientService$.$currentAccess$;
  var accessId = access && access.$getGlobalId$();
  if(!this.$references$.hasOwnProperty(key)) {
    this.$references$[key] = {}
  }
  if(!this.$references$[key].hasOwnProperty(accessId)) {
    this.$references$[key][accessId] = new PropertyReferenceValue(key, this)
  }
  return this.$references$[key][accessId]
};
goog.$exportProperty$(Component.prototype, "getReference", Component.prototype.$getReference$);
Component.prototype.$clearReference$ = function(key) {
  if(!this.$destroyed$) {
    key = $A.$expressionService$.normalize(key);
    $A.assert(key.indexOf(".") > -1, "Unable to clear reference for key '" + key + "'. No value provider was specified. Did you mean 'v." + key + "'?");
    var path = key.split(".");
    var valueProvider = this.$getValueProvider$(path.shift());
    $A.assert(valueProvider, "Unknown value provider for key '" + key + "'.");
    $A.assert(valueProvider.$clearReference$, "Value provider does not implement clearReference() method.");
    var subPath = path.join(".");
    var value = valueProvider.$clearReference$(subPath);
    if($A["util"].$isExpression$(value)) {
      value.$removeChangeHandler$(this, key)
    }
  }
};
goog.$exportProperty$(Component.prototype, "clearReference", Component.prototype.$clearReference$);
Component.prototype.get = function(key) {
  if(this.$destroyed$ === 1) {
    return undefined
  }
  if(!$A["util"].$isString$(key)) {
    var msg = "The provided key (" + key + ") is not a string and cannot be used to look up values for the current component.";
    throw new $A.$auraError$(msg);
  }
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  var root = path.shift();
  var valueProvider = this.$getValueProvider$(root);
  if(path.length) {
    if(!valueProvider) {
      $A.assert(false, "Unable to get value for key '" + key + "'. No value provider was found for '" + root + "'.")
    }
    var value;
    if($A["util"].$isFunction$(valueProvider.get)) {
      value = valueProvider.get(path.join("."), this)
    }else {
      value = $A.$expressionService$.$resolve$(path, valueProvider)
    }
    return value
  }else {
    return valueProvider
  }
};
goog.$exportProperty$(Component.prototype, "get", Component.prototype.get);
Component.prototype.$getShadowAttribute$ = function(key) {
  if(key.indexOf("v.") !== 0) {
    return null
  }
  return this.$attributeSet$.$getShadowValue$(key.substr(2))
};
Component.prototype.set = function(key, value, ignoreChanges) {
  if(this.$destroyed$ !== 1) {
    key = $A.$expressionService$.normalize(key);
    $A.assert(key.indexOf(".") > -1, "Unable to set value for key '" + key + "'. No value provider was specified. Did you mean 'v." + key + "'?");
    var path = key.split(".");
    var root = path.shift();
    var valueProvider = this.$getValueProvider$(root);
    if(!valueProvider) {
      $A.assert(false, "Unable to set value for key '" + key + "'. No value provider was found for '" + root + "'.")
    }
    if(!valueProvider.set) {
      $A.assert(false, "Unable to set value for key '" + key + "'. Value provider does not implement 'set(key, value)'.")
    }
    var subPath = path.join(".");
    var oldValue = valueProvider.get(subPath, this);
    var returnValue = valueProvider.set(subPath, value, this);
    if($A["util"].$isExpression$(value)) {
      value.$addChangeHandler$(this, key);
      if(!ignoreChanges) {
        value = value.evaluate()
      }
    }
    var changed = $A["util"].isArray(value) || $A["util"].$isObject$(value) || oldValue !== value;
    if(changed && !ignoreChanges) {
      $A.$renderingService$.$addDirtyValue$(key, this);
      var index = path.length > 1 ? path[path.length - 1] : undefined;
      this.$fireChangeEvent$(key, oldValue, value, index)
    }
    return returnValue
  }
};
goog.$exportProperty$(Component.prototype, "set", Component.prototype.set);
Component.prototype.$setShadowAttribute$ = function(key, value) {
  if(key.indexOf("v.") === 0) {
    var oldValue = this.get(key);
    var attribute = key.substr(2);
    this.$attributeSet$.$setShadowValue$(attribute, value);
    var newValue = this.get(key);
    if(oldValue !== newValue) {
      $A.$renderingService$.$addDirtyValue$(key, this);
      this.$fireChangeEvent$(key, oldValue, newValue)
    }
  }
};
Component.prototype.$markDirty$ = function(reason) {
  if(!this.$destroyed$) {
    $A.$renderingService$.$addDirtyValue$(reason || "Component.markDirty()", this)
  }
};
goog.$exportProperty$(Component.prototype, "markDirty", Component.prototype.$markDirty$);
Component.prototype.$markClean$ = function(value) {
  $A.$renderingService$.$removeDirtyValue$(value, this)
};
goog.$exportProperty$(Component.prototype, "markClean", Component.prototype.$markClean$);
Component.prototype.$fireChangeEvent$ = function(key, oldValue, newValue, index) {
  if(!this.$destroyed$) {
    var component = this.$concreteComponentId$ ? this.$getConcreteComponent$() : this;
    var handlers = component.$handlers$ && component.$handlers$["change"];
    var observers = [];
    var keypath = key + ".";
    for(var handler in handlers) {
      if(handler === key || handler.indexOf(keypath) === 0 || key.indexOf(handler + ".") === 0) {
        observers = observers.concat(handlers[handler])
      }
    }
    if(observers.length) {
      var eventDef = $A.$eventService$.$getEventDef$("aura:valueChange");
      var dispatcher = {};
      dispatcher[eventDef.$getDescriptor$().$getQualifiedName$()] = {"default":observers};
      var changeEvent = new Aura.$Event$.$Event$({"eventDef":eventDef, "eventDispatcher":dispatcher, "component":this});
      changeEvent.$setParams$({"expression":key, "value":newValue, "oldValue":oldValue, "index":index});
      changeEvent.$fire$()
    }
  }
};
Component.prototype.$autoDestroy$ = function(destroy) {
  if(!$A["util"].$isUndefinedOrNull$(destroy)) {
    this.$shouldAutoDestroy$ = !!destroy
  }else {
    return this.$shouldAutoDestroy$
  }
};
goog.$exportProperty$(Component.prototype, "autoDestroy", Component.prototype.$autoDestroy$);
Component.prototype.$getConcreteComponent$ = function() {
  return this.$concreteComponentId$ && $A.$componentService$.get(this.$concreteComponentId$) || this
};
goog.$exportProperty$(Component.prototype, "getConcreteComponent", Component.prototype.$getConcreteComponent$);
Component.prototype.$isConcrete$ = function() {
  return!this.$concreteComponentId$
};
goog.$exportProperty$(Component.prototype, "isConcrete", Component.prototype.$isConcrete$);
Component.prototype.$getAttributeValueProvider$ = function() {
  return this.$attributeValueProvider$ || this
};
goog.$exportProperty$(Component.prototype, "getAttributeValueProvider", Component.prototype.$getAttributeValueProvider$);
Component.prototype.$setAttributeValueProvider$ = function(avp) {
  this.$attributeValueProvider$ = avp;
  if(avp) {
    this.$owner$ = avp.$globalId$;
    avp.index(this.$localId$, this.$globalId$)
  }
};
goog.$exportProperty$(Component.prototype, "setAttributeValueProvider", Component.prototype.$setAttributeValueProvider$);
Component.prototype.$getComponentValueProvider$ = function() {
  for(var valueProvider = this.$attributeValueProvider$ || this.$facetValueProvider$;!$A["util"].$isComponent$(valueProvider) && $A["util"].$isFunction$(valueProvider.$getComponent$);) {
    valueProvider = valueProvider.$getComponent$()
  }
  return valueProvider
};
goog.$exportProperty$(Component.prototype, "getComponentValueProvider", Component.prototype.$getComponentValueProvider$);
Component.prototype.$getOwner$ = function() {
  if($A["util"].$isUndefinedOrNull$(this.$owner$)) {
    this.$owner$ = this.$getAttributeValueProvider$().$globalId$
  }
  return $A.$componentService$.get(this.$owner$)
};
goog.$exportProperty$(Component.prototype, "getOwner", Component.prototype.$getOwner$);
Component.prototype.$getContainer$ = function() {
  return $A.$getComponent$(this.$containerComponentId$)
};
Component.prototype.$addValueProvider$ = function(key, valueProvider) {
  if(this.$destroyed$) {
    return
  }
  $A.assert($A["util"].$isString$(key), "Component.addValueProvider(): 'key' must be a valid String.");
  $A.assert(",v,m,c,e,this,globalid,def,null,version,".indexOf("," + key.toLowerCase() + ",") === -1, "Component.addValueProvider(): '" + key + "' is a reserved valueProvider.");
  $A.assert(!$A["util"].$isUndefinedOrNull$(valueProvider), "Component.addValueProvider(): 'valueProvider' is required.");
  if(this.$valueProviders$[key] !== undefined) {
    $A.$warning$("The value provider already existes: " + key);
    return
  }
  this.$valueProviders$[key] = valueProvider
};
goog.$exportProperty$(Component.prototype, "addValueProvider", Component.prototype.$addValueProvider$);
Component.prototype.$removeValueProvider$ = function(key) {
  if(this.$destroyed$) {
    return
  }
  $A.assert($A["util"].$isString$(key), "Component.removeValueProvider(): 'key' must be a valid String.");
  $A.assert(",v,m,c,e,this,globalid,def,null,version,".indexOf("," + key.toLowerCase() + ",") === -1, "Component.removeValueProvider(): '" + key + "' is a reserved valueProvider and can not be removed.");
  if(this.$valueProviders$.hasOwnProperty(key)) {
    this.$valueProviders$[key] = undefined
  }
};
Component.prototype.$getModel$ = function() {
  return this.$model$
};
goog.$exportProperty$(Component.prototype, "getModel", Component.prototype.$getModel$);
Component.prototype.$getEvent$ = function(name) {
  var eventDef = this.$getDef$().$getEventDef$(name);
  if(!eventDef || this.$destroyed$ === 1) {
    return null
  }
  if(!$A.$clientService$.$allowAccess$(eventDef, this)) {
    var message = "Access Check Failed! Component.getEvent():'" + name + "' of component '" + this + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return null
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return new Aura.$Event$.$Event$({"name":name, "eventDef":eventDef, "component":this.$getConcreteComponent$()})
};
goog.$exportProperty$(Component.prototype, "getEvent", Component.prototype.$getEvent$);
Component.prototype.$getEventByDescriptor$ = function(descriptor) {
  var name = this.$getDef$().$getEventNameByDescriptor$(descriptor);
  if(name === null) {
    return null
  }
  return this.$getEvent$(name)
};
Component.prototype.$fire$ = function(name) {
  var dispatcher = this.$getEventDispatcher$();
  if(!dispatcher) {
    return
  }
  var eventDef = this.$componentDef$.$getEventDef$(name, true);
  var eventQName = eventDef.$getDescriptor$().$getQualifiedName$();
  var handlers = dispatcher[eventQName];
  if(handlers) {
    var event = new Aura.$Event$.$Event$({"eventDef":eventDef, "eventDispatcher":dispatcher});
    event.$setParams$({value:this});
    event.$fire$()
  }
};
Component.prototype.$isDirty$ = function(expression) {
  if(!expression) {
    return $A.$renderingService$.$hasDirtyValue$(this)
  }
  return $A.$renderingService$.$isDirtyValue$(expression, this)
};
goog.$exportProperty$(Component.prototype, "isDirty", Component.prototype.$isDirty$);
Component.prototype.$isValid$ = function() {
  return!this.$destroyed$
};
goog.$exportProperty$(Component.prototype, "isValid", Component.prototype.$isValid$);
Component.prototype.toString = function() {
  if(!this.$_description$) {
    this.$_description$ = this.$getDef$() + " {" + this.$globalId$ + "}" + (this.$getLocalId$() ? " {" + this.$getLocalId$() + "}" : "")
  }
  var attributesOutput = [];
  return this.$_description$ + attributesOutput.join(",")
};
goog.$exportProperty$(Component.prototype, "toString", Component.prototype.toString);
Component.prototype.toJSON = function() {
  return{"globalId":this.$globalId$, "isValid":this.$isValid$()}
};
Component.prototype.$getHandledEvents$ = function() {
  var ret = {};
  var concrete = this.$getConcreteComponent$();
  var eventDispatcher = concrete.$getEventDispatcher$();
  if(eventDispatcher) {
    for(var name in eventDispatcher) {
      if(eventDispatcher.hasOwnProperty(name)) {
        var eventHandlerConfig = eventDispatcher.hasOwnProperty(name) && eventDispatcher[name];
        for(var phase in eventHandlerConfig) {
          if(eventHandlerConfig.hasOwnProperty(phase) && eventHandlerConfig[phase].length) {
            ret[name.toLowerCase()] = true;
            break
          }
        }
      }
    }
  }
  return ret
};
goog.$exportProperty$(Component.prototype, "getHandledEvents", Component.prototype.$getHandledEvents$);
Component.prototype.$hasEventHandler$ = function(eventName) {
  if(eventName) {
    var handledEvents = this.$getHandledEvents$();
    return handledEvents[eventName.toLowerCase()]
  }
  return false
};
goog.$exportProperty$(Component.prototype, "hasEventHandler", Component.prototype.$hasEventHandler$);
Component.prototype.$getFacets$ = function() {
  if(!this.$_cachedFacetNames$) {
    var facetNames = [];
    var attributeDefs = this.$getDef$().$getAttributeDefs$();
    var values = attributeDefs.$getValues$();
    if(values) {
      var valueNames = attributeDefs.$getNames$();
      var attributeDef;
      var c = 0;
      for(var length = valueNames.length;c < length;c++) {
        attributeDef = values[valueNames[c]];
        if(attributeDef.$getTypeDefDescriptor$() === "aura://Aura.Component[]") {
          facetNames.push(attributeDef.$getDescriptor$().getName())
        }
      }
    }
    this.$_cachedFacetNames$ = facetNames
  }
  var names = this.$_cachedFacetNames$;
  var facets = [];
  var i = 0;
  for(var len = names.length;i < len;i++) {
    facets.push(this.get("v." + names[i]))
  }
  return facets
};
goog.$exportProperty$(Component.prototype, "getFacets", Component.prototype.$getFacets$);
Component.prototype.$isFlavorable$ = function() {
  return this.$flavorable$
};
goog.$exportProperty$(Component.prototype, "isFlavorable", Component.prototype.$isFlavorable$);
Component.prototype.$getFlavor$ = function() {
  return this.$flavor$ || this.$getDef$().$getDefaultFlavor$()
};
goog.$exportProperty$(Component.prototype, "getFlavor", Component.prototype.$getFlavor$);
Component.prototype.$render$ = function() {
  if(this.$destroyed$) {
    return null
  }
  var render = this["renderer"] && this["renderer"]["render"];
  if(render) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      var secureThis = $A.$lockerService$.$wrapComponent$(this);
      var result = render(secureThis, this["helper"]);
      if(secureThis !== this) {
        result = $A.$lockerService$.$unwrap$(this, result)
      }
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    return this.$superRender$()
  }
};
goog.$exportProperty$(Component.prototype, "render", Component.prototype.$render$);
Component.prototype.$afterRender$ = function() {
  if(this.$destroyed$) {
    return
  }
  var afterRender = this["renderer"] && this["renderer"]["afterRender"];
  if(afterRender) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      afterRender($A.$lockerService$.$wrapComponent$(this), this["helper"])
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    this.$superAfterRender$()
  }
};
goog.$exportProperty$(Component.prototype, "afterRender", Component.prototype.$afterRender$);
Component.prototype.$rerender$ = function() {
  if(this.$destroyed$) {
    return null
  }
  var rerender = this["renderer"] && this["renderer"]["rerender"];
  if(rerender) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      var secureThis = $A.$lockerService$.$wrapComponent$(this);
      var result = rerender(secureThis, this["helper"]);
      if(secureThis !== this) {
        result = $A.$lockerService$.$unwrap$(this, result)
      }
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    return this.$superRerender$()
  }
};
goog.$exportProperty$(Component.prototype, "rerender", Component.prototype.$rerender$);
Component.prototype.$unrender$ = function() {
  if(this.$destroyed$ === 1) {
    return
  }
  $A.$renderingService$.$cleanComponent$(this.$globalId$);
  var unrender = this["renderer"] && this["renderer"]["unrender"];
  if(unrender) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      unrender($A.$lockerService$.$wrapComponent$(this), this["helper"])
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    if(this.$isRootComponent$) {
      $A.$renderingService$.$unrenderFacet$(this)
    }
    this.$superUnrender$()
  }
};
goog.$exportProperty$(Component.prototype, "unrender", Component.prototype.$unrender$);
Component.prototype.$getVersion$ = function() {
  if(this.$destroyed$) {
    return null
  }
  var ret = this.$getVersionInternal$();
  return ret ? ret : this.get("version")
};
goog.$exportProperty$(Component.prototype, "getVersion", Component.prototype.$getVersion$);
Component.prototype.$getVersionInternal$ = function() {
  return $A.$clientService$.$getAccessVersion$(this.$getType$().split(":")[0])
};
Component.prototype.$getValueProvider$ = function(key) {
  if(this.$valueProviders$.hasOwnProperty(key)) {
    return this.$valueProviders$[key]
  }
  key = key.toLowerCase();
  if(this.$valueProviders$.hasOwnProperty(key)) {
    return this.$valueProviders$[key]
  }
};
Component.prototype.$setupValueProviders$ = function(customValueProviders) {
  if(!this.$attributeSet$) {
    this.$attributeSet$ = this.$isConcrete$() ? new AttributeSet(this.$componentDef$.$attributeDefs$) : this.$getConcreteComponent$().$attributeSet$
  }
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$;
  vp["m"] = this.$model$;
  vp["c"] = this.$createActionValueProvider$();
  vp["e"] = this.$createEventValueProvider$();
  vp["this"] = this;
  vp["globalid"] = this.$getGlobalId$();
  vp["def"] = this.$componentDef$;
  vp["style"] = this.$createStyleValueProvider$();
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
Component.prototype.$createActionValueProvider$ = function() {
  var controllerDef = this.$componentDef$.$getControllerDef$();
  if(controllerDef || this["controller"]) {
    return new ActionValueProvider(this, controllerDef)
  }
};
Component.prototype.$createStyleValueProvider$ = function() {
  return new StyleValueProvider(this)
};
Component.prototype.$setupComponentDef$ = function(config) {
  var componentDef = $A.$componentService$.$getDef$(config["componentDef"]);
  $A.assert(componentDef, "componentDef is required");
  this.$componentDef$ = componentDef;
  if(config["original"]) {
    this.$replaceComponentClass$(componentDef.$getDescriptor$().$getQualifiedName$())
  }
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
Component.prototype.$createComponentStack$ = function(facets, valueProvider) {
  var facetStack = {};
  for(var i = 0;i < facets.length;i++) {
    var facet = facets[i];
    var facetName = facet["descriptor"];
    var facetConfig = facet["value"];
    if(!$A["util"].isArray(facetConfig)) {
      facetConfig = [facetConfig]
    }
    var action = $A.getContext().$getCurrentAction$();
    if(action) {
      action.$pushCreationPath$(facetName)
    }
    var components = [];
    for(var index = 0;index < facetConfig.length;index++) {
      var config = facetConfig[index];
      if($A["util"].$isComponent$(config)) {
        components.push(config);
        config.$setContainerComponentId$(this.$globalId$)
      }else {
        if(config && config["componentDef"]) {
          if(action) {
            action.$setCreationPathIndex$(index)
          }
          $A.$clientService$.$setCurrentAccess$(valueProvider);
          try {
            var facetConfigAttr = {"values":{}};
            var facetConfigClone = $A["util"].apply({}, config);
            if(facetConfigClone["attributes"]) {
              $A["util"].apply(facetConfigAttr["values"], config["attributes"]["values"], true)
            }else {
              facetConfigClone["attributes"] = {}
            }
            facetConfigAttr["valueProvider"] = config["attributes"] && config["attributes"]["valueProvider"] || valueProvider;
            facetConfigClone["attributes"] = facetConfigAttr;
            facetConfigClone["containerComponentId"] = this.$globalId$;
            components.push($A.$componentService$.$createComponentPriv$(facetConfigClone))
          }finally {
            $A.$clientService$.$releaseCurrentAccess$()
          }
        }else {
          throw new $A.$auraError$("Component.createComponentStack: invalid config. Expected component definition, found '" + config + "'.", null, $A.severity.$QUIET$);
        }
      }
    }
    if(action) {
      action.$popCreationPath$(facetName)
    }
    facetStack[facetName] = components
  }
  return facetStack
};
Component.prototype.$setupSuper$ = function(configAttributes) {
  var superDef = this.$componentDef$.$getSuperDef$();
  if(superDef) {
    var superConfig = {};
    var superAttributes = {};
    superConfig["componentDef"] = {"descriptor":superDef.$getDescriptor$().toString()};
    superConfig["concreteComponentId"] = this.$concreteComponentId$ || this.$globalId$;
    $A.$pushCreationPath$("super");
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      if(configAttributes) {
        superAttributes["values"] = {};
        var facets = this.$componentDef$.$getFacets$();
        if(facets) {
          for(var i = 0;i < facets.length;i++) {
            var facetDef = AttributeSet.$getDef$(facets[i]["descriptor"], this.$componentDef$);
            if(!$A.$clientService$.$allowAccess$(facetDef[0], facetDef[1])) {
              var message = "Access Check Failed! Component.setupSuper():'" + facets[i]["descriptor"] + "' of component '" + this + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
              if($A.$clientService$.$enableAccessChecks$) {
                if($A.$clientService$.$logAccessFailures$) {
                  $A.error(null, new $A.$auraError$(message))
                }
                continue
              }else {
                if($A.$clientService$.$logAccessFailures$) {
                  $A.$warning$(message)
                }
              }
            }
            superAttributes["values"][facets[i]["descriptor"]] = facets[i]["value"]
          }
        }
        superAttributes["events"] = configAttributes["events"];
        superAttributes["valueProvider"] = configAttributes["facetValueProvider"]
      }
      superConfig["attributes"] = superAttributes;
      this.$setSuperComponent$($A.$componentService$.$createComponentPriv$(superConfig))
    }finally {
      $A.$clientService$.$releaseCurrentAccess$();
      $A.$popCreationPath$("super")
    }
  }
};
Component.prototype.$setSuperComponent$ = function(component) {
  if(component) {
    this.$superComponent$ = component
  }
};
Component.prototype.$isCollectionOfAuraComponentDefs$ = function(facetValueConfig) {
  if($A["util"].isArray(facetValueConfig)) {
    for(var i = 0;i < facetValueConfig.length;i++) {
      var facetItem = facetValueConfig[i];
      if(!facetItem["componentDef"] || !facetItem["componentDef"]["descriptor"]) {
        return false
      }
    }
    return true
  }else {
    return false
  }
};
Component.prototype.$setupAttributes$ = function(config, localCreation) {
  var configValues = config && config["values"] || {};
  if(!configValues.hasOwnProperty("body")) {
    configValues["body"] = []
  }
  var attributes = {};
  var attributeDefs = this.$componentDef$.$attributeDefs$;
  var attributeNames = attributeDefs.$getNames$();
  var setByDefault = {};
  var partialAttributes = this.$partialConfig$ && this.$partialConfig$["attributes"] && this.$partialConfig$["attributes"]["values"];
  if(!this.$concreteComponentId$) {
    for(var x = 0;x < attributeNames.length;x++) {
      var name = attributeNames[x];
      var defaultDef = attributeDefs.$getDef$(name);
      var defaultValue = defaultDef.$getDefault$();
      if(defaultValue !== undefined) {
        if(!configValues.hasOwnProperty(name) || $A["util"].$equals$(configValues[name], defaultValue)) {
          setByDefault[name] = true;
          if(defaultDef.$getTypeDefDescriptor$() === "aura://Aura.Component[]" || defaultDef.$getTypeDefDescriptor$() === "aura://Aura.ComponentDefRef[]") {
            defaultValue = $A["util"].apply([], defaultValue, true, true);
            for(var facet = 0;facet < defaultValue.length;facet++) {
              if(defaultValue[facet]["attributes"] && !defaultValue[facet]["attributes"]["valueProvider"]) {
                defaultValue[facet]["attributes"]["valueProvider"] = this
              }
            }
            configValues[defaultDef.$getDescriptor$().getName()] = defaultValue
          }else {
            configValues[defaultDef.$getDescriptor$().getName()] = valueFactory.create(defaultValue, this)
          }
        }
      }else {
        if(defaultDef.required && !configValues.hasOwnProperty(name)) {
          $A.$warning$("While creating component '" + this.type + "' ; missing required attribute '" + name + "'. " + $A.$clientService$.$getAccessStackHierarchy$())
        }
      }
      if(!setByDefault[name] && partialAttributes && partialAttributes[name] === configValues[name]) {
        setByDefault[name] = true
      }
    }
  }
  for(var attribute in configValues) {
    var value = configValues[attribute];
    var attributeDef = attributeDefs.$getDef$(attribute);
    if(!attributeDef) {
      continue
    }
    if($A.$componentService$.$isConfigDescriptor$(value)) {
      value = value["value"]
    }
    var attributeType = attributeDef.$getTypeDefDescriptor$();
    var isFacet = attributeType === "aura://Aura.Component[]" || attributeType === "aura://Object" && this.$isCollectionOfAuraComponentDefs$(value);
    var isDefRef = attributeType === "aura://Aura.ComponentDefRef[]";
    if(!setByDefault[attribute]) {
      var def = AttributeSet.$getDef$(attribute, this.$getDef$());
      if(!$A.$clientService$.$allowAccess$(def[0], def[1])) {
        var message = "Access Check Failed! Component.setupAttributes():'" + attribute + "' of component '" + this + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
        if($A.$clientService$.$enableAccessChecks$) {
          if($A.$clientService$.$logAccessFailures$) {
            $A.error(null, new $A.$auraError$(message))
          }
          continue
        }else {
          if($A.$clientService$.$logAccessFailures$) {
            $A.$warning$(message)
          }
        }
      }
    }
    if(isFacet) {
      if($A["util"].$isUndefinedOrNull$(value)) {
        continue
      }
      var attributeValueProvider = config && config["valueProvider"] || this.$getAttributeValueProvider$();
      value = valueFactory.create(value, config["valueProvider"]);
      if($A["util"].$isExpression$(value)) {
        value.$addChangeHandler$(this, "v." + attribute);
        value = value.evaluate()
      }
      if($A["util"].$isString$(value)) {
        value = [$A.$componentService$.$createComponentPriv$({"componentDef":{"descriptor":"markup://aura:text"}, "attributes":{"values":{"value":value}}})]
      }
      var facetStack = this.$createComponentStack$([{"descriptor":attribute, value:value}], attributeValueProvider, localCreation);
      if(attribute === "body") {
        attributes[attribute] = this.$concreteComponentId$ && this.$getConcreteComponent$().$attributeSet$.$values$["body"] || {};
        attributes[attribute][this.$globalId$] = facetStack["body"] || []
      }else {
        attributes[attribute] = facetStack[attribute]
      }
    }else {
      if(isDefRef) {
        if($A["util"].$isUndefinedOrNull$(value)) {
          continue
        }
        if(!$A["util"].isArray(value)) {
          var reference = valueFactory.create(value, config["valueProvider"]);
          if($A["util"].$isExpression$(reference)) {
            reference.$addChangeHandler$(this, "v." + attribute, null, true);
            value = reference.evaluate()
          }else {
            value = [value];
            $A.$warning$("Component.setupAttributes: CDR[] WAS NOT AN ARRAY")
          }
        }
        var cdrs = [];
        for(var i = 0;i < value.length;i++) {
          var cdrObj = value[i];
          var cdr = {"attributes":{"values":{}}};
          cdr["componentDef"] = cdrObj["componentDef"];
          cdr["localId"] = cdrObj["localId"];
          cdr["flavor"] = cdrObj["flavor"];
          if(cdrObj["attributes"]) {
            $A["util"].apply(cdr["attributes"]["values"], cdrObj["attributes"]["values"])
          }
          cdr["attributes"]["valueProvider"] = cdrObj["attributes"] && cdrObj["attributes"]["valueProvider"] || config["valueProvider"];
          cdrs.push(cdr)
        }
        if(attribute === "body") {
          attributes[attribute] = this.$concreteComponentId$ && this.$getConcreteComponent$().$attributeSet$.$values$["body"] || {};
          attributes[attribute][this.$globalId$] = cdrs
        }else {
          attributes[attribute] = cdrs
        }
      }else {
        attributes[attribute] = valueFactory.create(value, config["valueProvider"] || this);
        if($A["util"].$isExpression$(attributes[attribute])) {
          attributes[attribute].$addChangeHandler$(this, "v." + attribute)
        }
      }
    }
  }
  if(this.$concreteComponentId$) {
    var concreteComponent = this.$getConcreteComponent$();
    concreteComponent.$attributeSet$.$merge$(attributes, null, this);
    this.$attributeSet$ = concreteComponent.$attributeSet$
  }else {
    this.$attributeSet$.$initialize$(attributes, this)
  }
};
Component.prototype.$validatePartialConfig$ = function(config, partialConfig) {
  var partialConfigO = partialConfig["original"];
  var partialConfigCD;
  var configCD = config["componentDef"]["descriptor"];
  if(!configCD) {
    configCD = config["componentDef"]
  }else {
    if(configCD.$getQualifiedName$) {
      configCD = configCD.$getQualifiedName$()
    }
  }
  if(partialConfig["componentDef"]) {
    if(partialConfig["componentDef"]["descriptor"]) {
      partialConfigCD = partialConfig["componentDef"]["descriptor"]
    }else {
      partialConfigCD = partialConfig["componentDef"]
    }
  }
  if(partialConfigO !== undefined && partialConfigCD !== configCD) {
    if(partialConfigO !== configCD) {
      $A.log("Configs at error");
      $A.log(config);
      $A.log(partialConfig);
      var mismatchErrorOrig = new $A.$auraError$("Mismatch at " + this.$globalId$ + " client expected " + configCD + " but got original " + partialConfigO + " providing " + partialConfigCD + " from server " + " for creationPath \x3d " + this.$creationPath$, null, $A.severity.$QUIET$);
      mismatchErrorOrig.$setAdditionalStacktraceGen$("Creation path mismatch");
      throw mismatchErrorOrig;
    }
  }else {
    if(partialConfigCD) {
      if(partialConfigCD !== configCD) {
        $A.log("Configs at error");
        $A.log(config);
        $A.log(partialConfig);
        var mismatchError = new $A.$auraError$("Mismatch at " + this.$globalId$ + " client expected " + configCD + " but got " + partialConfigCD + " from server " + " for creationPath \x3d " + this.$creationPath$, null, $A.severity.$QUIET$);
        mismatchError.$setAdditionalStacktraceGen$("Creation path mismatch");
        throw mismatchError;
      }
    }
  }
};
Component.prototype.$getMethodHandler$ = function(methodDef, methodEventDef) {
  var component = this;
  return function Component$getMethodHandler() {
    if(!$A.$clientService$.$allowAccess$(methodDef, component)) {
      var message = "Access Check Failed! Component.method():'" + methodDef.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        return undefined
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
    var methodName = methodDef.$getDescriptor$().name;
    var actionTarget = methodDef.action || "c.".concat(methodName);
    var action = component.get(actionTarget);
    if(action) {
      var methodEvent = new Aura.$Event$.$Event$({"eventDef":methodEventDef});
      var params = {"name":methodName, "arguments":null};
      if(methodDef.attributes && methodDef.attributes.$getNames$().length > 0) {
        params["arguments"] = {};
        var counter = 0;
        var attributeNames = methodDef.attributes.$getNames$();
        for(var a = 0;a < attributeNames.length;a++) {
          var attributeName = attributeNames[a];
          params["arguments"][attributeName] = arguments[counter] === undefined ? methodDef.attributes.$getDef$(attributeName).$getDefault$() : arguments[counter];
          counter++
        }
        for(var i = counter;i < arguments.length;i++) {
          params["argument_" + i] = arguments[i]
        }
      }else {
        params["arguments"] = $A["util"].$toArray$(arguments)
      }
      methodEvent.$setParams$(params);
      methodEvent.$fired$ = true;
      action.$runDeprecated$(methodEvent);
      return action.returnValue
    }
    return undefined
  }
};
Component.prototype.$getActionCaller$ = function(valueProvider, actionExpression) {
  if(!valueProvider && $A["util"].$isExpression$(actionExpression)) {
    valueProvider = actionExpression.$valueProvider$
  }
  var actionCaller = function Component$getActionCaller(event) {
    if(valueProvider.$destroyed$ === 1 && event.$getDef$().$getDescriptor$().getName() !== "valueDestroy") {
      return
    }
    var clientAction;
    actionExpression = valueFactory.create(actionExpression, valueProvider);
    if($A["util"].$isExpression$(actionExpression)) {
      clientAction = actionExpression.evaluate()
    }else {
      clientAction = valueProvider.get(actionExpression)
    }
    if(clientAction && $A["util"].$isString$(clientAction)) {
      clientAction = valueProvider.$getConcreteComponent$().get(clientAction)
    }
    if($A["util"].$isAction$(clientAction)) {
      clientAction.$runDeprecated$(event)
    }else {
      if($A["util"].$isEvent$(clientAction)) {
        clientAction.$sourceEvent$ = event;
        clientAction.$fire$()
      }else {
        $A.assert(false, "no client action by name " + actionExpression)
      }
    }
  };
  actionCaller["valueProvider"] = valueProvider;
  actionCaller["actionExpression"] = actionExpression;
  return actionCaller
};
Component.prototype.$createEventValueProvider$ = function() {
  if(!this.$eventValueProvider$ && !this.$destroyed$) {
    this.$eventValueProvider$ = new EventValueProvider(this)
  }
  return this.$eventValueProvider$
};
Component.prototype.$getEventDispatcher$ = function() {
  if(!this.$eventValueProvider$) {
    if(!this.$destroyed$) {
      this.$createEventValueProvider$()
    }else {
      return null
    }
  }
  return this.$eventValueProvider$.$events$
};
goog.$exportProperty$(Component.prototype, "getEventDispatcher", Component.prototype.$getEventDispatcher$);
Component.prototype.$setupComponentEvents$ = function(cmp, config) {
  var dispatcher;
  if(!this.$concreteComponentId$) {
    var events = this.$componentDef$.$getAllEvents$();
    var len = events.length;
    if(len > 0) {
      dispatcher = this.$getEventDispatcher$();
      if(dispatcher !== null) {
        for(var i = 0;i < events.length;i++) {
          dispatcher[events[i]] = {}
        }
      }
    }
    var def = this.$componentDef$;
    var keys = def.$getAllEvents$();
    var values = config["events"] || config["values"];
    if(values) {
      var valueProvider = config["valueProvider"];
      for(var j = 0;j < keys.length;j++) {
        var key = keys[j];
        var eventValue = values[key];
        if(eventValue) {
          $A.assert(!this.$concreteComponentId$, "Event handler for " + key + " defined on super component " + this.$globalId$);
          cmp.$addHandler$(key, valueProvider || this, eventValue["value"] || eventValue, false, "bubble")
        }
      }
    }
  }
  var cmpHandlers = this.$componentDef$.$getCmpHandlerDefs$();
  if(cmpHandlers) {
    for(var k = 0;k < cmpHandlers.length;k++) {
      var cmpHandler = cmpHandlers[k];
      cmp.$addHandler$(cmpHandler["name"], cmp, cmpHandler["action"], false, cmpHandler["phase"], cmpHandler["includeFacets"])
    }
  }
};
Component.prototype.$setupApplicationEventHandlers$ = function() {
  var handlerDefs = this.$componentDef$.$getAppHandlerDefs$();
  if(handlerDefs) {
    for(var i = 0;i < handlerDefs.length;i++) {
      var handlerDef = handlerDefs[i];
      $A.$eventService$.$addEventHandler$(this, handlerDef["eventDef"], valueFactory.create(handlerDef["action"], this), handlerDef["phase"], handlerDef["includeFacets"])
    }
  }
};
Component.prototype.$setupValueEventHandlers$ = function(cmp) {
  var handlerDefs = this.$componentDef$.$getValueHandlerDefs$();
  if(handlerDefs) {
    for(var i = 0;i < handlerDefs.length;i++) {
      var handlerDef = handlerDefs[i];
      var action = valueFactory.create(handlerDef["action"], cmp);
      var event = handlerDef["name"];
      var value = valueFactory.create(handlerDef["value"], cmp);
      if($A["util"].$isExpression$(value) && value.getExpression() === "this") {
        var eventQName = this.$componentDef$.$getEventDef$(event, true).$getDescriptor$().$getQualifiedName$();
        this.$addHandler$(eventQName, this, action, false, "default")
      }else {
        var handlerConfig = {"action":action, "event":event, "value":value};
        cmp.$addChangeHandler$(handlerConfig)
      }
    }
  }
};
Component.prototype.$setupMethods$ = function() {
  var defs = this.$componentDef$.$methodDefs$;
  if(defs) {
    var methodEventDef = $A.$eventService$.$getEventDef$("aura:methodCall");
    var methodDef;
    for(var i = 0;i < defs.length;i++) {
      methodDef = new Aura.$Method$.$MethodDef$(defs[i]);
      this[methodDef.$getDescriptor$().name] = this.$getMethodHandler$(methodDef, methodEventDef)
    }
  }
};
Component.prototype.$setupModel$ = function(config) {
  var def = this.$componentDef$.$getModelDef$();
  if(def) {
    if(!config && this.$partialConfig$) {
      config = this.$partialConfig$["model"]
    }
    this.$model$ = def.$newInstance$(config || {})
  }
};
Component.prototype.$setupFlavors$ = function(config, configAttributes) {
  if(config["flavorable"]) {
    this.$flavorable$ = true
  }
  if(config["flavor"]) {
    this.$flavor$ = valueFactory.create(config["flavor"], configAttributes["valueProvider"])
  }
};
Component.prototype.$doIndex$ = function(cmp) {
  var localId = this.$localId$;
  if(!$A["util"].$isUndefinedOrNull$(localId)) {
    var valueProvider = cmp.$getAttributeValueProvider$();
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(!valueProvider) {
      throw new Error("No attribute value provider defined for component " + cmp);
    }
    if(valueProvider === this) {
      valueProvider = this.$getOwner$()
    }
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(!valueProvider) {
      throw new Error("No owner specified for component " + cmp);
    }
    valueProvider.index(localId, this.$globalId$)
  }
};
Component.prototype.$doDeIndex$ = function() {
  var localId = this.$localId$;
  if(localId) {
    var valueProvider = this.$getAttributeValueProvider$();
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(valueProvider === this) {
      valueProvider = this.$getOwner$()
    }
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(!$A["util"].$isUndefinedOrNull$(valueProvider)) {
      valueProvider.$deIndex$(localId, this.$globalId$)
    }
  }
};
Component.prototype.$replaceComponentClass$ = function(descriptor) {
  var classConstructor = $A.$componentService$.$getComponentClass$(descriptor);
  if(classConstructor && this["constructor"] !== classConstructor) {
    this["constructor"] = classConstructor;
    this["controller"] = classConstructor.prototype["controller"];
    this["helper"] = classConstructor.prototype["helper"];
    this["renderer"] = classConstructor.prototype["renderer"];
    this["provider"] = classConstructor.prototype["provider"]
  }
};
Component.prototype.$injectComponent$ = function(config, localCreation) {
  if((this.$componentDef$.$isAbstract$() || this["provider"]) && !this.$concreteComponentId$) {
    var context = $A.getContext();
    var act = context.$getCurrentAction$();
    if(act) {
      act.$reactivatePath$()
    }
    if(this["provider"]) {
      $A.$clientService$.$setCurrentAccess$(this);
      try {
        var providedConfig = this.$provide$(localCreation);
        this.$setProvided$(providedConfig["componentDef"], providedConfig["attributes"])
      }finally {
        $A.$clientService$.$releaseCurrentAccess$()
      }
    }else {
      $A.assert(this.$partialConfig$, "Abstract component without provider def cannot be instantiated : " + this.$componentDef$);
      this.$setProvided$($A.$componentService$.$getDef$(this.$partialConfig$["componentDef"]), null)
    }
    this.$setupModel$(config["model"]);
    this.$valueProviders$["m"] = this.$model$;
    this.$valueProviders$["c"] = this.$createActionValueProvider$()
  }
};
Component.prototype.$provide$ = function(localCreation) {
  var provideMethod = this["provider"] && this["provider"]["provide"];
  $A.assert(provideMethod, "Provide method not found");
  var providedConfig = provideMethod(this, localCreation);
  if(!providedConfig || $A["util"].$isString$(providedConfig)) {
    providedConfig = {"componentDef":providedConfig}
  }
  if(providedConfig["componentDef"]) {
    var def = $A.$componentService$.$getDef$(providedConfig["componentDef"]);
    providedConfig["componentDef"] = def
  }else {
    providedConfig["componentDef"] = this.$getDef$()
  }
  return providedConfig
};
Component.prototype.$setProvided$ = function(realComponentDef, attributes) {
  $A.assert(realComponentDef instanceof ComponentDef, "No definition for provided component: " + this.$componentDef$);
  $A.assert(!realComponentDef.$isAbstract$(), "Provided component cannot be abstract: " + realComponentDef);
  $A.assert(!realComponentDef.$hasRemoteDependencies$() || realComponentDef.$hasRemoteDependencies$() && this.$partialConfig$, "Client provided component cannot have server dependencies: " + realComponentDef);
  if(this.$componentDef$ === realComponentDef && !attributes) {
    return
  }
  this.$componentDef$ = realComponentDef;
  this.$attributeSet$.$merge$(attributes, realComponentDef.$getAttributeDefs$(), this);
  this.$replaceComponentClass$(realComponentDef.$getDescriptor$().$getQualifiedName$())
};
Component.prototype.$associateRenderedBy$ = function(cmp, element) {
  if(!$A["util"].$hasDataAttribute$(element, $A.$componentService$.$renderedBy$)) {
    $A["util"].$setDataAttribute$(element, $A.$componentService$.$renderedBy$, cmp.$globalId$)
  }
};
Component.prototype.$getLocator$ = function(targetCmp, includeMetadata) {
  return $A.$expressionService$.$resolveLocator$(this, targetCmp, includeMetadata)
};
Aura.$Component$.$Component$ = Component;
function BaseComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
}
BaseComponent.prototype = Object.create(Component.prototype);
BaseComponent.prototype.$superRender$ = function() {
};
BaseComponent.prototype.$superAfterRender$ = function() {
};
BaseComponent.prototype.$superRerender$ = function() {
};
BaseComponent.prototype.$superUnrender$ = function() {
};
BaseComponent.prototype.$getSuper$ = function() {
};
BaseComponent.prototype.$getSuperest$ = function() {
  return this
};
BaseComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = $A.$componentService$.get(this.$concreteComponentId$).$attributeSet$;
  vp["m"] = this.$model$;
  vp["this"] = this;
  vp["globalid"] = this.$concreteComponentId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
BaseComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:component"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
BaseComponent.prototype["renderer"] = {"render":function(component) {
  var rendering = component.$getRendering$();
  return rendering || $A.$renderingService$.$renderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}, "afterRender":function(component) {
  $A.$afterRender$(component.$attributeSet$.$getBody$(component.$globalId$))
}, "rerender":function(component) {
  return $A.$renderingService$.$rerenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}, "unrender":function(component) {
  $A.$renderingService$.$unrenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}};
Aura.$Component$.$BaseComponent$ = BaseComponent;
function ExpressionComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  this.$isRootComponent$ = true;
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes, localCreation);
  this.$doIndex$(this);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
}
ExpressionComponent.prototype = Object.create(Component.prototype);
ExpressionComponent.prototype.$superRender$ = function() {
};
ExpressionComponent.prototype.$superAfterRender$ = function() {
};
ExpressionComponent.prototype.$superRerender$ = function() {
};
ExpressionComponent.prototype.$superUnrender$ = function() {
};
ExpressionComponent.prototype.$getSuper$ = function() {
};
ExpressionComponent.prototype.$getSuperest$ = function() {
  return this
};
ExpressionComponent.prototype.$setContainerComponentId$ = function(containerComponentId) {
  this.$containerComponentId$ = containerComponentId;
  if(this.$isValid$()) {
    var enableAccessChecks = $A.$clientService$.$enableAccessChecks$;
    try {
      $A.$clientService$.$enableAccessChecks$ = false;
      var facetValue = this.get("v.value");
      if($A["util"].isArray(facetValue)) {
        for(var fidx = 0;fidx < facetValue.length;fidx++) {
          if($A["util"].$isComponent$(facetValue[fidx])) {
            for(;facetValue instanceof PassthroughValue;) {
              facetValue = facetValue.$getComponent$()
            }
            facetValue[fidx].$setContainerComponentId$(this.$globalId$)
          }
        }
      }else {
        if($A["util"].$isComponent$(facetValue)) {
          facetValue.$setContainerComponentId$(this.$globalId$)
        }
      }
    }finally {
      $A.$clientService$.$enableAccessChecks$ = enableAccessChecks
    }
  }
};
ExpressionComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
ExpressionComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:expression"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
ExpressionComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:expression" || type === "aura:rootComponent"
};
ExpressionComponent.prototype["renderer"] = {"render":function(component) {
  var value = component.$attributeSet$.$getValue$("value");
  if($A["util"].$isUndefinedOrNull$(value)) {
    value = ""
  }
  if(!$A["util"].$isComponent$(value) && !$A["util"].isArray(value)) {
    var owner = component.$getOwner$();
    $A.$clientService$.$setCurrentAccess$(owner);
    try {
      value = component.$_lastRenderedTextNode$ = $A.$createComponentFromConfig$({"descriptor":"markup://aura:text", "attributes":{"value":value}});
      value.$setContainerComponentId$(component.$globalId$)
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
    $A.$lockerService$.$trust$(owner, value)
  }
  return $A.$renderingService$.$renderFacet$(component, value)
}, "rerender":function(component) {
  var ret = [];
  if(component.$isRendered$()) {
    var value = component.$attributeSet$.$getValue$("value");
    if(!($A["util"].$isComponent$(value) || $A["util"].isArray(value))) {
      if($A["util"].$isUndefinedOrNull$(value)) {
        value = ""
      }
      if(component.$_lastRenderedTextNode$ && component.$_lastRenderedTextNode$.$isValid$()) {
        component.$_lastRenderedTextNode$.set("v.value", value, true);
        value = component.$_lastRenderedTextNode$;
        return $A.$rerender$(value)
      }else {
        value = component.$_lastRenderedTextNode$ = $A.$createComponentFromConfig$({"descriptor":"markup://aura:text", "attributes":{"value":value}});
        value.$setContainerComponentId$(component.$globalId$)
      }
    }else {
      if(component.$_lastRenderedTextNode$) {
        component.$_lastRenderedTextNode$.$destroy$();
        delete component.$_lastRenderedTextNode$
      }
    }
    ret = $A.$renderingService$.$rerenderFacet$(component, value)
  }
  return ret
}, "unrender":function(component) {
  $A.$renderingService$.$unrenderFacet$(component);
  if(component.$_lastRenderedTextNode$) {
    component.$_lastRenderedTextNode$.$destroy$();
    delete component.$_lastRenderedTextNode$
  }
}, "afterRender":function(component) {
  var value = component.$attributeSet$.$getValue$("value");
  if($A["util"].$isComponent$(value) || $A["util"].isArray(value)) {
    $A.$afterRender$(value)
  }
}};
Aura.$Component$.$ExpressionComponent$ = ExpressionComponent;
function HtmlComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  this.$isRootComponent$ = true;
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$doIndex$(this);
  this.$setupFlavors$(config, configAttributes);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
  var tag = this.$attributeSet$.$getValue$("tag");
  if(!$A["util"].$isUndefinedOrNull$(tag)) {
    this.$componentDef$.$getHelper$().$validateTagName$(tag)
  }
  if(tag === "script" && $A.root) {
    throw new Error(HtmlComponent.$SCRIPT_ERROR_MESSAGE$);
  }
}
goog.$exportSymbol$("HtmlComponent", HtmlComponent);
HtmlComponent.$SCRIPT_ERROR_MESSAGE$ = "The HTML tag 'script' is not allowed outside of an application or template markup.";
HtmlComponent.prototype = Object.create(Component.prototype);
HtmlComponent.prototype.$superRender$ = function() {
};
HtmlComponent.prototype.$superAfterRender$ = function() {
};
HtmlComponent.prototype.$superRerender$ = function() {
};
HtmlComponent.prototype.$superUnrender$ = function() {
};
HtmlComponent.prototype.$getSuper$ = function() {
};
HtmlComponent.prototype.$getSuperest$ = function() {
  return this
};
HtmlComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:html"});
  $A.$lockerService$.$trust$(this.$componentDef$, this);
  var owner = this.$getOwner$();
  for(var ownerName = owner.$getType$();ownerName === "aura:iteration" || ownerName === "aura:if";) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$()
  }
  $A.$lockerService$.$trust$(owner, this)
};
HtmlComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["this"] = this;
  vp["globalid"] = this.$globalId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
HtmlComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:html" || type === "aura:rootComponent"
};
HtmlComponent.prototype["renderer"] = {"render":function(component, helper) {
  var tag = component.$attributeSet$.$getValue$("tag");
  if($A["util"].$isUndefinedOrNull$(tag)) {
    throw new Error("Undefined tag attribute for " + component.$getGlobalId$());
  }
  helper.$validateTagName$(tag);
  if(tag === "script" && $A.root) {
    throw new Error(HtmlComponent.$SCRIPT_ERROR_MESSAGE$);
  }
  var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
  var element = document.createElement(tag);
  if($A["util"].$isIE$ && HTMLAttributes && HTMLAttributes["type"]) {
    helper.$createHtmlAttribute$(component, element, "type", HTMLAttributes["type"])
  }
  for(var attribute in HTMLAttributes) {
    if(!$A["util"].$isIE$ || attribute !== "type") {
      helper.$createHtmlAttribute$(component, element, attribute, HTMLAttributes[attribute])
    }
  }
  $A["util"].$setDataAttribute$(element, $A.$componentService$.$renderedBy$, component.$globalId$);
  helper.$processJavascriptHref$(element);
  if(helper.$canHaveBody$(component)) {
    var body = component.$attributeSet$.$getBody$(component.$globalId$);
    $A.$renderingService$.$renderFacet$(component, body, element)
  }
  var owner = component.$getOwner$();
  for(var ownerName = owner.$getType$();ownerName === "aura:iteration" || ownerName === "aura:if";) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$()
  }
  $A.$lockerService$.$trust$(owner, element);
  return element
}, "rerender":function(component, helper) {
  var element = component.$getElement$();
  if(!element) {
    return
  }
  var skipMap = {"height":true, "width":true, "class":true};
  var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
  if(HTMLAttributes) {
    for(var name in HTMLAttributes) {
      var lowerName = name.toLowerCase();
      if(skipMap[lowerName] || lowerName.indexOf("on") === 0) {
        continue
      }
      var value = HTMLAttributes[name];
      if($A["util"].$isExpression$(value)) {
        value = value.evaluate()
      }
      if(helper.$SPECIAL_BOOLEANS$.hasOwnProperty(lowerName)) {
        value = $A["util"].$getBooleanValue$(value)
      }
      var oldValue = element[helper.$caseAttribute$(lowerName)];
      if(value !== oldValue) {
        helper.$createHtmlAttribute$(component, element, lowerName, value);
        if($A["util"].$isExpression$(oldValue)) {
          oldValue.$removeChangeHandler$(component, "HTMLAttributes." + name)
        }
      }
    }
    var className = HTMLAttributes["class"];
    if($A["util"].$isExpression$(className)) {
      className = className.evaluate()
    }
    if($A["util"].$isUndefinedOrNull$(className)) {
      className = ""
    }
    if(!$A["util"].$isUndefinedOrNull$(element.getAttribute("data-aura-class"))) {
      className += " " + element.getAttribute("data-aura-class")
    }
    if(element["className"] !== className) {
      element["className"] = className
    }
  }
  helper.$processJavascriptHref$(element);
  if(helper.$canHaveBody$(component)) {
    $A.$renderingService$.$rerenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$), element)
  }
}, "afterRender":function(component, helper) {
  if(helper.$canHaveBody$(component)) {
    $A.$afterRender$(component.$attributeSet$.$getBody$(component.$globalId$))
  }
}, "unrender":function(component, helper) {
  var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
  for(var attribute in HTMLAttributes) {
    helper.$destroyHtmlAttribute$(component, attribute, HTMLAttributes[attribute])
  }
  $A.$renderingService$.$unrenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}};
HtmlComponent.prototype["helper"] = {$SPECIAL_BOOLEANS$:{"checked":true, "selected":true, "disabled":true, "readonly":true, "multiple":true, "ismap":true, "defer":true, "declare":true, "noresize":true, "nowrap":true, "noshade":true, "compact":true, "autocomplete":true, "required":true}, $SPECIAL_CASINGS$:{"readonly":"readOnly", "colspan":"colSpan", "rowspan":"rowSpan", "bgcolor":"bgColor", "tabindex":"tabIndex", "usemap":"useMap", "accesskey":"accessKey", "maxlength":"maxLength", "for":"htmlFor", 
"class":"className", "frameborder":"frameBorder"}, $BODYLESS_TAGS$:{"area":true, "base":true, "br":true, "col":true, "command":true, "embed":true, "hr":true, "img":true, "input":true, "keygen":true, "link":true, "meta":true, "param":true, "source":true, "track":true, "wbr":true}, $ALLOWED_TAGS$:{"a":true, "abbr":true, "acronym":true, "address":true, "area":true, "article":true, "aside":true, "audio":true, "b":true, "bdi":true, "bdo":true, "big":true, "blockquote":true, "body":true, "br":true, "button":true, 
"caption":true, "canvas":true, "center":true, "cite":true, "code":true, "col":true, "colgroup":true, "command":true, "datalist":true, "dd":true, "del":true, "details":true, "dfn":true, "dir":true, "div":true, "dl":true, "dt":true, "em":true, "fieldset":true, "figure":true, "figcaption":true, "footer":true, "form":true, "h1":true, "h2":true, "h3":true, "h4":true, "h5":true, "h6":true, "head":true, "header":true, "hgroup":true, "hr":true, "html":true, "i":true, "iframe":true, "img":true, "input":true, 
"ins":true, "keygen":true, "kbd":true, "label":true, "legend":true, "li":true, "link":true, "map":true, "mark":true, "menu":true, "meta":true, "meter":true, "nav":true, "ol":true, "optgroup":true, "option":true, "output":true, "p":true, "pre":true, "progress":true, "q":true, "rp":true, "rt":true, "ruby":true, "s":true, "samp":true, "script":true, "section":true, "select":true, "small":true, "source":true, "span":true, "strike":true, "strong":true, "style":true, "sub":true, "summary":true, "sup":true, 
"table":true, "tbody":true, "td":true, "textarea":true, "tfoot":true, "th":true, "thead":true, "time":true, "title":true, "tr":true, "track":true, "tt":true, "u":true, "ul":true, "var":true, "video":true, "wbr":true}, $NAMES$:{"domHandler":"fcDomHandler", "hashHandler":"fcHashHandler"}, $validateTagName$:function(tagName) {
  if(!this.$ALLOWED_TAGS$.hasOwnProperty(tagName) && !this.$ALLOWED_TAGS$.hasOwnProperty(tagName.toLowerCase())) {
    throw new Error("The HTML tag '" + tagName + "' is not allowed.");
  }
}, $caseAttribute$:function(attribute) {
  return this.$SPECIAL_CASINGS$[attribute] || attribute
}, $addNamedClickHandler$:function(element, handler, handlerName) {
  var previousHandler = element[handlerName];
  if($A["util"].$isFunction$(previousHandler)) {
    $A["util"].$removeOn$(element, "click", previousHandler)
  }
  $A["util"].$on$(element, "click", handler);
  element[handlerName] = handler;
  return previousHandler
}, $domEventHandler$:function(event) {
  var eventName = "on" + event.type;
  var element = event.currentTarget;
  var ownerComponent = $A.$componentService$.$getRenderingComponentForElement$(element);
  if(!ownerComponent) {
    return
  }
  var htmlAttributes = ownerComponent.get("v.HTMLAttributes");
  var valueExpression = htmlAttributes[eventName];
  var onclickExpression;
  if(eventName === "ontouchend" || eventName === "onpointerup" || eventName === "onMSPointerUp") {
    onclickExpression = htmlAttributes["onclick"];
    if(!$A["util"].$isEmpty$(onclickExpression)) {
      if($A["util"].$isEmpty$(valueExpression)) {
        valueExpression = onclickExpression
      }
    }
  }
  if($A["util"].$isExpression$(valueExpression)) {
    var action = valueExpression.evaluate();
    if(action) {
      this.$dispatchAction$(action, event, ownerComponent)
    }
  }
}, $dispatchAction$:function(action, event) {
  $A.$run$(function() {
    action.$runDeprecated$(event)
  })
}, $canHaveBody$:function(component) {
  var tag = component.$attributeSet$.$getValue$("tag");
  if($A["util"].$isUndefinedOrNull$(tag)) {
    throw new Error("Undefined tag attribute for " + component.$getGlobalId$());
  }
  return!this.$BODYLESS_TAGS$[tag.toLowerCase()]
}, $createHtmlAttribute$:function(component, element, name, attribute) {
  var value;
  var lowerName = name.toLowerCase();
  if(lowerName.indexOf("on") === 0) {
    var eventName = lowerName.substring(2);
    if(eventName === "click") {
      this.$addNamedClickHandler$(element, $A.$getCallback$(this.$domEventHandler$.bind(this)), this.$NAMES$["domHandler"])
    }else {
      $A["util"].$on$(element, eventName, $A.$getCallback$(this.$domEventHandler$.bind(this)))
    }
  }else {
    var isSpecialBoolean = this.$SPECIAL_BOOLEANS$.hasOwnProperty(lowerName);
    if($A["util"].$isExpression$(attribute)) {
      attribute.$addChangeHandler$(component, "HTMLAttributes." + name);
      value = attribute.evaluate()
    }else {
      value = attribute
    }
    if(isSpecialBoolean) {
      value = $A["util"].$getBooleanValue$(value)
    }
    var isString = $A["util"].$isString$(value);
    if(isString && value.indexOf("/auraFW") === 0) {
      value = $A.getContext().$getContextPath$() + value
    }
    if(lowerName === "href" && element.tagName === "A" && value && $A["util"].$supportsTouchEvents$()) {
      var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
      var target = HTMLAttributes["target"];
      if($A["util"].$isExpression$(target)) {
        target = target.evaluate()
      }
      this.$addNamedClickHandler$(element, function onClickHtmlComponent() {
        if(isString && value.indexOf("#") === 0) {
          $A.$run$(function() {
            $A.$historyService$.set(value.substring(1))
          })
        }
      }, this.$NAMES$["hashHandler"]);
      if(target) {
        element.setAttribute("target", target)
      }
      element.setAttribute("href", value)
    }else {
      if(!$A["util"].$isUndefinedOrNull$(value) && (lowerName === "role" || lowerName.lastIndexOf("aria-", 0) === 0)) {
        element.setAttribute(name, value)
      }else {
        if(isSpecialBoolean) {
          var casedName = this.$caseAttribute$(lowerName);
          if(value === false) {
            element.removeAttribute(casedName);
            if(casedName === "checked") {
              element.removeAttribute("defaultChecked")
            }
          }else {
            element.setAttribute(casedName, name);
            if(casedName === "checked") {
              element.setAttribute("defaultChecked", true)
            }
          }
          if($A["util"].$isUndefinedOrNull$(value)) {
            value = ""
          }
          element[casedName] = value
        }else {
          if($A["util"].$isIE$ && element.tagName === "INPUT" && lowerName === "type") {
            try {
              element.setAttribute("type", value)
            }catch(e) {
              return undefined
            }
          }else {
            if(!$A["util"].$isUndefined$(value) && !($A["util"].$isIE$ && element.tagName === "INPUT" && lowerName === "value" && value === null)) {
              var casedAttribute = this.$caseAttribute$(lowerName);
              lowerName = name.toLowerCase();
              if(lowerName === "style" && $A["util"].$isIE$) {
                element.style.cssText = value
              }else {
                if(lowerName === "type" || lowerName === "href" || lowerName === "style" || lowerName.indexOf("data-") === 0) {
                  element.setAttribute(casedAttribute, value)
                }else {
                  if(lowerName === "srcdoc" && element.tagName === "IFRAME" && !$A["util"].$isUndefinedOrNull$(value)) {
                    var message;
                    if(!$A.get("$Global")["srcdoc"]) {
                      message = "The '" + name + "' attribute is not supported, and will not be set for " + element + " in " + component;
                      $A.$warning$(message)
                    }else {
                      message = "The '" + name + "' attribute has been set for " + element + " in " + component;
                      element[casedAttribute] = value
                    }
                    $A.$logger$.$reportError$(new $A.$auraError$(message), null, "WARNING")
                  }else {
                    if(element.tagName === "LINK" && lowerName === "rel" && value && value.toLowerCase && $A["util"].$isString$(value) && value.toLowerCase().indexOf("import") !== -1) {
                      $A.$warning$("The '" + name + "' attribute is not supported, and will not be set for " + element + " in " + component)
                    }else {
                      if($A["util"].$isUndefinedOrNull$(value)) {
                        value = ""
                      }
                      element[casedAttribute] = value
                    }
                  }
                }
              }
            }else {
              if($A["util"].$isIE$ && element.tagName === "INPUT" && lowerName === "value" && value === null) {
                element.value = ""
              }
            }
          }
        }
      }
    }
  }
}, $destroyHtmlAttribute$:function(component, name, attribute) {
  if($A["util"].$isExpression$(attribute)) {
    attribute.$removeChangeHandler$(component, "HTMLAttributes." + name)
  }
}, $processJavascriptHref$:function(element) {
  if(element.tagName === "A") {
    var href = element.getAttribute("href");
    if(!href) {
      element.setAttribute("href", "javascript:void(0);")
    }
    element.addEventListener("click", this.$inlineJavasciptCSPViolationPreventer$)
  }
}, $inlineJavasciptCSPViolationPreventer$:function(event) {
  var hrefTarget = this.href;
  if(hrefTarget && /^\s*javascript:\s*void\((\s*|0|null|'.*')\)/.test(hrefTarget.toLowerCase())) {
    event.preventDefault()
  }
}};
Aura.$Component$.$HtmlComponent$ = HtmlComponent;
function IfComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$injectComponent$(config, localCreation);
  this.$doIndex$(this);
  this.$setupValueEventHandlers$(this);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
  this.$_destroying$ = false;
  this.$fire$("init")
}
IfComponent.prototype = Object.create(Component.prototype);
IfComponent.prototype.$setupModel$ = function() {
};
IfComponent.prototype.$superRender$ = function() {
};
IfComponent.prototype.$superAfterRender$ = function() {
};
IfComponent.prototype.$superRerender$ = function() {
};
IfComponent.prototype.$superUnrender$ = function() {
};
IfComponent.prototype.$getSuper$ = function() {
};
IfComponent.prototype.$getModel$ = function() {
};
IfComponent.prototype.$getSuperest$ = function() {
  return this
};
IfComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:if"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
IfComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["c"] = this.$createActionValueProvider$();
  vp["this"] = this;
  vp["globalid"] = this.$globalid$;
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
IfComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:if" || type === "aura:rootComponent"
};
IfComponent.prototype["controller"] = {"init":function(cmp, evt, helper) {
  var bodyTemplate = cmp.$attributeSet$.$getBody$(cmp.$globalId$);
  var isTrue = $A["util"].$getBooleanValue$(cmp.$attributeSet$.$getValue$("isTrue"));
  var template = cmp.$attributeSet$.$getValue$("template");
  if(bodyTemplate.length && !template.length) {
    cmp.set("v.template", bodyTemplate, true);
    cmp.set("v.body", [], true)
  }
  var body = helper.$createBody$(cmp, isTrue);
  cmp.set("v.body", body, true);
  cmp.$_truth$ = isTrue
}, "handleTheTruth":function(cmp, evt, helper) {
  var isTrue = $A["util"].$getBooleanValue$(cmp.$attributeSet$.$getValue$("isTrue"));
  if(cmp.$_truth$ !== isTrue) {
    helper.$clearUnrenderedBody$(cmp);
    cmp.set("v.body", helper.$createBody$(cmp, isTrue, true));
    cmp.$_truth$ = isTrue
  }
}};
IfComponent.prototype["helper"] = {$createBody$:function(cmp, isTrue) {
  var body = [];
  var facet = isTrue ? cmp.$attributeSet$.$getValue$("template") : cmp.$attributeSet$.$getValue$("else");
  $A.$pushCreationPath$("body");
  var i = 0;
  for(var length = facet.length;i < length;i++) {
    $A.$setCreationPathIndex$(i);
    var cdr = facet[i];
    if(!cdr["attributes"]["valueProvider"]) {
      cdr["attributes"]["valueProvider"] = cmp.$getAttributeValueProvider$()
    }
    if(!cdr["containerComponentId"]) {
      cdr["containerComponentId"] = cmp.$getGlobalId$()
    }
    body.push($A.$componentService$.$createComponentFromConfig$(cdr))
  }
  $A.$popCreationPath$("body");
  return body
}, $clearUnrenderedBody$:function(cmp) {
  var hasUnrenderBody = false;
  var currentBody = cmp.$attributeSet$.$getBody$(cmp.$globalId$);
  for(var i = 0;i < currentBody.length;i++) {
    var child = currentBody[i];
    if(!child.$isRendered$()) {
      hasUnrenderBody = true;
      child.$destroy$()
    }
  }
  if(hasUnrenderBody) {
    var owner = cmp.$getOwner$();
    $A.$warning$(["[Performance degradation] ", 'markup://aura:if ["' + cmp.$getGlobalId$() + '"] in ', owner.$getType$() + ' ["' + owner.$getGlobalId$() + '"] ', "needed to clear unrendered body.\n", "More info: https://developer.salesforce.com/docs/atlas.en-us.lightning.meta/lightning/perf_warnings_if.htm\n", "Component hierarchy: " + $A["util"].$getComponentHierarchy$(owner)].join(""))
  }
}};
IfComponent.prototype["provider"] = {"provide":function(component) {
  return component
}};
IfComponent.prototype["renderer"] = Aura.$Component$.$BaseComponent$.prototype["renderer"];
Aura.$Component$.$IfComponent$ = IfComponent;
function IterationComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$injectComponent$(config, localCreation);
  this.$setupComponentEvents$(this, configAttributes);
  this.$doIndex$(this);
  this.$setupValueEventHandlers$(this);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
  this.$_destroying$ = false;
  this.$fire$("init")
}
IterationComponent.prototype = Object.create(Component.prototype);
IterationComponent.prototype.$setupModel$ = function() {
};
IterationComponent.prototype.$superRender$ = function() {
};
IterationComponent.prototype.$superAfterRender$ = function() {
};
IterationComponent.prototype.$superRerender$ = function() {
};
IterationComponent.prototype.$superUnrender$ = function() {
};
IterationComponent.prototype.$getSuper$ = function() {
};
IterationComponent.prototype.$getSuperest$ = function() {
  return this
};
IterationComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:iteration"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
IterationComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["c"] = this.$createActionValueProvider$();
  vp["e"] = this.$createEventValueProvider$();
  vp["this"] = this;
  vp["globalid"] = this.$globalId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
IterationComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:iteration" || type === "aura:rootComponent"
};
IterationComponent.prototype["controller"] = {"rangeChange":function(component, evt, helper) {
  helper.$updateBody$(component)
}, "itemsChange":function(component, evt, helper) {
  helper.$updateBody$(component)
}, "templateChange":function(component, evt, helper) {
  helper.$createBody$(component, false)
}, "init":function(component, evt, helper) {
  var bodyTemplate = component.$attributeSet$.$getBody$(component.$globalId$);
  var template = component.$attributeSet$.$getValue$("template");
  if(bodyTemplate.length && !template.length) {
    component.set("v.body", [], true);
    component.set("v.template", bodyTemplate, true)
  }
  helper.$createBody$(component, true)
}};
IterationComponent.prototype["helper"] = {$createBody$:function(component, localCreation) {
  component.set("v.loaded", false);
  component.$_itemInfo$ = [];
  var helper = this;
  this.$buildBody$(component, function createBodyItem(cmp, template, item, index, itemVar, indexVar, templateValueProvider, forceServer, callback) {
    this.$buildTemplate$(cmp, template, item, index, itemVar, indexVar, templateValueProvider, localCreation, forceServer, callback)
  }, function createBodyComplete(cmp, components) {
    if(cmp.$isValid$()) {
      cmp.set("v.body", components, true);
      cmp.set("v.loaded", true);
      var evt = cmp.get("e.iterationComplete");
      if(evt) {
        evt.$fire$({"operation":"Initialize"})
      }
      var queued = cmp.$_queueUpdate$;
      cmp.$_queueUpdate$ = false;
      if(queued) {
        helper.$updateBody$(cmp)
      }
    }
  })
}, $clearUnrenderedBody$:function(component) {
  var currentBody = component.$attributeSet$.$getBody$(component.$globalId$);
  var cleanedCmps = 0;
  if(currentBody.length) {
    for(var i = 0;i < currentBody.length;i++) {
      if(currentBody[i].$isValid$() && !currentBody[i].$isRendered$()) {
        currentBody[i].$destroy$();
        component.$_itemInfo$.splice(i - cleanedCmps, 1);
        cleanedCmps++
      }
    }
    if(cleanedCmps) {
      var owner = component.$getOwner$();
      $A.$warning$(["[Performance degradation] ", "markup://aura:iteration [id:" + component.$getGlobalId$() + "] ", "in ", owner.$getType$() + ' ["' + owner.$getGlobalId$() + '"] ', "had multiple items set in the same Aura cycle.\n", "More info: https://developer.salesforce.com/docs/atlas.en-us.lightning.meta/lightning/perf_warnings_iteration.htm\n", "Component hierarchy: " + $A["util"].$getComponentHierarchy$(owner)].join(""))
    }
  }
}, $updateBody$:function(component) {
  if(component.$attributeSet$.$getValue$("loaded") === false) {
    component.$_queueUpdate$ = true;
    return component.$_queueUpdate$
  }
  this.$clearUnrenderedBody$(component);
  component.set("v.loaded", false);
  var itemInfo = component.$_itemInfo$.slice();
  var helper = this;
  component.$_itemInfo$.length = 0;
  this.$buildBody$(component, function updateBodyItem(cmp, template, item, index, itemVar, indexVar, templateValueProvider, forceServer, callback) {
    var found = false;
    var components = null;
    for(var i = 0;i < itemInfo.length;i++) {
      if(itemInfo[i].item === item) {
        components = itemInfo[i].$components$;
        if(itemInfo[i].index !== index) {
          for(var j = 0;j < components.length;j++) {
            var avp = components[j].$getAttributeValueProvider$();
            if(avp) {
              avp.set(indexVar, index);
              avp.set(itemVar, cmp.$getReference$("v.items[" + index + "]"), true)
            }
          }
        }
        found = true;
        itemInfo.splice(i, 1);
        this.$trackItem$(cmp, item, index, components);
        callback(components);
        break
      }
    }
    if(!found) {
      this.$buildTemplate$(cmp, template, item, index, itemVar, indexVar, templateValueProvider, false, forceServer, callback)
    }
  }, function updateBodyComplete(cmp, components) {
    if(cmp.$isValid$()) {
      cmp.set("v.body", components);
      cmp.set("v.loaded", true);
      var evt = cmp.get("e.iterationComplete");
      if(evt) {
        evt.$fire$({"operation":"Update"})
      }
      var queued = cmp.$_queueUpdate$;
      cmp.$_queueUpdate$ = false;
      if(queued) {
        helper.$updateBody$(cmp)
      }
    }
  })
}, $buildBody$:function(component, itemHandler, completeHandler) {
  function getCollector(index) {
    return function iteration$getCollector(itemComponents) {
      collector[index] = itemComponents;
      if(++currentCall === expectedCalls) {
        var components = [];
        for(var j = 0;j < collector.length;j++) {
          components = components.concat(collector[j])
        }
        completeHandler(component, components)
      }
    }
  }
  var items = component.$attributeSet$.$getValue$("items");
  var template = component.$attributeSet$.$getValue$("template");
  var startIndex = this.$getStart$(component);
  var endIndex = this.$getEnd$(component);
  var expectedCalls = endIndex - startIndex;
  var collector = [];
  var currentCall = 0;
  if(items && items.length && template && template.length && expectedCalls > 0) {
    var itemVar = component.$attributeSet$.$getValue$("var");
    var indexVar = component.$attributeSet$.$getValue$("indexVar");
    var forceServer = component.$attributeSet$.$getValue$("forceServer");
    var templateValueProvider = component.$getComponentValueProvider$();
    $A.$pushCreationPath$("body");
    for(var i = startIndex;i < endIndex;i++) {
      $A.$setCreationPathIndex$(i);
      itemHandler.bind(this)(component, template, items[i], i, itemVar, indexVar, templateValueProvider, forceServer, getCollector(i - startIndex))
    }
    $A.$popCreationPath$("body")
  }else {
    completeHandler(component, [])
  }
}, $buildTemplate$:function(component, template, item, index, itemVar, indexVar, templateValueProvider, localCreation, forceServer, callback) {
  function collector(templateComponents) {
    helper.$trackItem$(component, item, index, templateComponents);
    callback(templateComponents)
  }
  $A.$pushCreationPath$("body");
  var helper = this;
  var componentDefRef = template[0];
  var iterationValueProvider = null;
  if(componentDefRef) {
    $A.$setCreationPathIndex$(0);
    var itemValueProviders = {};
    itemValueProviders[itemVar] = component.$getReference$("v.items[" + index + "]");
    itemValueProviders[indexVar] = index;
    iterationValueProvider = $A.$expressionService$.$createPassthroughValue$(itemValueProviders, componentDefRef["attributes"]["valueProvider"] || templateValueProvider);
    if(localCreation) {
      var components = [];
      for(var i = 0;i < template.length;i++) {
        template[i]["attributes"]["valueProvider"] = iterationValueProvider;
        components.push($A.$createComponentFromConfig$(template[i]))
      }
      collector(components)
    }else {
      $A.$componentService$.$newComponentAsync$(this, collector, template, iterationValueProvider, localCreation, false, forceServer)
    }
  }
  $A.$popCreationPath$("body")
}, $getStart$:function(cmp) {
  return Math.max(0, parseInt(cmp.$attributeSet$.$getValue$("start") || 0, 10))
}, $getEnd$:function(cmp) {
  var items = cmp.$attributeSet$.$getValue$("items");
  if(items && items.length) {
    var end = parseInt(cmp.$attributeSet$.$getValue$("end"), 10);
    return isNaN(end) ? items.length : Math.min(items.length, end)
  }
  return 0
}, $trackItem$:function(component, item, index, components) {
  component.$_itemInfo$.push({item:item, index:index, $components$:components})
}};
IterationComponent.prototype["provider"] = {"provide":function(component) {
  return component
}};
IterationComponent.prototype["renderer"] = {"render":function(component) {
  var rendering = component.$getRendering$();
  return rendering || $A.$renderingService$.$renderFacet$(component, component.get("v.body"))
}, "afterRender":function(component) {
  var body = component.get("v.body");
  $A.$afterRender$(body)
}, "rerender":function(component) {
  var body = component.get("v.body");
  return $A.$renderingService$.$rerenderFacet$(component, body)
}, "unrender":function(component) {
  var body = component.get("v.body");
  $A.$renderingService$.$unrenderFacet$(component, body)
}};
Aura.$Component$.$IterationComponent$ = IterationComponent;
function TextComponent(config, localCreation) {
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = false;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  this.$setupGlobalId$(config["globalId"], localCreation);
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$doIndex$(this)
}
TextComponent.prototype = Object.create(Component.prototype);
TextComponent.prototype.$superRender$ = function() {
};
TextComponent.prototype.$superAfterRender$ = function() {
};
TextComponent.prototype.$superRerender$ = function() {
};
TextComponent.prototype.$superUnrender$ = function() {
};
TextComponent.prototype.$getSuper$ = function() {
};
TextComponent.prototype.$getSuperest$ = function() {
  return this
};
TextComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["this"] = this;
  vp["globalid"] = this.$globalId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
TextComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:text"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
TextComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:text" || type === "aura:rootComponent"
};
TextComponent.prototype["renderer"] = {"render":function(component) {
  var value = component.$attributeSet$.$getValue$("value");
  var trunc = component.$attributeSet$.$getValue$("truncate");
  if(trunc) {
    var truncateByWord = $A["util"].$getBooleanValue$(component.$attributeSet$.$getValue$("truncateByWord"));
    var ellipsis = $A["util"].$getBooleanValue$(component.$attributeSet$.$getValue$("ellipsis"));
    trunc = 1 * trunc;
    value = $A["util"].truncate(value, trunc, ellipsis, truncateByWord)
  }
  var textNode = document.createTextNode($A["util"].$isUndefinedOrNull$(value) ? "" : value);
  var owner = component.$getOwner$();
  for(var ownerName = owner.$getType$();ownerName === "aura:iteration" || ownerName === "aura:if";) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$()
  }
  $A.$lockerService$.$trust$(owner, textNode);
  $A.$renderingService$.$setMarker$(component, textNode);
  return textNode
}, "rerender":function(component) {
  var element = component.$getElement$();
  if(element && element.parentNode) {
    var textValue = component.$attributeSet$.$getValue$("value");
    textValue = $A["util"].$isUndefinedOrNull$(textValue) ? "" : textValue;
    if(element.nodeValue !== textValue) {
      element.nodeValue = textValue
    }
  }
}};
Aura.$Component$.$TextComponent$ = TextComponent;
function InteropComponent(config) {
  var cmpDef = $A.$componentService$.$getDef$(config["componentDef"]);
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$componentDef$ = cmpDef;
  this.$interopCtor$ = cmpDef.$interopCtor$;
  this.$interopDef$ = cmpDef.$interopDef$;
  this.$_customElement$ = null;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$shouldAutoDestroy$ = true;
  this.$localIndex$ = {};
  this.$valueProviders$ = {};
  this.$handlers$ = {};
  this.$localId$ = config["localId"];
  this.$attributeValueProvider$ = config["attributes"]["valueProvider"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.$currentClassMap$ = {};
  this.$elementListeners$ = {};
  this.$references$ = {};
  this.$isPrimitiveString$ = {};
  this.$attrNameToPropMap$ = this.$componentDef$.$attrNameToPropMap$;
  this.$propNameToAttrMap$ = this.$componentDef$.$propNameToAttrMap$;
  this.$setupGlobalId$(config["globalId"]);
  $A.$componentService$.$indexComponent$(this);
  $A.$lockerService$.$trust$(cmpDef.definition, this);
  if(this.$localId$) {
    this.$doIndex$(this)
  }
  this.attributes = this.$setupAttributes$(config["attributes"]);
  this.$updateReadOnlyBoundProps$ = [];
  this.$setupMethods$();
  this.$HTML_ATTRS_TO_DOM_PROPS$ = this.$componentDef$.$HTML_ATTRS_TO_DOM_PROPS$
}
goog.$exportSymbol$("InteropComponent", InteropComponent);
InteropComponent.prototype = Object.create(Component.prototype);
InteropComponent.prototype.constructor = InteropComponent;
InteropComponent.prototype.$bridgeAction$ = function(prv, isEvent, hasNativeAPIExposed, action) {
  var component = this;
  return $A.$getCallback$(function callbackBridge(params) {
    var targetAction = prv && prv.evaluate() || action;
    var event = new Aura.$Event$.$InteropEvent$(component, {"isEvent":isEvent, "params":params, "exposeNativeAPI":!!hasNativeAPIExposed});
    $A.$run$(function() {
      targetAction.$runDeprecated$(event)
    })
  })
};
InteropComponent.prototype.$hasNativeAPIExposed$ = function(eventName) {
  var interopMap = this.$interopCtor$["interopMap"];
  var exposeNativeAPI = interopMap && interopMap["exposeNativeEvent"];
  return exposeNativeAPI && exposeNativeAPI[eventName]
};
InteropComponent.prototype.$setupAttributes$ = function(config) {
  var configValues = config && config["values"] || {};
  var attributes = {};
  var self = this;
  var changeHandlerPRVFactory = function(ctx, attr) {
    return function() {
      ctx.$attributeChange$(attr || this.$handler$.key, ctx.get("v." + (attr ? attr : this.$handler$.key)))
    }
  };
  var changeHandlerFCV = function(attr, fcv) {
    this.$attributeChange$(attr, fcv.evaluate())
  };
  for(var attribute in configValues) {
    if(attribute.indexOf("aura:") === 0) {
      continue
    }
    var isEvent = false;
    var value = configValues[attribute];
    var valueConfig = value;
    if($A.$componentService$.$isConfigDescriptor$(value)) {
      valueConfig = value["value"]
    }
    this.$isPrimitiveString$[attribute] = typeof valueConfig === "string";
    var valueProvider = config["valueProvider"];
    valueConfig = valueFactory.create(valueConfig, valueProvider || this);
    if($A["util"].$isExpression$(valueConfig)) {
      if(valueConfig.$getIsGlobal$ && valueConfig.$getIsGlobal$()) {
        valueConfig = valueConfig.evaluate()
      }else {
        if(valueConfig.getExpression) {
          var key = $A.$expressionService$.normalize(valueConfig.getExpression());
          var provider = key.split(".")[0];
          var isPTV = valueProvider instanceof PassthroughValue;
          $A.assert(isPTV || provider === "c" || provider === "v", "Provider type not supported");
          var valueDescriptor = value["descriptor"] || attribute;
          var startsWithOn = valueDescriptor && valueDescriptor.indexOf("on") === 0;
          var hasNativeAPIExposed = startsWithOn && this.$hasNativeAPIExposed$(valueDescriptor.substr(2));
          if(provider === "v") {
            if(hasNativeAPIExposed) {
              isEvent = true;
              valueConfig = this.$bridgeAction$(valueConfig, isEvent, hasNativeAPIExposed)
            }else {
              valueConfig.$addChangeHandler$(this, attribute, changeHandlerPRVFactory(this))
            }
          }else {
            if(provider === "c") {
              var definedAttribute = !!this.$interopDef$["props"][valueDescriptor];
              $A.assert(definedAttribute || startsWithOn, "Attribute not defined in the component");
              isEvent = !definedAttribute;
              valueConfig = this.$bridgeAction$(valueConfig, isEvent, hasNativeAPIExposed)
            }else {
              valueConfig.$addChangeHandler$(this, attribute, changeHandlerPRVFactory(this, attribute))
            }
          }
        }else {
          valueConfig.$addChangeHandler$(this, attribute, changeHandlerFCV.bind(self, attribute, valueConfig))
        }
      }
    }else {
      if($A["util"].$isAction$(valueConfig)) {
        isEvent = true;
        valueConfig = this.$bridgeAction$(undefined, isEvent, attribute.indexOf("on") === 0 && this.$hasNativeAPIExposed$(attribute.substr(2)), valueConfig)
      }
    }
    var isAttrInDefinition = !!this.$attrNameToPropMap$[attribute];
    var assertionMessage = '"' + attribute + '" must either be a public property of ' + this.getName() + " or a global HTML attribute";
    if(isEvent || isAttrInDefinition || this.$isHtmlGlobalAttr$(attribute)) {
      attributes[attribute] = valueConfig
    }else {
      $A.$warning$(assertionMessage)
    }
  }
  return attributes
};
InteropComponent.prototype.$isHtmlGlobalAttr$ = function(attrName) {
  return InteropComponent.$HTML_GLOBAL_ATTRS$[attrName] || false
};
InteropComponent.prototype.$isReadOnlyProperty$ = function(propName) {
  return this.$interopDef$["props"][propName]["config"] === 1
};
InteropComponent.$HTML_GLOBAL_ATTRS$ = {"accesskey":true, "class":true, "contenteditable":true, "contextmenu":true, "dir":true, "draggable":true, "dropzone":true, "hidden":true, "id":true, "lang":true, "spellcheck":true, "style":true, "tabindex":true, "title":true, "translate":true, "role":true};
InteropComponent.prototype.$getPublicMethodNames$ = function() {
  return Object.keys(this.$interopDef$["methods"])
};
goog.$exportProperty$(InteropComponent.prototype, "getPublicMethodNames", InteropComponent.prototype.$getPublicMethodNames$);
InteropComponent.prototype.$setupMethods$ = function() {
  var self = this;
  this.$getPublicMethodNames$().forEach(function(m) {
    self[m] = function() {
      if(!self.$rendered$) {
        return $A.$warning$("Methods are not available until the component is rendered")
      }
      var elmt = self.$getElement$();
      var rv = elmt[m].apply(elmt, arguments);
      return $A.$componentService$.$moduleEngine$["unwrap"](rv)
    }
  })
};
InteropComponent.prototype.$attributeChange$ = function(key, value) {
  if(this.$rendered$) {
    var element = this.$getElement$();
    var propName = this.$attrNameToPropMap$[key];
    if(!propName && this.$isHtmlGlobalAttr$(key)) {
      this.$setGlobalAttribute$(element, key, value)
    }else {
      if(!this.$isReadOnlyProperty$(propName)) {
        if(propName === this.$propertyToIgnoreOnNextControlledUpdate$) {
          this.$propertyToIgnoreOnNextControlledUpdate$ = undefined
        }else {
          element[propName] = value;
          this.$rehydrateBoundReadOnlyProps$()
        }
      }
    }
  }
};
InteropComponent.prototype.$rehydrateBoundReadOnlyProps$ = function() {
  this.$updateReadOnlyBoundProps$.forEach(function(func) {
    func()
  })
};
InteropComponent.$_classNameCacheMap$ = {};
InteropComponent.prototype.$getMapFromClassName$ = function(className) {
  if(className === undefined || className == null || className === "") {
    return{}
  }
  var SPACE_CHAR = 32;
  var map = InteropComponent.$_classNameCacheMap$[className];
  if(map) {
    return map
  }
  map = {};
  var start = 0;
  var i;
  var len = className.length;
  for(i = 0;i < len;i++) {
    if(className.charCodeAt(i) === SPACE_CHAR) {
      if(i > start) {
        map[className.slice(start, i)] = true
      }
      start = i + 1
    }
  }
  if(i > start) {
    map[className.slice(start, i)] = true
  }
  InteropComponent.$_classNameCacheMap$[className] = map;
  return map
};
InteropComponent.prototype.$updateClassAttribute$ = function(element, value) {
  var currentClassMap = this.$currentClassMap$;
  $A.assert(currentClassMap !== null && typeof currentClassMap === "object", "Current Class Map must be an object.");
  var classMap = this.$getMapFromClassName$(value);
  Object.keys(currentClassMap).forEach(function(className) {
    if(!classMap[className]) {
      element.classList.remove(className)
    }
  });
  Object.keys(classMap).forEach(function(className) {
    if(!currentClassMap[className]) {
      element.classList.add(className)
    }
  });
  this.$currentClassMap$ = classMap
};
InteropComponent.prototype.$setGlobalAttribute$ = function(element, attrName, value) {
  if(attrName === "class") {
    this.$updateClassAttribute$(element, value);
    return
  }
  if(attrName.charCodeAt(0) === 100 && attrName.indexOf("data-") === 0) {
    element.setAttribute(attrName, value);
    return
  }
  var propName = this.$HTML_ATTRS_TO_DOM_PROPS$[attrName] || attrName;
  element[propName] = value
};
InteropComponent.prototype.get = function(key) {
  if(!$A["util"].$isString$(key)) {
    var msg = "The provided key (" + key + ") is not a string and cannot be used to look up values for the current component.";
    throw new $A.$auraError$(msg);
  }
  if(key === "version") {
    return null
  }
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  path.shift();
  $A.assert(path.length === 1, "This component does not allow to get nested properties");
  var propValue = $A.$expressionService$.$resolve$(path.join("."), this.attributes);
  if(propValue !== undefined && propValue !== null && $A["util"].$isExpression$(propValue.value)) {
    propValue = propValue.value.evaluate()
  }else {
    if(!$A["util"].$isExpression$(this.attributes[path[0]])) {
      var propName = this.$attrNameToPropMap$[path[0]];
      var element = this.$getElement$();
      if(propName && element) {
        propValue = element[propName]
      }
    }
  }
  return $A.$componentService$.$moduleEngine$["unwrap"](propValue)
};
goog.$exportProperty$(InteropComponent.prototype, "get", InteropComponent.prototype.get);
InteropComponent.prototype.set = function(key, value) {
  var normalizedKey = $A.$expressionService$.normalize(key);
  var path = normalizedKey.split(".");
  var provider = path.shift();
  var oldValue;
  $A.assert(provider === "v", "This component does not allow mutations on controller actions");
  $A.assert(path.length === 1, "This component does not allow set on nested properties");
  var expr = path.join(".");
  var attrValue = this.attributes[expr];
  if(attrValue && $A["util"].$isExpression$(attrValue.value)) {
    $A.$warning$("Component " + this.$componentDef$.$interopClassName$ + ' is not the owner of property "' + expr + '" and should not change it directly');
    attrValue.value.set(value)
  }else {
    if(attrValue && attrValue.getExpression) {
      oldValue = attrValue.evaluate();
      attrValue.set(value)
    }else {
      oldValue = this.attributes[expr];
      this.attributes[expr] = value;
      this.$attributeChange$(expr, value)
    }
  }
  var changed = $A["util"].isArray(value) || $A["util"].$isObject$(value) || oldValue !== value;
  if(changed) {
    this.$fireChangeEvent$(key, oldValue, value)
  }
};
goog.$exportProperty$(InteropComponent.prototype, "set", InteropComponent.prototype.set);
InteropComponent.$originalCurrentTargetDescriptor$ = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
function getWrappedInteropEventListener(listener, element) {
  var descriptor = {configurable:true, enumerable:true, value:element};
  return function(event) {
    Object.defineProperties(event, {target:descriptor, currentTarget:InteropComponent.$originalCurrentTargetDescriptor$});
    listener(event)
  }
}
InteropComponent.prototype.$attachOnChangeToElement$ = function(element) {
  function handleInteropChange(event) {
    var detail = event.detail;
    if(detail && event.target === element) {
      Object.keys(detail).forEach(function(propName) {
        var attrName = self.$propNameToAttrMap$[propName];
        if(attrName in self.attributes) {
          self.$propertyToIgnoreOnNextControlledUpdate$ = propName;
          try {
            self.set("v." + attrName, detail[propName])
          }finally {
            self.$propertyToIgnoreOnNextControlledUpdate$ = undefined
          }
        }
      })
    }
  }
  var self = this;
  element.addEventListener("change", getWrappedInteropEventListener(handleInteropChange, element))
};
InteropComponent.prototype.$attachInteropEvents$ = function(cmp, element) {
  var findOwnerName = Aura.$ExportsModule$["INTEROP_FIND_OWNER"];
  element.addEventListener(findOwnerName, function claimOwnershipWrapper(event) {
    event.stopPropagation();
    event["detail"]["claimOwnership"](cmp)
  })
};
InteropComponent.prototype.$render$ = function() {
  var element = document.createElement(this.$componentDef$.$elementName$);
  this.$_customElement$ = this.$setupInteropInstance$();
  $A.$lockerService$.$trust$(this, this.$_customElement$);
  return[element]
};
goog.$exportProperty$(InteropComponent.prototype, "render", InteropComponent.prototype.$render$);
InteropComponent.prototype.$setupInteropInstance$ = function() {
  this.$currentClassMap$ = {};
  var elementName = this.$componentDef$.$elementName$;
  var Ctor = this.$interopCtor$;
  var element = this.$invokeLwcRoutine$("constructor", function() {
    return $A.$componentService$.$moduleEngine$["createElement"](elementName, {"is":Ctor})
  });
  var cmp = this;
  element.$__customElement$ = 1;
  this.$attachOnChangeToElement$(element);
  this.$attachInteropEvents$(cmp, element);
  Object.keys(this.attributes).forEach(function(attrName) {
    var value = cmp.get("v." + attrName);
    var propName = this.$attrNameToPropMap$[attrName];
    if(attrName.indexOf("on") === 0 && !propName) {
      var evtName = attrName.substring(2);
      var evtListenerFn = getWrappedInteropEventListener(value, element);
      this.$elementListeners$[evtName] = evtListenerFn;
      element.addEventListener(evtName, evtListenerFn)
    }else {
      if(!propName && this.$isHtmlGlobalAttr$(attrName)) {
        this.$setGlobalAttribute$(element, attrName, value)
      }else {
        if(!cmp.$isReadOnlyProperty$(propName)) {
          if(this.$isPrimitiveString$[propName] && element[propName] === false) {
            value = value === "true"
          }
          if(value !== undefined) {
            element[propName] = value
          }
        }else {
          var attribute = this.$propNameToAttrMap$[propName];
          if($A["util"].$isExpression$(this.attributes[attribute])) {
            this.$updateReadOnlyBoundProps$.push(function() {
              cmp.set("v." + attribute, element[propName])
            })
          }
        }
      }
    }
  }.bind(this));
  return element
};
InteropComponent.prototype.$swapInteropElement$ = function(currentElement, newElement) {
  if(currentElement === newElement) {
    return
  }
  this.$disassociateElements$();
  $A.$renderingService$.$moveReferencesToMarker$(currentElement, newElement);
  this.$associateElement$(newElement);
  this.$invokeLwcRoutine$("connect", function() {
    currentElement.parentElement.replaceChild(newElement, currentElement)
  });
  this.$updateContainerElement$(this.$getContainer$(), currentElement, newElement);
  if(this.$componentDef$.$hasElementConstructor$()) {
    var cmp = this;
    var lwcCmp = this.$getElement$();
    Object.keys(this.$interopDef$["props"]).forEach(function(propName) {
      if(cmp.$isReadOnlyProperty$(propName)) {
        cmp.set("v." + cmp.$propNameToAttrMap$[propName], lwcCmp[propName])
      }
    })
  }
};
InteropComponent.prototype.$updateContainerElement$ = function(container, currentElement, newElement) {
  if(!container) {
    return
  }
  var concrete = container.$getConcreteComponent$();
  if(concrete.$getType$() === "aura:html") {
    return
  }
  var parentAllElements = $A.$renderingService$.$getAllElementsCopy$(concrete);
  if(parentAllElements.indexOf(currentElement) >= 0) {
    concrete.$disassociateElements$();
    for(var i = 0;i < parentAllElements.length;i++) {
      var element = parentAllElements[i];
      if(element === currentElement) {
        concrete.$associateElement$(newElement);
        $A.$renderingService$.$addAuraClass$(concrete, newElement)
      }else {
        concrete.$associateElement$(element)
      }
    }
  }else {
    if(parentAllElements.indexOf(newElement) >= 0) {
      $A.$renderingService$.$addAuraClass$(concrete, newElement)
    }
  }
  this.$updateContainerElement$(concrete.$getContainer$(), currentElement, newElement)
};
InteropComponent.prototype.$afterRender$ = function() {
  if(this.$destroyed$ || this.elements === undefined) {
    return
  }
  var element = this.elements[0];
  if(element && element.parentElement) {
    this.$swapInteropElement$(element, this.$_customElement$);
    return
  }
  var owner = $A.$getCmp$(this.$owner$);
  if(owner) {
    var handleValueRenderOnce = function handleValueRenderOnceFunc() {
      owner.$removeEventHandler$("markup://aura:valueRender", handleValueRenderOnce);
      var el = this.elements[0];
      if(el && el.parentElement) {
        this.$swapInteropElement$(el, this.$_customElement$)
      }else {
        $A.$warning$("Unexpected situation encountered where the interop component " + this.$getGlobalId$() + " never swapped in its custom element due to it missing its parentElement.")
      }
    }.bind(this);
    owner.$addEventHandler$("markup://aura:valueRender", handleValueRenderOnce, "default")
  }
};
goog.$exportProperty$(InteropComponent.prototype, "afterRender", InteropComponent.prototype.$afterRender$);
InteropComponent.prototype.$getElement$ = function() {
  return this.$_customElement$
};
goog.$exportProperty$(InteropComponent.prototype, "getElement", InteropComponent.prototype.$getElement$);
InteropComponent.prototype.$unrender$ = function() {
  $A.$renderingService$.$cleanComponent$(this.$globalId$);
  var elements = this.$getElements$();
  if(elements) {
    this.$invokeLwcRoutine$("disconnect", function() {
      for(;elements.length;) {
        $A["util"].$removeElement$(elements.pop())
      }
    })
  }
  this.$disassociateElements$()
};
goog.$exportProperty$(InteropComponent.prototype, "unrender", InteropComponent.prototype.$unrender$);
InteropComponent.prototype.$destroy$ = function() {
  if(this.$destroyed$) {
    return
  }
  var cmp = this;
  var attrs = this.attributes;
  var customElement = this.$getElement$();
  var elementListeners = this.$elementListeners$;
  this.$destroyed$ = -1;
  Object.keys(attrs).forEach(function(attrName) {
    var attrValue = attrs[attrName];
    if($A["util"].$isExpression$(attrValue)) {
      attrValue.$removeChangeHandler$(cmp, attrName)
    }else {
      if(attrValue && $A["util"].$isExpression$(attrValue.value)) {
        attrValue.value.$removeChangeHandler$(cmp, attrName)
      }
    }
  });
  if(customElement) {
    Object.keys(elementListeners).forEach(function(evtName) {
      customElement.removeEventListener(evtName, elementListeners[evtName])
    })
  }
  this.$elementListeners$ = undefined;
  this.$doDeIndex$();
  $A.$renderingService$.$unrender$(this);
  $A.$componentService$.$deIndex$(this.$globalId$);
  this.$destroyed$ = 1
};
goog.$exportProperty$(InteropComponent.prototype, "destroy", InteropComponent.prototype.$destroy$);
InteropComponent.prototype.find = function() {
  return null
};
goog.$exportProperty$(InteropComponent.prototype, "find", InteropComponent.prototype.find);
InteropComponent.prototype.$findInstancesOf$ = function() {
  return[]
};
InteropComponent.prototype.$findInstanceOf$ = function(type) {
  return this.$getType$() === type ? this : null
};
InteropComponent.prototype.$getSuperest$ = function() {
  this.$raiseInvalidInteropApi$("getSuperest", arguments)
};
InteropComponent.prototype.$implementsDirectly$ = function() {
  this.$raiseInvalidInteropApi$("implementsDirectly", arguments)
};
InteropComponent.prototype.$getRenderer$ = function() {
};
goog.$exportProperty$(InteropComponent.prototype, "getRenderer", InteropComponent.prototype.$getRenderer$);
InteropComponent.prototype.$fire$ = function() {
};
InteropComponent.prototype.$getRendering$ = function() {
  this.$raiseInvalidInteropApi$("getRendering", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getRendering", InteropComponent.prototype.$getRendering$);
InteropComponent.prototype.$getSuper$ = function() {
  return null
};
goog.$exportProperty$(InteropComponent.prototype, "getSuper", InteropComponent.prototype.$getSuper$);
InteropComponent.prototype.$getConcreteComponent$ = function() {
  return this
};
goog.$exportProperty$(InteropComponent.prototype, "getConcreteComponent", InteropComponent.prototype.$getConcreteComponent$);
InteropComponent.prototype.$isConcrete$ = function() {
  return true
};
goog.$exportProperty$(InteropComponent.prototype, "isConcrete", InteropComponent.prototype.$isConcrete$);
InteropComponent.prototype.$getModel$ = function() {
  this.$raiseInvalidInteropApi$("getModel", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getModel", InteropComponent.prototype.$getModel$);
InteropComponent.prototype.$getEvent$ = function() {
  this.$raiseInvalidInteropApi$("getEvent", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getEvent", InteropComponent.prototype.$getEvent$);
InteropComponent.prototype.$getEventByDescriptor$ = function() {
  this.$raiseInvalidInteropApi$("getEventByDescriptor", arguments)
};
InteropComponent.prototype.toString = function() {
  return"InteropComponent: " + this.$componentDef$.$getDescriptor$().toString()
};
goog.$exportProperty$(InteropComponent.prototype, "toString", InteropComponent.prototype.toString);
InteropComponent.prototype.$getFacets$ = function() {
  this.$raiseInvalidInteropApi$("getFacets", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getFacets", InteropComponent.prototype.$getFacets$);
InteropComponent.prototype.$raiseInvalidInteropApi$ = function(func, args) {
  var error = "Interop component tried calling function [" + func + "]";
  var argsArr = Array.prototype.slice.call(args);
  if(argsArr.length) {
    error += " with arguments [" + argsArr.join(",") + "]"
  }
  if(this.$globalId$ && this.$componentDef$) {
    error += ", " + this.$componentDef$ + " [" + this.$globalId$ + "]"
  }
  var ae = new $A.$auraError$(error, null, $A.severity.$QUIET$);
  ae.$component$ = this.toString();
  throw ae;
};
InteropComponent.prototype.$invokeLwcRoutine$ = function(phase, func) {
  function onWindowError(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    if(!gotWindowError) {
      gotWindowError = true;
      windowError = event.error
    }
  }
  function setupOnWindowError() {
    existingOnWindowError = window.onerror;
    window.onerror = null;
    window.addEventListener("error", onWindowError)
  }
  function cleanupOnWindowError() {
    window.removeEventListener("error", onWindowError);
    window.onerror = existingOnWindowError
  }
  function throwAuraError(error) {
    var auraError = new $A.$auraError$("Error during LWC component " + phase + " phase:", error);
    $A.$lastKnownError$ = auraError;
    throw auraError;
  }
  var windowError;
  var gotWindowError;
  var existingOnWindowError;
  if(phase === "connect" || phase === "disconnect") {
    setupOnWindowError()
  }
  var result;
  try {
    result = func()
  }catch(error$$0) {
    throwAuraError(error$$0)
  }finally {
    if(phase === "connect" || phase === "disconnect") {
      cleanupOnWindowError()
    }
  }
  if(gotWindowError) {
    throwAuraError(windowError)
  }
  return result
};
Aura.$Component$.$InteropComponent$ = InteropComponent;
function InteropModule(config) {
  var cmpDef = $A.$componentService$.$getDef$(config["componentDef"]);
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$componentDef$ = cmpDef;
  this.$interopClass$ = cmpDef.$interopClass$;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$shouldAutoDestroy$ = true;
  this.$localId$ = config["localId"];
  this.$attributeValueProvider$ = config["attributes"]["valueProvider"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.$allElements$ = [];
  this.$setupGlobalId$(config["globalId"]);
  $A.$componentService$.$indexComponent$(this);
  $A.$lockerService$.$trust$(cmpDef.definition, this);
  if(this.$localId$) {
    this.$doIndex$(this)
  }
  this.$publicMethodNames$ = Object.getOwnPropertyNames(this.$interopClass$);
  this.$setupMethods$()
}
goog.$exportSymbol$("InteropModule", InteropModule);
InteropModule.prototype = Object.create(Aura.$Component$.$InteropComponent$.prototype);
InteropModule.prototype.constructor = InteropModule;
InteropModule.prototype.$getPublicMethodNames$ = function() {
  return this.$publicMethodNames$
};
goog.$exportProperty$(InteropModule.prototype, "getPublicMethodNames", InteropModule.prototype.$getPublicMethodNames$);
InteropModule.prototype.$setupMethods$ = function() {
  var interopClass = this.$interopClass$;
  var isModuleWithOnlyDefaultExport = this.$publicMethodNames$.length === 2 && Object.prototype.hasOwnProperty.call(interopClass, "default") && interopClass["__esModule"];
  if(isModuleWithOnlyDefaultExport) {
    interopClass = this.$interopClass$["default"];
    this.$publicMethodNames$ = Object.getOwnPropertyNames(interopClass)
  }
  var self = this;
  this.$publicMethodNames$.forEach(function(m) {
    Object.defineProperty(self, m, {get:function() {
      return interopClass[m]
    }})
  })
};
InteropModule.prototype.get = function() {
  this.$raiseInvalidInteropApi$("get", arguments)
};
goog.$exportProperty$(InteropModule.prototype, "get", InteropModule.prototype.get);
InteropModule.prototype.set = function() {
  this.$raiseInvalidInteropApi$("set", arguments)
};
goog.$exportProperty$(InteropModule.prototype, "set", InteropModule.prototype.set);
InteropModule.prototype.$render$ = function() {
};
goog.$exportProperty$(InteropModule.prototype, "render", InteropModule.prototype.$render$);
InteropModule.prototype.$unrender$ = function() {
};
goog.$exportProperty$(InteropModule.prototype, "unrender", InteropModule.prototype.$unrender$);
InteropModule.prototype.$destroy$ = function() {
  this.$doDeIndex$();
  $A.$componentService$.$deIndex$(this.$globalId$)
};
goog.$exportProperty$(InteropModule.prototype, "destroy", InteropModule.prototype.$destroy$);
InteropModule.prototype.toString = function() {
  return"InteropModule: " + this.$componentDef$.$getDescriptor$().toString()
};
goog.$exportProperty$(InteropModule.prototype, "toString", InteropModule.prototype.toString);
Aura.$Component$.$InteropModule$ = InteropModule;
function ComponentDef(config) {
  var descriptor = new DefDescriptor(config[Json.$ApplicationKey$.$DESCRIPTOR$]);
  this.$descriptor$ = descriptor;
  this.$hasRemoteDeps$ = descriptor.toString().indexOf("layout://") !== 0 && descriptor.toString().indexOf("sitelayout://") !== 0 && (config[Json.$ApplicationKey$.$HASSERVERDEPENDENCIES$] || false);
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$];
  this.$styleDef$ = config[Json.$ApplicationKey$.$STYLEDEF$] ? new StyleDef(config[Json.$ApplicationKey$.$STYLEDEF$]) : undefined;
  this.$flavoredStyleDef$ = config[Json.$ApplicationKey$.$FLAVOREDSTYLEDEF$] ? new StyleDef(config[Json.$ApplicationKey$.$FLAVOREDSTYLEDEF$]) : undefined;
  this.$controllerDef$ = config[Json.$ApplicationKey$.$CONTROLLERDEF$] ? $A.$componentService$.$createControllerDef$(config[Json.$ApplicationKey$.$CONTROLLERDEF$]) : undefined;
  this.$modelDef$ = config[Json.$ApplicationKey$.$MODELDEF$] ? $A.$componentService$.$createModelDef$(config[Json.$ApplicationKey$.$MODELDEF$]) : undefined;
  this.$methodDefs$ = config[Json.$ApplicationKey$.$METHODDEFS$] ? config[Json.$ApplicationKey$.$METHODDEFS$] : undefined;
  this.$tokens$ = config[Json.$ApplicationKey$.$TOKENS$] ? config[Json.$ApplicationKey$.$TOKENS$] : undefined;
  this.$minVersion$ = config[Json.$ApplicationKey$.$MINVERSION$] ? config[Json.$ApplicationKey$.$MINVERSION$] : undefined;
  this.$requireLocker$ = config[Json.$ApplicationKey$.$REQUIRELOCKER$] ? config[Json.$ApplicationKey$.$REQUIRELOCKER$] : undefined;
  this.$lockerNext$ = config[Json.$ApplicationKey$.$LOCKER_NEXT$] ? config[Json.$ApplicationKey$.$LOCKER_NEXT$] : undefined;
  this.$apiVersion$ = config[Json.$ApplicationKey$.$APIVERSION$] ? config[Json.$ApplicationKey$.$APIVERSION$] : undefined;
  this.$interfaces$ = {};
  var intfConfig = config[Json.$ApplicationKey$.$INTERFACES$];
  if(intfConfig) {
    for(var m = 0;m < intfConfig.length;m++) {
      var intf = new DefDescriptor(intfConfig[m]);
      var intfName = intf.$getFullName$();
      this.$interfaces$[intfName] = true
    }
  }
  var superDef = config[Json.$ApplicationKey$.$SUPERDEF$];
  if(superDef === undefined && !this.$interfaces$["aura:rootComponent"]) {
    superDef = "markup://aura:component"
  }
  this.$superDef$ = this.$initSuperDef$(superDef);
  if(config.hasOwnProperty(Json.$ApplicationKey$.$COMPONENTCLASS$)) {
    try {
      var componentClass = $A.$clientService$.$evalExporter$(config[Json.$ApplicationKey$.$COMPONENTCLASS$], descriptor.toString());
      componentClass()
    }catch(e) {
      var auraError = new $A.$auraError$("ComponentDef initialization error", e);
      auraError.$setComponent$(descriptor.$getQualifiedName$());
      throw auraError;
    }
  }
  var appHandlerDefs;
  var cmpHandlerDefs;
  var valueHandlerDefs;
  this.$facets$ = config[Json.$ApplicationKey$.$FACETS$];
  this.$isAbs$ = !!config[Json.$ApplicationKey$.$ABSTRACT$];
  if(config[Json.$ApplicationKey$.$LOCATIONCHANGEEVENTDEF$]) {
    this.$locationChangeEventDef$ = $A.$eventService$.$createEventDef$(config[Json.$ApplicationKey$.$LOCATIONCHANGEEVENTDEF$])
  }else {
    this.$locationChangeEventDef$ = null
  }
  var registerEventDefs = {};
  this.$registerEventDefs$ = registerEventDefs;
  var allEvents = [];
  this.$allEvents$ = allEvents;
  var cred = config[Json.$ApplicationKey$.$REGISTEREVENTDEFS$];
  if(cred) {
    for(var i = 0;i < cred.length;i++) {
      var regConfig = cred[i];
      var name = regConfig[Json.$ApplicationKey$["NAME"]];
      allEvents.push(name);
      var eventDef = {};
      eventDef[Json.$ApplicationKey$.$DESCRIPTOR$] = regConfig[Json.$ApplicationKey$.$EVENTDEF$];
      registerEventDefs[name] = $A.$eventService$.$createEventDef$(eventDef)
    }
  }
  var handlerDefConfigs = config[Json.$ApplicationKey$.$HANDLERDEFS$];
  if(handlerDefConfigs) {
    for(var j = 0;j < handlerDefConfigs.length;j++) {
      var handlerConfig = handlerDefConfigs[j];
      if(handlerConfig[Json.$ApplicationKey$.$EVENTDEF$]) {
        if(handlerConfig[Json.$ApplicationKey$["NAME"]]) {
          if(!cmpHandlerDefs) {
            cmpHandlerDefs = []
          }
          cmpHandlerDefs.push({"name":handlerConfig[Json.$ApplicationKey$["NAME"]], "action":handlerConfig[Json.$ApplicationKey$.$ACTION$], "phase":handlerConfig[Json.$ApplicationKey$.$PHASE$], "includeFacets":handlerConfig[Json.$ApplicationKey$.$INCLUDEFACETS$], "eventDef":$A.$eventService$.$createEventDef$(handlerConfig[Json.$ApplicationKey$.$EVENTDEF$])})
        }else {
          if(!appHandlerDefs) {
            appHandlerDefs = []
          }
          appHandlerDefs.push({"action":handlerConfig[Json.$ApplicationKey$.$ACTION$], "phase":handlerConfig[Json.$ApplicationKey$.$PHASE$], "includeFacets":handlerConfig[Json.$ApplicationKey$.$INCLUDEFACETS$], "eventDef":$A.$eventService$.$createEventDef$(handlerConfig[Json.$ApplicationKey$.$EVENTDEF$])})
        }
      }else {
        if(handlerConfig[Json.$ApplicationKey$.$VALUE$]) {
          if(!valueHandlerDefs) {
            valueHandlerDefs = []
          }
          valueHandlerDefs.push({"name":handlerConfig[Json.$ApplicationKey$["NAME"]], "action":handlerConfig[Json.$ApplicationKey$.$ACTION$], "value":handlerConfig[Json.$ApplicationKey$.$VALUE$]})
        }else {
          if(!cmpHandlerDefs) {
            cmpHandlerDefs = []
          }
          cmpHandlerDefs.push({"name":handlerConfig[Json.$ApplicationKey$["NAME"]], "action":handlerConfig[Json.$ApplicationKey$.$ACTION$]})
        }
      }
    }
  }
  var subDefs = config[Json.$ApplicationKey$.$SUBDEFS$];
  if(subDefs) {
    for(var k = 0;k < subDefs.length;k++) {
      $A.$componentService$.$getDef$(subDefs[k])
    }
  }
  this.$appHandlerDefs$ = appHandlerDefs || null;
  this.$cmpHandlerDefs$ = cmpHandlerDefs || null;
  this.$valueHandlerDefs$ = valueHandlerDefs || null;
  this.$isCSSPreloaded$ = config[Json.$ApplicationKey$.$CSSPRELOADED$] || false;
  if(config[Json.$ApplicationKey$.$DEFAULTFLAVOR$]) {
    this.$defaultFlavor$ = config[Json.$ApplicationKey$.$DEFAULTFLAVOR$]
  }
  if(config[Json.$ApplicationKey$.$FLAVORABLECHILD$]) {
    this.$flavorableChild$ = true
  }
  if(config[Json.$ApplicationKey$.$DYNAMICALLYFLAVORABLE$]) {
    this.$dynamicallyFlavorable$ = config[Json.$ApplicationKey$.$DYNAMICALLYFLAVORABLE$]
  }
  if(config[Json.$ApplicationKey$.$FLAVOROVERRIDES$]) {
    this.$flavorOverrides$ = new FlavorsDef(config[Json.$ApplicationKey$.$FLAVOROVERRIDES$])
  }
  if(config[Json.$ApplicationKey$.$LOCATORDEFS$]) {
    this.$locatorDefs$ = config[Json.$ApplicationKey$.$LOCATORDEFS$]
  }
  this.$attributeDefs$ = new AttributeDefSet(config[Json.$ApplicationKey$.$ATTRIBUTEDEFS$], this.$descriptor$.$getNamespace$());
  this.$requiredVersionDefs$ = new RequiredVersionDefSet(config[Json.$ApplicationKey$.$REQUIREDVERSIONDEFS$]);
  this.$initStyleDefs$();
  this.$hasInitHandler$
}
goog.$exportSymbol$("ComponentDef", ComponentDef);
ComponentDef.prototype.$hasInit$ = function() {
  if(this.$hasInitHandler$ === undefined) {
    if(!this.$valueHandlerDefs$) {
      this.$hasInitHandler$ = false
    }else {
      for(var c = 0;c < this.$valueHandlerDefs$.length;c++) {
        if(this.$valueHandlerDefs$[c].name === "init") {
          this.$hasInitHandler$ = true;
          return this.$hasInitHandler$
        }
      }
    }
    this.$hasInitHandler$ = false
  }
  return this.$hasInitHandler$
};
ComponentDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(ComponentDef.prototype, "getDescriptor", ComponentDef.prototype.$getDescriptor$);
ComponentDef.prototype.$isAbstract$ = function() {
  return this.$isAbs$
};
goog.$exportProperty$(ComponentDef.prototype, "isAbstract", ComponentDef.prototype.$isAbstract$);
ComponentDef.prototype.$getSuperDef$ = function() {
  return this.$superDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getSuperDef", ComponentDef.prototype.$getSuperDef$);
ComponentDef.prototype.$getHelper$ = function() {
  var name = this.$descriptor$.$getQualifiedName$();
  var componentClass = $A.$componentService$.$getComponentClass$(name);
  return componentClass ? componentClass.prototype["helper"] : undefined
};
goog.$exportProperty$(ComponentDef.prototype, "getHelper", ComponentDef.prototype.$getHelper$);
ComponentDef.prototype.$getRequiredVersionDefs$ = function() {
  return this.$requiredVersionDefs$
};
ComponentDef.prototype.$hasRemoteDependencies$ = function() {
  return this.$hasRemoteDeps$
};
ComponentDef.prototype.$getAllStyleDefs$ = function() {
  return this.$allStyleDefs$
};
ComponentDef.prototype.$getAllFlavoredStyleDefs$ = function() {
  return this.$allFlavoredStyleDefs$
};
ComponentDef.prototype.$getStyleClassName$ = function() {
  var className = this.$styleClassName$;
  if(!className) {
    className = "";
    var styleDefs = this.$getAllStyleDefs$();
    if(styleDefs) {
      var styleDefLen = styleDefs.length;
      for(var t = 0;t < styleDefLen;t++) {
        var styleDef = styleDefs[t];
        className = className + styleDef.$getClassName$() + " ";
        if(!this.$isCSSPreloaded$) {
          styleDef.apply()
        }
      }
    }
    this.$styleClassName$ = className;
    if(!this.$isCSSPreloaded$) {
      var flavoredStyleDefs = this.$getAllFlavoredStyleDefs$();
      if(flavoredStyleDefs) {
        var i = 0;
        for(var len = flavoredStyleDefs.length;i < len;i++) {
          flavoredStyleDefs[i].apply()
        }
      }
    }
  }
  return className
};
goog.$exportProperty$(ComponentDef.prototype, "getStyleClassName", ComponentDef.prototype.$getStyleClassName$);
ComponentDef.prototype.$getStyleDef$ = function() {
  return this.$styleDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getStyleDef", ComponentDef.prototype.$getStyleDef$);
ComponentDef.prototype.$getDefaultFlavor$ = function() {
  if($A["util"].$isUndefined$(this.$flavorOverride$)) {
    var override = null;
    var appDesc = $A.getContext().$getApp$();
    if(appDesc) {
      var appDef = $A.$componentService$.$getDef$(appDesc, true);
      if(appDef) {
        var defaults = appDef.$getFlavorOverrides$();
        if(defaults) {
          override = defaults.$getFlavor$(this.$descriptor$);
          if(override === "{!remove}") {
            override = ""
          }
        }
      }
    }
    this.$flavorOverride$ = $A["util"].$isUndefinedOrNull$(override) ? null : override
  }
  return!$A["util"].$isUndefinedOrNull$(this.$flavorOverride$) ? this.$flavorOverride$ : this.$getExplicitDefaultFlavor$()
};
goog.$exportProperty$(ComponentDef.prototype, "getDefaultFlavor", ComponentDef.prototype.$getDefaultFlavor$);
ComponentDef.prototype.$getExplicitDefaultFlavor$ = function() {
  if(!$A["util"].$isUndefinedOrNull$(this.$defaultFlavor$)) {
    return this.$defaultFlavor$
  }
  if(this.$superDef$) {
    return this.$superDef$.$getExplicitDefaultFlavor$()
  }
  return null
};
ComponentDef.prototype.$hasFlavorableChild$ = function() {
  return!!this.$flavorableChild$
};
goog.$exportProperty$(ComponentDef.prototype, "hasFlavorableChild", ComponentDef.prototype.$hasFlavorableChild$);
ComponentDef.prototype.$getFlavorOverrides$ = function() {
  return this.$flavorOverrides$
};
goog.$exportProperty$(ComponentDef.prototype, "getFlavorOverrides", ComponentDef.prototype.$getFlavorOverrides$);
ComponentDef.prototype.$isDynamicallyFlavorable$ = function() {
  return this.$dynamicallyFlavorable$ || this.$superDef$ && this.$superDef$.$isDynamicallyFlavorable$()
};
ComponentDef.prototype.$getDynamicallyFlavorable$ = function() {
  var ret = [];
  if(this.$dynamicallyFlavorable$) {
    ret.push(this)
  }
  if(this.$superDef$) {
    ret = ret.concat(this.$superDef$.$getDynamicallyFlavorable$())
  }
  return ret
};
ComponentDef.prototype.$getAttributeDefs$ = function() {
  return this.$attributeDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getAttributeDefs", ComponentDef.prototype.$getAttributeDefs$);
ComponentDef.prototype.$getFacets$ = function() {
  return this.$facets$
};
goog.$exportProperty$(ComponentDef.prototype, "getFacets", ComponentDef.prototype.$getFacets$);
ComponentDef.prototype.$getFacet$ = function(facetName) {
  if(!this.$facetMap$) {
    var facetMap = {};
    if(this.$facets$) {
      var facets = this.$facets$;
      var c = 0;
      for(var length = facets.length;c < length;c++) {
        facetMap[facets[c]["descriptor"]] = facets[c]
      }
    }
    this.$facetMap$ = facetMap
  }
  return this.$facetMap$.hasOwnProperty(facetName) ? this.$facetMap$[facetName] : undefined
};
ComponentDef.prototype.$getControllerDef$ = function() {
  return this.$controllerDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getControllerDef", ComponentDef.prototype.$getControllerDef$);
ComponentDef.prototype.$getModelDef$ = function() {
  return this.$modelDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getModelDef", ComponentDef.prototype.$getModelDef$);
ComponentDef.$valueEvents$ = {"change":"aura:valueChange", "destroy":"aura:valueDestroy", "init":"aura:valueInit", "render":"aura:valueRender"};
ComponentDef.prototype.$getEventDef$ = function(name, includeValueEvents) {
  var ret = this.$registerEventDefs$[name];
  if(!ret && includeValueEvents) {
    if(ComponentDef.$valueEvents$.hasOwnProperty(name)) {
      name = ComponentDef.$valueEvents$[name]
    }
    ret = $A.get("e").$getDef$(name)
  }
  return ret
};
goog.$exportProperty$(ComponentDef.prototype, "getEventDef", ComponentDef.prototype.$getEventDef$);
ComponentDef.prototype.$getEventNameByDescriptor$ = function(descriptor) {
  for(var name in this.$registerEventDefs$) {
    if(this.$registerEventDefs$[name] && this.$registerEventDefs$[name].$descriptor$ && this.$registerEventDefs$[name].$descriptor$.$qualifiedName$ === descriptor) {
      return name
    }
  }
  return null
};
ComponentDef.prototype.$getAllEvents$ = function() {
  return this.$allEvents$
};
goog.$exportProperty$(ComponentDef.prototype, "getAllEvents", ComponentDef.prototype.$getAllEvents$);
ComponentDef.prototype.$getAppHandlerDefs$ = function() {
  return this.$appHandlerDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getAppHandlerDefs", ComponentDef.prototype.$getAppHandlerDefs$);
ComponentDef.prototype.$getCmpHandlerDefs$ = function() {
  return this.$cmpHandlerDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getCmpHandlerDefs", ComponentDef.prototype.$getCmpHandlerDefs$);
ComponentDef.prototype.$getValueHandlerDefs$ = function() {
  return this.$valueHandlerDefs$
};
ComponentDef.prototype.toString = function() {
  return this.$descriptor$.$getQualifiedName$()
};
goog.$exportProperty$(ComponentDef.prototype, "toString", ComponentDef.prototype.toString);
ComponentDef.prototype.$isInstanceOf$ = function(name) {
  var thisName = this.$descriptor$.$getFullName$();
  if(thisName === name || this.$implementsDirectly$(name)) {
    return true
  }
  if(this.$superDef$) {
    return this.$superDef$.$isInstanceOf$(name)
  }
  return false
};
goog.$exportProperty$(ComponentDef.prototype, "isInstanceOf", ComponentDef.prototype.$isInstanceOf$);
ComponentDef.prototype.$implementsDirectly$ = function(type) {
  return!$A["util"].$isUndefined$(this.$interfaces$[type])
};
ComponentDef.prototype.$getLocationChangeEvent$ = function() {
  var evt = this.$locationChangeEventDef$;
  if(evt) {
    return evt.$getDescriptor$().$getQualifiedName$()
  }
  return"markup://aura:locationChange"
};
goog.$exportProperty$(ComponentDef.prototype, "getLocationChangeEvent", ComponentDef.prototype.$getLocationChangeEvent$);
ComponentDef.prototype.$getLayouts$ = function() {
  return this.$layouts$
};
goog.$exportProperty$(ComponentDef.prototype, "getLayouts", ComponentDef.prototype.$getLayouts$);
ComponentDef.prototype.$getLocatorDefs$ = function() {
  return this.$locatorDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getLocatorDefs", ComponentDef.prototype.$getLocatorDefs$);
ComponentDef.prototype.$initSuperDef$ = function(config) {
  if(!config) {
    return null
  }
  var superDef = $A.$componentService$.$createComponentDef$(config);
  if(!superDef) {
    var failingCmp = this.$descriptor$.$getFullName$();
    var superCmp = config["descriptor"] ? config["descriptor"] : config;
    var auraError = new $A.$auraError$("Super component's def (" + superCmp + ") is missing for " + failingCmp);
    auraError.$setComponent$(failingCmp);
    throw auraError;
  }
  return superDef
};
ComponentDef.prototype.$initStyleDefs$ = function() {
  this.$allStyleDefs$ = [];
  this.$allFlavoredStyleDefs$ = [];
  var s = this.$superDef$;
  if(s) {
    var superStyles = s.$getAllStyleDefs$();
    if(superStyles) {
      this.$allStyleDefs$ = this.$allStyleDefs$.concat(superStyles)
    }
    var superFlavoredStyles = s.$getAllFlavoredStyleDefs$();
    if(superFlavoredStyles) {
      this.$allFlavoredStyleDefs$ = this.$allFlavoredStyleDefs$.concat(superFlavoredStyles)
    }
  }
  if(this.$styleDef$) {
    this.$allStyleDefs$.push(this.$styleDef$)
  }
  if(this.$flavoredStyleDef$) {
    this.$allFlavoredStyleDefs$.push(this.$flavoredStyleDef$)
  }
};
ComponentDef.prototype.$getMinVersion$ = function() {
  return this.$minVersion$
};
ComponentDef.prototype.$getApiVersion$ = function() {
  return this.$apiVersion$
};
ComponentDef.prototype.$isLockerRequired$ = function() {
  return this.$requireLocker$
};
goog.$exportProperty$(ComponentDef.prototype, "isLockerRequired", ComponentDef.prototype.$isLockerRequired$);
Aura.$Component$.$ComponentDef$ = ComponentDef;
function InteropComponentDef(config) {
  this.$interop$ = true;
  this.$access$ = config.$access$;
  this.$descriptor$ = new DefDescriptor(config.$descriptor$);
  this.$dependencies$ = config.$dependencies$;
  this.definition = config.definition;
  this.$moduleName$ = config.$moduleName$;
  this.$interopClass$ = config.$interopClass$;
  this.$elementName$ = config.$elementName$;
  this.$interopClassName$ = this.$descriptor$.$getNamespace$() + "$" + this.$descriptor$.getName();
  this.$minVersion$ = config.$minVersion$;
  this.$requireLocker$ = config.$requireLocker$;
  this.$attributeDefs$ = new AttributeDefSet(config.$attributeDefs$, this.$descriptor$.$getNamespace$());
  this.$requiredVersionDefs$ = new RequiredVersionDefSet(config[Json.$ApplicationKey$.$REQUIREDVERSIONDEFS$]);
  this.$registerEventDefs$ = {};
  var Ctor = this.$interopClass$["default"] || this.$interopClass$;
  this.$interopCtor$ = $A.$componentService$.$isComponentConstructor$(Ctor) && Ctor;
  if(this.$interopCtor$) {
    this.$interopDef$ = $A.$componentService$.$moduleEngine$["getComponentDef"](this.$interopCtor$);
    this.$setupPropAttrMap$(this.$interopCtor$["interopMap"], this.$interopDef$["props"])
  }
}
goog.$exportSymbol$("InteropComponentDef", InteropComponentDef);
InteropComponentDef.prototype.$hasElementConstructor$ = function() {
  return!!this.$interopCtor$
};
InteropComponentDef.prototype.$setupPropAttrMap$ = function(interopMap, props) {
  var propNames = Object.keys(props);
  var interopPropOverride = interopMap && $A["util"].$isObject$(interopMap["props"]) ? interopMap["props"] : {};
  var propName;
  var attrName;
  this.$attrNameToPropMap$ = {};
  this.$propNameToAttrMap$ = {};
  for(var i = 0;i < propNames.length;i++) {
    propName = propNames[i];
    attrName = interopPropOverride[propName] || InteropComponentDef.prototype.$DOM_PROPS_TO_AURA_ATTRS$[propName] || propName;
    this.$attrNameToPropMap$[attrName] = propName;
    this.$propNameToAttrMap$[propName] = attrName
  }
};
InteropComponentDef.prototype.$HTML_ATTRS_TO_DOM_PROPS$ = {"accesskey":"accessKey", "readonly":"readOnly", "tabindex":"tabIndex", "bgcolor":"bgColor", "colspan":"colSpan", "rowspan":"rowSpan", "contenteditable":"contentEditable", "crossorigin":"crossOrigin", "datetime":"dateTime", "formaction":"formAction", "ismap":"isMap", "maxlength":"maxLength", "minlength":"minLength", "novalidate":"noValidate", "usemap":"useMap", "for":"htmlFor", "aria-activedescendant":"ariaActiveDescendant", "aria-atomic":"ariaAtomic", 
"aria-autocomplete":"ariaAutoComplete", "aria-busy":"ariaBusy", "aria-checked":"ariaChecked", "aria-colcount":"ariaColCount", "aria-colindex":"ariaColIndex", "aria-colspan":"ariaColSpan", "aria-controls":"ariaControls", "aria-current":"ariaCurrent", "aria-describedby":"ariaDescribedBy", "aria-details":"ariaDetails", "aria-disabled":"ariaDisabled", "aria-errormessage":"ariaErrorMessage", "aria-expanded":"ariaExpanded", "aria-flowto":"ariaFlowTo", "aria-haspopup":"ariaHasPopup", "aria-hidden":"ariaHidden", 
"aria-invalid":"ariaInvalid", "aria-keyshortcuts":"ariaKeyShortcuts", "aria-label":"ariaLabel", "aria-labelledby":"ariaLabelledBy", "aria-level":"ariaLevel", "aria-live":"ariaLive", "aria-modal":"ariaModal", "aria-multiline":"ariaMultiLine", "aria-multiselectable":"ariaMultiSelectable", "aria-orientation":"ariaOrientation", "aria-owns":"ariaOwns", "aria-placeholder":"ariaPlaceholder", "aria-posinset":"ariaPosInSet", "aria-pressed":"ariaPressed", "aria-readonly":"ariaReadOnly", "aria-relevant":"ariaRelevant", 
"aria-required":"ariaRequired", "aria-roledescription":"ariaRoleDescription", "aria-rowcount":"ariaRowCount", "aria-rowindex":"ariaRowIndex", "aria-rowspan":"ariaRowSpan", "aria-selected":"ariaSelected", "aria-setsize":"ariaSetSize", "aria-sort":"ariaSort", "aria-valuemax":"ariaValueMax", "aria-valuemin":"ariaValueMin", "aria-valuenow":"ariaValueNow", "aria-valuetext":"ariaValueText"};
InteropComponentDef.prototype.$DOM_PROPS_TO_AURA_ATTRS$ = Object.keys(InteropComponentDef.prototype.$HTML_ATTRS_TO_DOM_PROPS$).reduce(function(map, attr) {
  if(attr.indexOf("-") === -1) {
    var prop = InteropComponentDef.prototype.$HTML_ATTRS_TO_DOM_PROPS$[attr];
    map[prop] = attr
  }
  return map
}, {});
InteropComponentDef.prototype.$hasInit$ = function() {
};
InteropComponentDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getDescriptor", InteropComponentDef.prototype.$getDescriptor$);
InteropComponentDef.prototype.$isAbstract$ = function() {
  return this.$isAbs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "isAbstract", InteropComponentDef.prototype.$isAbstract$);
InteropComponentDef.prototype.$getSuperDef$ = function() {
  return this.$superDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getSuperDef", InteropComponentDef.prototype.$getSuperDef$);
InteropComponentDef.prototype.$getHelper$ = function() {
  var name = this.$getDescriptor$().$getQualifiedName$();
  var componentClass = $A.$componentService$.$getComponentClass$(name);
  return componentClass ? componentClass.prototype["helper"] : undefined
};
goog.$exportProperty$(InteropComponentDef.prototype, "getHelper", InteropComponentDef.prototype.$getHelper$);
InteropComponentDef.prototype.$getRequiredVersionDefs$ = function() {
  return this.$requiredVersionDefs$
};
InteropComponentDef.prototype.$getMinVersion$ = function() {
  return this.$minVersion$
};
InteropComponentDef.prototype.$getApiVersion$ = function() {
  return undefined
};
InteropComponentDef.prototype.$hasRemoteDependencies$ = function() {
  return this.$hasRemoteDeps$
};
InteropComponentDef.prototype.$getAllStyleDefs$ = function() {
  return this.$allStyleDefs$
};
InteropComponentDef.prototype.$getAllFlavoredStyleDefs$ = function() {
  return this.$allFlavoredStyleDefs$
};
InteropComponentDef.prototype.$getStyleClassName$ = function() {
  var className = this.$styleClassName$;
  if(!className) {
    className = "";
    var styleDefs = this.$getAllStyleDefs$();
    if(styleDefs) {
      var styleDefLen = styleDefs.length;
      for(var t = 0;t < styleDefLen;t++) {
        var styleDef = styleDefs[t];
        className = className + styleDef.$getClassName$() + " ";
        if(!this.$isCSSPreloaded$) {
          styleDef.apply()
        }
      }
    }
    this.$styleClassName$ = className;
    if(!this.$isCSSPreloaded$) {
      var flavoredStyleDefs = this.$getAllFlavoredStyleDefs$();
      if(flavoredStyleDefs) {
        var i = 0;
        for(var len = flavoredStyleDefs.length;i < len;i++) {
          flavoredStyleDefs[i].apply()
        }
      }
    }
  }
  return className
};
goog.$exportProperty$(InteropComponentDef.prototype, "getStyleClassName", InteropComponentDef.prototype.$getStyleClassName$);
InteropComponentDef.prototype.$getStyleDef$ = function() {
  return this.$styleDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getStyleDef", InteropComponentDef.prototype.$getStyleDef$);
InteropComponentDef.prototype.$getDefaultFlavor$ = function() {
  if($A["util"].$isUndefined$(this.$flavorOverride$)) {
    var override = null;
    var appDesc = $A.getContext().$getApp$();
    if(appDesc) {
      var appDef = $A.$componentService$.$getDef$(appDesc, true);
      if(appDef) {
        var defaults = appDef.$getFlavorOverrides$();
        if(defaults) {
          override = defaults.$getFlavor$(this.$descriptor$);
          if(override === "{!remove}") {
            override = ""
          }
        }
      }
    }
    this.$flavorOverride$ = $A["util"].$isUndefinedOrNull$(override) ? null : override
  }
  return!$A["util"].$isUndefinedOrNull$(this.$flavorOverride$) ? this.$flavorOverride$ : this.$getExplicitDefaultFlavor$()
};
goog.$exportProperty$(InteropComponentDef.prototype, "getDefaultFlavor", InteropComponentDef.prototype.$getDefaultFlavor$);
InteropComponentDef.prototype.$getExplicitDefaultFlavor$ = function() {
  if(!$A["util"].$isUndefinedOrNull$(this.$defaultFlavor$)) {
    return this.$defaultFlavor$
  }
  if(this.$superDef$) {
    return this.$superDef$.$getExplicitDefaultFlavor$()
  }
  return null
};
InteropComponentDef.prototype.$hasFlavorableChild$ = function() {
  return!!this.$flavorableChild$
};
goog.$exportProperty$(InteropComponentDef.prototype, "hasFlavorableChild", InteropComponentDef.prototype.$hasFlavorableChild$);
InteropComponentDef.prototype.$getFlavorOverrides$ = function() {
  return this.$flavorOverrides$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getFlavorOverrides", InteropComponentDef.prototype.$getFlavorOverrides$);
InteropComponentDef.prototype.$isDynamicallyFlavorable$ = function() {
  return this.$dynamicallyFlavorable$ || this.$superDef$ && this.$superDef$.$isDynamicallyFlavorable$()
};
InteropComponentDef.prototype.$getDynamicallyFlavorable$ = function() {
  var ret = [];
  if(this.$dynamicallyFlavorable$) {
    ret.push(this)
  }
  if(this.$superDef$) {
    ret = ret.concat(this.$superDef$.$getDynamicallyFlavorable$())
  }
  return ret
};
InteropComponentDef.prototype.$getAttributeDefs$ = function() {
  return this.$attributeDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getAttributeDefs", InteropComponentDef.prototype.$getAttributeDefs$);
InteropComponentDef.prototype.$getFacets$ = function() {
  return this.$facets$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getFacets", InteropComponentDef.prototype.$getFacets$);
InteropComponentDef.prototype.$getFacet$ = function(facetName) {
  if(!this.$facetMap$) {
    var facetMap = {};
    if(this.$facets$) {
      var facets = this.$facets$;
      var c = 0;
      for(var length = facets.length;c < length;c++) {
        facetMap[facets[c]["descriptor"]] = facets[c]
      }
    }
    this.$facetMap$ = facetMap
  }
  return this.$facetMap$.hasOwnProperty(facetName) ? this.$facetMap$[facetName] : undefined
};
InteropComponentDef.prototype.$getControllerDef$ = function() {
  return this.$controllerDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getControllerDef", InteropComponentDef.prototype.$getControllerDef$);
InteropComponentDef.prototype.$getModelDef$ = function() {
  return this.$modelDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getModelDef", InteropComponentDef.prototype.$getModelDef$);
ComponentDef.$valueEvents$ = {"change":"aura:valueChange", "destroy":"aura:valueDestroy", "init":"aura:valueInit", "render":"aura:valueRender"};
InteropComponentDef.prototype.$getEventDef$ = function(name, includeValueEvents) {
  var ret = this.$registerEventDefs$[name];
  if(!ret && includeValueEvents) {
    if(ComponentDef.$valueEvents$.hasOwnProperty(name)) {
      name = ComponentDef.$valueEvents$[name]
    }
    ret = $A.get("e").$getDef$(name)
  }
  return ret
};
goog.$exportProperty$(InteropComponentDef.prototype, "getEventDef", InteropComponentDef.prototype.$getEventDef$);
InteropComponentDef.prototype.$getEventNameByDescriptor$ = function(descriptor) {
  for(var name in this.$registerEventDefs$) {
    if(this.$registerEventDefs$[name] && this.$registerEventDefs$[name].$descriptor$ && this.$registerEventDefs$[name].$descriptor$.$qualifiedName$ === descriptor) {
      return name
    }
  }
  return null
};
InteropComponentDef.prototype.$getAllEvents$ = function() {
  return this.$allEvents$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getAllEvents", InteropComponentDef.prototype.$getAllEvents$);
InteropComponentDef.prototype.$getAppHandlerDefs$ = function() {
  return this.$appHandlerDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getAppHandlerDefs", InteropComponentDef.prototype.$getAppHandlerDefs$);
InteropComponentDef.prototype.$getCmpHandlerDefs$ = function() {
  return this.$cmpHandlerDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getCmpHandlerDefs", InteropComponentDef.prototype.$getCmpHandlerDefs$);
InteropComponentDef.prototype.$getValueHandlerDefs$ = function() {
  return this.$valueHandlerDefs$
};
InteropComponentDef.prototype.toString = function() {
  return this.$getDescriptor$().$getQualifiedName$()
};
goog.$exportProperty$(InteropComponentDef.prototype, "toString", InteropComponentDef.prototype.toString);
InteropComponentDef.prototype.$isInstanceOf$ = function(name) {
  var thisName = this.$descriptor$.$getNamespace$() + ":" + this.$descriptor$.getName();
  return thisName === name
};
goog.$exportProperty$(InteropComponentDef.prototype, "isInstanceOf", InteropComponentDef.prototype.$isInstanceOf$);
InteropComponentDef.prototype.$implementsDirectly$ = function(type) {
  return!$A["util"].$isUndefined$(this.$interfaces$[type])
};
InteropComponentDef.prototype.$getLocationChangeEvent$ = function() {
  var evt = this.$locationChangeEventDef$;
  if(evt) {
    return evt.$getDescriptor$().$getQualifiedName$()
  }
  return"markup://aura:locationChange"
};
goog.$exportProperty$(InteropComponentDef.prototype, "getLocationChangeEvent", InteropComponentDef.prototype.$getLocationChangeEvent$);
InteropComponentDef.prototype.$getLayouts$ = function() {
  return this.$layouts$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getLayouts", InteropComponentDef.prototype.$getLayouts$);
InteropComponentDef.prototype.$getLocatorDefs$ = function() {
  return this.$locatorDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getLocatorDefs", InteropComponentDef.prototype.$getLocatorDefs$);
InteropComponentDef.prototype.$initSuperDef$ = function(config) {
  if(config) {
    var sDef = $A.$componentService$.$createComponentDef$(config);
    $A.assert(sDef, "Super def undefined for " + this.$descriptor$ + " value \x3d " + config["descriptor"]);
    return sDef
  }
  return null
};
InteropComponentDef.prototype.$isLockerRequired$ = function() {
  return this.$requireLocker$
};
goog.$exportProperty$(InteropComponentDef.prototype, "isLockerRequired", InteropComponentDef.prototype.$isLockerRequired$);
InteropComponentDef.prototype.$initStyleDefs$ = function() {
  this.$allStyleDefs$ = [];
  this.$allFlavoredStyleDefs$ = [];
  var s = this.$superDef$;
  if(s) {
    var superStyles = s.$getAllStyleDefs$();
    if(superStyles) {
      this.$allStyleDefs$ = this.$allStyleDefs$.concat(superStyles)
    }
    var superFlavoredStyles = s.$getAllFlavoredStyleDefs$();
    if(superFlavoredStyles) {
      this.$allFlavoredStyleDefs$ = this.$allFlavoredStyleDefs$.concat(superFlavoredStyles)
    }
  }
  if(this.$styleDef$) {
    this.$allStyleDefs$.push(this.$styleDef$)
  }
  if(this.$flavoredStyleDef$) {
    this.$allFlavoredStyleDefs$.push(this.$flavoredStyleDef$)
  }
};
InteropComponentDef.prototype.$getType$ = function() {
  return this.$getDescriptor$().$getFullName$()
};
goog.$exportProperty$(InteropComponentDef.prototype, "getType", InteropComponentDef.prototype.$getType$);
Aura.$Component$.$InteropComponentDef$ = InteropComponentDef;
function ActionValueProvider(component, controllerDef) {
  this.$actions$;
  this.$component$ = component;
  this.$controllerDef$ = controllerDef
}
ActionValueProvider.prototype.get = function(key) {
  if(!this.$actions$) {
    this.$actions$ = {}
  }
  var actionDef = this.$actions$[key];
  if(!actionDef) {
    actionDef = this.$component$["controller"] && this.$component$["controller"][key];
    if(actionDef) {
      var clientDef = {};
      clientDef[Json.$ApplicationKey$.$DESCRIPTOR$] = this.$component$.$getType$() + "$controller$" + key;
      clientDef[Json.$ApplicationKey$["NAME"]] = key;
      clientDef[Json.$ApplicationKey$.$ACTIONTYPE$] = "CLIENT";
      clientDef[Json.$ApplicationKey$.$CODE$] = actionDef;
      actionDef = new ActionDef(clientDef);
      if(this.$controllerDef$ && this.$controllerDef$.$hasActionDef$(key)) {
        var message = "Component '" + this.$component$.$getType$() + "' has server and client action name conflicts: " + key;
        $A.$warning$(message)
      }
    }else {
      actionDef = this.$controllerDef$ && this.$controllerDef$.$getActionDef$(key)
    }
    if(!actionDef) {
      var cmpType = this.$component$.$getType$();
      var auraError = new $A.$auraError$("Unable to find action '" + key + "' on the controller of " + cmpType);
      auraError.$setComponent$(cmpType);
      auraError["componentStack"] = $A["util"].$getComponentHierarchy$(this.$component$);
      throw auraError;
    }
    this.$actions$[key] = actionDef
  }
  return actionDef.$newInstance$(this.$component$)
};
Aura.$Component$.$ActionValueProvider$ = ActionValueProvider;
function EventValueProvider(component) {
  this.$events$ = {};
  this.$component$ = component.$globalId$
}
EventValueProvider.prototype.get = function(key) {
  return $A.$getComponent$(this.$component$).$getEvent$(key)
};
Aura.$Component$.$EventValueProvider$ = EventValueProvider;
function StyleValueProvider(component) {
  this.$component$ = component
}
StyleValueProvider.prototype.get = function(key) {
  if(key === "name") {
    var styleDef = this.$component$.$getDef$().$getStyleDef$();
    return!$A["util"].$isUndefinedOrNull$(styleDef) ? styleDef.$getClassName$() : null
  }
};
Aura.$Component$.$StyleValueProvider$ = StyleValueProvider;
function GlobalValueProviders(gvp, initCallback) {
  this.$valueProviders$ = {"$Browser":new Aura.$Provider$.$ObjectValueProvider$(gvp["$Browser"]), "$Label":new Aura.$Provider$.$LabelValueProvider$(gvp["$Label"]), "$Locale":new Aura.$Provider$.$ObjectValueProvider$(gvp["$Locale"]), "$Global":new Aura.$Provider$.$ContextValueProvider$(gvp["$Global"])};
  for(var type in $A.$globalValueProviders$) {
    var valueProvider = $A.$globalValueProviders$[type];
    valueProvider.$getValues$ = valueProvider.$getValues$ || valueProvider["getValues"];
    valueProvider.get = valueProvider.get || valueProvider["get"];
    valueProvider.$merge$ = valueProvider.$merge$ || valueProvider["merge"]
  }
  $A["util"].apply(this.$valueProviders$, $A.$globalValueProviders$, false, false, true);
  var bootstrapGVPData = [];
  for(type in gvp) {
    if(["$Browser", "$Label", "$Locale", "$Global"].indexOf(type) >= 0) {
      continue
    }
    bootstrapGVPData.push({"type":type, "values":gvp[type]})
  }
  this.load(bootstrapGVPData);
  if(initCallback) {
    initCallback(this)
  }
}
goog.$exportSymbol$("GlobalValueProviders", GlobalValueProviders);
GlobalValueProviders.prototype.$STORAGE_KEY$ = "globalValueProviders";
GlobalValueProviders.prototype.$MUTEX_KEY$ = "GlobalValueProviders";
GlobalValueProviders.prototype.$mutexUnlock$ = undefined;
GlobalValueProviders.prototype.$persistenceQueued$ = false;
GlobalValueProviders.prototype.$LOADED_FROM_PERSISTENT_STORAGE$ = false;
GlobalValueProviders.prototype.$LABELS_LOADED_FROM_PERSISTENT_STORAGE$ = false;
GlobalValueProviders.prototype.$ABSENT_GVP_VALUES_COOKIE$ = "auraGvpValuesAbsence";
GlobalValueProviders.prototype.$merge$ = function(gvps, doNotPersist, overwrite) {
  if(!gvps) {
    return
  }
  var valueProvider;
  var i;
  var type;
  var newGvp;
  var values;
  for(i = 0;i < gvps.length;i++) {
    try {
      newGvp = gvps[i];
      type = newGvp["type"];
      if(!this.$valueProviders$[type]) {
        this.$valueProviders$[type] = new Aura.$Provider$.$ObjectValueProvider$
      }
      valueProvider = this.$valueProviders$[type];
      if(valueProvider.$merge$) {
        type === "$Label" ? valueProvider.$merge$(newGvp["values"], overwrite) : valueProvider.$merge$(newGvp["values"])
      }else {
        $A["util"].apply(valueProvider, newGvp["values"], true, false, true)
      }
      $A.$expressionService$.$updateGlobalReferences$(type, newGvp["values"])
    }catch(e$$0) {
      var auraError = new $A.$auraError$("Merging GVP '" + type + "' failed", e$$0);
      auraError.$setComponent$(type);
      throw auraError;
    }
  }
  if(doNotPersist) {
    return
  }
  var storage = this.$getStorage$();
  if(!storage) {
    return
  }
  if(this.$persistenceQueued$) {
    return
  }
  this.$persistenceQueued$ = true;
  var that = this;
  $A["util"].$Mutex$.$lock$(that.$MUTEX_KEY$, function(unlock) {
    that.$mutexUnlock$ = unlock;
    var errors = [];
    storage.get(that.$STORAGE_KEY$, true)["then"](undefined, function storageGetError(e) {
      var message = "GlobalValueProviders.merge(): failed to load GVP values from storage, will overwrite storage with in-memory values.";
      $A.$warning$(message, e);
      errors.push({"action":"load", "message":message, "error":e})
    })["then"](function collectGvps(value) {
      that.$persistenceQueued$ = false;
      var toStore = [];
      for(type in that.$valueProviders$) {
        if(that.$valueProviders$.hasOwnProperty(type)) {
          valueProvider = that.$valueProviders$[type];
          var storable = typeof valueProvider["isStorable"] === "function" ? valueProvider["isStorable"]() : true;
          if(storable) {
            values = valueProvider.$getStorableValues$ ? valueProvider.$getStorableValues$() : valueProvider.$getValues$ ? valueProvider.$getValues$() : valueProvider;
            toStore.push({"type":type, "values":values})
          }
        }
      }
      if(value) {
        try {
          var j;
          var map = {};
          for(j in value) {
            map[value[j]["type"]] = value[j]["values"]
          }
          for(j in toStore) {
            type = toStore[j]["type"];
            if(!map[type]) {
              map[type] = {};
              value.push({"type":type, "values":map[type]})
            }
            $A["util"].apply(map[type], toStore[j]["values"], true, true, true)
          }
          toStore = value
        }catch(e) {
          var message = "GlobalValueProviders.merge(): merging from storage failed, overwriting with in-memory values.";
          $A.$warning$(message, e);
          errors.push({"action":"merge", "message":message, "error":e})
        }
      }
      return storage.set(that.$STORAGE_KEY$, toStore)
    })["then"](function storageGetSuccess() {
      if(that.$getAbsentGvpValuesCookie$()) {
        that.$clearAbsentGvpValuesCookie$()
      }
      if(errors.length > 0) {
        var message = "GlobalValueProviders.merge(): GVP values in storage have been overwritten with in-memory values.";
        $A.$warning$(message);
        $A.$metricsService$.transaction("aura", "performance:gvpStorageFailure", {"context":{"attributes":{"message":message, "errors":JSON.stringify(errors)}}})
      }
      that.$mutexUnlock$()
    }, function storageGetError2(e) {
      that.$setAbsentGvpValuesCookie$();
      var message = "GlobalValueProviders.merge(): failed to store merged GVP values to storage.";
      $A.$warning$(message, e);
      var labels = [];
      for(i = 0;i < gvps.length;i++) {
        if(gvps[i]["type"] === "$Label") {
          labels = Object.keys(gvps[i]["values"]);
          break
        }
      }
      errors.push({"action":"save", "message":message, "error":e, "dropped-labels":labels});
      $A.$metricsService$.transaction("aura", "performance:gvpStorageFailure", {"context":{"attributes":{"message":message, "errors":JSON.stringify(errors)}}});
      that.$mutexUnlock$()
    })
  })
};
GlobalValueProviders.prototype.$getStorage$ = function() {
  var storage = $A.$storageService$.$getStorage$($A.$clientService$.$getActionStorageName$());
  return storage && storage.$isPersistent$() ? storage : undefined
};
GlobalValueProviders.prototype.$loadFromStorage$ = function() {
  var storage = this.$getStorage$();
  if(!storage || this.$getAbsentGvpValuesCookie$()) {
    return Promise["resolve"]()
  }
  var that = this;
  return storage.get(this.$STORAGE_KEY$, true)["then"](function processValue(value) {
    $A.$run$(function() {
      if(value) {
        that.$merge$(value, true);
        that.$LOADED_FROM_PERSISTENT_STORAGE$ = true
      }
    })
  })["then"](undefined, function storageGetError3() {
    $A.$run$(function() {
    })
  })
};
GlobalValueProviders.prototype.$loadLabelsFromStorage$ = function() {
  var storage = this.$getStorage$();
  if(!storage || this.$getAbsentGvpValuesCookie$() || this.$LABELS_LOADED_FROM_PERSISTENT_STORAGE$) {
    return Promise["resolve"]()
  }
  var that = this;
  return storage.get(that.$STORAGE_KEY$, true)["then"](function processValue(value) {
    $A.$run$(function() {
      value = value["filter"](function(elem) {
        return elem.type === "$Label"
      });
      if(value) {
        that.$merge$(value, true, false);
        that.$LABELS_LOADED_FROM_PERSISTENT_STORAGE$ = true
      }
    })
  })["then"](undefined, function storageGetError3() {
    $A.$run$(function() {
    })
  })
};
GlobalValueProviders.prototype.load = function(gvps) {
  if(gvps && gvps.length) {
    Aura["afterBootstrapReady"].push(function() {
      try {
        this.$merge$(gvps, true)
      }catch(e) {
        $A.$warning$("GlobalValueProviders merge failed.")
      }
    }.bind(this))
  }
};
GlobalValueProviders.prototype.$addValueProvider$ = function(type, valueProvider) {
  if(!this.$valueProviders$.hasOwnProperty(type)) {
    valueProvider.$getValues$ = valueProvider.$getValues$ || valueProvider["getValues"];
    valueProvider.get = valueProvider.get || valueProvider["get"];
    valueProvider.$merge$ = valueProvider.$merge$ || valueProvider["merge"];
    this.$valueProviders$[type] = valueProvider
  }
};
GlobalValueProviders.prototype.$getValueProvider$ = function(type) {
  return this.$valueProviders$[type]
};
GlobalValueProviders.prototype.get = function(expression, callback) {
  expression = $A.$expressionService$.normalize(expression).split(".");
  var type = expression.shift();
  var valueProvider = this.$valueProviders$[type];
  $A.assert(valueProvider, "Unknown value provider: '" + type + "'.");
  return valueProvider.get ? valueProvider.get(expression, callback) : $A.$expressionService$.$resolve$(expression, valueProvider)
};
goog.$exportProperty$(GlobalValueProviders.prototype, "get", GlobalValueProviders.prototype.get);
GlobalValueProviders.prototype.$getAbsentGvpValuesCookie$ = function() {
  var cookie = $A["util"].$getCookie$(this.$ABSENT_GVP_VALUES_COOKIE$);
  return cookie === "true"
};
GlobalValueProviders.prototype.$setAbsentGvpValuesCookie$ = function() {
  var duration = 1E3 * 60 * 60 * 24 * 7;
  $A["util"]["setCookie"](this.$ABSENT_GVP_VALUES_COOKIE$, "true", duration)
};
GlobalValueProviders.prototype.$clearAbsentGvpValuesCookie$ = function() {
  $A["util"].$clearCookie$(this.$ABSENT_GVP_VALUES_COOKIE$)
};
Aura.$Provider$.$GlobalValueProviders$ = GlobalValueProviders;
function LabelQueue() {
  this.$components$ = [];
  this.$callbacks$ = [];
  this.$returnValues$ = [];
  this.$requested$ = false
}
LabelQueue.prototype.$getComponents$ = function() {
  return this.$components$
};
LabelQueue.prototype.$addComponent$ = function(component) {
  this.$components$.push(component)
};
LabelQueue.prototype.$getReturnValues$ = function() {
  return this.$returnValues$
};
LabelQueue.prototype.$addReturnValue$ = function(value) {
  this.$returnValues$.push(value)
};
LabelQueue.prototype.$getCallbacks$ = function() {
  return this.$callbacks$
};
LabelQueue.prototype.$addCallback$ = function(callback) {
  if($A["util"].$isFunction$(callback)) {
    this.$callbacks$.push(callback)
  }
};
Aura.$Provider$.$LabelQueue$ = LabelQueue;
function LabelValueProvider(values) {
  this.$values$ = values || {};
  this.$queue$ = {}
}
LabelValueProvider.prototype.$requestServerLabel$ = function(section, name, callback) {
  var queue = this.$getQueue$(section, name);
  var placeholder = "";
  placeholder = "[" + section + "." + name + "]";
  queue.$addCallback$(callback);
  if(!queue.$requested$) {
    var action = $A.get("c.aura://LabelController.getLabel");
    action.$setParams$({"name":name, "section":section});
    action.$setCallback$(this, function(result) {
      var returnValue = placeholder;
      if(result.$getState$() === "SUCCESS") {
        returnValue = result.$getReturnValue$();
        var labels = this.$values$[section];
        if(!labels) {
          this.$values$[section] = labels = {}
        }
        labels[name] = returnValue;
        $A.$expressionService$.$updateGlobalReference$("$Label." + section + "." + name, null, returnValue)
      }else {
        $A.$warning$("Error getting label: $Label." + section + "." + name + ". Caused by: " + JSON.stringify(result.getError()))
      }
      var callbacks = queue.$getCallbacks$();
      for(var i = 0;i < callbacks.length;i++) {
        callbacks[i].call(null, returnValue)
      }
      this.$removeQueue$(section, name)
    });
    $A.$enqueueAction$(action);
    queue.$requested$ = true
  }
  return placeholder
};
LabelValueProvider.prototype.$getQueue$ = function(section, name) {
  var exp = this.$getQueueKey$(section, name);
  if(!this.$queue$[exp]) {
    this.$queue$[exp] = new Aura.$Provider$.$LabelQueue$
  }
  return this.$queue$[exp]
};
LabelValueProvider.prototype.$removeQueue$ = function(section, name) {
  var exp = this.$getQueueKey$(section, name);
  delete this.$queue$[exp]
};
LabelValueProvider.prototype.$getQueueKey$ = function(section, name) {
  return section + "." + name
};
LabelValueProvider.prototype.$getValues$ = function() {
  return this.$values$
};
LabelValueProvider.prototype.$merge$ = function(values, overwrite) {
  overwrite !== undefined ? $A["util"].apply(this.$values$, values, overwrite, true, true) : $A["util"].apply(this.$values$, values, true, true, true)
};
LabelValueProvider.prototype.get = function(expression, callback) {
  var path = expression.split(".");
  if(path.length !== 2) {
    $A.log("$Label requests must have both section and name");
    return null
  }
  var section = path[0];
  var name = path[1];
  var value = this.$values$[section] && this.$values$[section][name];
  if(value === undefined) {
    value = this.$requestServerLabel$(section, name, callback)
  }else {
    if($A["util"].$isFunction$(callback)) {
      callback.call(null, value)
    }
  }
  return value
};
Aura.$Provider$.$LabelValueProvider$ = LabelValueProvider;
function ObjectValueProvider(values) {
  this.$values$ = values || {}
}
ObjectValueProvider.prototype.$getValues$ = function() {
  return this.$values$
};
ObjectValueProvider.prototype.$merge$ = function(values) {
  $A["util"].apply(this.$values$, values, true, true, true)
};
ObjectValueProvider.prototype.get = function(expression, callback) {
  var value = this.$values$[expression] || $A.$expressionService$.$resolve$(expression, this.$values$);
  if($A["util"].$isFunction$(callback)) {
    callback(value)
  }
  return value
};
Aura.$Provider$.$ObjectValueProvider$ = ObjectValueProvider;
function ContextValueProvider(values) {
  this.$values$ = values || {}
}
ContextValueProvider.prototype.$getValues$ = function() {
  var result = {};
  for(var key in this.$values$) {
    if(this.$values$.hasOwnProperty(key)) {
      result[key] = this.$extract$(this.$values$[key])
    }
  }
  return result
};
ContextValueProvider.prototype.$getStorableValues$ = function() {
  return this.$values$
};
ContextValueProvider.prototype.$serializeForServer$ = function() {
  var serverValues = {};
  for(var key in this.$values$) {
    if(this.$values$.hasOwnProperty(key)) {
      var current = this.$values$[key];
      if(current.hasOwnProperty("value")) {
        serverValues[key] = current["value"]
      }
    }
  }
  return serverValues
};
ContextValueProvider.prototype.$merge$ = function(values) {
  for(var key in values) {
    if(values.hasOwnProperty(key)) {
      var value = values[key];
      if(!value || !(value.hasOwnProperty("value") || value.hasOwnProperty("defaultValue"))) {
        throw new Error("Invalid merge value at key '" + key + "' with value '" + value + "'");
      }
      if(value.hasOwnProperty("value")) {
        if(!this.$values$.hasOwnProperty(key)) {
          if(value.hasOwnProperty("originalValue")) {
            delete value["originalValue"]
          }
          this.$values$[key] = value
        }else {
          if(value["originalValue"] === this.$values$[key].value) {
            delete value["originalValue"];
            this.$values$[key] = value
          }
        }
      }else {
        delete value["originalValue"];
        this.$values$[key] = value
      }
    }
  }
};
ContextValueProvider.prototype.get = function(key) {
  if(this.$values$.hasOwnProperty(key) === false) {
    throw new Error("Attempting to retrieve an unknown global item '" + key + "'. Global items must be pre-registered and have a default value");
  }
  return this.$extract$(this.$values$[key])
};
ContextValueProvider.prototype.set = function(key, value) {
  $A.assert(key.indexOf(".") === -1, "Unable to set value for key '" + key + "', did you add an extra '.'?");
  if($A["util"].$isExpression$(value)) {
    throw new Error("Unable to set global value '" + key + "' to the expression '" + value + "'. Global items must be constants");
  }
  if(this.$values$.hasOwnProperty(key) === false) {
    throw new Error("Attempting to set an unknown global item '" + key + "'. Global items must be pre-registered and have a default value");
  }
  var gv = this.$values$[key];
  if(gv && gv["writable"]) {
    gv["value"] = value === null ? undefined : value
  }else {
    throw new Error("Attempting to set a read only global item '" + key + "'");
  }
  return value
};
ContextValueProvider.prototype.$extract$ = function(gv) {
  return gv && (gv.hasOwnProperty("value") ? gv["value"] : gv["defaultValue"])
};
Aura.$Provider$.$ContextValueProvider$ = ContextValueProvider;
function LibraryIncludeRegistry() {
  this.$libExporter$ = {};
  this.$exporter$ = {};
  this.$dependencies$ = {};
  this.$dependenciesInstances$ = {};
  this.$instance$ = {};
  this.$dependencyQueue$ = [];
  this.$dependencyQueueChanged$ = false
}
LibraryIncludeRegistry.prototype.$hasLibraryInclude$ = function(descriptor) {
  return descriptor in this.$exporter$ || descriptor in this.$instance$
};
LibraryIncludeRegistry.prototype.$addLibraryInclude$ = function(descriptor, dependencies, exporter) {
  $A.assert($A["util"].$isString$(descriptor), "Include descriptor is invalid: " + descriptor);
  $A.assert($A["util"].$isFunction$(exporter), "Include exporter is not a function: " + descriptor);
  if(!this.$hasLibraryInclude$(descriptor)) {
    var context = $A.getContext();
    if(context) {
      var namespace = descriptor.split("//")[1].split(".")[0];
      var runInLocker = $A.$lockerService$.isEnabled() && context.$lockerAuraRuntimeExcludedComponents$.indexOf(descriptor.toLowerCase()) === -1 && context.$lockerAuraRuntimeIncludedNamespaces$.indexOf(namespace.toLowerCase()) !== -1;
      if(runInLocker) {
        exporter = $A.$lockerService$.$createForLibNext$(namespace, exporter)
      }
    }
    this.$exporter$[descriptor] = exporter;
    this.$dependencies$[descriptor] = dependencies;
    this.$dependenciesInstances$[descriptor] = []
  }
};
LibraryIncludeRegistry.prototype.$addLibraryExporter$ = function(descriptor, exporter) {
  this.$libExporter$[descriptor] = exporter
};
LibraryIncludeRegistry.prototype.$getLibraryInclude$ = function(descriptor) {
  var instance;
  if(descriptor in this.$instance$) {
    instance = this.$instance$[descriptor]
  }else {
    this.$clearDependencyQueue$();
    for(this.$enqueueDependency$(descriptor);this.$hasDependencyQueue$();) {
      var queue = this.$cloneDependencyQueue$();
      for(var i = 0;i < queue.length;i++) {
        var dependency = queue[i];
        instance = this.$buildLibraryInclude$(dependency)
      }
      if(!this.$hasDependencyQueueChanged$()) {
        throw new Error("Cannot solve library include dependencies: " + descriptor);
      }
    }
  }
  return instance
};
goog.$exportSymbol$("LibraryIncludeRegistry.prototype.getLibraryInclude", LibraryIncludeRegistry.prototype.$getLibraryInclude$);
LibraryIncludeRegistry.prototype.$hydrateLibrary$ = function(descriptor, exporter) {
  var script = $A.$clientService$.$uncommentExporter$(exporter);
  exporter = $A.$clientService$.$evalExporter$(script, descriptor, "lib");
  if(!exporter) {
    var defDescriptor = new Aura.$System$.$DefDescriptor$(descriptor);
    var includeComponentSource = $A.$clientService$.$isInternalNamespace$(defDescriptor.$getNamespace$());
    var errorMessage = !includeComponentSource ? "Hydrating the component" + descriptor + " failed." : "Hydrating the component" + descriptor + " failed.\n Exporter code: " + script;
    var auraError = new $A.$auraError$(errorMessage, null, $A.severity.$QUIET$);
    auraError.$setComponent$(descriptor);
    throw auraError;
  }
  return exporter()
};
LibraryIncludeRegistry.prototype.$buildLibraryInclude$ = function(descriptor) {
  if(this.$libExporter$[descriptor]) {
    this.$hydrateLibrary$(descriptor, this.$libExporter$[descriptor]);
    delete this.$libExporter$[descriptor]
  }
  var resolved = true;
  var dependencies = this.$dependencies$[descriptor] || [];
  var dependenciesInstances = this.$dependenciesInstances$[descriptor] || [];
  for(var i = 0;i < dependencies.length;i++) {
    if(!dependenciesInstances.hasOwnProperty(i)) {
      var dependency = dependencies[i];
      if(this.$instance$.hasOwnProperty(dependency)) {
        dependenciesInstances[i] = this.$instance$[dependency]
      }else {
        this.$enqueueDependency$(dependency);
        resolved = false
      }
    }
  }
  if(resolved) {
    var exporter = this.$exporter$[descriptor];
    if(!$A["util"].$isFunction$(exporter)) {
      throw new Error("Library include not defined: " + descriptor);
    }
    var instance = exporter.apply({}, dependenciesInstances);
    this.$instance$[descriptor] = instance;
    this.$dequeueDependency$(descriptor);
    delete this.$exporter$[descriptor];
    return instance
  }
};
LibraryIncludeRegistry.prototype.$clearDependencyQueue$ = function() {
  this.$dependencyQueue$ = []
};
LibraryIncludeRegistry.prototype.$enqueueDependency$ = function(descriptor) {
  var index = this.$dependencyQueue$.indexOf(descriptor);
  if(index < 0) {
    this.$dependencyQueue$.unshift(descriptor);
    this.$dependencyQueueChanged$ = true
  }
};
LibraryIncludeRegistry.prototype.$dequeueDependency$ = function(descriptor) {
  var index = this.$dependencyQueue$.indexOf(descriptor);
  if(index >= 0) {
    this.$dependencyQueue$.splice(index, 1);
    this.$dependencyQueueChanged$ = true
  }
};
LibraryIncludeRegistry.prototype.$cloneDependencyQueue$ = function() {
  var queue = this.$dependencyQueue$.slice(0);
  this.$dependencyQueueChanged$ = false;
  return queue
};
LibraryIncludeRegistry.prototype.$hasDependencyQueue$ = function() {
  return this.$dependencyQueue$.length > 0
};
LibraryIncludeRegistry.prototype.$hasDependencyQueueChanged$ = function() {
  return this.$dependencyQueueChanged$
};
Aura.$Library$.$LibraryIncludeRegistry$ = LibraryIncludeRegistry;
function LibraryRegistry() {
  this.$libraries$ = {};
  this.$instance$ = {}
}
LibraryRegistry.prototype.$initLibraries$ = function(libraries) {
  $A.assert($A["util"].$isEmpty$(this.$libraries$), "Library registry already initialized.");
  $A.assert($A["util"].isArray(libraries), "Library registry must be initialized with an array.");
  this.$libraries$ = libraries
};
goog.$exportSymbol$("LibraryRegistry.prototype.initLibraries", LibraryRegistry.prototype.$initLibraries$);
LibraryRegistry.prototype.$hasLibrary$ = function(descriptor) {
  return descriptor in this.$libraries$ || descriptor in this.$instance$
};
LibraryRegistry.prototype.$addLibrary$ = function(descriptor, includes) {
  $A.assert($A["util"].$isString$(descriptor), "Library descriptor is invalid: " + descriptor);
  $A.assert($A["util"].$isObject$(includes), "Library includes must be an array: " + descriptor);
  if(!this.$hasLibrary$(descriptor)) {
    this.$libraries$[descriptor] = includes
  }
};
LibraryRegistry.prototype.$getLibrary$ = function(descriptor) {
  var instance = this.$instance$[descriptor];
  if(!instance) {
    var includes = this.$libraries$[descriptor];
    if(includes) {
      instance = this.$buildLibrary$(includes);
      this.$instance$[descriptor] = instance;
      $A.$componentService$.$addModule$(descriptor, descriptor, [], null, instance)
    }
  }
  return instance
};
LibraryRegistry.prototype.$getLibraryDescriptors$ = function() {
  return Object.keys(this.$libraries$)
};
LibraryRegistry.prototype.$buildLibrary$ = function(includes) {
  var instance = {};
  for(var key in includes) {
    if(includes.hasOwnProperty(key)) {
      var descriptor = includes[key];
      instance[key] = $A.$componentService$.$getLibraryInclude$(descriptor)
    }
  }
  return instance
};
Aura.$Library$.$LibraryRegistry$ = LibraryRegistry;
function SourceMapRegistry() {
  this.$registry$ = {};
  this.$memo$ = {}
}
goog.$exportSymbol$("SourceMapRegistry", SourceMapRegistry);
SourceMapRegistry.prototype.$addSourceMapEntry$ = function(descriptor, sourceMap, type) {
  if(this.$isValidSourceMap$(sourceMap)) {
    var originalUrl = sourceMap[Json.$ApplicationKey$.$SOURCEURL$];
    var sourceUrl = this.$normalizeUrl$(originalUrl);
    var newEntry = {$descriptor$:descriptor, type:type, start:{$line$:sourceMap[Json.$ApplicationKey$.$START$][Json.$ApplicationKey$.$LINE$], $column$:sourceMap[Json.$ApplicationKey$.$START$][Json.$ApplicationKey$.$COLUMN$]}, end:{$line$:sourceMap[Json.$ApplicationKey$.$END$][Json.$ApplicationKey$.$LINE$], $column$:sourceMap[Json.$ApplicationKey$.$END$][Json.$ApplicationKey$.$COLUMN$]}};
    if(!this.$registry$[sourceUrl]) {
      this.$registry$[sourceUrl] = []
    }
    return this.$insertEntryInOrder$(this.$registry$[sourceUrl], newEntry)
  }
  return-1
};
goog.$exportProperty$(SourceMapRegistry.prototype, "addSourceMapEntry", SourceMapRegistry.prototype.$addSourceMapEntry$);
SourceMapRegistry.prototype.$normalizeUrl$ = function(originalUrl) {
  var queryIndex = originalUrl.indexOf("?");
  var protocolIndex = originalUrl.indexOf("://");
  var protocol = protocolIndex > -1 ? originalUrl.substring(0, protocolIndex) + "://" : "";
  if(protocolIndex > -1 && (queryIndex == -1 || queryIndex > protocolIndex)) {
    originalUrl = originalUrl.substring(protocolIndex + 3)
  }
  if(queryIndex > -1) {
    var preQuery = originalUrl.substring(0, queryIndex);
    return originalUrl.substring(preQuery.lastIndexOf("/"))
  }
  var lastSlashIdx = originalUrl.lastIndexOf("/");
  if(lastSlashIdx > -1) {
    return originalUrl.substring(lastSlashIdx)
  }
  return protocol + originalUrl
};
SourceMapRegistry.prototype.$insertEntryInOrder$ = function(sourceMapEntries, newSourceMapEntry) {
  if(newSourceMapEntry && sourceMapEntries && Array.isArray(sourceMapEntries)) {
    for(var ptr = sourceMapEntries.length - 1;ptr >= 0 && this.$compareLocations$(sourceMapEntries[ptr].start, newSourceMapEntry.start) > 0;) {
      ptr--
    }
    var idxToInsert = ptr + 1;
    if(idxToInsert === sourceMapEntries.length) {
      sourceMapEntries.push(newSourceMapEntry)
    }else {
      sourceMapEntries.splice(idxToInsert, 0, newSourceMapEntry)
    }
    return idxToInsert
  }
  return-1
};
SourceMapRegistry.prototype.$compareLocations$ = function(locationA, locationB) {
  var lineDelta = locationA.$line$ - locationB.$line$;
  if(lineDelta === 0) {
    return locationA.$column$ - locationB.$column$
  }
  return lineDelta
};
SourceMapRegistry.prototype.$isValidSourceMap$ = function(sourceMapEntry) {
  if(sourceMapEntry != null) {
    var sourceUrl = sourceMapEntry[Json.$ApplicationKey$.$SOURCEURL$];
    var startObj = sourceMapEntry[Json.$ApplicationKey$.$START$];
    var endObj = sourceMapEntry[Json.$ApplicationKey$.$END$];
    var startLine = startObj ? startObj[Json.$ApplicationKey$.$LINE$] : null;
    var startColumn = startObj ? startObj[Json.$ApplicationKey$.$COLUMN$] : null;
    var endLine = endObj ? endObj[Json.$ApplicationKey$.$LINE$] : null;
    var endColumn = endObj ? endObj[Json.$ApplicationKey$.$COLUMN$] : null;
    var isValidTypes = !!sourceUrl && typeof sourceUrl === "string" && typeof startLine === "number" && typeof startColumn === "number" && typeof endLine === "number" && typeof endColumn === "number";
    var isValidStartLine = startLine >= 0 && endLine >= startLine;
    var isValidStartColumn = startColumn >= 0 && (startLine === endLine ? startColumn <= endColumn : true);
    return isValidTypes && isValidStartLine && isValidStartColumn
  }
  return false
};
SourceMapRegistry.prototype.$getMemoKey$ = function(originalUrl, line, column) {
  var sourceUrl = this.$normalizeUrl$(originalUrl);
  return sourceUrl + ":" + line + ":" + column
};
SourceMapRegistry.prototype.$getModule$ = function(originalUrl, targetLine, targetColumn) {
  var sourceUrl = this.$normalizeUrl$(originalUrl);
  var modules = this.$registry$[sourceUrl];
  if(!modules) {
    return null
  }
  var memoKey = this.$getMemoKey$(sourceUrl, targetLine, targetColumn);
  if(this.$memo$[memoKey] != null) {
    return this.$memo$[memoKey]
  }
  var low = 0;
  for(var high = modules.length - 1;low <= high;) {
    var mid = Math.floor((low + high) / 2);
    var midPointModule = modules[mid];
    var compStart = this.$compareLocations$({$line$:targetLine, $column$:targetColumn}, midPointModule.start);
    var compEnd = this.$compareLocations$({$line$:targetLine, $column$:targetColumn}, midPointModule.end);
    if(compStart >= 0 && compEnd <= 0) {
      this.$memo$[memoKey] = midPointModule;
      return midPointModule
    }
    if(compEnd < 0) {
      high = mid - 1
    }else {
      low = mid + 1
    }
  }
  return null
};
Aura.$SourceMap$.$SourceMapRegistry$ = SourceMapRegistry;
function EventDef(config) {
  if(typeof config === "string") {
    this.$descriptor$ = new DefDescriptor(config);
    return
  }
  this.$descriptor$ = new DefDescriptor(config[Json.$ApplicationKey$.$DESCRIPTOR$]);
  var superDef = config[Json.$ApplicationKey$.$SUPERDEF$];
  if(!superDef && EventDef.$KNOWN_SUPER_DEFS$.hasOwnProperty(config[Json.$ApplicationKey$.$TYPE$]) && EventDef.$KNOWN_SUPER_DEFS$[config[Json.$ApplicationKey$.$TYPE$]] !== config[Json.$ApplicationKey$.$DESCRIPTOR$]) {
    superDef = EventDef.$KNOWN_SUPER_DEFS$[config[Json.$ApplicationKey$.$TYPE$]]
  }
  this.$superDef$ = this.$initSuperDef$(superDef);
  this.$attributeDefsConfigs$ = config[Json.$ApplicationKey$.$ATTRIBUTES$];
  this.$attributeDefs$ = undefined;
  this.type = config[Json.$ApplicationKey$.$TYPE$];
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$]
}
goog.$exportSymbol$("EventDef", EventDef);
EventDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(EventDef.prototype, "getDescriptor", EventDef.prototype.$getDescriptor$);
EventDef.prototype.$getEventType$ = function() {
  return this.type
};
goog.$exportProperty$(EventDef.prototype, "getEventType", EventDef.prototype.$getEventType$);
EventDef.prototype.$getAttributeDefs$ = function() {
  if(this.$attributeDefs$ === undefined) {
    var definitions = [];
    for(var key in this.$attributeDefsConfigs$) {
      definitions.push(this.$attributeDefsConfigs$[key])
    }
    this.$attributeDefs$ = new AttributeDefSet(definitions, this.$getDescriptor$().$getNamespace$())
  }
  return this.$attributeDefs$
};
goog.$exportProperty$(EventDef.prototype, "getAttributeDefs", EventDef.prototype.$getAttributeDefs$);
EventDef.prototype.$getSuperDef$ = function() {
  return this.$superDef$
};
goog.$exportProperty$(EventDef.prototype, "getSuperDef", EventDef.prototype.$getSuperDef$);
EventDef.prototype.$initSuperDef$ = function(superDef) {
  if(superDef) {
    return $A.$eventService$.$createEventDef$(superDef)
  }else {
    return null
  }
};
EventDef.$KNOWN_SUPER_DEFS$ = {"APPLICATION":"markup://aura:applicationEvent", "COMPONENT":"markup://aura:componentEvent", "VALUE":"markup://aura:valueEvent"};
Aura.$Event$.$EventDef$ = EventDef;
Aura.$Event$.$Event$ = function(config) {
  this.source = config["component"] || $A.$clientService$.$currentAccess$ || $A.$getRoot$();
  this.$sourceEvent$ = null;
  this.$eventDef$ = config["eventDef"];
  this.$eventDispatcher$ = config["eventDispatcher"];
  this.$eventName$ = config["name"];
  this.$params$ = {};
  this.$fired$ = false;
  this.$eventStopPropagation$ = false;
  this.defaultPrevented = false;
  this.paused = false;
  this.$componentEvent$ = false;
  this.$phase$ = undefined;
  this.$eventHandlerIterator$ = null;
  this[Symbol["for"]("@@lockerLiveValue")] = true;
  $A.$lockerService$.$trust$(this.source, this)
};
goog.$exportSymbol$("Aura.Event.Event", Aura.$Event$.$Event$);
var recordEventO11yMetrics = Aura.$Utils$.$Util$.prototype.$getO11yMetricRecordingFunction$("evt");
Aura.$Event$.$Event$.prototype.$getSource$ = function() {
  return this.source
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getSource", Aura.$Event$.$Event$.prototype.$getSource$);
Aura.$Event$.$Event$.prototype.$getSourceEvent$ = function() {
  return this.$sourceEvent$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getSourceEvent", Aura.$Event$.$Event$.prototype.$getSourceEvent$);
Aura.$Event$.$Event$.prototype.$getDef$ = function() {
  return this.$eventDef$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getDef", Aura.$Event$.$Event$.prototype.$getDef$);
Aura.$Event$.$Event$.prototype.$getPhase$ = function() {
  return this.$phase$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getPhase", Aura.$Event$.$Event$.prototype.$getPhase$);
Aura.$Event$.$Event$.prototype.stopPropagation = function() {
  var eventExecutionType = this.$getEventExecutionType$();
  $A.assert(eventExecutionType !== "COMPONENT" || eventExecutionType !== "APPLICATION" || this.$getPhase$() !== "default", "stopPropagation() is not supported in the 'default' phase");
  this.$eventStopPropagation$ = true
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "stopPropagation", Aura.$Event$.$Event$.prototype.stopPropagation);
Aura.$Event$.$Event$.prototype.preventDefault = function() {
  $A.assert(this.$getPhase$() !== "default", "preventDefault() is not supported in the 'default' phase");
  this.defaultPrevented = true
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "preventDefault", Aura.$Event$.$Event$.prototype.preventDefault);
Aura.$Event$.$Event$.prototype.pause = function() {
  $A.assert(this.$getPhase$() !== "default", "pause() is not supported in the 'default' phase");
  if(!this.paused) {
    this.paused = true
  }
  return this
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "pause", Aura.$Event$.$Event$.prototype.pause);
Aura.$Event$.$Event$.prototype.$resume$ = function() {
  $A.assert(this.$getPhase$() !== "default", "resume() is not supported in the 'default' phase");
  if(this.paused) {
    this.paused = false;
    this.$executeHandlers$()
  }
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "resume", Aura.$Event$.$Event$.prototype.$resume$);
Aura.$Event$.$Event$.prototype.$setComponentEvent$ = function() {
  this.$componentEvent$ = true;
  return this
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "setComponentEvent", Aura.$Event$.$Event$.prototype.$setComponentEvent$);
Aura.$Event$.$Event$.prototype.getName = function() {
  return this.$eventName$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getName", Aura.$Event$.$Event$.prototype.getName);
Aura.$Event$.$Event$.prototype.$getType$ = function() {
  return this.$eventDef$.$getDescriptor$().$getFullName$()
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getType", Aura.$Event$.$Event$.prototype.$getType$);
Aura.$Event$.$Event$.prototype.$getEventType$ = function() {
  return this.$eventDef$.$getEventType$()
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getEventType", Aura.$Event$.$Event$.prototype.$getEventType$);
Aura.$Event$.$Event$.prototype.$setParams$ = function(config) {
  if(this.$fired$) {
    $A.assert(false, "Event.setParams(): cannot modify all params in an event that has already been fired.")
  }
  if(config) {
    var attributeDefs = this.$eventDef$.$getAttributeDefs$();
    for(var key in config) {
      if(config.hasOwnProperty(key)) {
        if(attributeDefs.hasAttribute(key)) {
          this.$params$[key] = config[key]
        }else {
          $A.$warning$("Event.setParams(): '" + key + "'('" + config[key] + "') is not a valid parameter. Valid parameters are '" + attributeDefs.$getNames$().join("', '") + "'")
        }
      }
    }
  }
  return this
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "setParams", Aura.$Event$.$Event$.prototype.$setParams$);
Aura.$Event$.$Event$.prototype.$setParam$ = function(key, value) {
  if(this.$fired$ && this.$componentEvent$) {
    $A.assert(false, "Event.setParam(): cannot modify a component event that has already been fired.")
  }
  if(this.$eventDef$.$getAttributeDefs$().hasAttribute(key)) {
    this.$params$[key] = value
  }else {
    $A.$warning$("Event.setParam(): '" + key + "' is not a valid parameter. Valid parameters are '" + this.$eventDef$.$getAttributeDefs$().$getNames$().join("', '") + "'")
  }
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "setParam", Aura.$Event$.$Event$.prototype.$setParam$);
Aura.$Event$.$Event$.prototype.$getParam$ = function(name) {
  return this.$params$[name]
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getParam", Aura.$Event$.$Event$.prototype.$getParam$);
Aura.$Event$.$Event$.prototype.$getParams$ = function() {
  return this.$params$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getParams", Aura.$Event$.$Event$.prototype.$getParams$);
Aura.$Event$.$Event$.prototype.$getEventExecutionType$ = function() {
  if(this.$eventDef$.$getDescriptor$().$getQualifiedName$() === "markup://aura:methodCall") {
    return"VALUE"
  }else {
    if(this.$eventName$) {
      return this.$componentEvent$ ? "LEGACY_COMPONENT" : "COMPONENT"
    }else {
      for(var def = this.$eventDef$;def;) {
        var qname = def.$getDescriptor$().$getQualifiedName$();
        var handlers = this.$eventDispatcher$[qname];
        if(handlers) {
          return def.$getEventType$() === "VALUE" ? "VALUE" : "APPLICATION"
        }
        def = def.$getSuperDef$()
      }
      return"APPLICATION"
    }
  }
};
Aura.$Event$.$Event$.prototype.$executeHandlers$ = function() {
  if(!this.$eventHandlerIterator$) {
    this.$eventHandlerIterator$ = this.$getHandlerIterator$()
  }
  this.$executeHandlerIterator$(this.$eventHandlerIterator$)
};
Aura.$Event$.$Event$.prototype.$executeHandlerIterator$ = function(handlerIterator) {
  var expectedError = false;
  var errorEventHandlerError = false;
  try {
    var res = {};
    var value;
    var type = this.$getType$();
    var isSystemError = type === "aura:systemError";
    var isCustomerError = type === "aura:customerError";
    for(var isComponentEventType = this.$getEventExecutionType$() === "COMPONENT";!this.paused && !res.$done$;) {
      res = handlerIterator.next();
      value = res.value;
      if(value && value.$handler$) {
        if(isComponentEventType && !value.$cmp$.$isValid$() && this.$phase$ !== "default") {
          this.stopPropagation()
        }
        this.$phase$ = value.$phase$;
        if(isSystemError || isCustomerError) {
          try {
            value.$handler$(this)
          }catch(e) {
            $A.$warning$("aura:systemError | aura:customerError event handler failed", e);
            $A.$logger$.$reportError$(e);
            errorEventHandlerError = true
          }
        }else {
          $A.$clientService$.$setCurrentAccess$(value.$cmp$);
          try {
            value.$handler$(this)
          }catch(e$$0) {
            expectedError = true;
            throw e$$0;
          }finally {
            $A.$clientService$.$releaseCurrentAccess$()
          }
        }
      }
    }
  }catch(error) {
    if(!expectedError) {
      recordEventO11yMetrics("executeHandlerIterator", ["ERROR"])
    }
    throw error;
  }
  if(!errorEventHandlerError) {
    recordEventO11yMetrics("executeHandlerIterator", ["SUCCESS"])
  }else {
    recordEventO11yMetrics("executeHandlerIterator", ["ERROR"])
  }
};
Aura.$Event$.$Event$.prototype.$getHandlerIterator$ = function() {
  var eventExecutionType = this.$getEventExecutionType$();
  switch(eventExecutionType) {
    case "VALUE":
      return $A.$eventService$.$getValueHandlerIterator$(this);
    case "LEGACY_COMPONENT":
      return $A.$eventService$.$getNonBubblingComponentEventHandlerIterator$(this);
    case "COMPONENT":
      return $A.$eventService$.$getComponentEventHandlerIterator$(this);
    case "APPLICATION":
      return $A.$eventService$.$getAppEventHandlerIterator$(this);
    default:
      throw new Aura.$Errors$.$AuraError$("Invalid event type");
  }
};
Aura.$Event$.$Event$.prototype.$fire$ = function(params) {
  var self = this;
  if(this.$fired$) {
    $A.assert(false, "Event.fire(): Unable to fire event. Event has already been fired.")
  }
  if(params) {
    this.$setParams$(params)
  }
  $A.$run$(function() {
    self.$fired$ = true;
    self.$executeHandlers$()
  }, this.$eventDef$.$getDescriptor$().$getQualifiedName$())
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "fire", Aura.$Event$.$Event$.prototype.$fire$);
Aura.$Event$.$InteropEvent$ = function(component, config) {
  $A.assert(component, "InteropEvent constructor requires the `component` argument.");
  var _config = config || {};
  var nativeEvent = _config["isEvent"] && _config["params"];
  if(nativeEvent && _config["exposeNativeAPI"] && nativeEvent["detail"] && nativeEvent["detail"]["_originalEvent"]) {
    nativeEvent = nativeEvent["detail"]["_originalEvent"]
  }
  var event = nativeEvent || {};
  this.$_name$ = event.type || _config["name"] || "";
  this.$_source$ = component;
  this.$_params$ = _config["isEvent"] ? this.$buildEventParams$($A.$componentService$.$moduleEngine$["unwrap"](event.detail) || {}) : _config["params"] || {};
  this["target"] = null;
  this["currentTarget"] = null;
  this["initEvent"] = null;
  if(nativeEvent) {
    if(nativeEvent.preventDefault) {
      this["preventDefault"] = nativeEvent.preventDefault.bind(nativeEvent)
    }
    if(nativeEvent.stopPropagation) {
      this["stopPropagation"] = nativeEvent.stopPropagation.bind(nativeEvent)
    }
    if(_config["exposeNativeAPI"]) {
      this["target"] = event.target;
      this["currentTarget"] = event.currentTarget;
      this.$exposeNativeEventAPI$(this, nativeEvent)
    }
  }
};
goog.$exportSymbol$("Aura.Event.InteropEvent", Aura.$Event$.$InteropEvent$);
Aura.$Event$.$InteropEvent$.prototype.$buildEventParams$ = function(eventDetails) {
  var unwrap = $A.$componentService$.$moduleEngine$["unwrap"];
  var evtDetails = {};
  var objKeys = Object.keys(eventDetails);
  var key;
  var i = 0;
  for(var n = objKeys.length;i < n;i++) {
    key = objKeys[i];
    evtDetails[key] = unwrap(eventDetails[key])
  }
  return evtDetails
};
Aura.$Event$.$InteropEvent$.prototype.$exposeNativeEventAPI$ = function(auraEvent, nativeEvent) {
  var createGetter = function(_nativeEvent, _attrName) {
    return function() {
      $A.$warning$("Avoid relying on the native event attribute `" + _attrName + "` as it is only included for backwards-compatibility. It " + "will eventually be deprecated. Use the aura event API " + "(e.g., getSource(), getParams(), etc) instead.");
      var value = _nativeEvent[_attrName];
      if(typeof value === "function") {
        value = value.bind(_nativeEvent)
      }
      return value
    }
  };
  for(var attrName in nativeEvent) {
    if(!(attrName in auraEvent)) {
      Object.defineProperty(auraEvent, attrName, {enumerable:true, get:createGetter(nativeEvent, attrName)})
    }
  }
};
Aura.$Event$.$InteropEvent$.prototype.$fire$ = function() {
  this.$raiseInvalidInteropApi$("fire", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "fire", Aura.$Event$.$InteropEvent$.prototype.$fire$);
Aura.$Event$.$InteropEvent$.prototype.getName = function() {
  return this.$_name$
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getName", Aura.$Event$.$InteropEvent$.prototype.getName);
Aura.$Event$.$InteropEvent$.prototype.$getParam$ = function(name) {
  return this.$_params$[name]
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getParam", Aura.$Event$.$InteropEvent$.prototype.$getParam$);
Aura.$Event$.$InteropEvent$.prototype.$getParams$ = function() {
  return this.$_params$
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getParams", Aura.$Event$.$InteropEvent$.prototype.$getParams$);
Aura.$Event$.$InteropEvent$.prototype.$getPhase$ = function() {
  this.$raiseInvalidInteropApi$("getPhase", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getPhase", Aura.$Event$.$InteropEvent$.prototype.$getPhase$);
Aura.$Event$.$InteropEvent$.prototype.$getSource$ = function() {
  return this.$_source$
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getSource", Aura.$Event$.$InteropEvent$.prototype.$getSource$);
Aura.$Event$.$InteropEvent$.prototype.pause = function() {
  this.$raiseInvalidInteropApi$("pause", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "pause", Aura.$Event$.$InteropEvent$.prototype.pause);
Aura.$Event$.$InteropEvent$.prototype.preventDefault = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "preventDefault", Aura.$Event$.$InteropEvent$.prototype.preventDefault);
Aura.$Event$.$InteropEvent$.prototype.$resume$ = function() {
  this.$raiseInvalidInteropApi$("resume", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "resume", Aura.$Event$.$InteropEvent$.prototype.$resume$);
Aura.$Event$.$InteropEvent$.prototype.$setParam$ = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "setParam", Aura.$Event$.$InteropEvent$.prototype.$setParam$);
Aura.$Event$.$InteropEvent$.prototype.$setParams$ = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "setParams", Aura.$Event$.$InteropEvent$.prototype.$setParams$);
Aura.$Event$.$InteropEvent$.prototype.stopPropagation = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "stopPropagation", Aura.$Event$.$InteropEvent$.prototype.stopPropagation);
Aura.$Event$.$InteropEvent$.prototype.$raiseInvalidInteropApi$ = function(func, args) {
  var error = "Interop event tried calling function [" + func + "]";
  var argsArr = Array.prototype.slice.call(args);
  if(argsArr.length) {
    error += " with arguments [" + argsArr.join(",") + "]"
  }
  if(this.$_source$ && this.$_source$.$globalId$) {
    error += ", " + this.$_source$ + " [" + this.$_source$.$globalId$ + "]"
  }
  var ae = new $A.$auraError$(error, null, $A.severity.$QUIET$);
  ae.$component$ = this.$_source$.toString();
  throw ae;
};
function ActionDef(config) {
  this.name = config[Json.$ApplicationKey$["NAME"]];
  this.$descriptor$ = config[Json.$ApplicationKey$.$DESCRIPTOR$];
  this.$actionType$ = config[Json.$ApplicationKey$.$ACTIONTYPE$];
  this.$storable$ = config[Json.$ApplicationKey$.$STORABLE$];
  this.$meth$ = null;
  this.$paramDefs$ = {};
  this.background = false;
  this.$caboose$ = false;
  this.$longRunning$ = config[Json.$ApplicationKey$.$LONGRUNNING$];
  this.$actionGroup$;
  this.$publicCachingEnabled$ = false;
  this.$publicCachingExpiration$ = -1;
  this.$namespaceAccessible$ = config[Json.$ApplicationKey$.$NAMESPACEACCESSIBLE$];
  if(this.$actionType$ === "SERVER") {
    this.$returnType$ = config[Json.$ApplicationKey$.$RETURNTYPE$] && config[Json.$ApplicationKey$.$RETURNTYPE$]["name"];
    var params = config[Json.$ApplicationKey$.$PARAMS$];
    if(!!params && $A["util"].isArray(params)) {
      for(var i = 0;i < params.length;i++) {
        this.$paramDefs$[params[i]["name"]] = params[i]
      }
    }
    if(config[Json.$ApplicationKey$.$BACKGROUND$]) {
      this.background = true
    }
    if(config[Json.$ApplicationKey$.$CABOOSE$]) {
      this.$caboose$ = true
    }
    if(config[Json.$ApplicationKey$.$ACTIONGROUP$]) {
      this.$actionGroup$ = config[Json.$ApplicationKey$.$ACTIONGROUP$]
    }
    if(config[Json.$ApplicationKey$.$PUBLICCACHINGENABLED$]) {
      this.$publicCachingEnabled$ = true;
      this.$publicCachingExpiration$ = config[Json.$ApplicationKey$.$PUBLICCACHINGEXPIRATION$]
    }
  }else {
    if(this.$actionType$ === "CLIENT") {
      try {
        this.$meth$ = $A["util"].$json$.$decodeString$(config[Json.$ApplicationKey$.$CODE$])
      }catch(e) {
        throw new $A.$auraError$("ActionDef ctor decode error: " + config[Json.$ApplicationKey$.$CODE$], e, $A.severity.$QUIET$);
      }
    }
  }
}
goog.$exportSymbol$("ActionDef", ActionDef);
ActionDef.prototype.getName = function() {
  return this.name
};
goog.$exportProperty$(ActionDef.prototype, "getName", ActionDef.prototype.getName);
ActionDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
ActionDef.prototype.$getActionType$ = function() {
  return this.$actionType$
};
ActionDef.prototype.$isClientAction$ = function() {
  return this.$actionType$ === "CLIENT"
};
goog.$exportProperty$(ActionDef.prototype, "isClientAction", ActionDef.prototype.$isClientAction$);
ActionDef.prototype.$isServerAction$ = function() {
  return this.$actionType$ === "SERVER"
};
goog.$exportProperty$(ActionDef.prototype, "isServerAction", ActionDef.prototype.$isServerAction$);
ActionDef.prototype.$isBackground$ = function() {
  return this.background === true
};
ActionDef.prototype.$isCaboose$ = function() {
  return this.$caboose$ === true
};
ActionDef.prototype.$isStorable$ = function() {
  return this.$storable$ === true
};
ActionDef.prototype.$isLongRunning$ = function() {
  return this.$longRunning$ === true
};
ActionDef.prototype.$isNamespaceAccessible$ = function() {
  return this.$namespaceAccessible$ === true
};
ActionDef.prototype.$getActionGroup$ = function() {
  return this.$actionGroup$
};
ActionDef.prototype.$isPublicCachingEnabled$ = function() {
  return this.$publicCachingEnabled$ === true
};
ActionDef.prototype.$getPublicCachingExpiration$ = function() {
  return this.$publicCachingExpiration$
};
ActionDef.prototype.$getActionGroup$ = function() {
  return this.$actionGroup$
};
ActionDef.prototype.$newInstance$ = function(cmp) {
  return new Action(this, "a", this.$meth$, this.$paramDefs$, this.background, cmp, this.$caboose$)
};
ActionDef.prototype.toString = function() {
  return this.$descriptor$.toString()
};
ActionDef.prototype.$getLoggableParams$ = function() {
  var loggableParams = [];
  var paramDefs = this.$paramDefs$;
  for(var key in paramDefs) {
    if(paramDefs[key]["loggable"]) {
      loggableParams.push(key)
    }
  }
  return loggableParams
};
Aura.$Controller$.$ActionDef$ = ActionDef;
function Action(def, suffix, method, paramDefs, background, cmp, caboose) {
  this.$def$ = def;
  this.$meth$ = method;
  this.$paramDefs$ = paramDefs;
  this.background = background;
  this.$cmp$ = cmp;
  this.$params$ = {};
  this.$responseState$ = null;
  this.$responseCode$ = null;
  this.state = "NEW";
  this.$callbacks$ = {};
  this.$events$ = [];
  this.$components$ = null;
  this.$actionId$ = Action.prototype.$nextActionId$++;
  this.id = this.$actionId$ > 0 ? this.$actionId$ + ";" + suffix : suffix;
  this.$originalResponse$ = undefined;
  this.$storable$ = def && def.$isStorable$();
  this.$longRunning$ = def && def.$isLongRunning$();
  this.$namespaceAccessible$ = def && def.$isNamespaceAccessible$();
  this.$caboose$ = caboose;
  this.$allAboardCallback$ = undefined;
  this.$abortable$ = false;
  this.$deferred$ = false;
  this.$defDependencies$ = undefined;
  this.$sourceContext$ = undefined;
  this.returnValue = undefined;
  this.$returnValueUserland$ = undefined;
  this.$pathStack$ = [];
  this.$canCreate$ = true;
  this.$pushCreationPath$("body");
  this.$setCreationPathIndex$(0);
  this.$refreshAction$ = undefined;
  this.$callingCmp$ = $A.$clientService$.$currentAccess$;
  this.$retryCount$ = 0;
  var headers = {};
  this.$setCustomHeader$ = function(key, val) {
    headers[key] = val
  };
  this.$getCustomHeaders$ = function() {
    return headers
  };
  $A.$lockerService$.$trust$(cmp, this)
}
goog.$exportSymbol$("Action", Action);
Action.$getStorageKey$ = function(descriptor, params) {
  return descriptor + ":" + $A["util"]["json"].$orderedEncode$(params)
};
Action.prototype.$nextActionId$ = 0;
Action.prototype.$getId$ = function() {
  return this.id
};
goog.$exportProperty$(Action.prototype, "getId", Action.prototype.$getId$);
Action.prototype.$setId$ = function(id) {
  this.id = id
};
Action.prototype.$setResponseCode$ = function(code) {
  this.$responseCode$ = code
};
Action.prototype.$getResponseCode$ = function() {
  return this.$responseCode$
};
Action.prototype.$setHeader$ = function(key, value) {
  this.$setCustomHeader$(key, value)
};
Action.prototype.$getHeaders$ = function() {
  return this.$getCustomHeaders$()
};
Action.prototype.$setSourceContext$ = function(sourceContext) {
  this.$sourceContext$ = sourceContext
};
Action.prototype.$getSourceContext$ = function() {
  return this.$sourceContext$
};
goog.$exportProperty$(Action.prototype, "getSourceContext", Action.prototype.$getSourceContext$);
Action.prototype.$getNextGlobalId$ = function() {
  if(!this.$nextGlobalId$) {
    this.$nextGlobalId$ = 1
  }
  return this.$nextGlobalId$++
};
Action.prototype.$reactivatePath$ = function() {
  this.$canCreate$ = true
};
Action.prototype.$forceCreationPath$ = function(path) {
  var absPath = "(empty)";
  var newAbsPath = this.$getId$() + path;
  if(this.$pathStack$.length > 0) {
    var top = this.$pathStack$[this.$pathStack$.length - 1];
    if(top.$absPath$ === newAbsPath) {
      return undefined
    }
    absPath = top.$absPath$
  }
  if(this.$topPath$() !== newAbsPath && (path.length < 2 || path.indexOf("/", 1) !== -1)) {
    $A.$warning$("force path of " + newAbsPath + " from " + absPath + " likely a use of returned component array without changing index")
  }
  var pathEntry = {$relPath$:"~FORCED~", $absPath$:newAbsPath, $idx$:undefined, $startIdx$:undefined};
  this.$pathStack$.push(pathEntry);
  return newAbsPath
};
Action.prototype.$setDeferred$ = function() {
  this.$deferred$ = this.$abortable$
};
Action.prototype.$isDeferred$ = function() {
  return this.$deferred$
};
Action.prototype.$setLongRunning$ = function() {
  this.$longRunning$ = true
};
Action.prototype.$isLongRunning$ = function() {
  return this.$longRunning$
};
Action.prototype.$releaseCreationPath$ = function(path) {
  var last;
  if(this.$pathStack$.length > 0) {
    last = this.$pathStack$[this.$pathStack$.length - 1]
  }
  if(!last || last.$absPath$ !== path) {
    $A.$warning$("unexpected unwinding of pathStack.  found " + (last ? last.$absPath$ + " idx " + last.$idx$ : "empty") + " expected " + path)
  }
  if(last && last.$relPath$ === "~FORCED~") {
    this.$pathStack$.pop()
  }
};
Action.prototype.$pushCreationPath$ = function(pathPart) {
  this.$canCreate$ = true;
  switch(pathPart) {
    case "body":
      pathPart = "*";
      break;
    case "super":
      pathPart = "$";
      break
  }
  var addedPath = "/" + pathPart;
  var newPath = this.$topPath$() + addedPath;
  var pathEntry = {$relPath$:addedPath, $absPath$:newPath, $idx$:undefined, $startIdx$:undefined};
  this.$pathStack$.push(pathEntry)
};
Action.prototype.$popCreationPath$ = function(pathPart) {
  var addedPath;
  this.$canCreate$ = false;
  switch(pathPart) {
    case "body":
      pathPart = "*";
      break;
    case "super":
      pathPart = "$";
      break
  }
  addedPath = "/" + pathPart;
  var last = this.$pathStack$.pop();
  if(!last || last.$relPath$ !== addedPath) {
    $A.$warning$("unexpected unwinding of pathStack.  found " + (last ? last.$relPath$ + " idx " + last.$idx$ : "empty") + " expected " + addedPath)
  }
  return last
};
Action.prototype.$topPath$ = function() {
  if(this.$pathStack$.length === 0) {
    return this.$getId$()
  }
  var top = this.$pathStack$[this.$pathStack$.length - 1];
  return top.$absPath$ + (top.$idx$ !== undefined ? "[" + top.$idx$ + "]" : "")
};
Action.prototype.$setCreationPathIndex$ = function(idx) {
  this.$canCreate$ = true;
  if(this.$pathStack$.length < 1) {
    $A.$warning$("Attempting to increment index on empty stack")
  }
  var top = this.$pathStack$[this.$pathStack$.length - 1];
  if(top.$idx$ === undefined) {
    top.$startIdx$ = idx;
    top.$idx$ = idx
  }else {
    if(idx !== 0 && idx !== top.$idx$ + 1) {
      $A.$warning$("Improper index increment. Expected: " + (top.$idx$ + 1) + ", Actual: " + idx)
    }else {
      top.$idx$ = idx
    }
  }
};
Action.prototype.$getCurrentPath$ = function() {
  if(!this.$canCreate$) {
  }
  this.$canCreate$ = false;
  return this.$topPath$()
};
Action.prototype.$getDef$ = function() {
  return this.$def$
};
goog.$exportProperty$(Action.prototype, "getDef", Action.prototype.$getDef$);
Action.prototype.getName = function() {
  return this.$def$.getName()
};
goog.$exportProperty$(Action.prototype, "getName", Action.prototype.getName);
Action.prototype.$setParams$ = function(config) {
  $A.assert($A["util"].$isObject$(config), "setParams() must be passed an object.");
  var paramDefs = this.$paramDefs$;
  for(var key in paramDefs) {
    this.$params$[key] = config[key]
  }
};
goog.$exportProperty$(Action.prototype, "setParams", Action.prototype.$setParams$);
Action.prototype.$setParam$ = function(key, value) {
  var paramDef = this.$paramDefs$[key];
  if(paramDef) {
    this.$params$[key] = value
  }
};
goog.$exportProperty$(Action.prototype, "setParam", Action.prototype.$setParam$);
Action.prototype.$getParam$ = function(name) {
  return this.$params$[name]
};
goog.$exportProperty$(Action.prototype, "getParam", Action.prototype.$getParam$);
Action.prototype.$getParams$ = function() {
  return this.$params$
};
goog.$exportProperty$(Action.prototype, "getParams", Action.prototype.$getParams$);
Action.prototype.$getLoggableParams$ = function() {
  var loggableParams = {};
  var loggableParamsKeys = this.$def$.$getLoggableParams$();
  for(var key = 0;key < loggableParamsKeys.length;++key) {
    var paramsValue = this.$params$[loggableParamsKeys[key]];
    loggableParams[loggableParamsKeys[key]] = typeof paramsValue === "object" ? JSON.stringify(paramsValue) : paramsValue
  }
  return loggableParams
};
Action.prototype.$getComponent$ = function() {
  return this.$cmp$
};
Action.prototype.$getComponentInfo$ = function() {
  return{"type":this.$cmp$ && this.$cmp$.$getType$()}
};
goog.$exportProperty$(Action.prototype, "getComponentInfo", Action.prototype.$getComponentInfo$);
Action.prototype.$setCallback$ = function(scope, callback, name) {
  $A.assert($A["util"].$isFunction$(callback), "Action.setCallback(): callback for '" + name + "' must be a function");
  if(name !== undefined && name !== "ALL" && name !== "SUCCESS" && name !== "ERROR" && name !== "INCOMPLETE" && name !== "ABORTED") {
    throw new $A.$auraError$("Action.setCallback(): Invalid callback name '" + name + "'");
  }
  if($A.$clientService$.$currentAccess$ && $A.$clientService$.$inAuraLoop$()) {
    callback = $A.$getCallback$(callback)
  }
  if(name === undefined || name === "ALL") {
    this.$callbacks$["SUCCESS"] = {"fn":callback, "s":scope};
    this.$callbacks$["ERROR"] = {"fn":callback, "s":scope};
    this.$callbacks$["INCOMPLETE"] = {"fn":callback, "s":scope}
  }else {
    this.$callbacks$[name] = {"fn":callback, "s":scope}
  }
};
goog.$exportProperty$(Action.prototype, "setCallback", Action.prototype.$setCallback$);
Action.prototype.$getCallback$ = function(type) {
  return this.$callbacks$[type]
};
goog.$exportProperty$(Action.prototype, "getCallback", Action.prototype.$getCallback$);
Action.prototype.$setAllAboardCallback$ = function(scope, callback) {
  $A.assert($A["util"].$isFunction$(callback), "Action 'All Aboard' callback should be a function");
  var that = this;
  this.$allAboardCallback$ = function() {
    callback.call(scope, that)
  }
};
goog.$exportProperty$(Action.prototype, "setAllAboardCallback", Action.prototype.$setAllAboardCallback$);
Action.prototype.$callAllAboardCallback$ = function(context) {
  if(this.$allAboardCallback$) {
    var previous = context.$setCurrentAction$(this);
    $A.$clientService$.$setCurrentAccess$(this.$cmp$);
    try {
      this.$allAboardCallback$()
    }catch(e) {
      this.$markException$(e);
      return false
    }finally {
      context.$setCurrentAction$(previous);
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
  return true
};
Action.prototype.$wrapCallback$ = function(scope, callback) {
  var nestedCallbacks = this.$callbacks$;
  var outerCallback = callback;
  var outerScope = scope;
  this.$callbacks$ = {};
  this.$setCallback$(this, function(action, cmp) {
    var cb = nestedCallbacks[this.$getState$()];
    if(cb && cb["fn"]) {
      cb["fn"].call(cb["s"], action, cmp)
    }
    outerCallback.call(outerScope, this, cmp);
    this.$callbacks$ = nestedCallbacks
  })
};
Action.prototype.$run$ = function(evt) {
  this.$runDeprecated$(evt)
};
goog.$exportProperty$(Action.prototype, "run", Action.prototype.$run$);
Action.prototype.$runDeprecated$ = function(evt) {
  $A.assert(this.$def$ && this.$def$.$isClientAction$(), "run() cannot be called on a server action. Use $A.enqueueAction() instead.");
  if(this.$cmp$.$destroyed$ === 1) {
    return
  }
  this.state = "RUNNING";
  $A.$clientService$.$setCurrentAccess$(this.$cmp$);
  try {
    var secureCmp = $A.$lockerService$.$wrapComponent$(this.$cmp$);
    var secureEvt = $A.$lockerService$.$wrapComponentEvent$(secureCmp, evt);
    this.returnValue = this.$meth$.call(undefined, secureCmp, secureEvt, this.$cmp$["helper"]);
    this.state = "SUCCESS"
  }catch(e) {
    this.$markException$(e)
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
};
goog.$exportProperty$(Action.prototype, "runDeprecated", Action.prototype.$runDeprecated$);
Action.prototype.$getState$ = function() {
  return this.state
};
goog.$exportProperty$(Action.prototype, "getState", Action.prototype.$getState$);
Action.prototype.$getReturnValue$ = function() {
  if(this.$returnValueUserland$ !== undefined) {
    return this.$returnValueUserland$
  }
  if(this.$storable$ && this.$responseState$ === "SUCCESS") {
    if($A["util"].isArray(this.returnValue)) {
      this.$returnValueUserland$ = $A["util"].apply([], this.returnValue, true, true)
    }else {
      if($A["util"].$isObject$(this.returnValue)) {
        this.$returnValueUserland$ = $A["util"].apply({}, this.returnValue, true, true)
      }else {
        this.$returnValueUserland$ = this.returnValue
      }
    }
  }else {
    this.$returnValueUserland$ = this.returnValue
  }
  return this.$returnValueUserland$
};
goog.$exportProperty$(Action.prototype, "getReturnValue", Action.prototype.$getReturnValue$);
Action.prototype.getError = function() {
  return this.error
};
goog.$exportProperty$(Action.prototype, "getError", Action.prototype.getError);
Action.prototype.$isBackground$ = function() {
  return this.background === true
};
goog.$exportProperty$(Action.prototype, "isBackground", Action.prototype.$isBackground$);
Action.prototype.$setBackground$ = function() {
  this.background = true
};
goog.$exportProperty$(Action.prototype, "setBackground", Action.prototype.$setBackground$);
Action.prototype.$updateFromResponse$ = function(response) {
  this.state = response["state"];
  this.$responseState$ = response["state"];
  this.returnValue = response["returnValue"];
  this.$returnValueUserland$ = undefined;
  this.error = response["error"];
  this.$storage$ = response["storage"];
  this.$components$ = response["components"];
  if(response["defDependencies"]) {
    this.$defDependencies$ = response["defDependencies"]
  }
  if(this.state === "ERROR") {
    var i;
    var newErrors = [];
    var fired = false;
    for(i = 0;i < response["error"].length;i++) {
      var err = response["error"][i];
      if(err["exceptionEvent"]) {
        if(err["useDefault"]) {
          var error = err["event"]["attributes"]["values"]["error"];
          error.severity = $A.severity.$ALERT$;
          var evtArgs = {"message":error["message"], "error":null, "auraError":error};
          window.setTimeout(function fireNewSystemErrorEvent() {
            $A.$eventService$.$getNewEvent$("markup://aura:systemError").$fire$(evtArgs)
          }, 0);
          return false
        }
        var eventObj = err["event"];
        if(eventObj["descriptor"]) {
          var eventDescriptor = new DefDescriptor(eventObj["descriptor"]);
          var eventName = eventDescriptor.getName();
          var eventNamespace = eventDescriptor.$getNamespace$();
          if(eventNamespace === "aura") {
            if(eventName === "clientOutOfSync" || eventName === "invalidSession") {
              $A.$clientService$.$throwExceptionEvent$(err);
              return false
            }
            if(eventName === "serverActionError") {
              this.error = [eventObj["attributes"]["values"]["error"]];
              return true
            }
          }
        }
        fired = true;
        this.$events$.push(err["event"])
      }else {
        newErrors.push(err)
      }
    }
    if(fired === true && newErrors.length === 0) {
      newErrors.push({"message":"Event fired"})
    }
    this.error = newErrors
  }else {
    if(this.$originalResponse$ && this.state === "SUCCESS") {
      var originalValue = $A["util"].$json$.$orderedEncode$(this.$originalReturnValue$);
      var refreshedValue = $A["util"].$json$.$orderedEncode$(this.returnValue);
      if(refreshedValue === originalValue) {
        var originalComponents = $A["util"].$json$.$orderedEncode$(this.$originalResponse$["components"]);
        var refreshedComponents = $A["util"].$json$.$orderedEncode$(response["components"]);
        if(refreshedComponents === originalComponents) {
          $A.log("Action.updateFromResponse(): skipping duplicate response: " + this.$getStorageKey$() + ", " + this.$getId$());
          return false
        }
      }
    }
  }
  if(this.$originalResponse$ && this.state === "INCOMPLETE") {
    return false
  }
  return true
};
Action.prototype.$getStored$ = function() {
  if(this.$storable$ && this.$responseState$ === "SUCCESS") {
    return{"returnValue":this.returnValue, "components":this.$components$, "defDependencies":this.$defDependencies$, "state":"SUCCESS", "storage":{"created":(new Date).getTime(), "expiration":this.$storableConfig$ && this.$storableConfig$["expiration"] ? this.$storableConfig$["expiration"] : undefined}}
  }
  return null
};
Action.prototype.$prepareToSend$ = function() {
  var json = this.toJSON();
  if(this.$isPubliclyCacheable$()) {
    delete json.id
  }
  return json
};
Action.prototype.$finishAction$ = function(context) {
  $A.$clientService$.$notifyListeners$("PRE", "Action.finishAction", [this, context]);
  this.$finishActionInternal$.apply(this, arguments);
  $A.$clientService$.$notifyListeners$("POST", "Action.finishAction", undefined, [this, context])
};
Action.prototype.$finishActionInternal$ = function(context) {
  var previous = context.$setCurrentAction$(this);
  var clearComponents = false;
  var id = this.$getId$(context);
  var error = undefined;
  var oldDisplayFlag = $A.$showErrors$();
  $A.$clientService$.$setCurrentAccess$(this.$cmp$);
  try {
    if(this.$isFromStorage$()) {
      $A.$showErrors$(false)
    }
    try {
      if(this.$cmp$ === undefined || this.$cmp$.$destroyed$ !== 1) {
        if(this.$components$) {
          context.$joinComponentConfigs$(this.$components$, id);
          clearComponents = true
        }
        if(this.$events$.length > 0) {
          for(var x = 0;x < this.$events$.length;x++) {
            try {
              this.$parseAndFireEvent$(this.$events$[x])
            }catch(e$$0) {
              error = this.$processFinishActionException$(e$$0, "Events failed: ")
            }
          }
        }
        var cb = this.$callbacks$[this.$getState$()];
        try {
          if(cb) {
            if(this.$defDependencies$ && $A.getContext().$uriAddressableDefsEnabled$) {
              var that = this;
              clearComponents = false;
              var componentsToFinish = this.$components$;
              this.$components$ = undefined;
              var access = $A.$clientService$.$currentAccess$;
              $A.$componentService$.$loadComponentDefs$(this.$defDependencies$, function(err) {
                var previousAction = context.$setCurrentAction$(that);
                $A.$clientService$.$setCurrentAccess$(access);
                try {
                  if(componentsToFinish) {
                    that.$components$ = componentsToFinish
                  }
                  if(err) {
                    that.state = "ERROR";
                    that.message = err.message
                  }
                  cb["fn"].call(cb["s"], that, that.$cmp$)
                }catch(e) {
                  that.$processFinishActionException$(e, "Callback failed: ", err, true)
                }finally {
                  $A.$clientService$.$releaseCurrentAccess$();
                  if(componentsToFinish) {
                    context.$clearComponentConfigs$(id)
                  }
                  context.$setCurrentAction$(previousAction)
                }
                if(err) {
                  throw err;
                }
              })
            }else {
              cb["fn"].call(cb["s"], this, this.$cmp$)
            }
          }else {
            if(this.$defDependencies$) {
              $A.$componentService$.$loadComponentDefs$(this.$defDependencies$, function(err) {
                if(err) {
                  throw err;
                }
              })
            }
          }
        }catch(e$$1) {
          if(!error) {
            error = this.$processFinishActionException$(e$$1, "Callback failed: ")
          }
        }
        if(this.$components$ && (cb || !this.$storable$ || !$A.$clientService$.$getActionStorage$().$isStorageEnabled$())) {
          context.$clearComponentConfigs$(id);
          clearComponents = false
        }
      }else {
        this.abort()
      }
    }catch(e$$2) {
      if(!error) {
        error = this.$processFinishActionException$(e$$2, "Action failed: ")
      }
      clearComponents = true
    }
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
  context.$setCurrentAction$(previous);
  if(clearComponents) {
    context.$clearComponentConfigs$(id)
  }
  $A.$showErrors$(oldDisplayFlag);
  if(error) {
    if($A.$clientService$.$inAuraLoop$() || error instanceof $A.$auraFriendlyError$) {
      throw error;
    }else {
      throw new $A.$auraError$("Action.prototype.finishAction Error ", error);
    }
  }
};
Action.prototype.$processFinishActionException$ = function(e, message, err, raise) {
  var failedMessage = message + (this.$def$ ? this.$def$.toString() : "");
  if(err) {
    failedMessage += "\nAdditionally, Component Definition loader failure: " + JSON.stringify(err)
  }
  $A.$warning$(failedMessage, e);
  e.message = e.message ? e.message + "\n" + failedMessage : failedMessage;
  if(raise) {
    if($A.$clientService$.$inAuraLoop$() || e instanceof $A.$auraFriendlyError$) {
      throw e;
    }else {
      var auraErr = new $A.$auraError$("Action.prototype.finishAction Error ", e);
      if(auraErr.id !== "" && auraErr.id !== undefined && auraErr.id !== null) {
        auraErr.$setAdditionalStacktraceGen$(e.message)
      }
      throw auraErr;
    }
  }
  return e
};
Action.prototype.$abortIfComponentInvalid$ = function(beforeSend) {
  if((!beforeSend || this.$abortable$) && this.$cmp$ !== undefined && this.$cmp$.$destroyed$ === 1) {
    this.abort();
    return true
  }
  return false
};
Action.prototype.abort = function() {
  this.state = "ABORTED";
  var cb = this.$callbacks$[this.state];
  try {
    if(cb) {
      cb["fn"].call(cb["s"], this, this.$cmp$)
    }
  }catch(e) {
    if($A.$clientService$.$inAuraLoop$()) {
      throw e;
    }else {
      throw new $A.$auraError$("Failed during aborted callback", e);
    }
  }finally {
    $A.log("ABORTED: " + this.$getStorageKey$())
  }
};
Action.prototype.$setAbortable$ = function() {
  this.$abortable$ = true
};
goog.$exportProperty$(Action.prototype, "setAbortable", Action.prototype.$setAbortable$);
Action.prototype.$isRefreshAction$ = function() {
  return this.$originalResponse$ !== undefined
};
goog.$exportProperty$(Action.prototype, "isRefreshAction", Action.prototype.$isRefreshAction$);
Action.prototype.$isAbortable$ = function() {
  return this.$abortable$
};
goog.$exportProperty$(Action.prototype, "isAbortable", Action.prototype.$isAbortable$);
Action.prototype.$setStorable$ = function(config) {
  $A.assert(this.$def$ && this.$def$.$isServerAction$(), "setStorable() cannot be called on a client action.");
  var configCopy = config;
  if(config && config["expiration"]) {
    configCopy = Object.assign({}, config, {$expiration$:undefined})
  }
  this.$unstable_setStorablePrivileged$(configCopy)
};
goog.$exportProperty$(Action.prototype, "setStorable", Action.prototype.$setStorable$);
Action.prototype.$unstable_setStorablePrivileged$ = function(config) {
  $A.assert(this.$def$ && this.$def$.$isServerAction$(), "unstable_setStorablePrivileged() cannot be called on a client action.");
  this.$storable$ = true;
  this.$storableConfig$ = config;
  this.$abortable$ = true
};
Action.prototype.$isStorable$ = function() {
  var ignoreExisting = this.$storableConfig$ && this.$storableConfig$["ignoreExisting"];
  return this.$_isStorable$() && !ignoreExisting
};
goog.$exportProperty$(Action.prototype, "isStorable", Action.prototype.$isStorable$);
Action.prototype.$setCaboose$ = function() {
  this.$caboose$ = true
};
goog.$exportProperty$(Action.prototype, "setCaboose", Action.prototype.$setCaboose$);
Action.prototype.$isCaboose$ = function() {
  return this.$caboose$
};
goog.$exportProperty$(Action.prototype, "isCaboose", Action.prototype.$isCaboose$);
Action.prototype.$_isStorable$ = function() {
  return this.$storable$ || false
};
Action.prototype.$getStorageKey$ = function() {
  return Action.$getStorageKey$(this.$def$ ? this.$def$.$getDescriptor$().toString() : "", this.$params$)
};
goog.$exportProperty$(Action.prototype, "getStorageKey", Action.prototype.$getStorageKey$);
Action.prototype.$isFromStorage$ = function() {
  return!$A["util"].$isUndefinedOrNull$(this.$storage$)
};
goog.$exportProperty$(Action.prototype, "isFromStorage", Action.prototype.$isFromStorage$);
Action.prototype.$setChained$ = function() {
  this.$chained$ = true;
  $A.$enqueueAction$(this)
};
goog.$exportProperty$(Action.prototype, "setChained", Action.prototype.$setChained$);
Action.prototype.$isChained$ = function() {
  return this.$chained$ || false
};
Action.prototype.$getRetryCount$ = function() {
  return this.$retryCount$
};
Action.prototype.$incrementRetryCount$ = function() {
  this.$retryCount$++
};
Action.prototype.toJSON = function() {
  var callingComponentDef = this.$callingCmp$ ? this.$callingCmp$.$getDef$ ? this.$callingCmp$.$getDef$() : this.$callingCmp$ : null;
  var requiredVersionDefs = callingComponentDef ? callingComponentDef.$getRequiredVersionDefs$() : null;
  var version = this.$cmp$ ? this.$cmp$.$getVersion$() : null;
  var isVersioned = requiredVersionDefs && requiredVersionDefs.$values$ || version;
  var json = {"id":this.$getId$(), "descriptor":this.$def$ ? this.$def$.$getDescriptor$() : "UNKNOWN", "callingDescriptor":isVersioned ? callingComponentDef ? callingComponentDef.$getDescriptor$().$getQualifiedName$() : "UNKNOWN" : "UNKNOWN", "params":this.$params$};
  if(isVersioned) {
    json["version"] = version
  }
  if(this.$storable$) {
    json["storable"] = this.$storable$
  }
  if(this.$longRunning$) {
    json["longRunning"] = this.$longRunning$
  }
  if(this.$namespaceAccessible$) {
    json["namespaceAccessible"] = this.$namespaceAccessible$
  }
  return json
};
goog.$exportProperty$(Action.prototype, "toJSON", Action.prototype.toJSON);
Action.prototype.$markException$ = function(e) {
  var descriptor = this.$def$ ? this.$def$.toString() : "";
  if(e instanceof $A.$auraError$ || e instanceof $A.$auraFriendlyError$) {
    e.$setComponent$(e["component"] || descriptor)
  }
  if(!e.id) {
    e = new $A.$auraError$(descriptor ? "Action failed: " + descriptor : "", e);
    e.$setComponent$(descriptor)
  }
  if(!e["componentStack"]) {
    e["componentStack"] = $A["util"].$getComponentHierarchy$(this.$cmp$)
  }
  this.state = "ERROR";
  this.error = e;
  if($A.$clientService$.$inAuraLoop$()) {
    $A.$lastKnownError$ = e;
    throw e;
  }
};
Action.prototype.$markError$ = function(context, e) {
  this.state = "ERROR";
  this.error = e;
  this.$finishAction$(context)
};
Action.prototype.$incomplete$ = function(context) {
  this.state = "INCOMPLETE";
  if(!this.error || !(this.error instanceof Array)) {
    this.error = [{message:"Disconnected or Canceled"}]
  }
  if(!this.$isRefreshAction$()) {
    this.$finishAction$(context)
  }
};
Action.prototype.$copyToRefresh$ = function() {
  var refreshAction = this.$def$.$newInstance$(this.$cmp$);
  refreshAction.$setParams$(this.$params$);
  refreshAction.$setStorable$({"ignoreExisting":true});
  refreshAction.background = this.background;
  refreshAction.$abortable$ = this.$abortable$;
  this.$refreshAction$ = refreshAction;
  return refreshAction
};
Action.prototype.$getRefreshAction$ = function(originalResponse) {
  var storage = originalResponse["storage"];
  var actionStorage = $A.$clientService$.$getActionStorage$().$getStorage$();
  var autoRefreshInterval = this.$storableConfig$ && !$A["util"].$isUndefined$(this.$storableConfig$["refresh"]) && $A["util"].$isNumber$(this.$storableConfig$["refresh"]) ? this.$storableConfig$["refresh"] * 1E3 : actionStorage.$getDefaultAutoRefreshInterval$();
  var now = (new Date).getTime();
  if(now - storage["created"] >= autoRefreshInterval && this.$def$) {
    var refreshAction = this.$copyToRefresh$();
    $A.log("Action.refresh(): auto refresh begin: " + this.$getId$() + " to " + refreshAction.$getId$());
    refreshAction.$originalResponse$ = originalResponse;
    refreshAction.$originalReturnValue$ = this.returnValue;
    var executeCallbackIfUpdated = this.$storableConfig$ && !$A["util"].$isUndefined$(this.$storableConfig$["executeCallbackIfUpdated"]) ? this.$storableConfig$["executeCallbackIfUpdated"] : true;
    if(executeCallbackIfUpdated !== false) {
      refreshAction.$callbacks$ = this.$callbacks$
    }
    return refreshAction
  }
  return null
};
Action.prototype.$getRetryFromStorageAction$ = function() {
  if(this.$isFromStorage$()) {
    var retryAction = this.$copyToRefresh$();
    retryAction.$callbacks$ = this.$callbacks$;
    return retryAction
  }
  return null
};
Action.prototype.$getStorage$ = function() {
  return $A.$clientService$.$getActionStorage$().$getStorage$()
};
goog.$exportProperty$(Action.prototype, "getStorage", Action.prototype.$getStorage$);
Action.prototype.$parseAndFireEvent$ = function(evtObj) {
  var descriptor = evtObj["descriptor"];
  var evt = null;
  var comp = this.$getComponent$();
  if(comp) {
    evt = comp.$getEventByDescriptor$(descriptor)
  }
  if(evt !== null) {
    if(evtObj["attributes"]) {
      evt.$setParams$(evtObj["attributes"]["values"])
    }
    evt.$fire$()
  }else {
    $A.$clientService$.$parseAndFireEvent$(evtObj)
  }
};
Action.prototype.$fireRefreshEvent$ = function(event, responseUpdated) {
  if(this.$cmp$ && this.$cmp$.$isValid$()) {
    var isRefreshObserver = this.$cmp$.$isInstanceOf$("auraStorage:refreshObserver");
    if(isRefreshObserver) {
      this.$cmp$.$getEvent$(event).$setParams$({"action":this, "responseUpdated":responseUpdated}).$fire$()
    }
  }
};
Action.prototype.$isPubliclyCacheable$ = function() {
  return $A.getContext().$isActionPublicCachingEnabled$() && this.$def$.$isPublicCachingEnabled$() && this.$def$.$getPublicCachingExpiration$() > 0
};
Aura.$Controller$.$Action$ = Action;
function ActionStorage() {
  this.$actionKeysFilter$ = undefined;
  this.$actionsFilterEnabled$ = true;
  this.$actionsFilterInited$ = false;
  this.$actionsFilterPopulated$ = false
}
ActionStorage.prototype.$STORAGE_NAME$ = "actions";
ActionStorage.prototype.$URI_DEFS_ENABLED_KEY$ = "_uri_defs_enabled";
ActionStorage.prototype.$enableActionsFilter$ = function(enable) {
  this.$actionsFilterEnabled$ = !!enable
};
ActionStorage.prototype.$setupActionsFilter$ = function() {
  if(this.$actionKeysFilter$ !== undefined) {
    return this.$actionsFilterInited$
  }
  if(!this.$actionsFilterEnabled$) {
    this.$actionKeysFilter$ = null;
    this.$actionsFilterInited$ = false
  }else {
    this.$actionKeysFilter$ = {};
    this.$actionsFilterInited$ = true;
    this.$populateActionsFilter$()
  }
  return this.$actionsFilterInited$
};
ActionStorage.prototype.$populateActionsFilter$ = function() {
  if(this.$actionsFilterPopulated$) {
    return Promise["resolve"]()
  }
  this.$actionsFilterPopulated$ = true;
  if(!this.$isStoragePersistent$() || !this.$setupActionsFilter$()) {
    return Promise["resolve"]()
  }
  var that = this;
  return this.$getAll$()["then"](function processActions(items) {
    var actionsStoredWithURIDefs = items[that.$URI_DEFS_ENABLED_KEY$];
    var uriEnabled = $A.getContext().$uriAddressableDefsEnabled$;
    var allowedStorage_size = actionsStoredWithURIDefs === undefined ? 0 : 1;
    if(uriEnabled !== !!actionsStoredWithURIDefs && Object.keys(items).length > allowedStorage_size) {
      $A.$warning$("Clearing actions db because uri addressable defs state was toggled");
      return that.clear()["then"](function setUriDefsEnabled() {
        return that.set(that.$URI_DEFS_ENABLED_KEY$, uriEnabled)["then"](function getEmptyArray() {
          return[]
        })
      })
    }else {
      if(actionsStoredWithURIDefs === undefined) {
        that.set(that.$URI_DEFS_ENABLED_KEY$, uriEnabled)
      }
    }
    return items
  })
};
ActionStorage.prototype.$clearActionsFilter$ = function() {
  this.$actionKeysFilter$ = undefined;
  this.$setupActionsFilter$()
};
ActionStorage.prototype.$isActionsFilterEnabled$ = function() {
  return this.$actionsFilterEnabled$
};
ActionStorage.prototype.$isActionsFilterInitialized$ = function() {
  return this.$actionsFilterInited$
};
ActionStorage.prototype.$isKeyAbsentFromCache$ = function(key) {
  if(!this.$isStorageEnabled$()) {
    return true
  }
  if(!this.$actionsFilterEnabled$ || !this.$actionKeysFilter$) {
    return false
  }
  return!this.$actionKeysFilter$[key]
};
ActionStorage.prototype.$getStorage$ = function() {
  return $A.$storageService$.$getStorage$(this.$STORAGE_NAME$)
};
ActionStorage.prototype.$isStoragePersistent$ = function() {
  var storage = this.$getStorage$();
  return!!storage && storage.$isPersistent$()
};
ActionStorage.prototype.$isStorageEnabled$ = function() {
  return!!this.$getStorage$()
};
ActionStorage.prototype.$setAll$ = function(values) {
  var key;
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]()
  }
  if(!this.$setupActionsFilter$()) {
    return storage.$setAll$(values)
  }
  for(key in values) {
    this.$actionKeysFilter$[key] = true
  }
  var that = this;
  return storage.$unstable_setAllPrivileged$(values)["then"](undefined, function storageSetAllError(e) {
    for(key in values) {
      that.$actionKeysFilter$[key] = undefined
    }
    throw e;
  })
};
ActionStorage.prototype.set = function(actionKey, value) {
  var values = {};
  values[actionKey] = value;
  return this.$setAll$(values)
};
ActionStorage.prototype.$getAll$ = function(actionKeys) {
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]({})
  }
  if(!this.$setupActionsFilter$()) {
    return storage.$getAll$(actionKeys, true)
  }
  var that = this;
  var key;
  return storage.$getAll$(actionKeys, true)["then"](function processItems(items) {
    if(Array.isArray(actionKeys) && actionKeys.length > 0) {
      for(var i = 0;i < actionKeys.length;i++) {
        key = actionKeys[i];
        if(!items[key] && that.$actionKeysFilter$[key]) {
          delete that.$actionKeysFilter$[key]
        }
      }
    }
    for(key in items) {
      that.$actionKeysFilter$[key] = true
    }
    return items
  })
};
ActionStorage.prototype.get = function(actionKey) {
  return this.$getAll$([actionKey])["then"](function getAction(items) {
    return items ? items[actionKey] : undefined
  })
};
ActionStorage.prototype.$removeAll$ = function(actionKeys, doNotFireModified) {
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]()
  }
  if(!this.$setupActionsFilter$()) {
    return storage.$removeAll$(actionKeys, doNotFireModified)
  }
  var key;
  for(var i = 0;i < actionKeys.length;i++) {
    key = actionKeys[i];
    if(this.$actionKeysFilter$[key]) {
      delete this.$actionKeysFilter$[key]
    }
  }
  return storage.$removeAll$(actionKeys, doNotFireModified)
};
ActionStorage.prototype.remove = function(actionKey, doNotFireModified) {
  return this.$removeAll$([actionKey], doNotFireModified)
};
ActionStorage.prototype.clear = function() {
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]()
  }
  if(this.$actionsFilterEnabled$) {
    this.$clearActionsFilter$()
  }
  return storage.clear()
};
Aura.$Controller$.$ActionStorage$ = ActionStorage;
function ControllerDef(config) {
  this.$descriptor$ = config[Json.$ApplicationKey$.$DESCRIPTOR$];
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$];
  this.$actionDefs$ = {};
  var actionDefs = config[Json.$ApplicationKey$.$ACTIONDEFS$];
  for(var i = 0;i < actionDefs.length;i++) {
    var actionDefConfig = actionDefs[i];
    var actionDef = $A.$componentService$.$createActionDef$(actionDefConfig);
    this.$actionDefs$[actionDef.getName()] = actionDef
  }
}
goog.$exportSymbol$("ControllerDef", ControllerDef);
ControllerDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
ControllerDef.prototype.$hasActionDef$ = function(key) {
  return this.$actionDefs$.hasOwnProperty(key)
};
ControllerDef.prototype.$getActionDef$ = function(key) {
  var action = this.$actionDefs$[key];
  return action
};
ControllerDef.prototype.get = function(key) {
  if(this.$access$ === "I") {
    var currentAccess = $A.$clientService$.$currentAccess$;
    if(currentAccess) {
      var namespace = currentAccess.$getDef$().$getDescriptor$().$getNamespace$();
      if(!$A.$clientService$.$isInternalNamespace$(namespace)) {
        if($A.$clientService$.$logAccessFailures$) {
          throw new Error(currentAccess.type + " cannot execute " + this.$descriptor$);
        }
        return null
      }
    }
  }
  return this.$getActionDef$(key).$newInstance$()
};
Aura.$Controller$.$ControllerDef$ = ControllerDef;
function AttributeDef(config) {
  this.$descriptor$ = new DefDescriptor(config[0]);
  this.$typeDefDescriptor$ = config[1];
  this.$access$ = config[2];
  this.required = config[3] === true;
  this.defaultValue = config[4]
}
goog.$exportSymbol$("AttributeDef", AttributeDef);
AttributeDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(AttributeDef.prototype, "getDescriptor", AttributeDef.prototype.$getDescriptor$);
AttributeDef.prototype.$isRequired$ = function() {
  return this.required === true
};
goog.$exportProperty$(AttributeDef.prototype, "isRequired", AttributeDef.prototype.$isRequired$);
AttributeDef.prototype.$getDefault$ = function() {
  return $A["util"].copy(this.defaultValue)
};
goog.$exportProperty$(AttributeDef.prototype, "getDefault", AttributeDef.prototype.$getDefault$);
AttributeDef.prototype.$getTypeDefDescriptor$ = function() {
  return this.$typeDefDescriptor$
};
goog.$exportProperty$(AttributeDef.prototype, "getTypeDefDescriptor", AttributeDef.prototype.$getTypeDefDescriptor$);
AttributeDef.prototype.$getNativeType$ = function() {
  $A.assert(this.$typeDefDescriptor$, "getNativeType() failed as there was no typeDefDescriptor for attribute " + this.$getDescriptor$() + ". Eacha attribute must have a definition before being set.");
  if(this.$typeDefDescriptor$.lastIndexOf("[]") === this.$typeDefDescriptor$.length - 2) {
    return"array"
  }
  switch(this.$typeDefDescriptor$) {
    case "aura://List":
      return"array";
    case "aura://Boolean":
      return"boolean";
    case "aura://String":
      return"string";
    case "aura://Decimal":
      return"number";
    case "aura://Number":
      return"number";
    case "aura://Integer":
      return"number"
  }
  return"object"
};
goog.$exportProperty$(AttributeDef.prototype, "getNativeType", AttributeDef.prototype.$getNativeType$);
Aura.$Attribute$.$AttributeDef$ = AttributeDef;
function AttributeSet(attributeDefSet) {
  this.$values$ = {};
  this.$shadowValues$ = {};
  this.$decorators$ = {};
  this.$attributeDefSet$ = attributeDefSet;
  this.$destroyed$ = false
}
AttributeSet.prototype.hasAttribute = function(name) {
  return this.$values$.hasOwnProperty(name)
};
AttributeSet.$getDef$ = function(key, component) {
  var def = [];
  for(var target = component.$getConcreteComponent$ ? component.$getConcreteComponent$() : component;target;) {
    var tempDef = target.$getDef$ ? target.$getDef$().$getAttributeDefs$().$getDef$(key) : target.$getAttributeDefs$().$getDef$(key);
    if(!tempDef) {
      break
    }
    def[0] = tempDef;
    def[1] = target;
    target = target.$getSuper$ ? target.$getSuper$() : target.$getSuperDef$()
  }
  return def
};
AttributeSet.prototype.get = function(key, component) {
  var value = undefined;
  var path = null;
  var attribute = key;
  if(key.lastIndexOf("body", 0) === 0) {
    key = key.replace(/^body\b/g, "body." + component.$globalId$)
  }
  if(key.indexOf(".") > -1) {
    path = key.split(".");
    attribute = path[0]
  }
  var defs = AttributeSet.$getDef$(attribute, component);
  if(!$A.$clientService$.$allowAccess$(defs[0], defs[1])) {
    var message = "Access Check Failed! AttributeSet.get(): attribute '" + attribute + "' of component '" + component + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return undefined
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  if(!path) {
    var decorators = this.$decorators$[key];
    if(decorators && decorators.length) {
      if(decorators.$decorating$) {
        value = decorators.value
      }else {
        decorators.$decorating$ = true;
        decorators.value = this.$values$[key];
        for(var i = 0;i < decorators.length;i++) {
          var decorator = decorators[i];
          value = decorator.value = decorators[i].evaluate()
        }
        decorators.$decorating$ = false;
        decorators.value = null
      }
    }else {
      value = this.$values$[key]
    }
  }else {
    value = aura.$expressionService$.$resolve$(key, this.$values$)
  }
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  if(this.$shadowValues$.hasOwnProperty(key)) {
    value += this.$getShadowValue$(key)
  }
  return value
};
AttributeSet.prototype.$getBody$ = function(globalId) {
  var key = "body." + globalId;
  var value = this.$values$["body"][globalId];
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  if(this.$shadowValues$.hasOwnProperty(key)) {
    value += this.$getShadowValue$(key)
  }
  return value
};
AttributeSet.prototype.$getValue$ = function(key) {
  var value = undefined;
  var decorators = this.$decorators$[key];
  if(decorators && decorators.length) {
    if(decorators.$decorating$) {
      value = decorators.value
    }else {
      decorators.$decorating$ = true;
      decorators.value = this.$values$[key];
      for(var i = 0;i < decorators.length;i++) {
        var decorator = decorators[i];
        value = decorator.value = decorators[i].evaluate()
      }
      decorators.$decorating$ = false;
      decorators.value = null
    }
  }else {
    value = this.$values$[key]
  }
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  if(this.$shadowValues$.hasOwnProperty(key)) {
    value += this.$getShadowValue$(key)
  }
  return value
};
AttributeSet.prototype.$getShadowValue$ = function(key) {
  var value = aura.$expressionService$.$resolve$(key, this.$values$, true);
  if(value instanceof FunctionCallValue) {
    if(this.$shadowValues$.hasOwnProperty(key)) {
      return this.$shadowValues$[key]
    }
    return""
  }
  return undefined
};
AttributeSet.prototype.$setShadowValue$ = function(key, value) {
  var oldValue = aura.$expressionService$.$resolve$(key, this.$values$, true);
  if(oldValue instanceof FunctionCallValue) {
    this.$shadowValues$[key] = value
  }
};
AttributeSet.prototype.set = function(key, value, component) {
  var target = this.$values$;
  var path = null;
  var attribute = key;
  if(key.lastIndexOf("body", 0) === 0) {
    key = key.replace(/^body\b/g, "body." + component.$globalId$)
  }
  if(key.indexOf(".") > -1) {
    path = key.split(".");
    attribute = path[0]
  }
  var defs = AttributeSet.$getDef$(attribute, component);
  if(!$A.$clientService$.$allowAccess$(defs[0], defs[1])) {
    var message = "Access Check Failed! AttributeSet.set(): '" + attribute + "' of component '" + component + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  if(!$A["util"].$isUndefinedOrNull$(value) && !this.$isValueValidForAttribute$(key, value)) {
    if(this.$isTypeOfArray$(key)) {
      value = !$A["util"].isArray(value) ? [value] : value
    }else {
    }
  }
  if(path) {
    for(var step = path.shift();path.length > 0;) {
      var nextStep = path.shift();
      var nextTarget = target[step];
      if(nextTarget === undefined) {
        if(isNaN(nextStep)) {
          target[step] = {}
        }else {
          target[step] = []
        }
        target = target[step]
      }else {
        if($A["util"].$isExpression$(nextTarget)) {
          target = nextTarget.evaluate()
        }else {
          target = nextTarget
        }
      }
      step = nextStep
    }
    key = step
  }
  var attrType = defs[0] && defs[0].$getTypeDefDescriptor$();
  var isFacet = attrType === "aura://Aura.Component[]";
  if(isFacet && value) {
    var facet = value;
    if(!$A["util"].isArray(facet)) {
      facet = [facet]
    }
    var facetValue = null;
    for(var i = 0;i < facet.length;i++) {
      facetValue = facet[i];
      if(facetValue) {
        for(;facetValue instanceof PassthroughValue;) {
          facetValue = facetValue.$getComponent$()
        }
        if(facetValue.$setContainerComponentId$ && facetValue.$isRendered$() === false) {
          facetValue.$setContainerComponentId$(component.$globalId$)
        }
      }
    }
  }
  if(target[key] instanceof PropertyReferenceValue && !target[key].$isGlobal$) {
    target[key].set(value)
  }else {
    if(!(target[key] instanceof FunctionCallValue)) {
      target[key] = value
    }else {
      $A.$warning$("AttributeSet.set(): unable to override the value for '" + key + "\x3d" + target[key] + "'. FunctionCallValues declared in markup are constant.")
    }
  }
};
AttributeSet.prototype.$clearReference$ = function(key) {
  var oldValue;
  var target = this.$values$;
  var step = key;
  if(key.indexOf(".") >= 0) {
    var path = key.split(".");
    target = aura.$expressionService$.$resolve$(path.slice(0, path.length - 1), target);
    step = path[path.length - 1]
  }
  if(target) {
    oldValue = target[step];
    if(oldValue instanceof PropertyReferenceValue) {
      target[step] = undefined;
      return oldValue
    }
  }
  return null
};
AttributeSet.prototype.$isValueValidForAttribute$ = function(attributeName, value) {
  var attributeDefSet = this.$attributeDefSet$;
  if(attributeName.indexOf(".") >= 0) {
    var path = attributeName.split(".");
    attributeName = path[0];
    if(attributeName !== "body" && path.length > 1) {
      return true
    }
  }
  var attributeDef = attributeDefSet.$getDef$(attributeName);
  if(!attributeDef) {
    return false
  }
  var nativeType = attributeDef.$getNativeType$();
  if($A["util"].$isExpression$(value) || nativeType === "object") {
    return true
  }
  if(nativeType === "array") {
    return $A["util"].isArray(value)
  }
  return typeof value === nativeType
};
AttributeSet.prototype.$isTypeOfArray$ = function(attributeName) {
  if(attributeName.indexOf(".") >= 0) {
    var path = attributeName.split(".");
    attributeName = path[0];
    if(attributeName !== "body" && path.length > 1) {
      return false
    }
  }
  var attributeDef = this.$attributeDefSet$.$getDef$(attributeName);
  return attributeDef && attributeDef.$getNativeType$() === "array"
};
AttributeSet.prototype.$merge$ = function(attributes, attributeDefSet, component) {
  if(attributeDefSet) {
    $A.assert(attributeDefSet instanceof AttributeDefSet, "AttributeSet.merge: A valid AttributeDefSet is required to merge attributes.");
    this.$attributeDefSet$ = attributeDefSet
  }
  this.$initialize$(attributes, component)
};
AttributeSet.prototype.$getDefault$ = function(name) {
  if(name) {
    var attributeDef = this.$attributeDefSet$.$getDef$(name);
    if(attributeDef) {
      return attributeDef.$getDefault$()
    }
  }
  return null
};
AttributeSet.prototype.$destroy$ = function() {
  var expressions = {};
  if(!this.$destroyed$) {
    var values = this.$values$;
    for(var k in values) {
      var v = values[k];
      if(k === "body") {
        for(var globalId in v) {
          var body = v[globalId];
          if(body) {
            for(var j = 0;j < body.length;j++) {
              var bodyCmp = body[j];
              if($A["util"].$isComponent$(bodyCmp) && bodyCmp.$autoDestroy$()) {
                bodyCmp.$destroy$()
              }
            }
          }
        }
        values[k] = undefined;
        continue
      }
      if($A["util"].isArray(v)) {
        var i = 0;
        for(var value;i < v.length;i++) {
          value = v[i];
          if($A["util"].$isExpression$(value)) {
            expressions[k] = value
          }else {
            if($A["util"].$isComponent$(value) && value.$autoDestroy$()) {
              value.$destroy$()
            }
          }
        }
      }else {
        if($A["util"].$isExpression$(v)) {
          expressions[k] = v
        }else {
          if($A["util"].$isComponent$(v) && v.$autoDestroy$()) {
            v.$destroy$()
          }
        }
      }
      values[k] = undefined
    }
    this.$destroyed$ = true
  }
  return expressions
};
AttributeSet.prototype.$initialize$ = function(attributes, component) {
  var attributeDefs = this.$attributeDefSet$.$getValues$();
  var attributeNames = this.$attributeDefSet$.$getNames$();
  if(!attributeDefs || !attributeNames) {
    return
  }
  var configValues = attributes || {};
  for(var i = 0;i < attributeNames.length;i++) {
    var attributeDef = attributeDefs[attributeNames[i]];
    var name = attributeDef.$getDescriptor$().getName();
    var hasAttribute = this.hasAttribute(name);
    var hasValue = configValues.hasOwnProperty(name);
    var value = configValues[name];
    if(!hasValue && !hasAttribute) {
      value = valueFactory.create(this.$getDefault$(name), component);
      hasValue = value !== undefined
    }
    if(hasValue && this.$values$[name] !== value || !hasAttribute) {
      if(hasAttribute && value instanceof FunctionCallValue) {
        if(!this.$decorators$[name]) {
          this.$decorators$[name] = []
        }
        this.$decorators$[name].push(value)
      }else {
        if(!(value instanceof PropertyReferenceValue && value.$equals$(this.$values$[name]))) {
          this.$values$[name] = value
        }
      }
    }
  }
};
Aura.$Attribute$.$AttributeSet$ = AttributeSet;
function AttributeDefSet(configs, defaultNamespace) {
  this.$values$ = {};
  this.$valuesOrder$ = [];
  if(configs) {
    for(var i = 0;i < configs.length;i++) {
      var attributeDef = new AttributeDef(configs[i], defaultNamespace);
      var descriptor = attributeDef.$getDescriptor$();
      if(!descriptor.$namespace$) {
        descriptor.$namespace$ = defaultNamespace
      }
      var name = descriptor.getName();
      this.$values$[name] = attributeDef;
      this.$valuesOrder$.push(name)
    }
  }
}
goog.$exportSymbol$("AttributeDefSet", AttributeDefSet);
AttributeDefSet.prototype.$each$ = function(f) {
  var values = this.$values$;
  var valuesOrder = this.$valuesOrder$;
  if(values) {
    for(var i = 0;i < valuesOrder.length;i++) {
      f(values[valuesOrder[i]], i)
    }
  }
};
goog.$exportProperty$(AttributeDefSet.prototype, "each", AttributeDefSet.prototype.$each$);
AttributeDefSet.prototype.hasAttribute = function(name) {
  return this.$values$.hasOwnProperty(name)
};
AttributeDefSet.prototype.$getDef$ = function(name) {
  return this.$values$ && this.$values$[name.split(".")[0]] || null
};
goog.$exportProperty$(AttributeDefSet.prototype, "getDef", AttributeDefSet.prototype.$getDef$);
AttributeDefSet.prototype.$getNames$ = function() {
  return this.$valuesOrder$
};
goog.$exportProperty$(AttributeDefSet.prototype, "getNames", AttributeDefSet.prototype.$getNames$);
AttributeDefSet.prototype.$getValues$ = function() {
  return this.$values$
};
goog.$exportProperty$(AttributeDefSet.prototype, "getValues", AttributeDefSet.prototype.$getValues$);
Aura.$Attribute$.$AttributeDefSet$ = AttributeDefSet;
Aura.$Method$.$MethodDef$ = function(config) {
  this.$descriptor$ = new DefDescriptor(config["name"]);
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$];
  this.action = config["action"];
  this.attributes = new AttributeDefSet(config["attributes"], this.$descriptor$.$getNamespace$())
};
goog.$exportSymbol$("Aura.Method.MethodDef", Aura.$Method$.$MethodDef$);
Aura.$Method$.$MethodDef$.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(Aura.$Method$.$MethodDef$.prototype, "getDescriptor", Aura.$Method$.$MethodDef$.prototype.$getDescriptor$);
function RequiredVersionDef(config) {
  this.$descriptor$ = new DefDescriptor(config["namespace"]);
  this.$namespace$ = config["namespace"];
  this.version = config["version"]
}
RequiredVersionDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
RequiredVersionDef.prototype.$getNamespace$ = function() {
  return $A["util"].copy(this.$namespace$)
};
RequiredVersionDef.prototype.$getVersion$ = function() {
  return $A["util"].copy(this.version)
};
function RequiredVersionDefSet(configs) {
  if(configs) {
    this.$values$ = {};
    for(var i = 0;i < configs.length;i++) {
      var requiredVersionDef = new RequiredVersionDef(configs[i]);
      var ns = requiredVersionDef.$getDescriptor$().getName();
      this.$values$[ns] = requiredVersionDef
    }
  }
}
RequiredVersionDefSet.prototype.$getDef$ = function(name) {
  var values = this.$values$;
  if(values) {
    return values[name]
  }
  return null
};
function AuraStorageService() {
  this.$storages$ = {};
  this.$adapters$ = {};
  this.version = "";
  this.$isolationKey$ = "";
  this.$partitionName$ = ""
}
goog.$exportSymbol$("AuraStorageService", AuraStorageService);
AuraStorageService.prototype.$getStorage$ = function(name) {
  $A.assert($A["util"].$isString$(name), "AuraStorageService.getStorage(): 'name' must be a String.");
  return this.$storages$[name]
};
goog.$exportProperty$(AuraStorageService.prototype, "getStorage", AuraStorageService.prototype.$getStorage$);
AuraStorageService.prototype.$getStorages$ = function() {
  return $A["util"].apply({}, this.$storages$)
};
goog.$exportProperty$(AuraStorageService.prototype, "getStorages", AuraStorageService.prototype.$getStorages$);
AuraStorageService.prototype.$initStorage$ = function(config) {
  $A.assert($A["util"].$isObject$(config), "config must be an object");
  $A.assert($A["util"].$isString$(config["name"]) && config["name"], "name must be a non-empty string");
  $A.assert(!this.$storages$[config["name"]], "Storage named '" + config["name"] + "' already exists");
  var expiration = 10;
  var MAX_EXPIRATOIN = Number.MAX_VALUE / 1E3;
  if($A["util"].$isFiniteNumber$(config["expiration"]) && config["expiration"] > 0) {
    expiration = config["expiration"];
    if(expiration > MAX_EXPIRATOIN) {
      expiration = MAX_EXPIRATOIN
    }
  }
  var validatedConfig = {"name":config["name"], "persistent":!!config["persistent"], "secure":!!config["secure"], "maxSize":$A["util"].$isFiniteNumber$(config["maxSize"]) && config["maxSize"] > 0 ? config["maxSize"] : 1E3 * 1024, "expiration":expiration, "debugLogging":!!config["debugLogging"], "clearOnInit":$A["util"].$isBoolean$(config["clearOnInit"]) ? config["clearOnInit"] : true, "version":config["version"] ? "" + config["version"] : this.version, "isolationKey":this.$isolationKey$, "autoRefreshInterval":$A["util"].$isFiniteNumber$(config["autoRefreshInterval"]) && 
  config["autoRefreshInterval"] >= 0 ? config["autoRefreshInterval"] : 30, "partitionName":this.$partitionName$};
  var adapterName = this.$selectAdapter$(validatedConfig["persistent"], validatedConfig["secure"]);
  validatedConfig["adapterClass"] = this.$adapters$[adapterName]["adapterClass"];
  var storage = new AuraStorage(validatedConfig);
  this.$storages$[validatedConfig["name"]] = storage;
  return storage
};
goog.$exportProperty$(AuraStorageService.prototype, "initStorage", AuraStorageService.prototype.$initStorage$);
AuraStorageService.prototype.$registerAdapter$ = function(config) {
  $A.assert($A["util"].$isString$(config["name"]) && config["name"], "config.name must be a non-empty string");
  $A.assert($A["util"].$isFunction$(config["adapterClass"]), "config.adapterClass must be a function");
  $A.assert(!this.$adapters$[config["name"]], "Adapter '" + config["name"] + "' already registered");
  var validatedConfig = {"name":config["name"], "adapterClass":config["adapterClass"], "persistent":!!config["persistent"], "secure":!!config["secure"]};
  this.$adapters$[validatedConfig["name"]] = validatedConfig
};
goog.$exportProperty$(AuraStorageService.prototype, "registerAdapter", AuraStorageService.prototype.$registerAdapter$);
AuraStorageService.prototype.$isRegisteredAdapter$ = function(name) {
  $A.assert($A["util"].$isString$(name), "AuraStorageService.isRegisteredAdapter(): 'name' must be a String.");
  return this.$adapters$[name] !== undefined
};
goog.$exportProperty$(AuraStorageService.prototype, "isRegisteredAdapter", AuraStorageService.prototype.$isRegisteredAdapter$);
AuraStorageService.prototype.$getAdapterConfig$ = function(adapter) {
  return this.$adapters$[adapter]
};
goog.$exportProperty$(AuraStorageService.prototype, "getAdapterConfig", AuraStorageService.prototype.$getAdapterConfig$);
AuraStorageService.prototype.$selectAdapter$ = function(persistent, secure) {
  var candidates = [];
  for(var name in this.$adapters$) {
    var adapter = this.$adapters$[name];
    if(!secure || adapter["secure"] === true) {
      candidates.push(adapter)
    }
  }
  if(candidates.length === 0) {
    $A.assert(this.$adapters$[Aura.$Storage$.$MemoryAdapter$["NAME"]], "Memory Aura Storage Adapter was not registered");
    return Aura.$Storage$.$MemoryAdapter$["NAME"]
  }
  var match;
  for(var n = 0;!match && n < candidates.length;n++) {
    var candidate = candidates[n];
    var candidateIsPersistent = candidate["persistent"];
    if(persistent && candidateIsPersistent === true || !persistent && !candidateIsPersistent) {
      match = candidate
    }
  }
  if(!match) {
    match = candidates[0]
  }
  return match["name"]
};
AuraStorageService.prototype.$deleteStorage$ = function(name) {
  $A.assert($A["util"].$isString$(name), "AuraStorageService.deleteStorage(): 'name' must be a String.");
  var storage = this.$getStorage$(name);
  if(!storage) {
    return Promise["resolve"]()
  }
  delete this.$storages$[name];
  return storage.$deleteStorage$()
};
goog.$exportProperty$(AuraStorageService.prototype, "deleteStorage", AuraStorageService.prototype.$deleteStorage$);
AuraStorageService.prototype.setVersion = function(version) {
  this.version = (version || "") + ""
};
goog.$exportProperty$(AuraStorageService.prototype, "setVersion", AuraStorageService.prototype.setVersion);
AuraStorageService.prototype.$getVersion$ = function() {
  return this.version
};
goog.$exportProperty$(AuraStorageService.prototype, "getVersion", AuraStorageService.prototype.$getVersion$);
AuraStorageService.prototype.$setIsolation$ = function(isolationKey) {
  this.$isolationKey$ = "" + (isolationKey || "");
  delete AuraStorageService.prototype.$setIsolation$;
  delete AuraStorageService.prototype["setIsolation"]
};
goog.$exportProperty$(AuraStorageService.prototype, "setIsolation", AuraStorageService.prototype.$setIsolation$);
AuraStorageService.prototype.$setPartition$ = function(partitionName) {
  this.$partitionName$ = "" + (partitionName || "");
  delete AuraStorageService.prototype.$setPartitionName$;
  delete AuraStorageService.prototype["setPartitionName"]
};
goog.$exportProperty$(AuraStorageService.prototype, "setPartition", AuraStorageService.prototype.$setPartition$);
Aura.$Services$.$AuraStorageService$ = AuraStorageService;
var AuraStorage = function AuraStorage(config) {
  this.version = "" + config["version"];
  this.$keyPrefix$ = this.$generateKeyPrefix$(config["isolationKey"], this.version);
  config["keyPrefix"] = this.$keyPrefix$;
  this.$ready$ = undefined;
  this.$queue$ = [];
  this.$fallbackMode$ = false;
  this.$config$ = Object.freeze(config);
  var AdapterCtr = config["adapterClass"];
  this.$adapter$ = new AdapterCtr(this.$config$);
  this.$adapterAntiObfuscation$(this.$adapter$);
  this.name = config["name"];
  this.$cacheStats$ = $A.$metricsService$.$registerCacheStats$("AuraStorage_" + this.name);
  this.$maxSize$ = config["maxSize"];
  this.$expiration$ = config["expiration"] * 1E3;
  this.$autoRefreshInterval$ = config["autoRefreshInterval"] * 1E3;
  this.$debugLogging$ = config["debugLogging"];
  this.$writeOperationsInFlight$ = 0;
  this.$readOperationsInFlight$ = 0;
  this.$stats$ = {size:-1};
  this.$sweepInterval$ = Math.min(Math.max(this.$expiration$ * 0.5, AuraStorage["SWEEP_INTERVAL"]["MIN"]), AuraStorage["SWEEP_INTERVAL"]["MAX"]);
  this.$lastSweepTime$ = (new Date).getTime();
  this.$sweepingSuspended$ = false;
  this.$sweepPromise$ = undefined;
  this.$sweepTimeout$ = undefined;
  this.log(this.$LOG_LEVEL$.$INFO$, $A["util"].$format$("initializing storage adapter using { maxSize: {0} KB, expiration: {1} sec, autoRefreshInterval: {2} sec, clearStorageOnInit: {3}, isolationKey: {4} }", (this.$maxSize$ / 1024).toFixed(1), (this.$expiration$ / 1E3).toFixed(0), (this.$autoRefreshInterval$ / 1E3).toFixed(0), config["clearOnInit"], this.$keyPrefix$));
  this.$adapter$.$initialize$()["then"](this.$adapterInitialize$.bind(this, true), this.$adapterInitialize$.bind(this, false))
};
goog.$exportSymbol$("AuraStorage", AuraStorage);
AuraStorage.prototype.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
AuraStorage.prototype.$adapterAntiObfuscation$ = function(adapter) {
  adapter.$initialize$ = adapter.$initialize$ || adapter["initialize"];
  adapter.getName = adapter.getName || adapter["getName"];
  adapter.$isSecure$ = adapter.$isSecure$ || adapter["isSecure"];
  adapter.$isPersistent$ = adapter.$isPersistent$ || adapter["isPersistent"];
  adapter.$suspendSweeping$ = adapter.$suspendSweeping$ || adapter["suspendSweeping"];
  adapter.$resumeSweeping$ = adapter.$resumeSweeping$ || adapter["resumeSweeping"];
  adapter.$setItems$ = adapter.$setItems$ || adapter["setItems"];
  adapter.$getItems$ = adapter.$getItems$ || adapter["getItems"];
  adapter.$removeItems$ = adapter.$removeItems$ || adapter["removeItems"];
  adapter.clear = adapter.clear || adapter["clear"];
  adapter.$sweep$ = adapter.$sweep$ || adapter["sweep"];
  adapter.$getSize$ = adapter.$getSize$ || adapter["getSize"];
  adapter.$deleteStorage$ = adapter.$deleteStorage$ || adapter["deleteStorage"]
};
AuraStorage.prototype.getName = function() {
  return this.$adapter$.getName()
};
goog.$exportProperty$(AuraStorage.prototype, "getName", AuraStorage.prototype.getName);
AuraStorage.prototype.$getSize$ = function() {
  return this.$enqueue$(this.$getSizeInternal$.bind(this))
};
goog.$exportProperty$(AuraStorage.prototype, "getSize", AuraStorage.prototype.$getSize$);
AuraStorage.prototype.$getSizeInternal$ = function(resolve, reject) {
  var that = this;
  this.$adapter$.$getSize$()["then"](function getSetSize(size) {
    that.$stats$.size = parseInt(size / 1024, 10);
    return size / 1024
  })["then"](resolve, reject)
};
AuraStorage.prototype.$getMaxSize$ = function() {
  return this.$maxSize$ / 1024
};
goog.$exportProperty$(AuraStorage.prototype, "getMaxSize", AuraStorage.prototype.$getMaxSize$);
AuraStorage.prototype.$enqueue$ = function(execute) {
  var that = this;
  if(this.$ready$ === true) {
    return new Promise(function(resolve, reject) {
      execute(resolve, reject)
    })
  }else {
    if(this.$ready$ === false) {
      return Promise["reject"](new Error(this.$getInitializationError$()))
    }
  }
  return new Promise(function(resolve, reject) {
    that.$queue$.push({"execute":execute, "resolve":resolve, "reject":reject});
    if(that.$ready$ !== undefined) {
      that.$executeQueue$()
    }
  })
};
AuraStorage.prototype.$adapterInitialize$ = function(readyState, error) {
  if(this.$ready$ !== undefined) {
    return
  }
  if(!readyState && !this.$fallbackMode$) {
    this.log(this.$LOG_LEVEL$.$WARNING$, $A["util"].$format$("adapterReady(): {0} adapter failed initialization, falling back to memory adapter", this.$adapter$.getName()));
    this.$logError$({"operation":"adapterReady", "error":error});
    this.$fallbackMode$ = true;
    var adapterClass = $A.$storageService$.$getAdapterConfig$(Aura.$Storage$.$MemoryAdapter$["NAME"])["adapterClass"];
    this.$adapter$ = new adapterClass(this.$config$);
    this.$adapterAntiObfuscation$(this.$adapter$);
    this.$adapter$.$initialize$()["then"](this.$adapterInitialize$.bind(this, true), this.$adapterInitialize$.bind(this, false));
    return
  }
  var that = this;
  var promise;
  if(readyState && this.$config$["clearOnInit"]) {
    promise = (new Promise(function(resolve, reject) {
      that.$clearInternal$(resolve, reject)
    }))["then"](undefined, function noop() {
    })
  }else {
    promise = Promise["resolve"]()
  }
  promise["then"](function executeQueueOnSuccess() {
    that.$ready$ = !!readyState;
    if(!that.$sweepingSuspended$) {
      that.$sweepTimeout$ = setTimeout(that.$sweep$, AuraStorage["SWEEP_INTERVAL"]["MAX"])
    }
    that.$executeQueue$()
  })
};
AuraStorage.prototype.$executeQueue$ = function() {
  var queue = this.$queue$;
  this.$queue$ = [];
  if(this.$ready$) {
    this.log(this.$LOG_LEVEL$.$INFO$, "executeQueue(): adapter completed initialization. Processing " + queue.length + " operations.")
  }else {
    var message = "executeQueue(): adapter failed initialization, entering permanent error state. All future operations will fail. Failing " + queue.length + " enqueued operations.";
    this.log(this.$LOG_LEVEL$.$WARNING$, message);
    this.$logError$({"operation":"initialize", "error":message})
  }
  for(var i = 0;i < queue.length;i++) {
    if(!this.$ready$) {
      queue[i]["reject"](new Error(this.$getInitializationError$()))
    }else {
      try {
        queue[i]["execute"](queue[i]["resolve"], queue[i]["reject"])
      }catch(e) {
        queue[i]["reject"](e)
      }
    }
  }
};
AuraStorage.prototype.$getInitializationError$ = function() {
  return"AuraStorage[" + this.name + "] adapter failed to initialize"
};
AuraStorage.prototype.clear = function() {
  return this.$enqueue$(this.$clearInternal$.bind(this))
};
goog.$exportProperty$(AuraStorage.prototype, "clear", AuraStorage.prototype.clear);
AuraStorage.prototype.$clearInternal$ = function(resolve, reject) {
  var that = this;
  this.$writeOperationsInFlight$ += 1;
  this.$adapter$.clear()["then"](function fireModifiedWrapper() {
    that.$writeOperationsInFlight$ -= 1;
    that.$fireModified$()
  }, function adaperClearError(e) {
    that.$writeOperationsInFlight$ -= 1;
    that.$logError$({"operation":"clear", "error":e});
    throw e;
  })["then"](resolve, reject)
};
AuraStorage.prototype.get = function(key, includeExpired) {
  $A.assert($A["util"].$isString$(key), "AuraStorage.get(): 'key' must be a String.");
  $A.assert(!includeExpired || $A["util"].$isBoolean$(includeExpired), "AuraStorage.get(): 'includeExpired' must be a Boolean.");
  return this.$getAll$([key], includeExpired)["then"](function getValue(items) {
    if(items) {
      return items[key]
    }
    return undefined
  })
};
goog.$exportProperty$(AuraStorage.prototype, "get", AuraStorage.prototype.get);
AuraStorage.prototype.$inFlightOperations$ = function() {
  return this.$readOperationsInFlight$ + this.$writeOperationsInFlight$ + this.$queue$.length
};
goog.$exportProperty$(AuraStorage.prototype, "inFlightOperations", AuraStorage.prototype.$inFlightOperations$);
AuraStorage.prototype.$inFlightReadOperations$ = function() {
  return this.$readOperationsInFlight$ + this.$queue$.length
};
goog.$exportProperty$(AuraStorage.prototype, "inFlightReadOperations", AuraStorage.prototype.$inFlightReadOperations$);
AuraStorage.prototype.$getAll$ = function(keys, includeExpired) {
  $A.assert(!keys || Array.isArray(keys), "AuraStorage.getAll(): 'keys' must be an Array.");
  $A.assert(!includeExpired || $A["util"].$isBoolean$(includeExpired), "AuraStorage.getAll(): 'includeExpired' must be a Boolean.");
  return this.$enqueue$(this.$getAllInternal$.bind(this, keys, includeExpired))
};
goog.$exportProperty$(AuraStorage.prototype, "getAll", AuraStorage.prototype.$getAll$);
AuraStorage.prototype.$getAllInternal$ = function(keys, includeExpired, resolve, reject) {
  function logHitsAndMisses(storageResults, hitsCount) {
    that.$cacheStats$["logHits"](hitsCount);
    that.$cacheStats$["logMisses"](keys.length - hitsCount);
    if(that.$debugLogging$) {
      var hit = [];
      var miss = [];
      var key;
      for(var j = 0;j < keys.length;j++) {
        key = keys[j];
        if(storageResults.hasOwnProperty(key)) {
          hit.push(key)
        }else {
          miss.push(key)
        }
      }
      if(hit.length > 0) {
        that.log(that.$LOG_LEVEL$.$INFO$, "getAll() - HIT on key(s): " + hit.join(", "))
      }
      if(miss.length > 0) {
        that.log(that.$LOG_LEVEL$.$INFO$, "getAll() - MISS on key(s): " + miss.join(", "))
      }
    }
  }
  var that = this;
  var prefixedKeys;
  var isKeysPresent = Array.isArray(keys) && keys.length > 0;
  if(isKeysPresent) {
    prefixedKeys = [];
    for(var i = 0;i < keys.length;i++) {
      prefixedKeys.push(this.$keyPrefix$ + keys[i])
    }
  }
  this.$readOperationsInFlight$ += 1;
  this.$adapter$.$getItems$(prefixedKeys, includeExpired)["then"](function processItems(items) {
    that.$readOperationsInFlight$ -= 1;
    var now = (new Date).getTime();
    var results = {};
    var item;
    var key;
    var hitsCount = 0;
    for(var k in items) {
      item = items[k];
      if(k.indexOf(that.$keyPrefix$) === 0 && (includeExpired || now < item["expires"])) {
        hitsCount++;
        key = k.substring(that.$keyPrefix$.length);
        results[key] = item["value"]
      }
    }
    if(isKeysPresent) {
      logHitsAndMisses(results, hitsCount)
    }
    return results
  })["then"](undefined, function adapterGetItemsError(e) {
    that.$readOperationsInFlight$ -= 1;
    that.$logError$({"operation":"getAll", "error":e});
    throw e;
  })["then"](resolve, reject)
};
AuraStorage.prototype.$buildPayload$ = function(key, value, now, privileged) {
  var encoded = false;
  var expiration = now + this.$expiration$;
  if(privileged && value["storage"] && value["storage"]["expiration"]) {
    expiration = now + value["storage"]["expiration"]
  }
  var size = $A["util"].$estimateSize$("" + key);
  if(this.$adapter$.$encodeValue$) {
    try {
      value = this.$adapter$.$encodeValue$(value);
      encoded = true;
      size += value.length
    }catch(e) {
    }
  }
  if(!encoded) {
    size += $A["util"].$estimateSize$(value)
  }
  if(size > this.$maxSize$) {
    throw new Error("AuraStorage.set() cannot store " + key + " of size " + size + "b because it's over the max size of " + this.$maxSize$ + "b");
  }
  return[this.$keyPrefix$ + key, {"value":value, "created":now, "expires":expiration, "valueEncoded":encoded}, size]
};
AuraStorage.prototype.set = function(key, value) {
  $A.assert($A["util"].$isString$(key), "AuraStorage.set(): 'key' must be a String.");
  var values = {};
  values[key] = value;
  return this.$setAll$(values)
};
goog.$exportProperty$(AuraStorage.prototype, "set", AuraStorage.prototype.set);
AuraStorage.prototype.$setAll$ = function(values) {
  $A.assert($A["util"].$isObject$(values), "AuraStorage.setAll(): 'values' must be an Object.");
  return this.$enqueue$(this.$setAllInternal$.bind(this, values, false))
};
goog.$exportProperty$(AuraStorage.prototype, "setAll", AuraStorage.prototype.$setAll$);
AuraStorage.prototype.$unstable_setAllPrivileged$ = function(values) {
  $A.assert($A["util"].$isObject$(values), "AuraStorage.setAllPrivileged(): 'values' must be an Object.");
  return this.$enqueue$(this.$setAllInternal$.bind(this, values, true))
};
AuraStorage.prototype.$setAllInternal$ = function(values, privileged, resolve, reject) {
  var now = (new Date).getTime();
  var storablesSize = 0;
  var storables = [];
  var storable;
  try {
    for(var key in values) {
      storable = this.$buildPayload$(key, values[key], now, privileged);
      storables.push(storable);
      storablesSize += storable[2]
    }
  }catch(e$$0) {
    this.$logError$({"operation":"setAll", "error":e$$0});
    reject(e$$0);
    return
  }
  if(storablesSize > this.$maxSize$) {
    var e2 = new Error("AuraStorage.set() cannot store " + Object.keys(values).length + " items of total size " + storablesSize + "b because it's over the max size of " + this.$maxSize$ + "b");
    this.$logError$({"operation":"setAll", "error":e2});
    reject(e2);
    return
  }
  var that = this;
  this.$writeOperationsInFlight$ += 1;
  this.$adapter$.$setItems$(storables)["then"](function fireModifiedWrapper() {
    that.$writeOperationsInFlight$ -= 1;
    var keys = Object.keys(values);
    that.log(that.$LOG_LEVEL$.$INFO$, "setAll() - " + keys.length + " key(s): " + keys.join(", "));
    that.$fireModified$()
  }, function adapterSetItemsError(e) {
    that.$writeOperationsInFlight$ -= 1;
    that.$logError$({"operation":"setAll", "error":e});
    throw e;
  })["then"](resolve, reject);
  this.$sweep$()
};
AuraStorage.prototype.remove = function(key, doNotFireModified) {
  $A.assert($A["util"].$isString$(key), "AuraStorage.remove(): 'key' must be a String.");
  $A.assert(!doNotFireModified || $A["util"].$isBoolean$(doNotFireModified), "AuraStorage.remove(): 'doNotFireModified' must be a Boolean.");
  return this.$removeAll$([key], doNotFireModified)
};
goog.$exportProperty$(AuraStorage.prototype, "remove", AuraStorage.prototype.remove);
AuraStorage.prototype.$removeAll$ = function(keys, doNotFireModified) {
  $A.assert($A["util"].isArray(keys), "AuraStorage.removeAll(): 'keys' must be an Array.");
  $A.assert(doNotFireModified === undefined || $A["util"].$isBoolean$(doNotFireModified), "AuraStorage.removeAll(): 'doNotFireModified' must be undefined or a Boolean.");
  return this.$enqueue$(this.$removeAllInternal$.bind(this, keys, doNotFireModified))
};
goog.$exportProperty$(AuraStorage.prototype, "removeAll", AuraStorage.prototype.$removeAll$);
AuraStorage.prototype.$removeAllInternal$ = function(keys, doNotFireModified, resolve, reject) {
  var prefixedKeys = [];
  for(var i = 0;i < keys.length;i++) {
    prefixedKeys.push(this.$keyPrefix$ + keys[i])
  }
  var that = this;
  this.$writeOperationsInFlight$ += 1;
  this.$adapter$.$removeItems$(prefixedKeys)["then"](function fireModifiedWrapper() {
    that.$writeOperationsInFlight$ -= 1;
    if(that.$debugLogging$) {
      for(i = 0;i < prefixedKeys.length;i++) {
        that.log(that.$LOG_LEVEL$.$INFO$, "removeAll() - key " + prefixedKeys[i])
      }
    }
    if(!doNotFireModified) {
      that.$fireModified$()
    }
  }, function adapterRemoveItemsError(e) {
    that.$writeOperationsInFlight$ -= 1;
    that.$logError$({"operation":"removeAll", "error":e});
    throw e;
  })["then"](resolve, reject)
};
AuraStorage.prototype.$sweep$ = function(ignoreInterval) {
  function doneSweeping(doNotFireModified, e) {
    this.$writeOperationsInFlight$ -= 1;
    this.log(this.$LOG_LEVEL$.$INFO$, "sweep() - complete" + (e ? " (with errors)" : ""));
    this.$logStats$();
    this.$sweepPromise$ = undefined;
    this.$lastSweepTime$ = (new Date).getTime();
    if(!doNotFireModified) {
      this.$fireModified$()
    }
  }
  $A.assert(ignoreInterval === undefined || $A["util"].$isBoolean$(ignoreInterval), "AuraStorage.sweep(): 'ignoreInterval' must be undefined or a Boolean.");
  if(this.$sweepTimeout$) {
    clearTimeout(this.$sweepTimeout$);
    this.$sweepTimeout$ = null
  }
  if(!this.$sweepingSuspended$) {
    this.$sweepTimeout$ = setTimeout(this.$sweep$, AuraStorage["SWEEP_INTERVAL"]["MAX"])
  }
  if(this.$sweepPromise$) {
    return this.$sweepPromise$
  }
  if(!this.$ready$) {
    return Promise["resolve"]()
  }
  if(!$A["finishedInit"]) {
    return Promise["resolve"]()
  }
  var sweepInterval = (new Date).getTime() - this.$lastSweepTime$;
  if(!ignoreInterval && sweepInterval < this.$sweepInterval$) {
    return Promise["resolve"]()
  }
  if(this.$sweepingSuspended$) {
    this.$logStats$();
    return Promise["resolve"]()
  }
  this.$writeOperationsInFlight$ += 1;
  this.$sweepPromise$ = this.$adapter$.$sweep$()["then"](undefined, function adapterSweepError(e) {
    this.$logError$({"operation":"sweep", "error":e});
    throw e;
  }.bind(this))["then"](doneSweeping.bind(this), doneSweeping.bind(this, true));
  return this.$sweepPromise$
};
AuraStorage.prototype.$suspendSweeping$ = function() {
  this.log(this.$LOG_LEVEL$.$INFO$, "suspendSweeping()");
  if(this.$sweepTimeout$) {
    clearTimeout(this.$sweepTimeout$);
    this.$sweepTimeout$ = null
  }
  this.$sweepingSuspended$ = true;
  if(this.$adapter$.$suspendSweeping$) {
    this.$adapter$.$suspendSweeping$()
  }
};
goog.$exportProperty$(AuraStorage.prototype, "suspendSweeping", AuraStorage.prototype.$suspendSweeping$);
AuraStorage.prototype.$resumeSweeping$ = function() {
  this.log(this.$LOG_LEVEL$.$INFO$, "resumeSweeping()");
  this.$sweepingSuspended$ = false;
  if(this.$adapter$.$resumeSweeping$) {
    this.$adapter$.$resumeSweeping$()
  }
  this.$sweep$()
};
goog.$exportProperty$(AuraStorage.prototype, "resumeSweeping", AuraStorage.prototype.$resumeSweeping$);
AuraStorage.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= this.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("AuraStorage['" + this.name + "'] " + msg, obj)
  }
};
AuraStorage.prototype.$logError$ = function(payload) {
  $A.$metricsService$.transaction("aura", "error:storage", {"context":{"attributes":{"name":this.name, "adapter":this.getName(), "operation":payload["operation"], "error":payload["error"] && payload["error"].toString()}}})
};
AuraStorage.prototype.$logStats$ = function() {
  if(this.$ready$ !== true) {
    return
  }
  $A.$metricsService$.transaction("aura", "performance:storage-stats", {"context":{"attributes":{"name":this.name, "adapter":this.getName(), "sizeKB":this.$stats$.size, "maxSizeKB":parseInt(this.$getMaxSize$(), 10)}}})
};
AuraStorage.prototype.$isPersistent$ = function() {
  return this.$adapter$.$isPersistent$()
};
goog.$exportProperty$(AuraStorage.prototype, "isPersistent", AuraStorage.prototype.$isPersistent$);
AuraStorage.prototype.$isSecure$ = function() {
  return this.$adapter$.$isSecure$()
};
goog.$exportProperty$(AuraStorage.prototype, "isSecure", AuraStorage.prototype.$isSecure$);
AuraStorage.prototype.$getVersion$ = function() {
  return this.version
};
goog.$exportProperty$(AuraStorage.prototype, "getVersion", AuraStorage.prototype.$getVersion$);
AuraStorage.prototype.$getExpiration$ = function() {
  return this.$expiration$ / 1E3
};
goog.$exportProperty$(AuraStorage.prototype, "getExpiration", AuraStorage.prototype.$getExpiration$);
AuraStorage.prototype.$getDefaultAutoRefreshInterval$ = function() {
  return this.$autoRefreshInterval$
};
AuraStorage.prototype.$deleteStorage$ = function() {
  return this.$enqueue$(this.$deleteStorageInternal$.bind(this))
};
AuraStorage.prototype.$deleteStorageInternal$ = function(resolve, reject) {
  this.$cacheStats$["unRegister"]();
  if(!this.$adapter$.$deleteStorage$) {
    resolve();
    return
  }
  var that = this;
  this.$adapter$.$deleteStorage$()["then"](undefined, function adapterDeleteStorageError(e) {
    that.$logError$({"operation":"deleteStorage", "error":e});
    throw e;
  })["then"](resolve, reject)
};
AuraStorage.prototype.$generateKeyPrefix$ = function(isolationKey, version) {
  return"" + isolationKey + version + AuraStorage.$KEY_DELIMITER$
};
AuraStorage.prototype.$fireModified$ = function() {
  var e = $A.$eventService$.$getNewEvent$("markup://auraStorage:modified");
  if(e) {
    e.$fire$({"name":this.name})
  }
};
AuraStorage.$KEY_DELIMITER$ = ":";
AuraStorage["SWEEP_INTERVAL"] = {"MIN":6E4, "MAX":3E5};
Aura.$Storage$.$AuraStorage$ = AuraStorage;
var AuraProfilerServiceProfilerEnabled = false;
var AuraProfilerServiceLogOperationStart;
var AuraProfilerServiceLogOperationStop;
Aura.$Services$.$ProfilerService$ = function() {
  var logOperation = noop;
  var profilerService = {};
  AuraProfilerServiceLogOperationStart = function(opId, cmpName, cmp) {
    logOperation(opId, 0, cmpName, cmp)
  };
  AuraProfilerServiceLogOperationStop = function(opId, cmpName, cmp) {
    logOperation(opId, 1, cmpName, cmp)
  };
  profilerService.$enableProfiler$ = function() {
    AuraProfilerServiceProfilerEnabled = true
  };
  profilerService.$disableProfiler$ = function() {
    AuraProfilerServiceProfilerEnabled = false
  };
  profilerService.$attachDispatcher$ = function(buffer) {
    logOperation = buffer
  };
  profilerService.$detachDispatcher$ = function() {
    var oldOperation = logOperation;
    logOperation = noop;
    return oldOperation
  };
  profilerService["attachDispatcher"] = profilerService.$attachDispatcher$;
  profilerService["detachDispatcher"] = profilerService.$detachDispatcher$;
  profilerService["enableProfiler"] = profilerService.$enableProfiler$;
  profilerService["disableProfiler"] = profilerService.$disableProfiler$;
  return profilerService
}();
Aura.$Services$.$AuraClientServiceMarker$ = 0;
Aura.$Services$.$AuraClientService$AuraXHR$ = function AuraXHR() {
  this.$allowFlowthrough$ = false;
  this.length = 0;
  this.$longRunning$ = false;
  this["marker"] = 0;
  this.$request$ = undefined;
  this.$actions$ = {}
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype["getRequestInfo"] = function() {
  if(this.$request$) {
    return{"getResponseHeader":this.$request$.getResponseHeader.bind(this.$request$), "responseText":this.$request$.responseText, "status":this.$request$.status, "statusText":this.$request$.statusText}
  }
  return{}
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype["getActions"] = function() {
  return this.$actions$
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype["getRequestStatus"] = function() {
  return this.$request$ && this.$request$.status
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.reset = function() {
  this.$request$ = undefined;
  this.$actions$ = {};
  this.$longRunning$ = false
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.$isLongRunning$ = function() {
  return this.$longRunning$
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.$setLongRunning$ = function() {
  this.$longRunning$ = true
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.$addAction$ = function(action) {
  if(action) {
    if(this.$actions$["" + action.$getId$()]) {
      throw new $A.$auraError$("Adding duplicate action", null, $A.severity.$QUIET$);
    }
    this.$actions$["" + action.$getId$()] = action
  }
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.$getAction$ = function(id) {
  var action;
  var key = id;
  if(!key) {
    var keys = Object.keys(this.$actions$);
    $A.assert(keys.length === 1, "When no ID is specified, there should only be one action in the XHR.");
    if(keys.length === 1) {
      key = keys[0]
    }
  }
  action = this.$actions$[key];
  if(action) {
    this.$actions$[key] = undefined
  }
  return action
};
Aura.$Services$.$AuraClientService$AuraActionCollector$ = function AuraActionCollector() {
  this.$clientActions$ = [];
  this.$clientIndex$ = 0;
  this.$actionsToCollect$ = 0;
  this.$collected$ = [];
  this.$collecting$ = [];
  this.$actionsToComplete$ = [];
  this.$completionIndex$ = 0;
  this.$collectedStorableActions$ = [];
  this.$actionsCompleted$ = 0
};
function AuraClientService(util) {
  this.$_host$ = "";
  this.$_token$ = null;
  this.$_isDisconnected$ = false;
  this.$authorizationToken$ = undefined;
  this.$auraStack$ = [];
  this.$actionStorage$ = new Aura.$Controller$.$ActionStorage$;
  this.$appcacheDownloadingEventFired$ = false;
  this.$isOutdated$ = false;
  this.$finishedInitDefs$ = false;
  this.$protocols$ = {"layout":true, "sitelayout":true};
  this.$lastSendTime$ = Date.now();
  this.$moduleServices$ = {};
  this.$moduleScopedImports$ = {};
  this.$defaultModuleScopedImports$ = {"salesforce":this.$defaultSalesforceImportResolver$.bind(this), "babel":this.$babelHelpersResolver$, "locker":this.$lockerResolver$};
  this.$i18nImportMap$ = undefined;
  this.$clientFormFactorMap$ = undefined;
  this.$moduleScopedImportsCache$ = {};
  this.$clientLibraries$ = {"ckeditor":{$resourceUrl$:"/auraFW/resources/{fwuid}/ckeditor/ckeditor-4.x/rel/ckeditor.js"}, "quill":{$resourceUrl$:"/auraFW/resources/{fwuid}/quill.js"}};
  this.$clientLibraryLoadsInProgress$ = 0;
  this.$accessStack$ = [];
  this.$registeredNamespaces$ = {$internal$:{}, $privileged$:{}};
  this.$currentAccess$ = null;
  this.$enableAccessChecks$ = true;
  this.$logAccessFailures$ = true;
  this.$appCacheError$ = false;
  this.$_appNotTearingDown$ = true;
  this.$xhrTimeout$ = undefined;
  this.$appBootstrap$;
  this.$appCacheProgress$ = 0;
  this.$appCacheUpdateCount$ = 0;
  this.$NOOP$ = function() {
  };
  var auraXHR = new Aura.$Services$.$AuraClientService$AuraXHR$;
  this.$availableXHRs$ = [auraXHR];
  this.$allXHRs$ = [auraXHR];
  this.$actionStoreMap$ = {};
  this.$collector$ = undefined;
  this.$xhrExclusivity$ = false;
  this.$boxcarReduction$ = false;
  this.$labelsFromStorage$ = true;
  this.$longRunningActionsCount$ = 0;
  this.$bootstrapInlined$ = false;
  this.$actionsQueued$ = [];
  this.$actionsDeferred$ = [];
  this.$longRunningDeferred$ = [];
  if(window.XMLHttpRequest) {
    this.$httpType$ = "generic"
  }else {
    this.$httpType$ = undefined
  }
  this.$_disconnected$ = undefined;
  this.$xhrIdleQueue$ = [];
  this.$optionClientSynchronous$ = true;
  this.$reloadFunction$ = undefined;
  this.$reloadPointPassed$ = false;
  this.$tokenSharing$ = util && util.$isLocalStorageEnabled$();
  this.$maxActionRetries$ = 4;
  this.$preListenerRegistry$ = {"receive":[], "send":[], "enqueueAction":[], "collectServerAction":[], "processResponses":[], "Action.finishAction":[]};
  this.$postListenerRegistry$ = {"receive":[], "send":[], "enqueueAction":[], "collectServerAction":[], "processResponses":[], "Action.finishAction":[]};
  this.$o11yListenerRegistry$ = {"acs.internalSend":[], "acs.decode":[], "acs.receive":[], "ars.render":[], "ars.rerender":[], "ars.unrender":[], "evt.executeHandlerIterator":[]};
  this.$handleAppCache$();
  this.$setupBootstrapErrorReloadButton$();
  this.$setupTokenListener$();
  this.$auraCmpDefBaseURI$ = "";
  this.$auraCmpDefBaseURIAuth$ = null;
  this.$staticResourceDomain$ = undefined;
  this.$_cdnEnabledForLatestDefRequest$ = false;
  this.$_isLiveEnabledForRestrictedDefRequest$ = false;
  this.$_disableAuraBundling$ = false;
  this.$_componentUids$ = {};
  this.$_csrfV2$ = false;
  var headerAllowList = ["X-SFDC-LDS-Endpoints"];
  var sidToken = undefined;
  this.$setSidToken$ = function(token) {
    sidToken = token
  };
  this.$isSidTokenSet$ = function() {
    return!!sidToken
  };
  this.$internalCreateAndOpenXhr$ = function(cmp, method, url, async, username, password) {
    var xhr;
    try {
      xhr = new XMLHttpRequest;
      xhr.open(method, url, async, username, password);
      if(!!Aura["bootstrap"] && !!Aura["bootstrap"]["isSidTokenEnabled"] && this.$isSidTokenSet$() && !!url) {
        var parsedUrlObj;
        if(typeof URL === "function") {
          parsedUrlObj = new URL(url, document.baseURI)
        }else {
          parsedUrlObj = document.createElement("a");
          parsedUrlObj.href = url
        }
        if(!!parsedUrlObj && parsedUrlObj.origin === document.location.origin) {
          if(getUrlAllowListForRawXHR().indexOf(parsedUrlObj.pathname) > -1) {
            var namespace = cmp && cmp.$isValid$() && cmp.$getDef$() && cmp.$getDef$().$getDescriptor$() && cmp.$getDef$().$getDescriptor$().$getNamespace$();
            if(!!namespace && getCmpAllowListForRawXHR().indexOf(namespace) > -1) {
              xhr.setRequestHeader("sid", sidToken)
            }
          }
        }
      }
    }catch(error) {
      xhr = null;
      var message = "[AuraClientService.prototype.createAndOpenXhr]: Error when trying to create XHR and set SID token in request header";
      var auraError = new $A.$auraError$(message, error, $A.severity.$ALERT$);
      $A.$logger$.$reportError$(auraError)
    }
    return xhr
  };
  this.$internalSend$ = function(auraXhrToSend, actions, method, options) {
    try {
      options = options || {background:false};
      var actionsToSend = [];
      var actionDefs = [];
      var that = this;
      var action;
      var context = $A.getContext();
      var i;
      var actionDef;
      var headers = {};
      var headerValueSet = {};
      for(i = 0;i < actions.length;i++) {
        action = actions[i];
        if(!action.$callAllAboardCallback$(context)) {
          action.$finishAction$(context);
          continue
        }
        if(this.$deDupe$(action, true)) {
          continue
        }
        auraXhrToSend.$addAction$(action);
        var actionHeaders = action.$getHeaders$();
        for(var key in actionHeaders) {
          if(headerAllowList.indexOf(key) < 0) {
            continue
          }
          var value = actionHeaders[key];
          if(!headerValueSet[key]) {
            headerValueSet[key] = {}
          }
          if(!headerValueSet[key][value]) {
            headerValueSet[key][value] = true
          }
        }
        for(key in headerValueSet) {
          headers[key] = Object.keys(headerValueSet[key]).join(", ")
        }
        if(action.$isChained$()) {
          continue
        }
        actionsToSend.push(action.$prepareToSend$());
        actionDef = action.$getDef$();
        actionDefs.push(actionDef)
      }
      if(actionsToSend.length === 0) {
        return false
      }
      var processed = false;
      var timedOut = false;
      var timerId = undefined;
      var marker = Aura.$Services$.$AuraClientServiceMarker$++;
      var qs;
      var url;
      var loc = window.location;
      try {
        var params = {"message":$A["util"].$json$.$encode$({"actions":actionsToSend}), "aura.context":context.$encodeForServer$(method === "POST", method === "GET")};
        if(method === "GET") {
          params["aura.isAction"] = true
        }else {
          params["aura.pageURI"] = loc.pathname + loc.search + loc.hash;
          params["aura.token"] = this.$_token$
        }
        qs = this.$buildParams$(params)
      }catch(e) {
        this.$notifyListeners$("O11Y", "acs.internalSend", ["BUILD_PARAM_ERROR"]);
        for(i = 0;i < actions.length;i++) {
          action = actions[i];
          action.$markException$(e);
          action.$finishAction$(context)
        }
        $A.error("failed to generate parameters for action xhr for action: " + actionsToSend[0], e);
        return false
      }
      if(method === "GET") {
        url = this.$_host$ + "/aura?" + qs
      }else {
        url = this.$_host$ + "/aura?r\x3d" + marker + "\x26" + this.$buildActionNameList$(actionsToSend, actionDefs)
      }
      auraXhrToSend.background = options.background;
      auraXhrToSend.length = qs.length;
      auraXhrToSend.$request$ = this.$createXHR$();
      auraXhrToSend.$request$["open"](method, url, this.$_appNotTearingDown$);
      for(var headerKey in headers) {
        auraXhrToSend.$request$.setRequestHeader(headerKey, headers[headerKey])
      }
      auraXhrToSend["marker"] = marker;
      auraXhrToSend.url = url;
      if(this.$_appNotTearingDown$ && "withCredentials" in auraXhrToSend.$request$) {
        auraXhrToSend.$request$["withCredentials"] = true
      }
      var onReady = function() {
        if(processed === false && (auraXhrToSend.$request$["readyState"] === 4 || timedOut)) {
          processed = true;
          if(timerId !== undefined) {
            that.$xhrClearTimeout$(timerId)
          }
          that.$receiveWrapper$(auraXhrToSend, timedOut)
        }
      };
      if(this.$currentAccess$ && this.$inAuraLoop$()) {
        onReady = $A.$getCallback$(onReady)
      }
      auraXhrToSend.$request$["onreadystatechange"] = onReady;
      if(options["headers"]) {
        headers = options["headers"];
        auraXhrToSend.$requestId$ = headers["X-SFDC-Request-Id"];
        for(key in headers) {
          if(headers.hasOwnProperty(key)) {
            auraXhrToSend.$request$.setRequestHeader(key, headers[key])
          }
        }
      }
      if(this.$authorizationToken$) {
        auraXhrToSend.$request$.setRequestHeader("Authorization", this.$authorizationToken$)
      }else {
        if(this.$isSidTokenSet$()) {
          auraXhrToSend.$request$.setRequestHeader("sid", sidToken)
        }
      }
      if(qs && method === "POST") {
        auraXhrToSend.$request$.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset\x3dISO-8859-13");
        auraXhrToSend.$request$["send"](qs)
      }else {
        if(method !== "POST") {
          auraXhrToSend.$request$["send"]()
        }else {
          this.$notifyListeners$("O11Y", "acs.internalSend", ["XHR_NOT_SENT"]);
          return false
        }
      }
      if(this.$xhrTimeout$ !== undefined) {
        timerId = this.$xhrSetTimeout$(function() {
          timedOut = true;
          timerId = undefined;
          onReady()
        })
      }
      setTimeout(function fireWaitingEvent() {
        $A.$eventService$.$getNewEvent$("markup://aura:waiting").$fire$()
      }, 1);
      this.$lastSendTime$ = Date.now();
      this.$notifyListeners$("O11Y", "acs.internalSend", ["SUCCESS"]);
      return true
    }catch(err) {
      this.$notifyListeners$("O11Y", "acs.internalSend", ["ERROR"]);
      throw err;
    }
  }
}
goog.$exportSymbol$("AuraClientService", AuraClientService);
AuraClientService.$TOKEN_KEY$ = "$AuraClientService.token$";
AuraClientService.$BOOT_TIMER_DURATION$ = 3E4;
AuraClientService.$INCOMPLETE_BOOT_THRESHOLD$ = 5;
AuraClientService.$CACHE_BUST_QUERY_PARAM$ = "nocache";
AuraClientService.$SYSTEM_EXCEPTION_EVENT_RETURN_STATUS$ = "SYSTEMERROR";
AuraClientService.$INVALID_SESSION_RETURN_STATUS$ = "INVALIDSESSION";
AuraClientService.$INVALID_CSRF$ = "invalid_csrf";
AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$ = "__RELOAD_COUNT";
AuraClientService.$UNKNOWN_FRAMEWORK_UID$ = "UNKNOWN";
AuraClientService.$MAX_ACTION_QUERY_LENGTH$ = 1E3;
AuraClientService.prototype.$setQueueSize$ = function(queueSize) {
  var auraXHR;
  if(queueSize === undefined) {
    queueSize = 4
  }
  if(queueSize < 2) {
    throw new $A.$auraError$("number of XHRs must be at least 2, is " + queueSize, null, $A.severity.$QUIET$);
  }
  if(this.$allXHRs$.length === 1) {
    for(var i = 1;i < queueSize;i += 1) {
      auraXHR = new Aura.$Services$.$AuraClientService$AuraXHR$;
      this.$availableXHRs$.push(auraXHR);
      this.$allXHRs$.push(auraXHR)
    }
  }
};
AuraClientService.prototype.$setXHRExclusivity$ = function(xhrExclusivity) {
  if(xhrExclusivity === undefined) {
    xhrExclusivity = false
  }
  this.$xhrExclusivity$ = xhrExclusivity
};
AuraClientService.prototype.$setBoxcarReduction$ = function(boxcarReduction) {
  if(boxcarReduction === undefined) {
    boxcarReduction = false
  }
  this.$boxcarReduction$ = boxcarReduction
};
AuraClientService.prototype.$isBoxcarReductionEnabled$ = function() {
  return boxcarReduction
};
AuraClientService.prototype.$setLabelsFromStorage$ = function(labelsFromStorage) {
  if(labelsFromStorage === undefined) {
    labelsFromStorage = true
  }
  this.$labelsFromStorage$ = labelsFromStorage
};
AuraClientService.prototype.$getAvailableLongRunningActionsCount$ = function() {
  return $A.getContext().$getMaxLongRunningActionsCount$() - this.$longRunningActionsCount$
};
AuraClientService.prototype.$incrementLongRunningActionsCount$ = function() {
  this.$longRunningActionsCount$++
};
AuraClientService.prototype.$decrementLongRunningActionsCount$ = function() {
  this.$longRunningActionsCount$--
};
AuraClientService.prototype.$setBootstrapInlined$ = function(bootstrapInlined) {
  this.$bootstrapInlined$ = !!bootstrapInlined
};
AuraClientService.prototype.$deferPendingActions$ = function() {
  var i;
  var action;
  for(i = 0;i < this.$actionsQueued$.length;i++) {
    action = this.$actionsQueued$[i];
    if(action) {
      action.$setDeferred$()
    }
  }
  for(i = 0;i < this.$actionsDeferred$.length;i++) {
    action = this.$actionsDeferred$[i];
    if(action) {
      action.$setDeferred$()
    }
  }
  if(this.$collector$) {
    for(i = 0;i < this.$collector$.$collecting$.length;i++) {
      action = this.$collector$.$collecting$[i];
      if(action) {
        action.$setDeferred$()
      }
    }
  }
};
AuraClientService.prototype.$setAuraCmpDefBaseURI$ = function(auraCmpDefBaseURI, auraCmpDefBaseURIAuth) {
  if(auraCmpDefBaseURI) {
    this.$auraCmpDefBaseURI$ = auraCmpDefBaseURI
  }
  if(auraCmpDefBaseURIAuth) {
    this.$auraCmpDefBaseURIAuth$ = auraCmpDefBaseURIAuth
  }
};
AuraClientService.prototype.$getAuraCmpDefBaseURI$ = function() {
  return this.$auraCmpDefBaseURI$
};
AuraClientService.prototype.$getAuraCmpDefBaseURIAuth$ = function() {
  return this.$auraCmpDefBaseURIAuth$
};
AuraClientService.prototype.$initStaticResourceDomainAndGVP$ = function(staticResourceDomain) {
  if(!$A["util"].$isUndefinedOrNull$(staticResourceDomain)) {
    var prefix = "$ResourceDomain";
    if(!$A.get(prefix)) {
      this.$staticResourceDomain$ = staticResourceDomain;
      $A.$addValueProvider$(prefix, {url:staticResourceDomain})
    }
  }
};
AuraClientService.prototype.$getStaticResourceDomain$ = function() {
  return this.$staticResourceDomain$
};
AuraClientService.prototype.$uncommentExporter$ = function(exporter) {
  exporter = exporter.toString();
  var start = exporter.indexOf("/*") + 2;
  var end = exporter.lastIndexOf("*/");
  return start < 0 || end < start ? exporter : exporter.substr(start, end - start)
};
AuraClientService.prototype.$evalExporter$ = function(script, descriptor, type) {
  var trustedScript = $A.$lockerService$.$trusted$["createScript"]("function evaledScript() {" + script + " }");
  return $A["util"].$globalEval$(trustedScript, descriptor, type)
};
AuraClientService.prototype.$decode$ = function(response, timedOut, requestId) {
  var expectedError = false;
  try {
    var ret = {};
    var e;
    if(timedOut || this.$isDisconnectedOrCancelled$(response)) {
      this.$setConnected$(false);
      ret["status"] = "INCOMPLETE";
      this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
      return ret
    }
    if(this.$_isDisconnected$) {
      e = $A.$eventService$.$getNewEvent$("markup://aura:connectionResumed");
      if(e) {
        this.$_isDisconnected$ = false;
        e.$fire$()
      }
    }
    var status = response["status"];
    ret["responseCode"] = status;
    if(status === 429) {
      ret["message"] = "Something went wrong. Try your last action again or refresh the page.";
      ret["status"] = "ERROR";
      this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
      return ret
    }
    var text = response["responseText"];
    if(/^\s*</.test(text)) {
      ret["message"] = "Communication error, please retry or reload the page";
      ret["status"] = "ERROR";
      this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
      return ret
    }
    if(status !== 200 || $A["util"].$stringEndsWith$(text, "/*ERROR*/")) {
      if(status === 200) {
        text = text.substring(text.indexOf("*/") + 2, text.lastIndexOf("/*"))
      }
      var resp;
      try {
        resp = text === "" ? null : $A["util"].$json$.$decode$(text, null)
      }catch(err) {
        resp = null;
        if($A.$initialized$ && $A["util"].$hasSourceURL$()) {
          err.message += ". context\x3d status: " + response["status"] + ", statusText: " + response["statusText"] + ", requestId: " + requestId + ", responseURL: " + response["responseURL"];
          $A.$logger$.$reportError$(err, null, "ERROR")
        }
      }
      if($A["util"].$isUndefinedOrNull$(resp)) {
        ret["message"] = "Communication error, please retry or reload the page";
        ret["status"] = "ERROR";
        var appCache = window.applicationCache;
        if(appCache && (appCache.status === appCache.IDLE || appCache.status === appCache.UPDATEREADY || appCache.status === appCache.OBSOLETE)) {
          try {
            $A.log("[AuraClientService.decode]: Communication error, status - " + status + ". Check for app cache updates using applicationCache.update()");
            appCache.update()
          }catch(ignore) {
          }
        }
        this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
        return ret
      }else {
        if(resp["exceptionEvent"] === true) {
          this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
          var evtObj = resp["event"];
          var eventName;
          var eventNamespace;
          if(evtObj["descriptor"]) {
            var descriptor = new DefDescriptor(evtObj["descriptor"]);
            eventName = descriptor.getName();
            eventNamespace = descriptor.$getNamespace$()
          }
          if(eventNamespace === "aura" && eventName === "invalidSession") {
            ret["status"] = AuraClientService.$INVALID_SESSION_RETURN_STATUS$;
            ret["event"] = evtObj;
            return ret
          }
          try {
            this.$throwExceptionEvent$(resp)
          }catch(err$$0) {
            expectedError = true;
            throw err$$0;
          }
          if(eventNamespace === "aura" && eventName === "clientOutOfSync") {
            ret["status"] = AuraClientService.$SYSTEM_EXCEPTION_EVENT_RETURN_STATUS$;
            return ret
          }
          ret["status"] = "ERROR";
          ret["message"] = "Received exception event" + (eventNamespace ? " " + eventNamespace + ":" : "") + (eventName ? eventName : "") + " from server";
          return ret
        }else {
          if(resp["message"]) {
            ret["message"] = resp["message"]
          }else {
            ret["message"] = "Communication error, please retry or reload the page"
          }
          ret["status"] = "ERROR";
          this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
          return ret
        }
      }
    }
    var responseMessage;
    try {
      responseMessage = $A["util"].$json$.$decode$(text)
    }catch(err$$1) {
      responseMessage = null;
      if($A.$initialized$ && $A["util"].$hasSourceURL$()) {
        err$$1.message += ". context\x3d status: " + response["status"] + ", statusText: " + response["statusText"] + ", requestId: " + requestId + ", responseURL: " + response["responseURL"];
        $A.$logger$.$reportError$(err$$1, null, "ERROR")
      }
    }
    if($A["util"].$isUndefinedOrNull$(responseMessage)) {
      this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
      ret["message"] = "Communication error, please retry or reload the page";
      ret["status"] = "ERROR";
      return ret
    }
    ret["status"] = "SUCCESS";
    ret["message"] = responseMessage;
    this.$notifyListeners$("O11Y", "acs.decode", ["SUCCESS"]);
    return ret
  }catch(error) {
    if(!expectedError) {
      var decodeError = new $A.$auraError$("Unexpected error in AuraClientService.decode", error);
      $A.$logger$.$reportError$(decodeError, null, "ERROR");
      this.$notifyListeners$("O11Y", "acs.decode", ["ERROR"])
    }
    throw error;
  }
};
AuraClientService.prototype.$throwExceptionEvent$ = function(resp) {
  var evtObj = resp["event"];
  var descriptor = evtObj["descriptor"];
  var values = evtObj["attributes"] && evtObj["attributes"]["values"];
  if(evtObj["eventDef"]) {
    $A.$eventService$.$createEventDef$(evtObj["eventDef"])
  }
  if(descriptor === "markup://aura:clientOutOfSync" && $A.getContext().$isCoosWarningEnabled$()) {
    var msg = resp["exceptionMessage"];
    this.$fireCOOSToastEvent$(msg, "error");
    values = {"message":msg};
    evtObj["attributes"] = {"values":values}
  }
  if($A.$eventService$.$hasHandlers$(descriptor)) {
    var evt = $A.$eventService$.$getNewEvent$(descriptor);
    if(evtObj["attributes"]) {
      evt.$setParams$(values)
    }
    evt.$fire$()
  }else {
    switch(descriptor) {
      case "markup://aura:noAccess":
        this.$handleNoAccessException$(values);
        break;
      case "markup://aura:clientOutOfSync":
        this.$handleClientOutOfSyncException$();
        break;
      case "markup://aura:invalidSession":
        this.$handleInvalidSessionException$(values);
        break;
      case "markup://aura:systemError":
        this.$handleSystemErrorException$();
        break;
      default:
        this.$handleGenericEventException$()
    }
  }
};
goog.$exportProperty$(AuraClientService.prototype, "throwExceptionEvent", AuraClientService.prototype.$throwExceptionEvent$);
AuraClientService.prototype.$handleNoAccessException$ = function(values) {
  $A.log("[AuraClientService.handleNoAccessException]: Reloading the page.");
  var redirectURL = values["redirectURL"];
  if(redirectURL) {
    window.location = redirectURL
  }else {
    this.$hardRefresh$()
  }
};
AuraClientService.prototype.$handleClientOutOfSyncException$ = function() {
  $A.log("[AuraClientService.handleClientOutOfSyncException]: Client out of sync.");
  this.$setOutdated$()
};
AuraClientService.prototype.$handleInvalidSessionException$ = function(values) {
  try {
    this.$invalidSession$()
  }catch(e) {
    $A.log("[AuraClientService.handleInvalidSessionException]: Invalid session, reloading the page.");
    window.location.reload(true)
  }
};
AuraClientService.prototype.$handleSystemErrorException$ = function() {
  var e = new Error("[SystemErrorException from server] unknown error");
  e.$reported$ = true;
  throw e;
};
AuraClientService.prototype.$handleGenericEventException$ = function() {
  var e = new Error("[GenericEventException from server] Unable to process event");
  e.$reported$ = true;
  throw e;
};
AuraClientService.prototype.$fireDoneWaiting$ = function() {
  $A.$eventService$.$getNewEvent$("markup://aura:doneWaiting").$fire$()
};
AuraClientService.prototype.$tearDown$ = function() {
  this.$_appNotTearingDown$ = false
};
AuraClientService.prototype.$initializeClientLibraries$ = function() {
  var scripts = document.getElementsByTagName("script");
  if(scripts) {
    var i = 0;
    for(var len = scripts.length;i < len;i++) {
      var script = scripts[i];
      if(script.getAttribute("data-src") && !script.getAttribute("src")) {
        var source = script.getAttribute("data-src");
        var name = source.split("/").pop().split(".").shift().toLowerCase();
        var lib = this.$clientLibraries$[name];
        if(lib && lib["loaded"]) {
          continue
        }
        this.$clientLibraries$[name] = $A["util"].apply(lib || {}, {$script$:script, loaded:false, $loading$:[]})
      }
    }
  }
};
AuraClientService.prototype.$clientLibraryLoadComplete$ = function() {
};
AuraClientService.prototype.$loadClientLibrary$ = function(name, callback) {
  function afterLoad() {
    that.$clientLibraryLoadsInProgress$--;
    $A.$metricsService$.$transactionEnd$("aura", "performance:loadClientLibrary");
    lib.loaded = true;
    for(var i in lib.$loading$) {
      lib.$loading$[i]()
    }
    lib.$loading$ = [];
    that.$clientLibraryLoadComplete$()
  }
  $A.assert(typeof name === "string", "AuraClientService.loadClientLibrary(): name must be a String.");
  name = name.toLowerCase();
  var lib = this.$clientLibraries$[name];
  $A.assert(lib, "AuraClientService.loadClientLibrary(): ClientLibrary has not been registered: " + name);
  if(lib.loaded) {
    return callback()
  }
  if(!lib.$script$) {
    var script = window.document.createElement("script");
    script.setAttribute("data-src", lib.$resourceUrl$.replace("{fwuid}", $A.getContext().$fwuid$));
    window.document.body.appendChild(script);
    lib.$script$ = script
  }
  lib.$loading$ = lib.$loading$ || [];
  lib.$loading$.push($A.$getCallback$(callback));
  if(lib.$loading$.length === 1) {
    this.$clientLibraryLoadsInProgress$++
  }
  var that = this;
  lib.$script$.onload = afterLoad;
  lib.$script$.onerror = function(event) {
    var message = "Failed to load client library: " + lib.$script$.getAttribute("data-src");
    if(event && event.message) {
      message += ". Caused by: " + event.message
    }
    var error = new $A.$auraError$(message, event && event.error);
    error.$setComponent$(name);
    $A.$warning$(message, error);
    $A.$logger$.$reportError$(error);
    afterLoad(error)
  };
  $A.$metricsService$.$transactionStart$("aura", "performance:loadClientLibrary", {"context":{"attributes":{"library":name}}});
  lib.$script$.src = lib.$script$.getAttribute("data-src")
};
goog.$exportProperty$(AuraClientService.prototype, "loadClientLibrary", AuraClientService.prototype.$loadClientLibrary$);
AuraClientService.prototype.$setInCollection$ = function() {
  this.$auraStack$.push("AuraClientService$collection")
};
AuraClientService.prototype.$clearInCollection$ = function() {
  var name = this.$auraStack$.pop();
  $A.assert(name === "AuraClientService$collection")
};
AuraClientService.prototype.$isDisconnectedOrCancelled$ = function(response) {
  if(response && response.status) {
    if(response.status === 0) {
      return true
    }else {
      if(response.status >= 12E3 && response.status < 13E3) {
        return true
      }
    }
  }else {
    return true
  }
  return false
};
AuraClientService.prototype.$singleAction$ = function(action, actionResponse) {
  var needUpdate;
  var needsRefresh;
  needUpdate = action.$updateFromResponse$(actionResponse);
  needsRefresh = action.$isRefreshAction$();
  if(!action.$abortIfComponentInvalid$(false)) {
    if(needUpdate) {
      action.$finishAction$($A.getContext())
    }
    if(needsRefresh) {
      action.$fireRefreshEvent$("refreshEnd", needUpdate)
    }
  }
};
AuraClientService.prototype.$isBB10$ = function() {
  var ua = navigator.userAgent;
  return ua.indexOf("BB10") > 0 && ua.indexOf("AppleWebKit") > 0
};
AuraClientService.prototype.$getManifestURL$ = function() {
  var htmlNode = document.body.parentNode;
  return htmlNode ? htmlNode.getAttribute("manifest") : null
};
AuraClientService.prototype.$isManifestPresent$ = function() {
  return!!this.$getManifestURL$()
};
AuraClientService.prototype.$countAvailableXHRs$ = function() {
  return this.$availableXHRs$.length
};
AuraClientService.prototype.$getAvailableXHR$ = function(isBackground) {
  if(isBackground && this.$availableXHRs$.length === 1) {
    return null
  }
  var auraXHR = this.$availableXHRs$.pop();
  return auraXHR
};
AuraClientService.prototype.$releaseXHR$ = function(auraXHR) {
  if(auraXHR.$isLongRunning$()) {
    this.$decrementLongRunningActionsCount$();
    if(this.$longRunningDeferred$.length > 0) {
      this.$actionsDeferred$ = this.$actionsDeferred$.concat(this.$longRunningDeferred$);
      this.$longRunningDeferred$ = []
    }
  }
  auraXHR.reset();
  this.$availableXHRs$.push(auraXHR);
  if(this.$inFlightXHRs$() === 0) {
    this.$processXHRIdleQueue$()
  }
};
goog.$exportProperty$(AuraClientService.prototype, "releaseXHR", AuraClientService.prototype.$releaseXHR$);
AuraClientService.prototype.$setupBootstrapErrorReloadButton$ = function() {
  var reloadButton = document.getElementById("auraErrorReload");
  if(!reloadButton) {
    return
  }
  reloadButton.href = this.$getHardRefreshURL$()
};
AuraClientService.prototype.$getHardRefreshURL$ = function() {
  var url = location.href;
  if(this.$isBB10$() && window.applicationCache && window.applicationCache.status !== window.applicationCache.UNCACHED) {
    url = location.protocol + "//" + location.host + location.pathname + "?b\x3d" + Date.now()
  }
  var params = "?" + AuraClientService.$CACHE_BUST_QUERY_PARAM$ + "\x3d" + encodeURIComponent(url).replace(/\%20/g, "%2b");
  var hIndex = url.indexOf("#");
  var qIndex = url.indexOf("?");
  var cutIndex = -1;
  if(hIndex > -1 && qIndex > -1) {
    cutIndex = hIndex < qIndex ? hIndex : qIndex
  }else {
    if(hIndex > -1) {
      cutIndex = hIndex
    }else {
      if(qIndex > -1) {
        cutIndex = qIndex
      }
    }
  }
  if(cutIndex > -1) {
    url = url.substring(0, cutIndex)
  }
  var sIndex = url.lastIndexOf("/");
  var appName = url.substring(sIndex + 1, url.length);
  var newUrl = appName + params;
  return newUrl
};
AuraClientService.prototype.$hardRefresh$ = function() {
  var cacheBustKey = "?" + AuraClientService.$CACHE_BUST_QUERY_PARAM$ + "\x3d";
  if(this.$shouldPreventReload$()) {
    var ae = new $A.$auraError$("We can't load the page. Please click Refresh.");
    ae["reported"] = true;
    this.$showErrorDialogWithReload$(ae);
    return
  }
  if(!this.$isManifestPresent$() || location.href.indexOf(cacheBustKey) > -1) {
    $A.log("[AuraClientService.hardRefresh]: Reloading page - " + location.href);
    window.location.reload(true);
    return
  }
  var url = this.$getHardRefreshURL$();
  $A.log("[AuraClientService.hardRefresh]: loading page - " + url);
  history.pushState(null, null, url);
  location.href = url
};
goog.$exportProperty$(AuraClientService.prototype, "hardRefresh", AuraClientService.prototype.$hardRefresh$);
AuraClientService.prototype.$isDevMode$ = function() {
  var context = $A.getContext();
  return!$A["util"].$isUndefined$(context) && context.$getMode$() === "DEV"
};
AuraClientService.prototype.$actualDumpCachesAndReload$ = function(metricsPayload) {
  function reload() {
    $A.log("[AuraClientService:actualDumpCachesAndReload] Reloading the page. Cause - " + JSON.stringify(metricsPayload));
    window.location.reload(true);
    if($A.getContext().$preventConcurrentDumpAndReloadEnabled$) {
      this.$reloadFunction$ = undefined
    }
  }
  this.$cleanUpBeforeReload$(metricsPayload)["then"](reload, reload)
};
AuraClientService.prototype.$dumpCachesAndReload$ = function(force, metricsPayload) {
  if(this.$reloadFunction$) {
    return
  }
  this.$reloadFunction$ = this.$actualDumpCachesAndReload$.bind(this, metricsPayload);
  if(this.$reloadPointPassed$ || force) {
    if(this.$shouldPreventReload$()) {
      var err = new AuraError("We can't load the page. Please click Refresh.");
      var extraMessage = "Bootstrap state: " + JSON.stringify(this.$getBootstrapState$()) + "\nMetrics payload: " + JSON.stringify(metricsPayload);
      err["reported"] = true;
      this.$showErrorDialogWithReload$(err, extraMessage)
    }else {
      this.$reloadFunction$()
    }
    if(!$A.getContext().$preventConcurrentDumpAndReloadEnabled$) {
      this.$reloadFunction$ = undefined
    }
  }
};
AuraClientService.prototype.$shouldPreventReload$ = function() {
  if(!$A["util"].$isSessionStorageEnabled$()) {
    return false
  }
  try {
    var count = window.sessionStorage.getItem(AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$);
    count = +count;
    count = isFinite(count) ? count : 0;
    if(count >= AuraClientService.$INCOMPLETE_BOOT_THRESHOLD$) {
      var idb = window.indexedDB;
      if(idb) {
        idb.deleteDatabase(this.$getActionStorageName$());
        idb.deleteDatabase($A.$componentService$.$getComponentDefStorageName$())
      }
      this.$clearReloadCount$();
      return true
    }
    window.sessionStorage.setItem(AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$, "" + (count + 1));
    return false
  }catch(ignore) {
  }
  return false
};
AuraClientService.prototype.$clearReloadCount$ = function() {
  if(!$A["util"].$isSessionStorageEnabled$()) {
    return
  }
  try {
    window.sessionStorage.removeItem(AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$)
  }catch(ignore) {
  }
};
AuraClientService.prototype.$showErrorDialogWithReload$ = function(e, additionalLoggedMessage) {
  if(e && e.message) {
    $A.message(e.message, e, true);
    if(e["reported"]) {
      return
    }
    try {
      if(additionalLoggedMessage) {
        e.message = e.message + " " + additionalLoggedMessage
      }
      $A.$logger$.$reportError$(e, undefined, "WARNING", true)
    }catch(e2) {
      var xhr = this.$createXHR$();
      xhr.open("POST", "/aura?r\x3d0", true);
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset\x3dISO-8859-13");
      var payload = {"actions":[{"id":"1;a", "descriptor":"aura://ComponentController/ACTION$reportFailedAction", "callingDescriptor":"UNKNOWN", "params":{"failedId":e.id && e.id.toString() || "", "failedAction":e["component"] || "", "clientError":e.message, "clientStack":(e.$stackTrace$ || e.stack || "").toString().substr(0, Aura.$Utils$.$Logger$.$MAX_STACKTRACE_SIZE$), "componentStack":"", "stacktraceIdGen":e["stacktraceIdGen"], "level":"ERROR"}, "version":null}]};
      var context;
      try {
        context = $A.getContext().$encodeForServer$(true)
      }catch(ce) {
        context = $A["util"].$json$.$encode$({"fwuid":AuraClientService.$UNKNOWN_FRAMEWORK_UID$})
      }
      var params = {"message":$A["util"].$json$.$encode$(payload), "aura.context":context};
      var queryString = this.$buildParams$(params);
      xhr.send(queryString)
    }
  }
};
AuraClientService.prototype.$handleAppCache$ = function() {
  function showProgress(progress) {
    if(!isFinite(progress)) {
      return
    }
    acs.$appCacheProgress$ = progress;
    if(!acs.$isDevMode$()) {
      return
    }
    var progressContEl = document.getElementById("auraAppcacheProgress");
    if(progressContEl) {
      if(progress > 0 && progress < 100) {
        progressContEl.style.display = "block";
        var progressEl = progressContEl.firstChild;
        progressEl.firstChild.style.width = progress + "%"
      }else {
        if(progress >= 100) {
          progressContEl.style.display = "none"
        }else {
          if(progress < 0) {
            progressContEl.className = "error"
          }
        }
      }
    }
  }
  function handleAppcacheChecking() {
    acs.$appcacheDownloadingEventFired$ = false
  }
  function handleAppcacheUpdateReady() {
    if(window.applicationCache.swapCache && window.applicationCache.status === window.applicationCache.UPDATEREADY) {
      try {
        window.applicationCache.swapCache()
      }catch(ignore) {
      }
      acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.updateready: Swap old cache for new one."})
    }
  }
  function handleAppcacheError(e) {
    acs.$appCacheError$ = true;
    if(e.stopImmediatePropagation) {
      e.stopImmediatePropagation()
    }
    if(window.applicationCache.status === window.applicationCache.OBSOLETE) {
      return
    }
    if(acs.$isBB10$()) {
      handleAppcacheObsolete();
      return
    }
    if(acs.$isOutdated$ && acs.$appcacheDownloadingEventFired$) {
      acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.error: App gets outdated while downloading app cache resources."});
      return
    }
    showProgress(-1);
    acs.$startBootTimers$();
    acs.$updateAppCacheIfOnlineAndIdle$()
  }
  function handleAppcacheDownloading(e) {
    acs.$appCacheUpdateCount$ = 0;
    acs.$appcacheDownloadingEventFired$ = true;
    var progress = Math.round(100 * e.loaded / e.total);
    showProgress(progress + 1)
  }
  function handleAppcacheProgress(e) {
    var progress = Math.round(100 * e.loaded / e.total);
    showProgress(progress)
  }
  function handleAppcacheNoUpdate() {
    acs.$appCacheUpdateCount$ = 0;
    showProgress(100);
    if(acs.$isOutdated$) {
      acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.noupdate: App gets outdated even if all app cache resources are up to date."})
    }
  }
  function handleAppcacheCached() {
    showProgress(100)
  }
  function handleAppcacheObsolete() {
    acs.$appCacheUpdateCount$ = 0;
    acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.obsolete: App cache resources are obsolete."})
  }
  var acs = this;
  if(window.applicationCache && window.applicationCache.addEventListener) {
    window.applicationCache.addEventListener("checking", handleAppcacheChecking, false);
    window.applicationCache.addEventListener("downloading", handleAppcacheDownloading, false);
    window.applicationCache.addEventListener("updateready", handleAppcacheUpdateReady, false);
    window.applicationCache.addEventListener("error", handleAppcacheError, false);
    window.applicationCache.addEventListener("progress", handleAppcacheProgress, false);
    window.applicationCache.addEventListener("noupdate", handleAppcacheNoUpdate, false);
    window.applicationCache.addEventListener("cached", handleAppcacheCached, false);
    window.applicationCache.addEventListener("obsolete", handleAppcacheObsolete, false)
  }
};
AuraClientService.prototype.$getBootstrapState$ = function() {
  var state = {"inline.js":!!Aura["inlineJsLoaded"], "aura.js":!!Aura["frameworkJsReady"], "bootstrap.js":!!Aura["appBootstrap"] || !!this.$appBootstrap$, "allCssLoaded":!Aura["bootstrap"]["appCssLoading"], "noCssError":!Aura["bootstrap"]["hasCssLoadError"]};
  var ready = Aura["appJsReady"] || [false];
  for(var i = 0;i < ready.length;i++) {
    state["apppart" + (i + 1) + "-" + ready.length + ".js"] = !!ready[i]
  }
  if(this.$isManifestPresent$()) {
    state["appcache"] = this.$appCacheProgress$
  }
  return state
};
AuraClientService.prototype.$getSidTokenState$ = function() {
  if(typeof Aura["getSidToken"] !== "undefined") {
    this.$setSidToken$(Aura["getSidToken"]())
  }
  var state = {"isSidTokenSet":this.$isSidTokenSet$(), "isSidTokenEnabled":!!Aura["bootstrap"]["isSidTokenEnabled"]};
  return state
};
AuraClientService.prototype.$shouldSkipWaitForSid$ = function() {
  try {
    if(!!Aura["bootstrap"] && !!Aura["bootstrap"]["isSidTokenEnabled"] && !this.$isSidTokenSet$()) {
      var sidState = this.$getSidTokenState$();
      if(sidState && !sidState["isSidTokenSet"]) {
        return false
      }
    }
  }catch(error) {
    var message = "[AuraClientService.shouldSkipWaitForSid]: Error when trying to check SID status. Defaulting to true";
    var auraError = new $A.$auraError$(message, error, $A.severity.$QUIET$);
    $A.$logger$.$reportError$(auraError)
  }
  return true
};
var getUrlAllowListForRawXHR;
var getCmpAllowListForRawXHR;
(function() {
  var urlAllowListForRawXHR = Object.freeze(["/_nc_external/system/security/session/SessionTimeServlet", "/chatter/handlers/chatterfile", "/_ui/common/request/servlet/RtaImageUploadServlet", "/_ui/selfservice/servlet/UploadCaseAttachmentsServlet"]);
  var cmpAllowListForRawXHR = Object.freeze(["forceChatter", "salesforceIdentity", "one", "force", "selfService"]);
  getUrlAllowListForRawXHR = function() {
    return urlAllowListForRawXHR
  };
  getCmpAllowListForRawXHR = function() {
    return cmpAllowListForRawXHR
  }
})();
AuraClientService.prototype.$createAndOpenXhr$ = function(cmp, method, url, async, username, password) {
  if(arguments.length <= 4) {
    username = null;
    password = null;
    if(arguments.length === 3) {
      async = true
    }
  }
  return this.$internalCreateAndOpenXhr$(cmp, method, url, async, username, password)
};
goog.$exportProperty$(AuraClientService.prototype, "createAndOpenXhr", AuraClientService.prototype.$createAndOpenXhr$);
AuraClientService.prototype.$startBootTimers$ = function() {
  function getBootProgressed(state1, state2) {
    var change = Object.keys(state1).reduce(function(prev, curr) {
      return prev || state1[curr] !== state2[curr]
    }, false);
    return change
  }
  var that = this;
  if(this.$_bootTimerId$) {
    window.clearTimeout(this.$_bootTimerId$)
  }
  var oldState = this.$getBootstrapState$();
  this.$_bootTimerId$ = window.setTimeout(function ckeckIfAppInitIsStalled() {
    if($A["finishedInit"]) {
      return
    }
    var newState = that.$getBootstrapState$();
    var progress = getBootProgressed(oldState, newState);
    if(progress || window.applicationCache && (window.applicationCache.status === window.applicationCache.CHECKING || window.applicationCache.status === window.applicationCache.DOWNLOADING)) {
      that.$startBootTimers$();
      return
    }
    $A.log("[AuraClientService.startBootTimers]: No progress made, reloading the page.");
    window.location.reload(true)
  }, AuraClientService.$BOOT_TIMER_DURATION$)
};
AuraClientService.prototype.$cleanUpBeforeReload$ = function(metricsPayload) {
  return $A.$componentService$.$clearDefsFromStorage$(metricsPayload)
};
AuraClientService.prototype.$setOutdated$ = function() {
  this.$isOutdated$ = true;
  var logPrefix = "AuraClientService.setOutdated";
  if(!$A.getContext()) {
    this.$actualDumpCachesAndReload$({"cause":logPrefix + ": Exception in inline.js does not create aura context."});
    return
  }
  var appCache = window.applicationCache;
  if(!appCache) {
    this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": App cache not supported."})
  }else {
    if(appCache.status === appCache.UNCACHED) {
      this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": UNCACHED app cache status."})
    }else {
      if(appCache.status === appCache.OBSOLETE) {
        this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": OBSOLETE app cache status."})
      }else {
        if(appCache.status === appCache.IDLE) {
          try {
            $A.log("[" + logPrefix + "]: IDLE app cache status. Check for app cache updates using applicationCache.update()");
            appCache.update()
          }catch(e) {
            this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": IDLE app cache status."})
          }
        }
      }
    }
  }
};
goog.$exportProperty$(AuraClientService.prototype, "setOutdated", AuraClientService.prototype.$setOutdated$);
AuraClientService.prototype.$updateAppCacheIfOnlineAndIdle$ = function() {
  if((!("onLine" in window.navigator) || window.navigator.onLine) && window.applicationCache.status === window.applicationCache.IDLE) {
    if(this.$appCacheUpdateCount$++ > AuraClientService.$INCOMPLETE_BOOT_THRESHOLD$) {
      $A.log("[AuraClientService.updateAppCacheIfOnlineAndIdle]: Application cache update count passed a given threshold and is ignored.");
      return false
    }
    try {
      $A.log("[AuraClientService.updateAppCacheIfOnlineAndIdle]: Check for app cache updates using applicationCache.update()");
      window.applicationCache.update();
      return true
    }catch(ignore) {
    }
  }
  return false
};
AuraClientService.prototype.$setConnected$ = function(isConnected) {
  var isDisconnected = !isConnected;
  if(isDisconnected === this.$_isDisconnected$) {
    return
  }
  var e = $A.$eventService$.$getNewEvent$(isDisconnected ? "aura:connectionLost" : "aura:connectionResumed");
  if(e) {
    this.$_isDisconnected$ = isDisconnected;
    e.$fire$()
  }else {
    alert(isDisconnected ? "Connection lost" : "Connection resumed")
  }
};
goog.$exportProperty$(AuraClientService.prototype, "setConnected", AuraClientService.prototype.$setConnected$);
AuraClientService.prototype.$initHost$ = function(host) {
  this.$_host$ = host || "";
  delete AuraClientService.prototype.$initHost$;
  delete AuraClientService.prototype["initHost"]
};
goog.$exportProperty$(AuraClientService.prototype, "initHost", AuraClientService.prototype.$initHost$);
AuraClientService.prototype.$init$ = function(config, token, container) {
  if(token) {
    this.$_token$ = token
  }
  var context = $A.getContext();
  var rootDef = $A.$componentService$.$getComponentDef$(config["componentDef"]);
  context.$setTokens$(rootDef.$tokens$);
  Aura.$bootstrapMark$("appCreationStart");
  var component = $A.$componentService$.$createComponentPriv$(config);
  Aura.$bootstrapMark$("appCreationEnd");
  this.$setCurrentAccess$(component);
  try {
    Aura.$bootstrapMark$("appRenderingStart");
    $A.$renderingService$.$render$(component, container || document.body);
    $A.$renderingService$.$afterRender$(component)
  }catch(e) {
    if(e instanceof $A.$auraError$) {
      throw e;
    }else {
      throw new $A.$auraError$("Error during rendering in init", e, $A.severity.$QUIET$);
    }
  }finally {
    this.$releaseCurrentAccess$();
    Aura.$bootstrapMark$("appRenderingEnd")
  }
  return component
};
goog.$exportProperty$(AuraClientService.prototype, "init", AuraClientService.prototype.$init$);
AuraClientService.prototype.$getCurrentAccessName$ = function() {
  if(!this.$currentAccess$) {
    return null
  }
  if(this.$currentAccess$.$getType$) {
    return this.$currentAccess$.$getType$()
  }else {
    return this.$currentAccess$.$getDescriptor$().$getFullName$()
  }
};
AuraClientService.prototype.$inFlightXHRs$ = function(excludeBackground) {
  if(excludeBackground) {
    var inFlight = $A["util"].filter(this.$allXHRs$, function(xhr) {
      return this.$availableXHRs$.indexOf(xhr) === -1 && !xhr.background
    }, this);
    return inFlight.length
  }
  return this.$allXHRs$.length - this.$availableXHRs$.length + this.$clientLibraryLoadsInProgress$
};
goog.$exportProperty$(AuraClientService.prototype, "inFlightXHRs", AuraClientService.prototype.$inFlightXHRs$);
AuraClientService.prototype.$maxAllowedParallelXHRCounts$ = function() {
  return this.$allXHRs$.length
};
goog.$exportProperty$(AuraClientService.prototype, "maxAllowedParallelXHRCounts", AuraClientService.prototype.$maxAllowedParallelXHRCounts$);
AuraClientService.prototype.$idle$ = function() {
  return this.$actionsQueued$.length === 0 && this.$actionsDeferred$.length === 0 && this.$availableXHRs$.length === this.$allXHRs$.length
};
AuraClientService.prototype.$runWhenXHRIdle$ = function(f) {
  this.$xhrIdleQueue$.push(f);
  if(this.$inFlightXHRs$() === 0) {
    this.$processXHRIdleQueue$();
    return
  }
};
AuraClientService.prototype.$processXHRIdleQueue$ = function() {
  $A.assert(this.$inFlightXHRs$() === 0, "Idle queue should only be processed when no XHRs are in flight");
  if(this.$xhrIdleQueue$.length === 0) {
    return
  }
  var queue = this.$xhrIdleQueue$;
  this.$xhrIdleQueue$ = [];
  for(var i = 0;i < queue.length;i++) {
    try {
      queue[i]()
    }catch(e) {
      $A.log("AuraClientService.processXHRIdleQueue: error thrown by enqueued function", e)
    }
  }
};
AuraClientService.prototype.$areActionsWaiting$ = function() {
  return!(this.$actionsQueued$.length === 0 && this.$actionsDeferred$.length === 0)
};
AuraClientService.prototype.$setNamespacePrivileges$ = function(sentNs) {
  var namespaces = {"internal":this.$registeredNamespaces$.$internal$, "privileged":this.$registeredNamespaces$.$privileged$};
  if(sentNs) {
    for(var x in namespaces) {
      if(sentNs[x]) {
        for(var i = 0;i < sentNs[x].length;i++) {
          namespaces[x][sentNs[x][i]] = true
        }
      }
    }
  }
};
AuraClientService.prototype.$initDefs$ = function() {
  var ready = Aura["appJsReady"] || [false];
  for(var i = 0;i < ready.length;i++) {
    if(!ready[i]) {
      Aura["appDefsReady"] = this.$initDefs$.bind(this);
      return
    }
  }
  var config = Aura["ApplicationDefs"];
  if(config) {
    var libraryDefs = config["libExporter"];
    for(i in libraryDefs) {
      $A.$componentService$.$addLibraryExporter$(i, libraryDefs[i])
    }
    var cmpExporter = config["cmpExporter"];
    for(i in cmpExporter) {
      $A.$componentService$.$addComponent$(i, cmpExporter[i])
    }
    $A.$componentService$.$initEventDefs$(config["eventDefs"]);
    $A.$componentService$.$initLibraryDefs$(config["libraryDefs"]);
    $A.$componentService$.$initControllerDefs$(config["controllerDefs"]);
    $A.$componentService$.$initModuleDefs$(config["moduleDefs"]);
    delete Aura["ApplicationDefs"]
  }
  this.$finishedInitDefs$ = true;
  if(Aura["afterAppDefsReady"]) {
    Aura["afterAppDefsReady"].forEach(function(fn) {
      fn()
    })
  }
  Aura["afterDefsReady"] = true;
  delete Aura["afterAppDefsReady"]
};
goog.$exportProperty$(AuraClientService.prototype, "initDefs", AuraClientService.prototype.$initDefs$);
AuraClientService.prototype.$getAppBootstrap$ = function() {
  if(Aura["appBootstrapStatus"] === "loaded") {
    return Aura["appBootstrap"]
  }else {
    if(Aura["appBootstrapStatus"] === "failed") {
      if(!window.applicationCache || window.applicationCache.status === window.applicationCache.UNCACHED || window.applicationCache.status === window.applicationCache.IDLE) {
        this.$dumpCachesAndReload$(false, {"cause":"AuraClientService.getAppBootstrap: Failed to load bootstrap.js."})
      }
    }
  }
  return undefined
};
AuraClientService.prototype.$setAppBootstrapStatus$ = function() {
  if(Aura["appBootstrapStatus"] === "loaded") {
    return
  }
  Aura["appBootstrapStatus"] = "failed";
  if(Aura["afterBootstrapReady"] && Aura["afterBootstrapReady"].length) {
    var queue = Aura["afterBootstrapReady"];
    Aura["afterBootstrapReady"] = [];
    for(var i = 0;i < queue.length;i++) {
      queue[i]()
    }
  }
};
AuraClientService.prototype.$runAfterBootstrapReady$ = function(callback) {
  Aura["afterBootstrapReady"] = Aura["afterBootstrapReady"] || [];
  if(this.$appBootstrap$) {
    callback.call(this, this.$appBootstrap$["data"]["app"]);
    return
  }
  var bootstrap = this.$getAppBootstrap$();
  if(!bootstrap) {
    Aura["afterBootstrapReady"].push(this.$runAfterBootstrapReady$.bind(this, callback));
    return
  }
  if(bootstrap["error"]) {
    if(bootstrap["error"]["exceptionEvent"]) {
      this.$throwExceptionEvent$(bootstrap["error"]);
      return
    }else {
      throw new $A.$auraError$("Aura.loadComponent(): Failed to initialize application.\n" + bootstrap["error"]["message"]);
    }
  }
  if(bootstrap["token"]) {
    $A.log("AuraClientService.runAfterBootstrapReady(): Received updated token from bootstrap");
    this.$setToken$(bootstrap["token"]);
    if(bootstrap["csrfV2"]) {
      this.$_csrfV2$ = true
    }
  }else {
    if(bootstrap["eikoocnekot"]) {
      var token = this.$buildToken$(bootstrap["eikoocnekot"], true);
      $A.log("AuraClientService.runAfterBootstrapReady(): Received updated token from bootstrap cookie");
      this.$setToken$(token);
      this.$_csrfV2$ = true
    }
  }
  if(this.$tokenSharing$ && this.$_token$) {
    $A.log("AuraClientService.runAfterBootstrapReady(): Broadcasting token received during bootstrap");
    var context = $A.getContext();
    this.$broadcastToken$(this.$_token$, context.$getApp$() || context.$getCmp$())
  }
  try {
    if(bootstrap["data"] && bootstrap["data"]["components"]) {
      bootstrap["context"]["components"] = bootstrap["data"]["components"]
    }
    if(bootstrap["context"]) {
      $A.getContext()["mergeContext"](bootstrap["context"])
    }
  }catch(e) {
    throw new $A.$auraError$("AuraClientService.runAfterBootstrapReady: bootstrap failed to merge");
  }
  this.$appBootstrap$ = bootstrap;
  delete Aura["appBootstrap"];
  callback.call(this, bootstrap["data"]["app"])
};
AuraClientService.prototype.$runAfterInitDefs$ = function(callback) {
  if(this.$finishedInitDefs$) {
    return callback()
  }
  Aura["afterAppDefsReady"] = Aura["afterAppDefsReady"] || [];
  Aura["afterAppDefsReady"].push(callback)
};
AuraClientService.prototype.$runAfterAppReady$ = function(callback) {
  if($A["finishedInit"]) {
    return callback()
  }
  Aura["afterAppReady"] = Aura["afterAppReady"] || [];
  Aura["afterAppReady"].push(callback)
};
AuraClientService.prototype.$initializeApplication$ = function() {
  Aura.$bootstrapMark$("runAfterContextCreated");
  var self = this;
  return new Promise(function(resolve) {
    self.$runAfterInitDefs$(function() {
      Aura.$bootstrapMark$("runAfterInitDefsReady");
      self.$runAfterBootstrapReady$(function(bootConfig) {
        if(Aura["afterBootstrapReady"] && Aura["afterBootstrapReady"].length) {
          var queue = Aura["afterBootstrapReady"];
          Aura["afterBootstrapReady"] = [];
          for(var i = 0;i < queue.length;i++) {
            queue[i]()
          }
        }
        Aura.$bootstrapMark$("runAfterBootstrapReady");
        resolve(bootConfig)
      })
    })
  })
};
AuraClientService.prototype.$initializeInjectedServices$ = function(services) {
  if(services) {
    var serviceRegistry = this.$moduleServices$;
    services.forEach(function initializeService(serviceDefinition) {
      var serviceModule = $A.$componentService$.$evaluateModuleDef$(serviceDefinition);
      var serviceConstructor = serviceModule["default"] || serviceModule;
      var service = serviceConstructor(Aura.$ServiceApi$, $A.$componentService$.$moduleEngine$);
      $A.assert(service.name, "Unknown service name");
      serviceRegistry[service.name] = service
    })
  }
};
AuraClientService.prototype.$addScopedModuleResolver$ = function(scope, resolver) {
  $A.assert(typeof resolver === "function", "Scoped module resolver must be a function");
  this.$moduleScopedImports$[scope] = resolver
};
goog.$exportProperty$(AuraClientService.prototype, "addScopedModuleResolver", AuraClientService.prototype.$addScopedModuleResolver$);
AuraClientService.prototype.$resolveScopedModuleImport$ = function(scope, fullImport) {
  if(!this.$moduleScopedImportsCache$[fullImport]) {
    var resolver = this.$moduleScopedImports$[scope];
    var defaultResolver = this.$defaultModuleScopedImports$[scope];
    $A.assert(resolver || defaultResolver, "No resolver found for scoped module import '" + fullImport + "'.");
    var resolvedValue = resolver && resolver(fullImport);
    if(resolvedValue === undefined && defaultResolver) {
      resolvedValue = defaultResolver(fullImport)
    }
    this.$moduleScopedImportsCache$[fullImport] = resolvedValue
  }
  return this.$moduleScopedImportsCache$[fullImport]
};
AuraClientService.prototype.$defaultSalesforceImportResolver$ = function(fullImport) {
  var path = fullImport.substring(12);
  var parts = path.split("/");
  var key = parts[0];
  switch(key) {
    case "label":
      return $A.get("$Label." + parts[1]);
    case "loader":
      return this.$defaultLoaderResolver$();
    case "i18n":
      return this.$defaultI18nResolver$(parts[1]);
    case "client":
      return this.$defaultClientResolver$(parts[1]);
    case "cssvars":
      return function(cssVar, fallback) {
        return $A.$clientService$.$cssVars$[cssVar.slice(2)] || fallback || "inherit"
      };
    case "gate":
      return{"isOpen":function(fallbackObj) {
        return fallbackObj.$fallback$
      }, "hasError":function() {
        return true
      }};
    default:
      return undefined
  }
};
AuraClientService.prototype.$VALID_IDENTIFIER_REGEX$ = /^[A-Z_][0-9A-Z_]*$/i;
AuraClientService.prototype.$isValidModuleNameFormat$ = function(moduleName) {
  if(typeof moduleName !== "string") {
    return false
  }
  var parts = moduleName.split("/");
  var validIdentifierRegex = AuraClientService.prototype.$VALID_IDENTIFIER_REGEX$;
  return parts.length === 2 && validIdentifierRegex.test(parts[0]) && validIdentifierRegex.test(parts[1])
};
AuraClientService.prototype.$normalizeImportedModule$ = function(importedModule) {
  var normalizedModuleDef;
  var getModuleExportPropertyDescriptor = function(module, exportName) {
    return{configurable:false, enumerable:true, get:function() {
      return module[exportName]
    }}
  };
  if(importedModule && importedModule["__esModule"]) {
    normalizedModuleDef = importedModule
  }else {
    normalizedModuleDef = {"default":importedModule}
  }
  var moduleDef = {};
  for(var key in normalizedModuleDef) {
    Object.defineProperty(moduleDef, key, getModuleExportPropertyDescriptor(normalizedModuleDef, key))
  }
  Object.seal(moduleDef);
  return moduleDef
};
AuraClientService.prototype.$loader$ = {$importedModuleRegistry$:{}, load:function(moduleName, accessDescriptor) {
  var isScopedImport = moduleName[0] === "@";
  if(isScopedImport) {
    var moduleScope = moduleName.substr(1).split("/")[0];
    return $A.$clientService$.$resolveScopedModuleImport$(moduleScope, moduleName)
  }
  var self = this;
  var isValidModuleNameFormat = AuraClientService.prototype.$isValidModuleNameFormat$(moduleName);
  return new Promise(function(resolve, reject) {
    if(!isValidModuleNameFormat) {
      return reject(new Error('"' + moduleName + "\" is not a valid module specifier in LWC. The syntax must be: import('{namespace}/{componentName}')"))
    }
    var internalModuleName = moduleName.replace("/", ":");
    Aura.$ExportsModule$["getDefinition"](internalModuleName, function(def) {
      var resolvedModule = self.$importedModuleRegistry$[internalModuleName];
      if(resolvedModule) {
        return resolve(resolvedModule)
      }
      if(!def) {
        return reject(new Error('Definition for module "' + moduleName + '" was not found'))
      }
      var normalizedModule = AuraClientService.prototype.$normalizeImportedModule$(def.$interopClass$);
      self.$importedModuleRegistry$[internalModuleName] = normalizedModule;
      resolve(normalizedModule)
    }, true, accessDescriptor)
  })
}};
AuraClientService.prototype.$defaultLoaderResolver$ = function() {
  return AuraClientService.prototype.$loader$
};
AuraClientService.prototype.$defaultI18nResolver$ = function(resource) {
  if(!this.$i18nImportMap$) {
    this.$i18nImportMap$ = {"lang":"lang", "dir":"dir", "firstDayOfWeek":"firstDayOfWeek", "timeZone":"timezone", "currency":"currencyCode", "dateTime.shortDateFormat":"shortDateFormat", "dateTime.mediumDateFormat":"dateFormat", "dateTime.longDateFormat":"longDateFormat", "dateTime.shortDateTimeFormat":"shortDatetimeFormat", "dateTime.mediumDateTimeFormat":"datetimeFormat", "dateTime.shortTimeFormat":"shortTimeFormat", "dateTime.mediumTimeFormat":"timeFormat", "number.numberFormat":"numberFormat", 
    "number.percentFormat":"percentFormat", "number.currencyFormat":"currencyFormat", "number.currencySymbol":"currency", "number.groupingSeparator":"grouping", "number.decimalSeparator":"decimal", "showJapaneseCalendar":"showJapaneseImperialYear"}
  }
  if(resource === "locale") {
    var locale = Intl["getCanonicalLocales"]($A.get("$Locale.userLocale"))[0];
    return Intl["DateTimeFormat"]["supportedLocalesOf"](locale)[0]
  }
  return $A.get("$Locale." + this.$i18nImportMap$[resource])
};
AuraClientService.prototype.$defaultClientResolver$ = function(resource) {
  if(resource !== "formFactor") {
    return undefined
  }
  if(!this.$clientFormFactorMap$) {
    this.$clientFormFactorMap$ = {"DESKTOP":"Large", "TABLET":"Medium", "PHONE":"Small"}
  }
  return this.$clientFormFactorMap$[$A.get("$Browser.formFactor")]
};
AuraClientService.prototype.$babelHelpersResolver$ = function(fullImport) {
  var parts = fullImport.split("/");
  var helperName = parts.pop();
  var type = parts.pop();
  if(type === "helpers") {
    return Aura["compat"]["babelHelpers"][helperName]
  }else {
    if(helperName === "regenerator") {
      return Aura["compat"]["regenerator"]
    }
  }
};
AuraClientService.prototype.$lockerResolver$ = function(fullImport) {
  if(fullImport === "@locker/sandbox") {
    return{"evaluateInCoreSandbox":function() {
      $A.$lockerService$.$evaluateInCoreSandbox$.apply($A.$lockerService$, arguments)
    }, "evaluateInSandbox":function() {
      $A.$lockerService$.$evaluateInSandbox$.apply($A.$lockerService$, arguments)
    }}
  }
  return undefined
};
AuraClientService.prototype.$inAuraLoop$ = function() {
  return this.$auraStack$.length > 0
};
AuraClientService.prototype.$pushStack$ = function(name) {
  this.$auraStack$.push(name)
};
AuraClientService.prototype.$popStack$ = function(name) {
  var lastName;
  if(this.$auraStack$.length > 0) {
    lastName = this.$auraStack$.pop();
    $A.assert(lastName === name, "Broken stack: popped " + lastName + " expected " + name + ", stack \x3d " + this.$auraStack$)
  }else {
    $A.$warning$("Pop from empty stack")
  }
  if(this.$auraStack$.length === 0) {
    this.$auraStack$.push("AuraClientService$popStack");
    this.$postProcess$()
  }
};
AuraClientService.prototype.$postProcess$ = function() {
  if(this.$auraStack$.length === 1 && this.$auraStack$[0] === "AuraClientService$popStack") {
    try {
      this.$process$()
    }catch(e) {
      throw e instanceof $A.$auraError$ ? e : new $A.$auraError$("AuraClientService.postProcess: error in processing", e);
    }finally {
      this.$auraStack$.pop()
    }
  }
};
AuraClientService.prototype.$process$ = function() {
  if(this.$collector$) {
    return
  }
  this.$collector$ = new Aura.$Services$.$AuraClientService$AuraActionCollector$;
  this.$continueProcessing$()
};
AuraClientService.prototype.$continueProcessing$ = function() {
  var i;
  var index = 0;
  var action;
  var actionList;
  var isStorageEnabled = this.$actionStorage$.$isStorageEnabled$();
  this.$collector$.$actionsToCollect$ += 1;
  actionList = this.$actionsQueued$;
  this.$actionsQueued$ = [];
  for(i = 0;i < actionList.length;i++) {
    action = actionList[i];
    try {
      if(action.$abortIfComponentInvalid$(true)) {
        continue
      }
      if(action.$getDef$().$isServerAction$()) {
        this.$collector$.$actionsToCollect$ += 1;
        this.$collector$.$collected$[index] = undefined;
        this.$collector$.$collecting$[index] = action;
        if(!action.$isRefreshAction$() && action.$isStorable$() && isStorageEnabled) {
          this.$collectStorableAction$(action, index)
        }else {
          this.$collectServerAction$(action, index)
        }
        index += 1
      }else {
        this.$collector$.$clientActions$.push(action)
      }
    }catch(e) {
      var errorWrapper = new $A.$auraError$(null, e);
      errorWrapper.action = action;
      $A.$logger$.$reportError$(errorWrapper)
    }
  }
  this.$processStorableActions$();
  this.$collector$.$actionsToCollect$ -= 1;
  this.$collector$.$clientIndex$ = 0;
  if(this.$optionClientSynchronous$) {
    this.$runClientActions$()
  }else {
    this.$continueClientActions$()
  }
};
AuraClientService.prototype.$collectStorableAction$ = function(action, index) {
  this.$collector$.$collectedStorableActions$[index] = action
};
AuraClientService.prototype.$allDefsExistOnClient$ = function(actionItem, response, callback, callbackArg) {
  var exist = false;
  if(response === undefined) {
    callback(exist, callbackArg);
    return
  }
  var deps = response["defDependencies"];
  if($A["util"].$isObject$(deps)) {
    if($A.getContext().$uriAddressableDefsEnabled$) {
      for(var dep in deps) {
        var config = deps[dep];
        if($A["util"].$isObject$(config)) {
          if(config[Json.$ApplicationKey$["NAME"]] && config[Json.$ApplicationKey$.$CODE$]) {
            $A.$componentService$.$initModuleDefs$([config])
          }else {
            $A.$componentService$.$saveComponentConfig$(config)
          }
        }
      }
      $A.$componentService$.$loadComponentDefs$(deps, function(err) {
        callback(!err, callbackArg, err)
      });
      return
    }else {
      for(var descriptor in deps) {
        if($A.$componentService$.$hasCacheableDefinitionOfAnyType$(descriptor)) {
          continue
        }
        $A.$metricsService$.transaction("aura", "performance:stored-action-missing-defs", {"context":{"attributes":{"action":actionItem.action.$def$.$descriptor$, "missingDef":descriptor, "requiredDefs":Object.keys(deps)}}});
        callback(exist, callbackArg);
        return
      }
      exist = true
    }
  }else {
    exist = true
  }
  callback(exist, callbackArg)
};
AuraClientService.prototype.$processStorableActions$ = function() {
  function actionStorageGetAllSuccess(items) {
    var existsCallback = function(exists, args) {
      try {
        if(exists) {
          that.$executeStoredAction$(args.$actionItem$.action, args.value, that.$collector$.$collected$, args.$actionItem$.index);
          that.$collector$.$actionsToCollect$ -= 1;
          that.$finishCollection$()
        }else {
          that.$collectServerAction$(args.$actionItem$.action, args.$actionItem$.index)
        }
      }catch(e) {
        $A.$logger$.$reportError$(e)
      }
    };
    for(var k in keysToActions) {
      arr = keysToActions[k];
      var value = loadLabelsFromStorage ? items[0][k] : items[k];
      for(var j = 0;j < arr.length;j++) {
        if(!value) {
          that.$collectServerAction$(arr[j].action, arr[j].index);
          continue
        }
        that.$allDefsExistOnClient$(arr[j], value, existsCallback, {value:value, $actionItem$:arr[j]})
      }
    }
    that.$finishCollection$()
  }
  function actionStorageGetAllError() {
    for(var keyToAction in keysToActions) {
      arr = keysToActions[keyToAction];
      for(var l = 0;l < arr.length;l++) {
        that.$collectServerAction$(arr[l].action, arr[l].index)
      }
    }
  }
  function actionStorageGetAllError2(error) {
    $A.$warning$(undefined, error);
    $A.$logger$.$reportError$(error)
  }
  var arr;
  var i;
  var action;
  if(this.$collector$.$collectedStorableActions$.length === 0) {
    return
  }
  var collectedStorableActions = this.$collector$.$collectedStorableActions$;
  this.$collector$.$collectedStorableActions$ = [];
  if(!this.$actionStorage$.$isStorageEnabled$()) {
    for(i = 0;i < collectedStorableActions.length;i++) {
      action = collectedStorableActions[i];
      if(!action) {
        this.$collectServerAction$(action, i)
      }
    }
    return
  }
  var keysToActions = {};
  var key;
  var loadLabelsFromStorage = false;
  for(i = 0;i < collectedStorableActions.length;i++) {
    action = collectedStorableActions[i];
    if(action) {
      key = action.$getStorageKey$();
      if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
        this.$collectServerAction$(action, i);
        continue
      }
      arr = keysToActions[key];
      if(!arr) {
        arr = [];
        keysToActions[key] = arr
      }
      arr.push({action:action, index:i});
      if(action.$def$.$descriptor$ === "aura://DynamicComponentController/ACTION$getTemplateDescriptorWithExpansionBundle" && $A.getContext().$uriAddressableDefsEnabled$ && this.$labelsFromStorage$) {
        loadLabelsFromStorage = true
      }
    }
  }
  if(Object.keys(keysToActions).length === 0) {
    return
  }
  var that = this;
  if(loadLabelsFromStorage) {
    Promise["all"]([this.$actionStorage$.$getAll$(Object.keys(keysToActions)), $A.getContext().$globalValueProviders$.$loadLabelsFromStorage$()])["then"](actionStorageGetAllSuccess, actionStorageGetAllError)["then"](undefined, actionStorageGetAllError2)
  }else {
    this.$actionStorage$.$getAll$(Object.keys(keysToActions))["then"](actionStorageGetAllSuccess, actionStorageGetAllError)["then"](undefined, actionStorageGetAllError2)
  }
};
AuraClientService.prototype.$persistStorableActions$ = function(actions) {
  var action;
  var key;
  var value;
  var doStore = false;
  var values = {};
  for(var i = 0;i < actions.length;i++) {
    action = actions[i];
    value = action.$getStored$();
    if(value) {
      try {
        key = action.$getStorageKey$()
      }catch(e) {
        var message = "AuraClientService.persistStorableActions(): Failed to get action storage key";
        var auraError = new $A.$auraError$(message, e);
        $A.$logger$.$reportError$(auraError, action);
        continue
      }
      doStore = true;
      values[key] = value
    }
  }
  if(doStore && this.$actionStorage$.$isStorageEnabled$()) {
    return this.$actionStorage$.$setAll$(values)["then"](undefined, function actionStorageSetAllError(error) {
      var keys = Object.keys(values);
      $A.$warning$("AuraClientService.persistStorableActions, problem storing " + keys.length + " actions:\n" + keys.join("\n") + "\n" + error)
    })
  }
  return Promise["resolve"]()
};
AuraClientService.prototype.$enqueueStoredAction$ = function(action, response) {
  this.$collector$.$actionsToComplete$.push({"action":action, "response":response})
};
AuraClientService.prototype.$executeStoredAction$ = function(action, response, collected, index) {
  var refreshAction = null;
  this.$setInCollection$();
  try {
    if(!action.$abortIfComponentInvalid$(false)) {
      try {
        action.$updateFromResponse$(response);
        action.$finishAction$($A.getContext())
      }catch(e) {
        refreshAction = action.$getRetryFromStorageAction$();
        $A.$warning$("Finishing cached action failed. Trying to refetch from server: " + refreshAction.$getStorageKey$(), e);
        $A.getContext().$clearComponentConfigs$(action.$getId$())
      }
      this.$collector$.$actionsCompleted$ += 1;
      if(!refreshAction) {
        refreshAction = action.$getRefreshAction$(response)
      }
      if(refreshAction) {
        action.$fireRefreshEvent$("refreshBegin");
        collected[index] = refreshAction
      }
    }
  }catch(e$$0) {
    var auraError = new $A.$auraError$("AuraClientService.executeStoredAction(): error happened when processing stored action", e$$0);
    $A.$logger$.$reportError$(auraError, action)
  }finally {
    this.$clearInCollection$()
  }
};
AuraClientService.prototype.$collectServerAction$ = function() {
  this.$notifyListeners$("PRE", "collectServerAction", arguments);
  this.$collectServerActionInternal$.apply(this, arguments);
  this.$notifyListeners$("POST", "collectServerAction", arguments)
};
AuraClientService.prototype.$collectServerActionInternal$ = function(action, index) {
  this.$collector$.$collected$[index] = action;
  this.$collector$.$actionsToCollect$ -= 1;
  this.$finishCollection$()
};
AuraClientService.prototype.$continueClientActions$ = function() {
  var that = this;
  if(this.$collector$.$clientIndex$ < this.$collector$.$clientActions$.length) {
    setTimeout(function deferedContinueClientActions() {
      that.$setInCollection$();
      that.$executeClientAction$(that.$collector$.$clientActions$[that.$collector$.$clientIndex$]);
      that.$clearInCollection$();
      that.$collector$.$clientIndex$ += 1;
      that.$continueClientActions$()
    }, 0)
  }else {
    this.$collector$.$clientActions$ = [];
    this.$finishCollection$()
  }
};
AuraClientService.prototype.$runClientActions$ = function() {
  var i;
  this.$setInCollection$();
  for(i = 0;i < this.$collector$.$clientActions$.length;i++) {
    this.$executeClientAction$(this.$collector$.$clientActions$[i])
  }
  this.$clearInCollection$();
  this.$collector$.$clientActions$ = [];
  this.$finishCollection$()
};
AuraClientService.prototype.$executeClientAction$ = function(action) {
  try {
    if(!action.$abortIfComponentInvalid$(false)) {
      action.$runDeprecated$();
      action.$finishAction$($A.getContext())
    }
  }catch(ignore) {
  }
};
AuraClientService.prototype.$finishCollection$ = function() {
  if(!this.$collector$ || this.$collector$.$actionsToCollect$ !== 0 || this.$collector$.$clientActions$.length) {
    return
  }
  if(this.$collector$.$actionsCompleted$) {
    this.$fireDoneWaiting$()
  }
  var i = 0;
  var length;
  var collected = this.$collector$.$collected$;
  this.$collector$.$collected$ = [];
  for(i = 0, length = collected.length;i < length;i++) {
    if(collected[i]) {
      this.$actionsDeferred$.push(collected[i])
    }
  }
  if(this.$actionsQueued$.length) {
    this.$continueProcessing$();
    return
  }
  if(this.$actionsDeferred$.length) {
    this.$sendActionXHRs$()
  }
  if(this.$collector$.$actionsToComplete$.length) {
    for(i = 0;i < this.$collector$.$actionsToComplete$.length;i++) {
      this.$collector$.$collected$.push(undefined)
    }
    this.$continueCompletions$()
  }else {
    this.$finishProcessing$()
  }
};
AuraClientService.prototype.$shouldSendOutForegroundActions$ = function(foregroundActions, cabooseCount) {
  if(foregroundActions.length > cabooseCount || cabooseCount > 0 && Date.now() - this.$lastSendTime$ > 6E4) {
    return true
  }else {
    return false
  }
};
AuraClientService.prototype.$sendActionXHRs$ = function() {
  var processing;
  var foreground = [];
  var background = [];
  var foregroundLongRunning = [];
  var backgroundLongRunning = [];
  var publiclyCacheableAndBackground = [];
  var publiclyCacheable = [];
  var deferred = [];
  var action;
  var auraXHR;
  var caboose = 0;
  var i;
  processing = this.$actionsDeferred$;
  this.$actionsDeferred$ = [];
  for(i = 0;i < processing.length;i++) {
    action = processing[i];
    if(action.$abortIfComponentInvalid$(true)) {
      continue
    }
    if(action.$isDeferred$()) {
      deferred.push(action)
    }else {
      if(action.$isLongRunning$()) {
        if(action.$isBackground$()) {
          backgroundLongRunning.push(action)
        }else {
          foregroundLongRunning.push(action)
        }
      }else {
        if(!action.$isBackground$() && action.$isPubliclyCacheable$()) {
          publiclyCacheable.push(action)
        }else {
          if(action.$isBackground$() && action.$isPubliclyCacheable$()) {
            publiclyCacheableAndBackground.push(action)
          }else {
            if(action.$isBackground$()) {
              background.push(action)
            }else {
              foreground.push(action);
              if(action.$isCaboose$()) {
                caboose += 1
              }
            }
          }
        }
      }
    }
  }
  if(this.$xhrExclusivity$) {
    this.$sendAsSingle$(foreground, foreground.length, {background:false})
  }else {
    if(this.$shouldSendOutForegroundActions$(foreground, caboose) && this.$shouldSkipWaitForSid$()) {
      auraXHR = this.$getAvailableXHR$(false);
      if(auraXHR) {
        if(!this.$sendWrapper$(auraXHR, foreground, "POST")) {
          this.$releaseXHR$(auraXHR)
        }
      }
    }
    if(!auraXHR) {
      this.$actionsDeferred$ = this.$actionsDeferred$.concat(foreground)
    }
  }
  if(publiclyCacheable.length) {
    this.$sendAsSingle$(publiclyCacheable, publiclyCacheable.length, {background:false})
  }
  if(foregroundLongRunning.length) {
    this.$sendAsSingle$(foregroundLongRunning, foregroundLongRunning.length, {background:false})
  }
  if(publiclyCacheableAndBackground.length) {
    this.$sendAsSingle$(publiclyCacheableAndBackground, publiclyCacheableAndBackground.length, {background:true})
  }
  if(background.length) {
    this.$sendAsSingle$(background, background.length, {background:true})
  }
  if(backgroundLongRunning.length) {
    this.$sendAsSingle$(backgroundLongRunning, backgroundLongRunning.length, {background:true})
  }
  if(deferred.length) {
    if(this.$idle$()) {
      this.$sendAsSingle$(deferred, deferred.length, {background:true})
    }else {
      this.$actionsDeferred$ = this.$actionsDeferred$.concat(deferred)
    }
  }
};
AuraClientService.prototype.$sendAsSingle$ = function(actions, count, options) {
  var i;
  var sent = 0;
  var auraXHR;
  var action;
  var background = options && options.background;
  for(i = 0;i < actions.length;i++) {
    action = actions[i];
    if(this.$deDupe$(action, false)) {
      continue
    }
    auraXHR = undefined;
    if(sent < count) {
      sent += 1;
      if(action.$isLongRunning$() && this.$getAvailableLongRunningActionsCount$() === 0) {
        this.$longRunningDeferred$.push(action);
        continue
      }
      auraXHR = this.$getAvailableXHR$(background);
      if(auraXHR) {
        if(action.$isLongRunning$()) {
          this.$incrementLongRunningActionsCount$();
          auraXHR.$setLongRunning$()
        }
        if(!this.$sendWrapper$(auraXHR, [action], action.$isPubliclyCacheable$() ? "GET" : "POST", options)) {
          this.$releaseXHR$(auraXHR)
        }
      }
    }
    if(!auraXHR) {
      this.$actionsDeferred$.push(action)
    }
  }
};
AuraClientService.prototype.$continueCompletions$ = function() {
  var that = this;
  if(this.$collector$.$completionIndex$ < this.$collector$.$actionsToComplete$.length) {
    setTimeout(function deferedContinueCompletions() {
      var collected = [null];
      var completion = that.$collector$.$actionsToComplete$[that.$collector$.$completionIndex$];
      that.$executeStoredAction$(completion["action"], completion["response"], collected, 0);
      that.$collector$.$completionIndex$ += 1;
      if(collected[0]) {
        that.$enqueueAction$(collected[0])
      }
      that.$continueCompletions$()
    }, 0)
  }else {
    if(this.$actionsQueued$.length) {
      this.$continueProcessing$()
    }else {
      this.$finishProcessing$()
    }
  }
};
AuraClientService.prototype.$finishProcessing$ = function() {
  this.$setInCollection$();
  try {
    $A.$renderingService$.$rerenderDirty$()
  }finally {
    this.$clearInCollection$();
    if(this.$actionsQueued$.length > 0) {
      this.$continueProcessing$()
    }else {
      this.$collector$ = undefined
    }
  }
};
AuraClientService.prototype.$deDupe$ = function(action, sending) {
  var key;
  var entry;
  var dupes;
  if(!action.$isStorable$()) {
    return false
  }
  try {
    key = action.$getStorageKey$()
  }catch(e) {
    return false
  }
  entry = this.$actionStoreMap$[key];
  if(entry && !(entry.action.$getState$() === "NEW" || entry.action.$getState$() === "RUNNING")) {
    dupes = entry.$dupes$;
    $A.$warning$("Unfinished handling of action for key " + key);
    entry = undefined
  }
  if(!entry) {
    if(!sending) {
      return false
    }
    entry = {};
    entry.action = action;
    if(dupes) {
      entry.$dupes$ = dupes
    }
    this.$actionStoreMap$[key] = entry;
    this.$actionStoreMap$[action.$getId$()] = key;
    return false
  }else {
    if(entry.action !== action) {
      if(!entry.$dupes$) {
        entry.$dupes$ = [action]
      }else {
        entry.$dupes$.push(action)
      }
      return true
    }
  }
  return false
};
AuraClientService.prototype.$getAndClearDupes$ = function(key) {
  if(!key || !this.$actionStoreMap$[key]) {
    return undefined
  }
  var entry;
  var dupes;
  entry = this.$actionStoreMap$[key];
  dupes = entry.$dupes$;
  delete this.$actionStoreMap$[entry.action.$getId$()];
  delete this.$actionStoreMap$[key];
  return dupes
};
AuraClientService.prototype.$sendWrapper$ = function() {
  this.$notifyListeners$("PRE", "send", arguments);
  var retVal = this.send.apply(this, arguments);
  this.$notifyListeners$("POST", "send", retVal, arguments);
  return retVal
};
AuraClientService.prototype.send = function(auraXHR, actions, method, options) {
  return this.$internalSend$(auraXHR, actions, method, options)
};
AuraClientService.prototype.$prepareRequest$ = function(actions) {
  var params = {"message":$A["util"].$json$.$encode$({"actions":actions}), "aura.context":$A.getContext().$encodeForServer$(true), "aura.token":this.$_token$};
  return this.$buildParams$(params)
};
AuraClientService.prototype.$sendBeacon$ = function(actions) {
  actions = $A["util"].isArray(actions) ? actions : [actions];
  var hasSendBeaconSupport = false;
  try {
    hasSendBeaconSupport = window.navigator && window.navigator["sendBeacon"] && window.Blob
  }catch(e) {
    $A.$warning$("Window is in-accessible")
  }
  if(hasSendBeaconSupport) {
    try {
      var blobObj = new Blob([this.$prepareRequest$(actions)], {"type":"application/x-www-form-urlencoded; charset\x3dISO-8859-13"});
      return window.navigator["sendBeacon"](this.$_host$ + "/auraAnalytics", blobObj)
    }catch(e$$0) {
      $A.$warning$("Unable to parse action payload")
    }
  }else {
    actions.forEach(function enqueueActionCaller(action) {
      $A.$enqueueAction$(action)
    });
    return true
  }
};
goog.$exportProperty$(AuraClientService.prototype, "sendBeacon", AuraClientService.prototype.$sendBeacon$);
AuraClientService.prototype.$xhrSetTimeout$ = function(f) {
  return setTimeout(f, this.$xhrTimeout$)
};
AuraClientService.prototype.$xhrClearTimeout$ = function(id) {
  return clearTimeout(id)
};
AuraClientService.prototype.$createXHR$ = function() {
  if(this.$httpType$) {
    if(this.$httpType$ === "generic") {
      return new XMLHttpRequest
    }else {
      if(this.$httpType$ === "msxml2") {
        return new ActiveXObject("Msxml2.XMLHTTP")
      }else {
        return new ActiveXObject("Microsoft.XMLHTTP")
      }
    }
  }
  if(window.ActiveXObject) {
    try {
      this.$httpType$ = "msxml2";
      return new ActiveXObject("Msxml2.XMLHTTP")
    }catch(e) {
      this.$httpType$ = "msxml";
      return new ActiveXObject("Microsoft.XMLHTTP")
    }
  }else {
    throw new $A.$auraError$("AuraClientService.createXHR: Unable to find an appropriate XHR");
  }
};
AuraClientService.prototype.$buildParams$ = function(map) {
  var arr = [];
  var first = true;
  for(var key in map) {
    if(!first) {
      arr.push("\x26")
    }
    first = false;
    if($A["util"].isArray(map[key])) {
      var valueArray = map[key];
      if(valueArray.length === 0) {
        arr.push(key);
        arr.push("\x3d")
      }else {
        for(var i = 0;i < valueArray.length;i++) {
          if(i > 0) {
            arr.push("\x26")
          }
          arr.push(key);
          arr.push("\x3d");
          arr.push(encodeURIComponent(valueArray[i]))
        }
      }
    }else {
      arr.push(key);
      arr.push("\x3d");
      arr.push(encodeURIComponent(map[key]))
    }
  }
  return arr.join("")
};
AuraClientService.prototype.$buildActionNameList$ = function(actions, actionDefs) {
  var i;
  var map = {};
  for(i = 0;i < actions.length;i++) {
    var actionDescriptor = actions[i]["descriptor"];
    var parts = actionDescriptor.split("/");
    var controllerMethod = parts.pop().split("$").pop();
    var controllerParts = parts.pop().split(".");
    var controller = controllerParts.pop();
    var index = controller.indexOf("Controller", controller.length - "Controller".length);
    if(index > 0) {
      controller = controller.substring(0, index)
    }
    var pkg;
    if(controllerParts.length === 0) {
      if(parts[0] === "aura:") {
        pkg = "aura"
      }else {
        pkg = "other"
      }
    }else {
      if(actionDefs && actionDefs[i] && actionDefs[i].$getActionGroup$()) {
        pkg = actionDefs[i].$getActionGroup$()
      }else {
        pkg = controllerParts.join("-")
      }
    }
    var actionName = pkg + "." + controller + "." + controllerMethod;
    map[actionName] = map[actionName] ? map[actionName] + 1 : 1
  }
  var arr = [];
  var keys = Object.keys(map).sort();
  for(i = 0;i < keys.length;i++) {
    if(i > 0) {
      arr.push("\x26")
    }
    var key = keys[i];
    arr.push(key, "\x3d", encodeURIComponent(map[key]))
  }
  var list = arr.join("");
  if(list.length > AuraClientService.$MAX_ACTION_QUERY_LENGTH$) {
    list = list.substring(0, list.lastIndexOf("\x26", AuraClientService.$MAX_ACTION_QUERY_LENGTH$))
  }
  return list
};
AuraClientService.prototype.$hydrateActions$ = function(actions, preloadMapId, response) {
  var i;
  var action;
  var xhr = this.$getAvailableXHR$(true);
  if(!xhr) {
    for(i = 0;i < actions.length;i++) {
      action = actions[i];
      this.$actionsDeferred$.unshift(action)
    }
    return
  }
  xhr.$request$ = response;
  for(i = 0;i < actions.length;i++) {
    action = actions[i];
    var id = preloadMapId[action.$getId$()];
    if(id) {
      action.$setId$(id)
    }
    xhr.$addAction$(action)
  }
  this.$receiveWrapper$(xhr)
};
goog.$exportProperty$(AuraClientService.prototype, "hydrateActions", AuraClientService.prototype.$hydrateActions$);
AuraClientService.prototype.$reifyActions$ = function(rawResponses, functionsWithDefDependencies) {
  var context = $A.getContext();
  var actionsToPersist = [];
  var nonStorableActions = [];
  var error = null;
  var allDefsInContextResponse = {};
  rawResponses.forEach(function(rawResponse) {
    var response = this.$decode$(rawResponse);
    if(response["status"] === "SUCCESS") {
      var reponsePayload = response["message"];
      var responseContext = reponsePayload["context"];
      var responseActions = reponsePayload["actions"];
      var responseCode = response["responseCode"];
      context["mergeContext"](responseContext, true);
      $A.$componentService$.$saveDefsToStorage$(responseContext, context);
      allDefsInContextResponse = this.$extractAllDefs$(responseContext);
      responseActions.forEach(function(responseAction) {
        var action = this.$buildStorableServerAction$(responseAction);
        var defDependencies;
        if(Object.keys(allDefsInContextResponse).length > 0) {
          defDependencies = allDefsInContextResponse
        }
        if(action) {
          action.$setResponseCode$(responseCode);
          if(functionsWithDefDependencies && functionsWithDefDependencies.indexOf(action.getName()) >= 0) {
            action.$defDependencies$ = defDependencies
          }
          actionsToPersist.push(action)
        }else {
          responseAction["responseCode"] = responseCode;
          nonStorableActions.push(responseAction)
        }
      }, this)
    }else {
      var newToken;
      if(response["status"] === AuraClientService.$INVALID_SESSION_RETURN_STATUS$) {
        var event = response["event"];
        var data = {};
        if(event) {
          newToken = event["attributes"] && event["attributes"]["values"] && event["attributes"]["values"]["newToken"];
          if(this.$isValidToken$(newToken) && newToken !== this.$_token$) {
            data["newToken"] = newToken
          }
        }
      }
      error = {"status":response["status"], "message":response["message"], "data":data}
    }
  }, this);
  return this.$persistStorableActions$(actionsToPersist)["then"](function afterPersistStorableActions() {
    return{"storableActions":actionsToPersist, "nonStorableActions":nonStorableActions, "error":error}
  })
};
AuraClientService.prototype.$receiveWrapper$ = function() {
  this.$notifyListeners$("PRE", "receive", arguments);
  var retVal = this.$receive$.apply(this, arguments);
  this.$notifyListeners$("POST", "receive", retVal, arguments);
  return retVal
};
AuraClientService.prototype.$receive$ = function(auraXHR, timedOut) {
  var responseMessage;
  this.$auraStack$.push("AuraClientService$receive");
  try {
    responseMessage = this.$decode$(auraXHR.$request$, timedOut, auraXHR.$requestId$, auraXHR);
    var responseCode = responseMessage["responseCode"];
    for(var id in auraXHR.$actions$) {
      if(auraXHR.$actions$.hasOwnProperty(id)) {
        auraXHR.$actions$[id].$setResponseCode$(responseCode)
      }
    }
    if(responseMessage["status"] === "SUCCESS") {
      this.$processResponses$(auraXHR, responseMessage["message"])
    }else {
      if(responseMessage["status"] === "INCOMPLETE") {
        this.$processIncompletes$(auraXHR)
      }else {
        if(responseMessage["status"] === "ERROR") {
          this.$processErrors$(auraXHR, responseMessage["message"])
        }else {
          if(responseMessage["status"] === AuraClientService.$INVALID_SESSION_RETURN_STATUS$) {
            this.$retryActions$(auraXHR, responseMessage["event"])
          }else {
            if(responseMessage["status"] === AuraClientService.$SYSTEM_EXCEPTION_EVENT_RETURN_STATUS$) {
              this.$processSystemError$(auraXHR)
            }
          }
        }
      }
    }
    this.$fireDoneWaiting$()
  }catch(e) {
    if(e instanceof $A.$auraError$) {
      if(e.action) {
        var failingCmp = e.action.$getComponent$();
        if(failingCmp) {
          var descriptor = failingCmp.$getDef$().$getDescriptor$().toString();
          e.$setComponent$(descriptor)
        }
      }
      this.$notifyListeners$("O11Y", "acs.receive", ["ERROR"]);
      throw e;
    }
    this.$notifyListeners$("O11Y", "acs.receive", ["ERROR"]);
    throw new $A.$auraError$("AuraClientService.receive action callback failed", e);
  }finally {
    this.$auraStack$.pop();
    this.$releaseXHR$(auraXHR);
    this.$process$()
  }
  this.$notifyListeners$("O11Y", "acs.receive", ["SUCCESS"]);
  return responseMessage
};
AuraClientService.prototype.$retryActions$ = function(auraXHR, event) {
  var newToken = event["attributes"] && event["attributes"]["values"] && event["attributes"]["values"]["newToken"];
  if(this.$isValidToken$(newToken) && newToken !== this.$_token$) {
    this.$setToken$(newToken, true, $A.getContext().$getApp$());
    $A.log("[AuraClientService.retryActions]: New token received, attempting to retry failed actions");
    for(var name in auraXHR.$actions$) {
      if(auraXHR.$actions$[name].$getRetryCount$() < this.$maxActionRetries$) {
        auraXHR.$actions$[name].$incrementRetryCount$();
        this.$enqueueAction$(auraXHR.$actions$[name])
      }else {
        $A.log("[AuraClientService.retryActions]: Exceeded action retry limit");
        this.$throwExceptionEvent$({event:event});
        this.$processSystemError$(auraXHR);
        break
      }
    }
  }else {
    $A.log("[AuraClientService.retryActions]: Could not retry actions, no token received.");
    this.$throwExceptionEvent$({event:event});
    if($A.getContext && $A.getContext().$isProcessInvalidSessionErrorEnabled$()) {
      this.$processErrors$(auraXHR, AuraClientService.$INVALID_SESSION_RETURN_STATUS$)
    }
    this.$processSystemError$(auraXHR)
  }
};
AuraClientService.prototype.$isValidToken$ = function(token) {
  return $A["util"].$isString$(token) && !$A["util"].$isEmpty$(token) && token !== AuraClientService.$INVALID_CSRF$
};
AuraClientService.prototype.$processErrors$ = function(auraXHR, errorMessage) {
  var action;
  var actions = auraXHR.$actions$;
  for(var id in actions) {
    if(actions.hasOwnProperty(id)) {
      action = actions[id];
      var error = new Error(errorMessage);
      $A.$warning$("Error in the server action response:" + errorMessage);
      try {
        action.$markError$($A.getContext(), [error])
      }catch(e) {
        if(e instanceof $A.$auraError$) {
          throw e;
        }
        var auraError = new $A.$auraError$("Error happened when processing action errors", e);
        auraError.action = action;
        throw auraError;
      }
    }
  }
};
AuraClientService.prototype.$processSystemError$ = function(auraXHR) {
  var action;
  var actions = auraXHR.$actions$;
  for(var id in actions) {
    if(actions.hasOwnProperty(id)) {
      if(this.$actionStoreMap$[id]) {
        action = actions[id];
        delete this.$actionStoreMap$[id];
        delete this.$actionStoreMap$[action.$getStorageKey$()]
      }
    }
  }
};
AuraClientService.prototype.$addAllDefsToMap$ = function(defs, map) {
  if($A["util"].isArray(defs)) {
    var i = 0;
    for(var length = defs.length;i < length;i++) {
      if(defs[i]["descriptor"]) {
        map[defs[i]["descriptor"]] = defs[i]
      }
    }
    return
  }
  for(var def in defs) {
    map[def] = defs[def]
  }
};
AuraClientService.prototype.$extractAllDefs$ = function(config) {
  var descriptors = {};
  this.$addAllDefsToMap$(config["componentDefs"], descriptors);
  this.$addAllDefsToMap$(config["libraryDefs"], descriptors);
  this.$addAllDefsToMap$(config["eventDefs"], descriptors);
  this.$addAllDefsToMap$(config["moduleDefs"], descriptors);
  this.$addAllDefsToMap$(config["descriptorUids"], descriptors);
  var loaded = Object.keys($A.getContext().loaded);
  var i = 0;
  for(var length = loaded.length;i < length;i++) {
    var def = loaded[i];
    if($A["util"].$isString$(def)) {
      if(def.indexOf("@") >= 0) {
        if(def.indexOf("APPLICATION@") === -1) {
          descriptors[def.split("@")[1]] = $A.getContext().loaded[def]
        }
      }else {
        descriptors[def] = $A.getContext().loaded[def]
      }
    }
  }
  return descriptors
};
AuraClientService.prototype.$processResponses$ = function() {
  this.$notifyListeners$("PRE", "processResponses", arguments);
  this.$processResponsesInternal$.apply(this, arguments);
  this.$notifyListeners$("POST", "processResponses", undefined, arguments)
};
AuraClientService.prototype.$processResponsesInternal$ = function(auraXHR, responseMessage) {
  var action;
  var actionResponses;
  var response;
  var dupes;
  if(responseMessage["eikoocnekot"]) {
    this.$setToken$(this.$buildToken$(responseMessage["eikoocnekot"], true));
    this.$_csrfV2$ = true
  }else {
    if(responseMessage["token"]) {
      this.$setToken$(responseMessage["token"]);
      if(responseMessage["csrfV2"]) {
        this.$_csrfV2$ = true
      }
    }
  }
  var context = $A.getContext();
  var priorAccess = this.$currentAccess$;
  var allDefsInContextResponse = {};
  if(!priorAccess) {
    this.$setCurrentAccess$($A.$getRoot$())
  }
  try {
    if("context" in responseMessage) {
      var responseContext = responseMessage["context"];
      context["mergeContext"](responseContext);
      $A.$componentService$.$saveDefsToStorage$(responseContext, context)["then"](undefined, function saveDefsToStorageError() {
      });
      allDefsInContextResponse = this.$extractAllDefs$(responseContext)
    }
  }catch(e) {
    $A.$logger$.$reportError$(e)
  }finally {
    if(!priorAccess) {
      this.$releaseCurrentAccess$()
    }
  }
  var events = responseMessage["events"] || responseMessage["event"] && [responseMessage["event"]];
  if(events) {
    var en = 0;
    for(var len = events.length;en < len;en++) {
      try {
        this.$parseAndFireEvent$(events[en])
      }catch(e$$0) {
        $A.$logger$.$reportError$(e$$0)
      }
    }
  }
  actionResponses = responseMessage["actions"];
  if(actionResponses === undefined) {
    return
  }
  var actionsToPersist = [];
  for(var r = 0;r < actionResponses.length;r++) {
    action = null;
    try {
      response = actionResponses[r];
      $A.assert(!response["id"] ? actionResponses.length === 1 : true, "When an action has no ID, there should be only one action in the response.");
      if(response[Json.$ApplicationKey$.$CLIENT_OUT_OF_SYNC$]) {
        this.$fireCOOSToastEvent$(response[Json.$ApplicationKey$.$CLIENT_OUT_OF_SYNC$]);
        continue
      }
      action = auraXHR.$getAction$(response["id"]);
      if(action) {
        if(response["storable"] && !action.$isStorable$()) {
          action.$setStorable$()
        }
      }else {
        if(response["state"] !== "SUCCESS") {
          continue
        }
        action = this.$buildStorableServerAction$(response)
      }
      if(!action) {
        throw new $A.$auraError$("Unable to find an action for " + response["id"] + ": " + JSON.stringify(response));
      }else {
        var defDependencies;
        if(Object.keys(allDefsInContextResponse).length > 0) {
          defDependencies = allDefsInContextResponse;
          action.$defDependencies$ = defDependencies
        }
        actionsToPersist.push(action);
        var key = this.$actionStoreMap$[action.$getId$()];
        dupes = this.$getAndClearDupes$(key);
        this.$singleAction$(action, response);
        if(dupes) {
          for(var i = 0;i < dupes.length;i++) {
            dupes[i].$defDependencies$ = defDependencies;
            this.$singleAction$(dupes[i], response)
          }
        }
      }
    }catch(e$$1) {
      if(e$$1 instanceof $A.$auraError$) {
        throw e$$1;
      }
      var auraError = new $A.$auraError$("Error happened when processing action responses", e$$1);
      auraError.action = action;
      throw auraError;
    }
  }
  this.$persistStorableActions$(actionsToPersist)
};
AuraClientService.prototype.$buildStorableServerAction$ = function(response) {
  var action = null;
  if(response["storable"]) {
    var descriptor = response["action"];
    var actionDef = $A.$componentService$.$getActionDef$(descriptor);
    if(!actionDef) {
      throw new $A.$auraError$("Missing action definition for " + descriptor);
    }
    action = actionDef.$newInstance$();
    action.$setStorable$();
    if(response["params"]) {
      action.$setParams$(response["params"])
    }
    action.$updateFromResponse$(response)
  }
  return action
};
AuraClientService.prototype.$processIncompletes$ = function(auraXHR) {
  var actions = auraXHR.$actions$;
  var id;
  var action;
  var key;
  var dupes;
  for(id in actions) {
    if(actions.hasOwnProperty(id)) {
      try {
        action = actions[id];
        action.$incomplete$($A.getContext());
        key = this.$actionStoreMap$[action.$getId$()];
        dupes = this.$getAndClearDupes$(key);
        if(dupes) {
          for(var i = 0;i < dupes.length;i++) {
            dupes[i].$incomplete$($A.getContext())
          }
        }
      }catch(e) {
        if(e instanceof $A.$auraError$) {
          throw e;
        }
        var auraError = new $A.$auraError$("Error happened when processing incompleted actions", e);
        auraError.action = action;
        throw auraError;
      }
    }
  }
};
AuraClientService.prototype.$parseAndFireEvent$ = function(evtObj) {
  var descriptor = evtObj["descriptor"];
  if(evtObj["eventDef"]) {
    $A.$eventService$.$createEventDef$(evtObj["eventDef"])
  }
  if($A.$eventService$.$hasHandlers$(descriptor)) {
    var evt = $A.$getEvt$(descriptor);
    if(evtObj["attributes"]) {
      evt.$setParams$(evtObj["attributes"]["values"])
    }
    evt.$fire$()
  }
};
AuraClientService.prototype.$fireCOOSToastEvent$ = function(msg, type) {
  var evt = $A.$getEvt$("force:showToast");
  if(evt) {
    evt.$setParams$({mode:"sticky", type:type || "warning", message:msg});
    evt.$fire$()
  }else {
    console.error(msg)
  }
};
AuraClientService.prototype.$setCsrfV2Enabled$ = function(enabled) {
  this.$_csrfV2$ = enabled
};
AuraClientService.prototype.$isCsrfV2Enabled$ = function() {
  return this.$_csrfV2$
};
AuraClientService.prototype.$buildToken$ = function(cookieName, deleteCookie) {
  var token = $A["util"].$getCookie$(cookieName);
  if(!token) {
    throw new Error("Unable to read the Aura token from the response.");
  }
  if(deleteCookie) {
    $A["util"].$clearCookie$(cookieName, "/", cookieName.indexOf("__Host-") === 0)
  }
  return token
};
AuraClientService.prototype.$setToken$ = function(newToken, broadcast, app) {
  var oldToken = this.$_token$;
  this.$_token$ = newToken;
  if(broadcast && this.$tokenSharing$ && (!oldToken || newToken !== oldToken)) {
    this.$broadcastToken$(newToken, app)
  }
};
AuraClientService.prototype.$broadcastToken$ = function(newToken, app) {
  if(this.$tokenSharing$) {
    $A.log("[AuraClientService.broadcastToken]: Broadcasting new token.");
    var tokenKey = AuraClientService.$TOKEN_KEY$;
    if(this.$isCsrfV2Enabled$()) {
      if(!app) {
        throw new Error("App is empty");
      }
      tokenKey += app
    }
    window.localStorage.setItem(tokenKey, newToken)
  }
};
AuraClientService.prototype.$setupTokenListener$ = function() {
  if(this.$tokenSharing$) {
    var self = this;
    if(window.addEventListener) {
      window.addEventListener("storage", function onStorage(event) {
        var context = $A.getContext();
        var tokenKey = AuraClientService.$TOKEN_KEY$;
        if(context) {
          if(self.$isCsrfV2Enabled$()) {
            var app = context.$getApp$() || context.$getCmp$();
            if(!app) {
              throw new Error("App is empty");
            }
            tokenKey += app
          }
          if(event.newValue) {
            var existingToken = self.$_token$;
            if(event.key === tokenKey && event.oldValue !== event.newValue) {
              $A.log("[AuraClientService.tokenListener]: Received new token.");
              self.$_token$ = event.newValue;
              window.localStorage.removeItem(tokenKey)
            }
            if(existingToken === null && self.$isCsrfV2Enabled$() && !event.oldValue && event.key.indexOf(AuraClientService.$TOKEN_KEY$) === 0 && context.$getMode$().indexOf("TEST") === -1) {
              window.location.reload(true)
            }
          }
        }
      })
    }
  }
};
AuraClientService.prototype.$resetToken$ = function(newToken) {
  this.$setToken$(newToken)
};
goog.$exportProperty$(AuraClientService.prototype, "resetToken", AuraClientService.prototype.$resetToken$);
AuraClientService.prototype.$injectComponent$ = function(config, locatorDomId, localId) {
  var context = $A.getContext();
  context["mergeContext"](config["context"]);
  var priorAccess = this.$currentAccess$;
  this.$initializeClientLibraries$();
  var actionResult = config["actions"][0];
  var action = $A.get("c.aura://ComponentController.getComponent");
  var self = this;
  action.$setCallback$(action, function getComponentCallback(a) {
    var root = $A.$getRoot$();
    if(!priorAccess) {
      self.$setCurrentAccess$(root)
    }
    try {
      var element = $A["util"].$getElement$(locatorDomId);
      var errors;
      if(!element) {
        element = document.body;
        errors = ["Invalid locatorDomId specified - no element found in the DOM with id\x3d" + locatorDomId]
      }else {
        errors = a.$getState$() === "SUCCESS" ? undefined : action.getError()
      }
      var componentConfig;
      if(!errors) {
        componentConfig = a.$getReturnValue$()
      }else {
        $A.getContext().$clearComponentConfigs$(a.$getId$());
        componentConfig = self.$createIntegrationErrorConfig$(errors)
      }
      $A["util"].apply(componentConfig, {"localId":localId, "attributes":{"valueProvider":root}}, null, true);
      var c = $A.$componentService$.$createComponentPriv$(componentConfig);
      if(!errors) {
        self.$addComponentHandlers$(c, config["actionEventHandlers"])
      }
      var body = root.get("v.body");
      body.push(c);
      root.set("v.body", body, true);
      $A.$render$(c, element);
      $A.$afterRender$(c)
    }finally {
      if(!priorAccess) {
        self.$releaseCurrentAccess$()
      }
    }
  });
  action.$updateFromResponse$(actionResult);
  action.$finishAction$($A.getContext())
};
goog.$exportProperty$(AuraClientService.prototype, "injectComponent", AuraClientService.prototype.$injectComponent$);
AuraClientService.prototype.$createIntegrationErrorConfig$ = function(errorText) {
  return{"componentDef":{"descriptor":"markup://ui:message"}, "attributes":{"valueProvider":$A.$getRoot$(), "values":{"title":"Aura Integration Service Error", "severity":"error", "body":[{"componentDef":{"descriptor":"markup://ui:outputText"}, "attributes":{"values":{"value":$A["util"].$json$.$encode$(errorText)}}}]}}}
};
AuraClientService.prototype.$renderInjection$ = function(component, locator, actionEventHandlers) {
  var error = null;
  var stringLocator = $A["util"].$isString$(locator);
  var hostEl = stringLocator ? document.getElementById(locator) : locator;
  if(!hostEl) {
    error = "Invalid locator specified - " + (stringLocator ? "no element found in the DOM with id\x3d" + locator : "locator element not provided");
    hostEl = document.body
  }
  if(component.$isInstanceOf$("aura:text")) {
    error = component.get("v.value")
  }
  if(error) {
    var errorConfig = this.$createIntegrationErrorConfig$(error);
    errorConfig["localId"] = component.$getLocalId$();
    component = $A.$componentService$.$createComponentPriv$(errorConfig)
  }
  this.$addComponentHandlers$(component, actionEventHandlers);
  $A.$render$(component, hostEl);
  $A.$afterRender$(component)
};
AuraClientService.prototype.$injectComponentAsync$ = function(config, locator, eventHandlers, callback) {
  var self = this;
  var priorAccess = this.$currentAccess$;
  var root = $A.$getRoot$();
  if(!priorAccess) {
    self.$setCurrentAccess$(root)
  }
  try {
    $A.$componentService$.$newComponentAsync$(undefined, function(component) {
      if(callback) {
        callback(component)
      }
      self.$renderInjection$(component, locator, eventHandlers)
    }, config, root, false, false, true)
  }finally {
    if(!priorAccess) {
      self.$releaseCurrentAccess$()
    }
  }
  var labelAction = $A.get("c.aura://ComponentController.loadLabels");
  labelAction.$setCallback$(this, function() {
  });
  self.$enqueueAction$(labelAction)
};
goog.$exportProperty$(AuraClientService.prototype, "injectComponentAsync", AuraClientService.prototype.$injectComponentAsync$);
AuraClientService.prototype.$addComponentHandlers$ = function(component, actionEventHandlers) {
  if(actionEventHandlers) {
    var containerValueProvider = {get:function(functionName) {
      var action = new Action;
      action.$run$ = action.$runDeprecated$ = window[functionName];
      return action
    }};
    for(var evt in actionEventHandlers) {
      component.$addHandler$(evt, containerValueProvider, actionEventHandlers[evt])
    }
  }
};
AuraClientService.prototype.$isConnected$ = function() {
  return!this.$_isDisconnected$
};
goog.$exportProperty$(AuraClientService.prototype, "isConnected", AuraClientService.prototype.$isConnected$);
AuraClientService.prototype.$enqueueAction$ = function() {
  this.$notifyListeners$("PRE", "enqueueAction", arguments);
  this.$enqueueActionInternal$.apply(this, arguments);
  this.$notifyListeners$("POST", "enqueueAction", arguments)
};
goog.$exportProperty$(AuraClientService.prototype, "enqueueAction", AuraClientService.prototype.$enqueueAction$);
AuraClientService.prototype.$enqueueActionInternal$ = function(action, background) {
  $A.assert($A["util"].$isAction$(action), "Cannot call EnqueueAction() with a non Action parameter.");
  if(background) {
    $A.$warning$("$A.enqueueAction(): Do not use the deprecated background parameter. The parameter is not used anymore.")
  }
  if(this.$allowFlowthrough$ || this.$boxcarReduction$ && this.$countAvailableXHRs$() > 2) {
    var isServerAction = action.$getDef$().$isServerAction$() && !action.$isRefreshAction$();
    if(isServerAction && !action.$isCaboose$() && this.$isActionAbsentFromStorage$(action)) {
      var auraXHR = this.$getAvailableXHR$(false);
      if(auraXHR) {
        if(!this.$sendWrapper$(auraXHR, [action], action.$isPubliclyCacheable$() ? "GET" : "POST")) {
          this.$releaseXHR$(auraXHR)
        }
        return
      }
    }
  }
  this.$actionsQueued$.push(action)
};
AuraClientService.prototype.$isActionAbsentFromStorage$ = function(action) {
  if(!action || !action.$isStorable$()) {
    return true
  }
  if(!this.$actionStorage$.$isStoragePersistent$()) {
    return true
  }
  if(this.$actionStorage$.$isActionsFilterEnabled$() && !this.$actionStorage$.$isActionsFilterInitialized$()) {
    return true
  }
  return this.$actionStorage$.$isKeyAbsentFromCache$(action.$getStorageKey$())
};
AuraClientService.prototype.$isActionInStorage$ = function(descriptor, params, callback) {
  callback = callback || this.$NOOP$;
  if(!$A["util"].$isString$(descriptor) || !$A["util"].$isObject$(params) || !this.$actionStorage$.$isStorageEnabled$()) {
    callback(false);
    return
  }
  var key = Action.$getStorageKey$(descriptor, params);
  if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
    callback(false);
    return
  }
  this.$actionStorage$.get(key)["then"](function actionStorageGetSuccess(value) {
    $A.$run$(function() {
      callback(!!value)
    })
  }, function actionStorageGetError(err) {
    $A.$warning$("AuraClientService.isActionInStorage(): storage.get() threw " + err);
    callback(false)
  })
};
goog.$exportProperty$(AuraClientService.prototype, "isActionInStorage", AuraClientService.prototype.$isActionInStorage$);
AuraClientService.prototype.$revalidateAction$ = function(descriptor, params, callback) {
  callback = callback || this.$NOOP$;
  if(!$A["util"].$isString$(descriptor) || !$A["util"].$isObject$(params) || !this.$actionStorage$.$isStorageEnabled$()) {
    callback(false);
    return
  }
  var key = Action.$getStorageKey$(descriptor, params);
  if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
    callback(false);
    return
  }
  var that = this;
  this.$actionStorage$.get(key)["then"](function actionStorageGetSuccess2(value) {
    if(value) {
      that.$actionStorage$.set(key, value)["then"](function actionStorageSetSuccess() {
        callback(true)
      }, function actionStorageSetError() {
        callback(false)
      })
    }else {
      callback(false)
    }
  }, function actionStorageGetError(err) {
    $A.$warning$("AuraClientService.revalidateAction(): storage.get() threw " + err);
    callback(false)
  })
};
goog.$exportProperty$(AuraClientService.prototype, "revalidateAction", AuraClientService.prototype.$revalidateAction$);
AuraClientService.prototype.$invalidateAction$ = function(descriptor, params, successCallback, errorCallback) {
  successCallback = successCallback || this.$NOOP$;
  errorCallback = errorCallback || this.$NOOP$;
  if(!$A["util"].$isString$(descriptor) || !$A["util"].$isObject$(params) || !this.$actionStorage$.$isStorageEnabled$()) {
    successCallback(false);
    return
  }
  var key = Action.$getStorageKey$(descriptor, params);
  if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
    successCallback(true);
    return
  }
  this.$actionStorage$.remove(key)["then"](function actionStorageRemoveSuccess() {
    successCallback(true)
  }, errorCallback)
};
goog.$exportProperty$(AuraClientService.prototype, "invalidateAction", AuraClientService.prototype.$invalidateAction$);
AuraClientService.prototype.$isInternalNamespace$ = function(namespace) {
  return this.$registeredNamespaces$.$internal$.hasOwnProperty(namespace)
};
AuraClientService.prototype.$isPrivilegedNamespace$ = function(namespace) {
  return this.$registeredNamespaces$.$privileged$.hasOwnProperty(namespace)
};
AuraClientService.prototype.$getAccessStackHierarchy$ = function() {
  return this.$currentAccess$ ? this.$accessStack$.map(function(component) {
    return"[" + component.$getType$() + "]"
  }).join(" \x3e ") : ""
};
AuraClientService.prototype.$setCurrentAccess$ = function(component) {
  if(!component) {
    component = this.$currentAccess$
  }else {
    for(;component instanceof PassthroughValue;) {
      component = component.$getComponent$()
    }
  }
  if(component) {
    this.$accessStack$.push(component);
    this.$currentAccess$ = component
  }
};
AuraClientService.prototype.$releaseCurrentAccess$ = function() {
  this.$accessStack$.pop();
  this.$currentAccess$ = this.$accessStack$[this.$accessStack$.length - 1]
};
AuraClientService.prototype.$getAccessVersion$ = function(name) {
  var currentAccessCaller = this.$accessStack$[this.$accessStack$.length - 2];
  var ret = null;
  if(currentAccessCaller) {
    var def = currentAccessCaller.$getDef$();
    if(def) {
      if(def.$getDescriptor$().$getNamespace$() === name) {
        ret = currentAccessCaller.get("version")
      }else {
        ret = def.$getRequiredVersionDefs$().$getDef$(name);
        if(ret) {
          ret = ret.$getVersion$()
        }
      }
    }
  }
  return ret
};
AuraClientService.prototype.$allowAccess$ = function(definition, component) {
  if(definition && definition.$getDescriptor$) {
    var currentAccess = this.$currentAccess$;
    if(definition.$access$ === "G") {
      return true
    }else {
      if(definition.$access$ === "p") {
        return currentAccess && (currentAccess === component || currentAccess.$getComponentValueProvider$() === component || currentAccess.$getDef$() === component)
      }else {
        if(!currentAccess) {
          currentAccess = component
        }
        if(currentAccess) {
          var accessDef = null;
          var accessFacetDef = null;
          if(currentAccess.$getComponentValueProvider$ && currentAccess.$getDef$) {
            var accessFacetValueProvider = currentAccess.$getComponentValueProvider$();
            accessFacetDef = accessFacetValueProvider && accessFacetValueProvider.$getDef$();
            accessDef = currentAccess.$getDef$()
          }else {
            accessDef = currentAccess
          }
          var accessDescriptor = accessDef && accessDef.$getDescriptor$();
          var accessNamespace = accessDescriptor && accessDescriptor.$getNamespace$();
          var accessFacetDescriptor = accessFacetDef && accessFacetDef.$getDescriptor$();
          var accessFacetNamespace = accessFacetDescriptor && accessFacetDescriptor.$getNamespace$();
          var allowProtocol = this.$protocols$.hasOwnProperty(accessDescriptor && accessDescriptor.$getPrefix$()) || this.$protocols$.hasOwnProperty(accessFacetDescriptor && accessFacetDescriptor.$getPrefix$());
          var accessInternal = allowProtocol || this.$registeredNamespaces$.$internal$.hasOwnProperty(accessNamespace) || this.$registeredNamespaces$.$internal$.hasOwnProperty(accessFacetNamespace);
          if(definition.$access$ === "I") {
            return accessInternal
          }
          if(definition.$access$ === "PP") {
            var isPrivileged = this.$registeredNamespaces$.$privileged$.hasOwnProperty(accessNamespace) || this.$registeredNamespaces$.$privileged$.hasOwnProperty(accessFacetNamespace);
            if(isPrivileged || accessInternal) {
              return true
            }
          }
          if(definition.$access$ === "P") {
            var targetDescriptor = definition.$getDescriptor$();
            var targetNamespace = targetDescriptor && targetDescriptor.$getNamespace$();
            var targetInternal = this.$registeredNamespaces$.$internal$.hasOwnProperty(targetNamespace);
            var accessRoot = this.$accessStack$ && this.$accessStack$[0];
            var accessRootDef = accessRoot && (accessRoot.$interop$ ? accessRoot : accessRoot.$getDef$());
            var accessRootDescriptor = accessRootDef && accessRootDef.$getDescriptor$();
            var accessRootNamespace = accessRootDescriptor && accessRootDescriptor.$getNamespace$();
            var accessRootInternal = this.$registeredNamespaces$.$internal$.hasOwnProperty(accessRootNamespace);
            var context = $A.getContext();
            var internalAccess = context.$isAuraComponentAccessFixEnabled$() ? accessRootNamespace === targetNamespace || accessRootInternal && accessInternal && !targetInternal : accessInternal && !targetInternal;
            if(currentAccess === component || accessNamespace === targetNamespace || accessFacetNamespace === targetNamespace || internalAccess) {
              return true
            }
          }
        }
        return definition.$isInstanceOf$ && definition.$isInstanceOf$("aura:application") || false
      }
    }
  }
  return false
};
AuraClientService.prototype.$invalidSession$ = function() {
  $A.log("[AuraClientService.invalidSession]: Reloading the page.");
  this.$hardRefresh$()
};
goog.$exportProperty$(AuraClientService.prototype, "invalidSession", AuraClientService.prototype.$invalidSession$);
AuraClientService.prototype.$setParallelBootstrapLoad$ = function() {
};
goog.$exportProperty$(AuraClientService.prototype, "setParallelBootstrapLoad", AuraClientService.prototype.$setParallelBootstrapLoad$);
AuraClientService.prototype.$setXHRTimeout$ = function(timeout) {
  $A.assert($A["util"].$isFiniteNumber$(timeout) && timeout > 0, "Timeout must be a positive number");
  this.$xhrTimeout$ = timeout
};
goog.$exportProperty$(AuraClientService.prototype, "setXHRTimeout", AuraClientService.prototype.$setXHRTimeout$);
AuraClientService.prototype.$populateActionsFilter$ = function() {
  var context = $A.getContext();
  if(!context.$globalValueProviders$.$LOADED_FROM_PERSISTENT_STORAGE$) {
    return Promise["resolve"]()
  }
  return this.$actionStorage$.$populateActionsFilter$()["then"](function actionStoragePopulateActionsFilterSuccess(items) {
    $A.log("ActionStorage: restored " + (items ? Object.keys(items).length : 0) + " actions")
  })
};
AuraClientService.prototype.$setPersistedActionsFilter$ = function(enable) {
  this.$actionStorage$.$enableActionsFilter$(enable)
};
goog.$exportProperty$(AuraClientService.prototype, "setPersistedActionsFilter", AuraClientService.prototype.$setPersistedActionsFilter$);
AuraClientService.prototype.$clearActionsFilter$ = function() {
  this.$actionStorage$.$clearActionsFilter$()
};
AuraClientService.prototype.$getActionStorage$ = function() {
  return this.$actionStorage$
};
AuraClientService.prototype.$getActionStorageName$ = function() {
  return this.$actionStorage$.$STORAGE_NAME$
};
AuraClientService.prototype.$getCurrentAccessGlobalId$ = function() {
  var owner = null;
  if(!$A["util"].$isUndefinedOrNull$(this.$currentAccess$)) {
    owner = this.$currentAccess$.$globalId$
  }
  return owner
};
AuraClientService.prototype.$setAuthorizationToken$ = function(token) {
  this.$authorizationToken$ = token
};
goog.$exportProperty$(AuraClientService.prototype, "setAuthorizationToken", AuraClientService.prototype.$setAuthorizationToken$);
AuraClientService.prototype.$addNotificationListener$ = function(stage, functionName, listenerName, callback, scope) {
  $A.assert(stage === "PRE" || stage === "POST" || stage === "O11Y");
  $A.assert(functionName && typeof functionName === "string", "functionName must be a valid string");
  $A.assert(listenerName && typeof listenerName === "string", "listenerName must be a valid string");
  $A.assert(typeof callback === "function", "callback must be provided");
  var listeners;
  switch(stage) {
    case "PRE":
      listeners = this.$preListenerRegistry$[functionName];
      break;
    case "POST":
      listeners = this.$postListenerRegistry$[functionName];
      break;
    case "O11Y":
      listeners = this.$o11yListenerRegistry$[functionName];
      break;
    default:
      listeners = null;
      break
  }
  if(!listeners) {
    throw new Error("AuraClientService.addNotificationListener: unknown function " + functionName);
  }
  listeners.push({"name":listenerName, "func":callback, "scope":scope})
};
AuraClientService.prototype.$addPreNotificationListener$ = function(functionName, listenerName, callback, scope) {
  this.$addNotificationListener$("PRE", functionName, listenerName, callback, scope)
};
goog.$exportProperty$(AuraClientService.prototype, "addPreNotificationListener", AuraClientService.prototype.$addPreNotificationListener$);
AuraClientService.prototype.$addPostNotificationListener$ = function(functionName, listenerName, callback, scope) {
  this.$addNotificationListener$("POST", functionName, listenerName, callback, scope)
};
goog.$exportProperty$(AuraClientService.prototype, "addPostNotificationListener", AuraClientService.prototype.$addPostNotificationListener$);
AuraClientService.prototype.$addO11yNotificationListener$ = function(functionName, listenerName, callback, scope) {
  this.$addNotificationListener$("O11Y", functionName, listenerName, callback, scope)
};
goog.$exportProperty$(AuraClientService.prototype, "addO11yNotificationListener", AuraClientService.prototype.$addO11yNotificationListener$);
AuraClientService.prototype.$removeNotificationListener$ = function(stage, functionName, callback) {
  $A.assert(stage === "PRE" || stage === "POST" || stage === "O11Y");
  $A.assert(functionName && typeof functionName === "string", "functionName must be a valid string");
  $A.assert(typeof callback === "function", "callback must be provided");
  var listeners;
  switch(stage) {
    case "PRE":
      listeners = this.$preListenerRegistry$[functionName];
      break;
    case "POST":
      listeners = this.$postListenerRegistry$[functionName];
      break;
    case "O11Y":
      listeners = this.$o11yListenerRegistry$[functionName];
      break;
    default:
      listeners = null;
      break
  }
  if(!listeners) {
    throw new Error("AuraClientService.removeNotificationListener: unknown function " + functionName);
  }
  for(var index = 0;index < listeners.length;index++) {
    if(listeners[index]["func"] === callback) {
      listeners.splice(index, 1);
      return
    }
  }
  $A.$warning$("AuraClientService.removeNotificationListener: unknown callback")
};
AuraClientService.prototype.$removePreNotificationListener$ = function(functionName, callback) {
  this.$removeNotificationListener$("PRE", functionName, callback)
};
goog.$exportProperty$(AuraClientService.prototype, "removePreNotificationListener", AuraClientService.prototype.$removePreNotificationListener$);
AuraClientService.prototype.$removePostNotificationListener$ = function(functionName, callback) {
  this.$removeNotificationListener$("POST", functionName, callback)
};
goog.$exportProperty$(AuraClientService.prototype, "removePostNotificationListener", AuraClientService.prototype.$removePostNotificationListener$);
AuraClientService.prototype.$removeO11yNotificationListener$ = function(functionName, callback) {
  this.$removeNotificationListener$("O11Y", functionName, callback)
};
goog.$exportProperty$(AuraClientService.prototype, "removeO11yNotificationListener", AuraClientService.prototype.$removeO11yNotificationListener$);
AuraClientService.prototype.$notifyListeners$ = function() {
  var stage = Array.prototype.shift.call(arguments);
  $A.assert(stage === "PRE" || stage === "POST" || stage === "O11Y");
  var functionName = Array.prototype.shift.call(arguments);
  var listeners;
  switch(stage) {
    case "PRE":
      listeners = this.$preListenerRegistry$[functionName];
      break;
    case "POST":
      listeners = this.$postListenerRegistry$[functionName];
      break;
    case "O11Y":
      listeners = this.$o11yListenerRegistry$[functionName];
      break;
    default:
      listeners = null;
      break
  }
  if(listeners && listeners.length) {
    var thoseArguments = arguments;
    listeners.forEach(function notifyIndividualListener(listener) {
      try {
        listener["func"].apply(listener["scope"], thoseArguments)
      }catch(e) {
        $A.log("AuraClientService.notifyListeners: error thrown by listener " + listener["name"], e)
      }
    })
  }
};
AuraClientService.prototype.$unstable_executeGlobalControllerInternal$ = function(endpoint, params, options, privileged, rawActionResponse, enableCustomHeaders) {
  var controller = "aura://" + endpoint;
  var path = controller.split(".");
  var controllerName = path.shift();
  var actionName = path.shift();
  rawActionResponse = !!rawActionResponse;
  var controllerDef = $A.$componentService$.$controllerDefRegistry$[controllerName];
  if(!controllerDef) {
    return Promise["reject"](new Error("Controller for endpoint " + endpoint + " does not exist"))
  }
  var action = controllerDef.$getActionDef$(actionName).$newInstance$();
  if(!action) {
    return Promise["reject"](new Error("Action of endpoint " + endpoint + " is not registered"))
  }
  action.$setParams$(params);
  var hotspot = options && options["hotspot"];
  var background = options && options["background"];
  var longRunning = options && options["longRunning"];
  var storableConfig = options && options["storable"];
  var sourceContext = options && options["sourceContext"];
  var headers = undefined;
  if(!!enableCustomHeaders) {
    headers = options && options["headers"]
  }
  return new Promise(function(resolve, reject) {
    if(background) {
      action.$setBackground$()
    }
    if(longRunning) {
      action.$setLongRunning$()
    }
    if(storableConfig && privileged) {
      action.$unstable_setStorablePrivileged$(storableConfig)
    }else {
      if(storableConfig) {
        action.$setStorable$(storableConfig)
      }
    }
    if(!!sourceContext) {
      action.$setSourceContext$(sourceContext)
    }
    if(!!headers) {
      for(var key in headers) {
        action.$setHeader$(key, headers[key])
      }
    }
    action.$setCallback$(null, function(response) {
      if(response.$getState$() !== "SUCCESS") {
        if(rawActionResponse) {
          reject(response)
        }else {
          var actionErrors = response.getError();
          if(actionErrors.length > 0) {
            reject(actionErrors[0])
          }else {
            reject(new Error("Error fetching component"))
          }
        }
        return
      }
      if(rawActionResponse) {
        resolve(response)
      }else {
        resolve(response.$getReturnValue$())
      }
    });
    $A.$run$(function() {
      if(hotspot) {
        $A.$executeHotspot$(function() {
          $A.$enqueueAction$(action)
        })
      }else {
        $A.$enqueueAction$(action)
      }
    })
  })
};
AuraClientService.prototype.$setCdnEnabledForLatestDefRequest$ = function(enabled) {
  this.$_cdnEnabledForLatestDefRequest$ = enabled
};
AuraClientService.prototype.$isCdnEnabledForLatestDefRequest$ = function() {
  return!!this.$_cdnEnabledForLatestDefRequest$
};
AuraClientService.prototype.$setIsLiveEnabledForRestrictedDefRequest$ = function(enabled) {
  this.$_isLiveEnabledForRestrictedDefRequest$ = enabled
};
AuraClientService.prototype.$isLiveEnabledForRestrictedDefRequest$ = function() {
  return!!this.$_isLiveEnabledForRestrictedDefRequest$
};
AuraClientService.prototype.$setComponentUids$ = function(componentUids) {
  this.$_componentUids$ = componentUids
};
AuraClientService.prototype.$getComponentUids$ = function() {
  return this.$_componentUids$
};
AuraClientService.prototype.$setAuraBundlingDisabled$ = function(disableAuraBundling) {
  this.$_disableAuraBundling$ = disableAuraBundling
};
AuraClientService.prototype.$isAuraBundlingDisabled$ = function() {
  return this.$_disableAuraBundling$
};
Aura.$Services$.$AuraClientService$ = AuraClientService;
function AuraComponentContext() {
  this.stack = []
}
AuraComponentContext.prototype.$Frame$ = function(cmp) {
  this.$cmp$ = cmp;
  this.$notes$ = undefined
};
AuraComponentContext.prototype.push = function(cmp) {
  var prior = this.stack.length ? this.stack[this.stack.length - 1].$cmp$ : undefined;
  this.stack.push(new this.$Frame$(cmp));
  return prior
};
AuraComponentContext.prototype.pop = function(cmp) {
  var oldFrame = this.stack.pop();
  if(cmp) {
    $A.assert(cmp === oldFrame.$cmp$, "ComponentContext mismatch detected.")
  }
  return oldFrame.$cmp$
};
AuraComponentContext.prototype.$currentContext$ = function() {
  var len = this.stack.length;
  return len ? this.stack[len - 1].$cmp$ : undefined
};
AuraComponentContext.prototype.$addNote$ = function(k, v) {
  if(!this.stack.length) {
    return
  }
  var top = this.stack[this.stack.length - 1];
  if(top.$notes$ === undefined) {
    top.$notes$ = {}
  }
  top[k] = v
};
AuraComponentContext.prototype.$getNote$ = function(k) {
  if(!this.stack.length) {
    return undefined
  }
  var top = this.stack[this.stack.length - 1];
  if(!top.$notes$) {
    return undefined
  }
  return top[k]
};
AuraComponentContext.prototype.$clearNote$ = function(k) {
  if(!this.stack.length) {
    return
  }
  var top = this.stack[this.stack.length - 1];
  if(!top.$notes$) {
    return
  }
  delete top[k]
};
Aura.$Services$.$AuraComponentContext$ = AuraComponentContext;
function AuraComponentService() {
  this.$moduleEngine$ = Aura["Engine"];
  this.$wireService$ = Aura["WireService"];
  delete Aura["Engine"];
  delete Aura["WireService"];
  this.$moduleDefRegistry$ = {};
  this.$moduleRegistry$ = {};
  this.$componentDefRegistry$ = {};
  this.$controllerDefRegistry$ = {};
  this.$actionDefRegistry$ = {};
  this.$modelDefRegistry$ = {};
  this.$libraryRegistry$ = new Aura.$Library$.$LibraryRegistry$;
  this.$libraryIncludeRegistry$ = new Aura.$Library$.$LibraryIncludeRegistry$;
  this.$componentClassRegistry$ = new Aura.$Component$.$ComponentClassRegistry$;
  this.$componentDefLoader$ = new Aura.$Component$.$ComponentDefLoader$;
  this.$componentDefStorage$ = new Aura.$Component$.$ComponentDefStorage$;
  this.$actionStorage$ = new Aura.$Controller$.$ActionStorage$;
  this.$sourceMapRegistry$ = new Aura.$SourceMap$.$SourceMapRegistry$;
  this.$descriptorCasingMap$ = {};
  this.$savedComponentConfigs$ = {};
  this.$controllerDefRelationship$ = {};
  this.$actionDefRelationship$ = {};
  this.$indexes$ = {$globalId$:{}};
  this.$dynamicNamespaces$ = [];
  this.$flavorable$ = "auraFlavorable";
  this.$renderedBy$ = "auraRenderedBy";
  this["renderedBy"] = this.$renderedBy$;
  this.$initCoreModules$();
  this.$trackingCreate$ = false
}
goog.$exportSymbol$("AuraComponentService", AuraComponentService);
AuraComponentService.$UNKNOWN_ERROR_MESSAGE_PREFIX$ = "An unknown error occurred attempting to fetch definitions at: ";
AuraComponentService.prototype.get = function(globalId) {
  return this.$indexes$.$globalId$[globalId]
};
goog.$exportProperty$(AuraComponentService.prototype, "get", AuraComponentService.prototype.get);
AuraComponentService.prototype.$isComponentConstructor$ = function(Ctor) {
  return typeof Ctor === "function" && this.$moduleEngine$["isComponentConstructor"](Ctor)
};
AuraComponentService.prototype.$initCoreModules$ = function() {
  var ProxyObject = window["Proxy"] || {};
  this.$addModule$("markup://lwc", "lwc", [], null, this.$moduleEngine$);
  this.$addModule$("markup://engine", "engine", [], null, this.$moduleEngine$);
  this.$addModule$("markup://wire-service", "wire-service", [], null, this.$wireService$);
  this.$addModule$("markup://assert", "assert", [], null, Aura.$ExportsAssert$);
  this.$addModule$("markup://logger", "logger", [], null, Aura.$ExportsLogger$);
  this.$addModule$("markup://aura", "aura", [], null, Aura.$ExportsModule$);
  this.$addModule$("markup://aura-storage", "aura-storage", [], null, Aura.$ExportsStorage$);
  this.$addModule$("markup://aura-instrumentation", "aura-instrumentation", [], null, Aura.$ExportsMetricsService$);
  var proxyPrefix = "proxy-compat/";
  Object.keys(ProxyObject).forEach(function(helper) {
    var moduleName = proxyPrefix + helper;
    this.$addModule$("markup://" + moduleName, moduleName, [], null, ProxyObject[helper])
  }.bind(this))
};
AuraComponentService.prototype.$addDescriptorCaseMapping$ = function(descriptorFrom, descriptorTo) {
  this.$descriptorCasingMap$[descriptorFrom] = descriptorTo
};
goog.$exportProperty$(AuraComponentService.prototype, "addDescriptorCaseMapping", AuraComponentService.prototype.$addDescriptorCaseMapping$);
AuraComponentService.prototype.$getComponent$ = function(identifier) {
  return this.get(identifier) || this.$getRenderingComponentForElement$(identifier)
};
goog.$exportProperty$(AuraComponentService.prototype, "getComponent", AuraComponentService.prototype.$getComponent$);
AuraComponentService.prototype.$isComponentDefRef$ = function(config) {
  if(!$A["util"].$isObject$(config)) {
    return false
  }
  var descriptor = config[Json.$ApplicationKey$.$DESCRIPTOR$] || config["descriptor"] || config["componentDef"] && config["componentDef"]["descriptor"];
  return descriptor !== null && descriptor !== undefined
};
AuraComponentService.prototype.$getDescriptorFromConfig$ = function(descriptorConfig) {
  var descriptor = descriptorConfig;
  if(descriptorConfig && typeof descriptorConfig !== "string") {
    if(descriptorConfig.hasOwnProperty(Json.$ApplicationKey$.$DESCRIPTOR$)) {
      descriptor = descriptorConfig[Json.$ApplicationKey$.$DESCRIPTOR$]
    }else {
      descriptor = descriptorConfig["descriptor"]
    }
  }
  $A.assert(descriptor, "Descriptor for Config required for registration");
  if(this.$descriptorCasingMap$[descriptor]) {
    $A.$deprecated$("Descriptor case sensitivity mismatch, descriptors are case sensitive.", "Please find the reference to: " + descriptor + " and change it to: " + this.$descriptorCasingMap$[descriptor], "getDescriptorFromConfig.descriptorCasingMap");
    return this.$descriptorCasingMap$[descriptor]
  }
  return descriptor
};
AuraComponentService.prototype.$createDescriptorConfig$ = function(descriptorConfig) {
  var descriptor = descriptorConfig;
  if(descriptorConfig && typeof descriptorConfig !== "string") {
    if(descriptorConfig.hasOwnProperty(Json.$ApplicationKey$.$DESCRIPTOR$)) {
      descriptor = descriptorConfig[Json.$ApplicationKey$.$DESCRIPTOR$]
    }else {
      descriptor = descriptorConfig["descriptor"]
    }
  }
  descriptor = descriptor.indexOf("://") < 0 ? "markup://" + descriptor : descriptor;
  return{"descriptor":descriptor}
};
AuraComponentService.prototype.$countComponents$ = function() {
  return Object.keys(this.$indexes$.$globalId$).length
};
goog.$exportProperty$(AuraComponentService.prototype, "countComponents", AuraComponentService.prototype.$countComponents$);
AuraComponentService.prototype.$getComponentLocator$ = function(cmp, targetCmp, includeMetadata) {
  $A.assert(cmp, "No component provided");
  return cmp.$getLocator$(targetCmp, includeMetadata)
};
goog.$exportProperty$(AuraComponentService.prototype, "getComponentLocator", AuraComponentService.prototype.$getComponentLocator$);
AuraComponentService.prototype.$getRenderingComponentForElement$ = function(element) {
  var ret;
  if($A["util"].$isUndefinedOrNull$(element)) {
    return null
  }
  if($A["util"].$hasDataAttribute$(element, this.$renderedBy$)) {
    var id = $A["util"].$getDataAttribute$(element, this.$renderedBy$);
    ret = this.get(id)
  }else {
    if(element.parentNode) {
      ret = this.$getRenderingComponentForElement$(element.parentNode)
    }
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getRenderingComponentForElement", AuraComponentService.prototype.$getRenderingComponentForElement$);
AuraComponentService.prototype.$getAttributeProviderForElement$ = function(element) {
  return this.$getRenderingComponentForElement$(element).$getAttributeValueProvider$()
};
goog.$exportProperty$(AuraComponentService.prototype, "getAttributeProviderForElement", AuraComponentService.prototype.$getAttributeProviderForElement$);
AuraComponentService.prototype.$containsComponent$ = function() {
  function contains(container, cmp, visited, isOwner) {
    if(container === cmp) {
      return{result:true, $isOwner$:isOwner}
    }
    if(!cmp || !container || visited[cmp.$globalId$]) {
      return{result:false}
    }
    visited[cmp.$globalId$] = true;
    var answer = contains(container, cmp.$getSuper$(), visited, isOwner);
    if(!answer.result) {
      for(var next = cmp;next;) {
        next = next.$getOwner$();
        if(next === cmp || !$A["util"].$isComponent$(next)) {
          return{result:false}
        }
        if(next.$getGlobalId$() !== cmp.$getGlobalId$()) {
          answer = contains(container, next, visited, isOwner);
          break
        }else {
          cmp = next
        }
      }
    }
    if(!answer.result) {
      answer = contains(container, cmp.$getContainer$(), visited, false)
    }
    return answer
  }
  return function(container, cmp) {
    return contains(container, cmp, {}, true)
  }
}();
AuraComponentService.prototype.$newComponentArray$ = function(config, attributeValueProvider, localCreation, doForce) {
  var ret = [];
  for(var i = 0;i < config.length;i++) {
    ret.push(this.$newComponentDeprecated$(config[i], attributeValueProvider, localCreation, doForce))
  }
  return ret
};
AuraComponentService.prototype.$createComponent$ = function(type, attributes, callback) {
  $A.assert($A["util"].$isString$(type), "ComponentService.createComponent(): 'type' must be a valid String.");
  $A.assert(!attributes || $A["util"].$isObject$(attributes), "ComponentService.createComponent(): 'attributes' must be a valid Object.");
  $A.assert($A["util"].$isFunction$(callback), "ComponentService.createComponent(): 'callback' must be a Function pointer.");
  if(type.indexOf(":") < 0) {
    attributes = {"tag":type, "HTMLAttributes":attributes};
    type = "aura:html"
  }
  var config = {"componentDef":this.$createDescriptorConfig$(type), "attributes":{"values":attributes}, "localId":attributes && attributes["aura:id"], "flavor":attributes && attributes["aura:flavor"], "skipCreationPath":true};
  this.$createComponentPrivAsync$(config, callback)
};
goog.$exportProperty$(AuraComponentService.prototype, "createComponent", AuraComponentService.prototype.$createComponent$);
AuraComponentService.prototype.$createInternalConfig$ = function(config) {
  var descriptor = config["descriptor"];
  $A.assert(descriptor.indexOf("markup://") === 0, "Descriptor needs to be of the format markup://ns:name");
  return{"componentDef":this.$createDescriptorConfig$(config["descriptor"]), "localId":config["localId"] || config["aura:id"], "flavor":config["flavor"], "skipCreationPath":config["skipCreationPath"], "attributes":{"values":config["attributes"], "valueProvider":config["valueProvider"]}}
};
AuraComponentService.prototype.$createComponentFromConfig$ = function(config) {
  $A.assert(config, "Config is required to create a component");
  if(config["descriptor"]) {
    config = this.$createInternalConfig$(config)
  }
  if(!config["attributes"]) {
    config["attributes"] = {}
  }
  return this.$createComponentPriv$(config)
};
goog.$exportProperty$(AuraComponentService.prototype, "createComponentFromConfig", AuraComponentService.prototype.$createComponentFromConfig$);
AuraComponentService.prototype.$createComponents$ = function(components, callback) {
  function getCollector(index) {
    return function(component, status, statusMessage) {
      created[index] = component;
      statusList[index] = {"status":status, "message":statusMessage};
      if(status === "ERROR" || status === "INCOMPLETE" && overallStatus !== "ERROR") {
        overallStatus = status
      }
      if(++collected === components.length) {
        callback(created, overallStatus, statusList)
      }
    }
  }
  $A.assert($A["util"].isArray(components), "ComponentService.createComponents(): 'components' must be a valid Array.");
  $A.assert($A["util"].$isFunction$(callback), "ComponentService.createComponents(): 'callback' must be a Function pointer.");
  var created = [];
  var overallStatus = "SUCCESS";
  var statusList = [];
  var collected = 0;
  for(var i = 0;i < components.length;i++) {
    this.$createComponent$(components[i][0], components[i][1], getCollector(i))
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "createComponents", AuraComponentService.prototype.$createComponents$);
AuraComponentService.prototype.$newComponent$ = function(config, attributeValueProvider, localCreation, doForce) {
  $A.$deprecated$("$A.newCmp and $A.componentService.newComponent are no longer supported.", "Use '$A.createComponent();'.", "AuraComponentService.newComponent");
  return this.$newComponentDeprecated$(config, attributeValueProvider, localCreation, doForce)
};
goog.$exportProperty$(AuraComponentService.prototype, "newComponent", AuraComponentService.prototype.$newComponent$);
AuraComponentService.prototype.$newComponentDeprecated$ = function(config, attributeValueProvider, localCreation, doForce) {
  $A.$deprecated$("$A.newCmpDeprecated and $A.componentService.newComponentDeprecated are not supported.", "Use '$A.createComponent();'.", "AuraComponentService.newComponentDeprecated");
  $A.assert(config, "config is required in ComponentService.newComponentDeprecated(config)");
  if($A["util"].isArray(config)) {
    return this.$newComponentArray$(config, attributeValueProvider, localCreation, doForce)
  }
  var configObj = this.$getComponentConfigs$(config, attributeValueProvider);
  var def = configObj["definition"];
  var desc = configObj["descriptor"];
  var load;
  config = configObj["configuration"];
  if(doForce !== true && !config["creationPath"]) {
    if(def && !def.$hasRemoteDependencies$()) {
      localCreation = true;
      delete config["load"]
    }else {
      if(!config["load"]) {
        load = "LAZY"
      }else {
        load = config["load"]
      }
    }
  }
  if(desc === "markup://aura:placeholder") {
    load = null
  }
  if(load === "LAZY" || load === "EXCLUSIVE") {
    localCreation = true;
    var oldConfig = config;
    config = {"componentDef":{"descriptor":"markup://aura:placeholder"}, "localId":oldConfig["localId"], "attributes":{"values":{"refDescriptor":desc, "attributes":oldConfig["attributes"] ? oldConfig["attributes"]["values"] : null, "exclusive":oldConfig["load"] === "EXCLUSIVE"}, "valueProvider":oldConfig["valueProvider"]}}
  }else {
    if(!$A.$clientService$.$allowAccess$(def)) {
      var message = "Access Check Failed! AuraComponentService.newComponentDeprecated(): '" + (def && def.$getDescriptor$().$getQualifiedName$()) + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        return null
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
  }
  return this.$createComponentInstance$(config, localCreation, def)
};
goog.$exportProperty$(AuraComponentService.prototype, "newComponentDeprecated", AuraComponentService.prototype.$newComponentDeprecated$);
AuraComponentService.prototype.$createComponentInstance$ = function(config, localCreation, def) {
  if(!config["skipCreationPath"]) {
    var context = $A.getContext();
    var creationPath;
    var action;
    action = context.$getCurrentAction$();
    if(action) {
      var newConfig;
      var currentPath = action.$topPath$();
      if(config["creationPath"]) {
        creationPath = action.$forceCreationPath$(config["creationPath"]);
        action.$releaseCreationPath$(creationPath)
      }else {
        if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        }else {
          creationPath = action.$getCurrentPath$()
        }
      }
      if(creationPath) {
        newConfig = context.$getComponentConfig$(creationPath);
        if(newConfig) {
          config["componentDef"] = newConfig["componentDef"]
        }
      }
    }
  }
  var componentDef = config["componentDef"];
  var desc = componentDef[Json.$ApplicationKey$.$DESCRIPTOR$] || componentDef;
  if(desc.$getDescriptor$) {
    desc = desc.$getDescriptor$().$getQualifiedName$()
  }else {
    if(desc.$getQualifiedName$) {
      desc = desc.$getQualifiedName$()
    }else {
      if(desc.indexOf("://") === -1) {
        desc = "markup://" + desc
      }
    }
  }
  var componentClassDef = config["componentClass"] || config["componentDef"][Json.$ApplicationKey$.$COMPONENTCLASS$];
  if(componentClassDef && !this.$hasComponentClass$(desc)) {
    try {
      var trustedScript = $A.$lockerService$.$trusted$["createScript"](componentClassDef);
      componentClassDef = $A["util"].$globalEval$(trustedScript, desc)
    }catch(e) {
      var e1 = new $A.$auraError$("error in eval of componentClass definition", e);
      e1.$setComponent$(desc);
      throw e1;
    }
    componentClassDef()
  }
  if(!this.$hasComponentClass$(desc)) {
    this.$createFromSavedComponentConfigs$(desc)
  }
  var classConstructor;
  try {
    classConstructor = this.$getComponentClass$(desc, def)
  }catch(e$$0) {
    var e2 = new $A.$auraError$("failure when getting component class definition", e$$0);
    e2.$setComponent$(desc);
    throw e2;
  }
  if(!classConstructor) {
    throw new $A.$auraError$("Component class not found: " + desc, null, $A.severity.$QUIET$);
  }
  return new classConstructor(config, localCreation)
};
AuraComponentService.prototype.$addComponentClass$ = function(descriptor, exporter, sourceMap) {
  if(sourceMap) {
    this.$sourceMapRegistry$.$addSourceMapEntry$(descriptor, sourceMap, "component")
  }
  return this.$componentClassRegistry$.$addComponentClass$(descriptor, exporter)
};
goog.$exportProperty$(AuraComponentService.prototype, "addComponentClass", AuraComponentService.prototype.$addComponentClass$);
AuraComponentService.prototype.$normalizeModuleName$ = function(name) {
  var normalizedName = name;
  if(normalizedName.indexOf("/") !== -1) {
    var nameParts = name.split("/");
    normalizedName = nameParts.shift().toLowerCase() + "/" + nameParts.join("/")
  }
  return normalizedName
};
goog.$exportProperty$(AuraComponentService.prototype, "normalizeModuleName", AuraComponentService.prototype.$normalizeModuleName$);
AuraComponentService.prototype.$initModuleDefs$ = function(modules) {
  var moduleDefRegistry = this.$moduleDefRegistry$;
  var code = Json.$ApplicationKey$.$CODE$;
  var minVersion = Json.$ApplicationKey$.$MINVERSION$;
  var access = Json.$ApplicationKey$.$ACCESS$;
  var requireLocker = Json.$ApplicationKey$.$REQUIRELOCKER$;
  var attributeDefs = Json.$ApplicationKey$.$ATTRIBUTEDEFS$;
  var customElement = Json.$ApplicationKey$.$CUSTOMELEMENT$;
  var descriptor = Json.$ApplicationKey$.$DESCRIPTOR$;
  var lockerReferenceInfo = Json.$ApplicationKey$.$LOCKER_REFERENCE_INFO$;
  var lockerVersion = Json.$ApplicationKey$.$LOCKER_VERSION$;
  var runtimeNamespace = Json.$ApplicationKey$.$RUNTIME_NAMESPACE$;
  var moduleLocation = Json.$ApplicationKey$.$MODULELOCATION$;
  modules.forEach(function(module) {
    if(!moduleDefRegistry[module[Json.$ApplicationKey$.$DESCRIPTOR$]]) {
      var exporter = {"exporter":module[code]};
      var name = module[Json.$ApplicationKey$["NAME"]];
      var normalizedName = AuraComponentService.prototype.$normalizeModuleName$(name);
      exporter[minVersion] = module[minVersion];
      exporter[access] = module[access];
      exporter[requireLocker] = module[requireLocker];
      exporter[attributeDefs] = module[attributeDefs];
      exporter[customElement] = module[customElement];
      exporter[lockerVersion] = module[lockerVersion];
      exporter[lockerReferenceInfo] = module[lockerReferenceInfo];
      exporter[runtimeNamespace] = module[runtimeNamespace];
      exporter[descriptor] = module[descriptor];
      moduleDefRegistry[module[descriptor]] = moduleDefRegistry[name] = moduleDefRegistry[normalizedName] = exporter;
      if(module[moduleLocation]) {
        this.$sourceMapRegistry$.$addSourceMapEntry$(module[descriptor], module[moduleLocation], "component");
        exporter[moduleLocation] = module[moduleLocation]
      }
    }
  }.bind(this))
};
goog.$exportProperty$(AuraComponentService.prototype, "initModuleDefs", AuraComponentService.prototype.$initModuleDefs$);
AuraComponentService.prototype.$addModule$ = function(descriptor, name, dependencies, exporterClass, nsexports) {
  if(exporterClass === undefined) {
    return this.$addModule$(descriptor, name, [], dependencies)
  }
  var moduleDefRegistry = this.$moduleDefRegistry$;
  var normalizedName = this.$normalizeModuleName$(name);
  var entry = this.$moduleDefRegistry$[descriptor] || (moduleDefRegistry[descriptor] = moduleDefRegistry[normalizedName] = moduleDefRegistry[name] = {});
  entry[Json.$ApplicationKey$.$DEPENDENCIES$] = dependencies;
  entry.definition = exporterClass;
  entry.$descriptor$ = descriptor;
  entry.$moduleName$ = normalizedName;
  entry.$ns$ = nsexports;
  entry.$stage$ = "addedModule"
};
goog.$exportProperty$(AuraComponentService.prototype, "addModule", AuraComponentService.prototype.$addModule$);
AuraComponentService.prototype.$evaluateModuleDef$ = function(descriptor) {
  var entry = this.$moduleDefRegistry$[descriptor] || this.$getLibraryAsModule$(descriptor);
  var factory;
  var exportns;
  var DEPENDENCIES = Json.$ApplicationKey$.$DEPENDENCIES$;
  var LOCKER_VERSION = Json.$ApplicationKey$.$LOCKER_VERSION$;
  var LOCKER_VERSION_LEGACY = Json.$ApplicationKey$.$LOCKER_VERSION_LEGACY$;
  var LOCKER_VERSION_NEXT = Json.$ApplicationKey$.$LOCKER_VERSION_NEXT$;
  var REQUIRELOCKER = Json.$ApplicationKey$.$REQUIRELOCKER$;
  var RUNTIME_NAMESPACE = Json.$ApplicationKey$.$RUNTIME_NAMESPACE$;
  var createLockerDescriptor = $A.$lockerService$.$createDescriptor$;
  var lockerWrap = $A.$lockerService$.$wrap$;
  $A.assert(entry, "Failed to find definition for dependency: " + descriptor);
  if(entry.$ns$) {
    return entry.$ns$
  }
  if(!entry[DEPENDENCIES]) {
    var exporter = entry["exporter"];
    if(typeof exporter === "function") {
      factory = exporter
    }else {
      var trustedScript = $A.$lockerService$.$trusted$["createScript"](exporter);
      factory = $A["util"].$globalEval$(trustedScript, descriptor)
    }
    factory()
  }
  entry.$stage$ = "evaluatingModuleDef";
  var namespaceAliases = $A.getContext().$moduleNamespaceAliases$;
  var entryDescriptor = createLockerDescriptor(entry);
  var requireLockerDef = entry[REQUIRELOCKER];
  var isLockerLegacyDef = requireLockerDef && entry[LOCKER_VERSION] === LOCKER_VERSION_LEGACY;
  var isLockerNextDef = requireLockerDef && entry[LOCKER_VERSION] === LOCKER_VERSION_NEXT;
  var log = {"descriptor":descriptor, "isLockerLegacyDef":!!isLockerLegacyDef, "isLockerNextDef":!!isLockerNextDef, "totalDeps":entry[DEPENDENCIES].length, "exports":0, "cDeps":[], "entryDefExists":false, "entryDefResults":"", "entryNsSet":false};
  var deps = entry[DEPENDENCIES].map(function convertDependency(name) {
    if(name === "exports") {
      log["exports"]++;
      exportns = {};
      $A.$lockerService$.$markLiveObject$(exportns);
      return exportns
    }
    var desc;
    var depEntry;
    var depLog = {name:name};
    var isScopedImport = name[0] === "@";
    if(isScopedImport) {
      var preventLegacyLockerScopedImports = $A.$lockerService$.isEnabled() && isLockerLegacyDef;
      if(preventLegacyLockerScopedImports) {
        $A.assert($A["util"].$isEmpty$(entry[RUNTIME_NAMESPACE]), "Scoped imports not allowed when a runtime namespace is specified: " + descriptor + " Name: " + name)
      }
      var moduleScope = name.substr(1).split("/")[0];
      if(name === "@salesforce/loader") {
        var loader = $A.$clientService$.$resolveScopedModuleImport$(moduleScope, name);
        return Object.assign({}, loader, {load:function interopLoad(moduleName) {
          return loader.load(moduleName, descriptor)
        }})
      }
      return $A.$clientService$.$resolveScopedModuleImport$(moduleScope, name)
    }else {
      if(name.indexOf(":") !== -1) {
        desc = "markup://" + name
      }else {
        desc = name;
        var names = name.split("/");
        var ns = names[0];
        var descName = names[1];
        var aliased = namespaceAliases[ns];
        if(aliased) {
          var aliasedDesc = "markup://" + aliased + ":" + descName;
          depLog["alias"] = aliasedDesc;
          var aliasedDep = this.$moduleDefRegistry$[aliasedDesc];
          if(aliasedDep) {
            depEntry = aliasedDep;
            desc = aliasedDesc
          }
          depLog["aliasFound"] = $A["util"].$getType$(aliasedDep)
        }
      }
    }
    if(!depEntry) {
      depEntry = this.$moduleDefRegistry$[desc]
    }
    if(depEntry && depEntry[DEPENDENCIES]) {
      var dep = this.$moduleDefRegistry$[desc];
      var depDescriptor = createLockerDescriptor(dep);
      var isLockerLegacyDep = depEntry[REQUIRELOCKER] && depEntry[LOCKER_VERSION] === LOCKER_VERSION_LEGACY;
      if(dep.$ns$) {
        if(isLockerNextDef || isLockerLegacyDef || isLockerLegacyDep) {
          return lockerWrap(dep.$ns$, depDescriptor, entryDescriptor, isLockerNextDef, $A.$lockerService$.$isLWSInternalNamespace$(entryDescriptor.$namespace$.toLowerCase(), descriptor))
        }
        return dep.$ns$
      }else {
        var tmp$$0 = function tmp() {
          if(!dep.$ns$) {
            depEntry[DEPENDENCIES].filter(function(depOfDep) {
              var defOfdepOfDep = $A.$componentService$.$moduleDefRegistry$[depOfDep];
              return defOfdepOfDep && !defOfdepOfDep.$ns$ && /^force[gG]enerated\/.*___RecordLayoutTemplate$/gm.test(depOfDep)
            }).forEach(function(unresolvedDepOfDep) {
              $A.$componentService$.$evaluateModuleDef$(unresolvedDepOfDep)
            });
            $A.$componentService$.$evaluateModuleDef$(desc)
          }
          depLog["resolved"] = !!dep.$ns$;
          depLog["stage"] = dep.$stage$;
          if(!depLog["resolved"]) {
            var logObj = Object.assign({}, log);
            logObj["cDeps"] = JSON.stringify(logObj["cDeps"]);
            $A.$metricsService$.transaction("ltng", "interaction", {"context":{"eventSource":"synthetic-aura-null-constructor", "eventType":"system", "attributes":{"log":logObj}}})
          }
          if(isLockerNextDef || isLockerLegacyDef || isLockerLegacyDep) {
            return lockerWrap(dep.$ns$, depDescriptor, entryDescriptor, isLockerNextDef)
          }
          return dep.$ns$
        };
        log["cDeps"].push(depLog);
        tmp$$0["__circular__"] = true;
        return tmp$$0
      }
    }
    var resolved = this.$evaluateModuleDef$(desc);
    if(isLockerNextDef || isLockerLegacyDef) {
      return lockerWrap(resolved, createLockerDescriptor(depEntry), entryDescriptor, isLockerNextDef)
    }
    return resolved
  }, this);
  var Ctor;
  log["entryDefExists"] = !!entry.definition;
  log["entryDefType"] = $A["util"].$getType$(entry.definition);
  if(entry.definition && $A["util"].$isFunction$(entry.definition)) {
    if(isLockerLegacyDef) {
      entry.definition = $A.$lockerService$.$createForModule$(entry.definition.toString(), entryDescriptor)
    }else {
      if(isLockerNextDef) {
        var namespace = entryDescriptor.$getNamespace$();
        var lockerKey = $A.$lockerService$.$getKeyForNamespace$(namespace);
        var lockerEnv = $A.$lockerService$.$getEnv$(lockerKey);
        entry.definition = $A.$lockerService$.$evaluateModuleInSandbox$(namespace, entry.definition, entryDescriptor);
        $A.$lockerService$.$trust$(lockerEnv, entry.definition)
      }
    }
    Ctor = entry.definition.apply(undefined, deps)
  }
  log["ctorType"] = $A["util"].$getType$(Ctor);
  log["exportnsType"] = $A["util"].$getType$(exportns);
  Ctor = Ctor || exportns;
  entry.$ns$ = Ctor;
  log["entryNsSet"] = true;
  if($A["util"].$isEmpty$(Ctor)) {
    log["cDeps"] = JSON.stringify(log["cDeps"]);
    $A.$metricsService$.transaction("ltng", "interaction", {"context":{"eventSource":"synthetic-aura-null-constructor", "eventType":"system", "attributes":{"log":log}}})
  }
  $A.$lockerService$.$trust$(entry.definition, Ctor);
  if(isLockerLegacyDef && exportns) {
    var key = $A.$lockerService$.$getKeyForNamespace$(entryDescriptor["runtimeNamespace"] || entryDescriptor.$getNamespace$());
    var nsKeys = Object.keys(entry.$ns$);
    var i = 0;
    for(var len = nsKeys.length;i < len;i++) {
      var k = nsKeys[i];
      var namedExport = entry.$ns$[k];
      if($A["util"].$isFunction$(namedExport) && $A.$lockerService$.$isSecureLightningElement$(namedExport, key)) {
        $A.$lockerService$.$trust$(entry.definition, namedExport)
      }
    }
  }
  entry.$stage$ = "evaluatedModuleDef";
  return Ctor
};
AuraComponentService.prototype.$createInteropComponentDef$ = function(descriptor) {
  var Ctor = this.$evaluateModuleDef$(descriptor);
  var module = this.$moduleDefRegistry$[descriptor];
  var interOpCmpDef = new Aura.$Component$.$InteropComponentDef$({$dependencies$:module[Json.$ApplicationKey$.$DEPENDENCIES$], definition:module.definition, $descriptor$:module.$descriptor$, $moduleName$:module.$moduleName$, $elementName$:module[Json.$ApplicationKey$.$CUSTOMELEMENT$], $access$:module[Json.$ApplicationKey$.$ACCESS$], $minVersion$:module[Json.$ApplicationKey$.$MINVERSION$], $attributeDefs$:module[Json.$ApplicationKey$.$ATTRIBUTEDEFS$], $requireLocker$:module[Json.$ApplicationKey$.$REQUIRELOCKER$], 
  $interopClass$:Ctor});
  this.$componentDefRegistry$[descriptor] = interOpCmpDef;
  return interOpCmpDef
};
AuraComponentService.prototype.$getComponentClass$ = function(descriptor, def) {
  return this.$componentClassRegistry$.$getComponentClass$(descriptor, def)
};
goog.$exportProperty$(AuraComponentService.prototype, "getComponentClass", AuraComponentService.prototype.$getComponentClass$);
AuraComponentService.prototype.$initEventDefs$ = function(evtConfigs) {
  for(var i = 0;i < evtConfigs.length;i++) {
    $A.$eventService$.$saveEventConfig$(evtConfigs[i])
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "initEventDefs", AuraComponentService.prototype.$initEventDefs$);
AuraComponentService.prototype.$initLibraryDefs$ = function(libraryConfigs) {
  for(var i = 0;i < libraryConfigs.length;i++) {
    $A.$componentService$.$saveLibraryConfig$(libraryConfigs[i])
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "initLibraryDefs", AuraComponentService.prototype.$initLibraryDefs$);
AuraComponentService.prototype.$initControllerDefs$ = function(controllerConfigs) {
  for(var i = 0;i < controllerConfigs.length;i++) {
    $A.$componentService$.$createControllerDef$(controllerConfigs[i])
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "initControllerDefs", AuraComponentService.prototype.$initControllerDefs$);
AuraComponentService.prototype.$hasComponentClass$ = function(descriptor) {
  return this.$componentClassRegistry$.$hasComponentClass$(descriptor)
};
AuraComponentService.prototype.$newComponentAsync$ = function(callbackScope, callback, config, attributeValueProvider, localCreation, doForce, forceServer) {
  function collectComponent(newComponent, status, statusMessage, index) {
    components[index] = newComponent;
    statusList[index] = status;
    if(status === "ERROR" || status === "INCOMPLETE" && overallStatus !== "ERROR") {
      overallStatus = status
    }
    if(++collected === config.length) {
      callback.call(callbackScope, isSingle ? components[0] : components, overallStatus, statusList)
    }
  }
  $A.$deprecated$("$A.newCmpAsync and $A.componentService.newComponentAsync are not supported.", "Use '$A.createComponent()'");
  $A.assert(config, "ComponentService.newComponentAsync(): 'config' must be a valid Object.");
  $A.assert($A["util"].$isFunction$(callback), "ComponentService.newComponentAsync(): 'callback' must be a Function pointer.");
  var isSingle = !$A["util"].isArray(config);
  if(isSingle) {
    config = [config]
  }
  var components = [];
  var overallStatus = "SUCCESS";
  var statusList = [];
  var collected = 0;
  if($A.getContext().$uriAddressableDefsEnabled$) {
    var descriptorMap = {};
    for(var idx = 0;idx < config.length;idx++) {
      if(config[idx]) {
        var cfg = this.$getComponentConfigs$(config[idx], attributeValueProvider);
        var descriptor = cfg["descriptor"]["descriptor"] || cfg["descriptor"];
        if(!cfg["definition"] && descriptor.indexOf("layout://") === -1) {
          descriptorMap[descriptor] = undefined
        }
      }
    }
    if(Object.keys(descriptorMap).length > 0) {
      this.$loadComponentDefs$(descriptorMap, $A.$getCallback$(function newComponentAsyncDefsLoaded() {
        $A.$componentService$.$newComponentAsync$(callbackScope, callback, isSingle ? config[0] : config, attributeValueProvider, localCreation, doForce, forceServer)
      }));
      return
    }
  }
  for(var i = 0;i < config.length;i++) {
    var configItem = config[i];
    if(configItem) {
      var configObj = this.$getComponentConfigs$(configItem, attributeValueProvider);
      var def = configObj["definition"];
      var desc = configObj["descriptor"]["descriptor"] || configObj["descriptor"];
      var forceClient = false;
      configItem = configObj["configuration"];
      if(configItem["creationPath"] && !forceServer) {
        forceClient = true
      }
      configItem["componentDef"] = {"descriptor":desc};
      if(!def && desc.indexOf("layout://") === 0) {
        $A.$componentService$.$dynamicNamespaces$ = [];
        throw new $A.$auraError$("Missing definition: " + desc, null, $A.severity.$QUIET$);
      }
      if(!forceClient && (!def || def && def.$hasRemoteDependencies$() || forceServer)) {
        var action = this.$requestComponent$(collectComponent, configItem, attributeValueProvider, i);
        $A.$enqueueAction$(action)
      }else {
        if($A.$clientService$.$allowAccess$(def)) {
          collectComponent(this["newComponentDeprecated"](configItem, attributeValueProvider, localCreation, doForce), "SUCCESS", "", i)
        }else {
          var message = "Access Check Failed! AuraComponentService.newComponentAsync(): '" + def.$getDescriptor$().$getQualifiedName$() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
          if($A.$clientService$.$enableAccessChecks$) {
            if($A.$clientService$.$logAccessFailures$) {
              $A.error(null, new $A.$auraError$(message))
            }
            collectComponent(null, "ERROR", "Unknown component '" + desc + "'.", i)
          }else {
            if($A.$clientService$.$logAccessFailures$) {
              $A.$warning$(message)
            }
            collectComponent(this["newComponentDeprecated"](configItem, attributeValueProvider, localCreation, doForce), "SUCCESS", "", i)
          }
        }
      }
    }
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "newComponentAsync", AuraComponentService.prototype.$newComponentAsync$);
AuraComponentService.prototype.$getDefinitionOfAnyType$ = function(descriptor) {
  descriptor = this.$getDescriptorFromConfig$(descriptor);
  return this.$getDef$(descriptor) || this.$getLibrary$(descriptor) || $A.$eventService$.$getDef$(descriptor)
};
AuraComponentService.prototype.$hasCacheableDefinitionOfAnyType$ = function(descriptor) {
  var desc = this.$getDescriptorFromConfig$(descriptor);
  return!!this.$hasModuleDefinition$(desc) || !!this.$componentDefRegistry$[desc] || this.$savedComponentConfigs$[desc] && Object.keys(this.$savedComponentConfigs$[desc]).length > 1 || $A["util"].$isFunction$(this.$savedComponentConfigs$[desc]) || !!this.$hasLibrary$(desc) || !!$A.$eventService$.$getEventDef$(desc)
};
AuraComponentService.prototype.$loadComponentDefs$ = function(descriptorMap, callback) {
  var missingDescriptorMap = {};
  for(var descriptor in descriptorMap) {
    if(descriptor.indexOf("://") === -1) {
      descriptor = "markup://" + descriptor
    }
    try {
      if(!this.$hasCacheableDefinitionOfAnyType$(descriptor)) {
        missingDescriptorMap[descriptor] = descriptorMap[descriptor]
      }else {
        if(this.$componentDefLoader$.$requestedDescriptors$[descriptor]) {
          delete this.$componentDefLoader$.$requestedDescriptors$[descriptor]
        }
      }
    }catch(e) {
    }
  }
  if(!$A["util"].$isObject$(missingDescriptorMap) || Object.keys(missingDescriptorMap).length === 0) {
    callback();
    return
  }
  this.$componentDefLoader$.$loadComponentDefs$(missingDescriptorMap, callback)
};
AuraComponentService.prototype.$requestComponent$ = function(callback, config, avp, index, returnNullOnError) {
  var action = $A.get("c.aura://ComponentController.getComponent");
  var attributes = config["attributes"] ? config["attributes"]["values"] ? config["attributes"]["values"] : config["attributes"] : null;
  var atts = {};
  for(var key in attributes) {
    var value = attributes[key];
    if(value && value.hasOwnProperty("value")) {
      value = value["value"]
    }
    var auraValue = valueFactory.create(value, avp);
    atts[key] = this.$computeValue$(auraValue, avp)
  }
  action.$setCallback$(this, function getComponentCallback(a) {
    if(avp && avp.$isValid$ && !avp.$isValid$()) {
      return
    }
    if($A.$clientService$.$currentAccess$ && !$A.$clientService$.$currentAccess$.$isValid$()) {
      return
    }
    var newComp = null;
    var status = a.$getState$();
    var statusMessage = "";
    if(status === "SUCCESS") {
      var returnedConfig = a.$getReturnValue$();
      if(!returnedConfig["attributes"]) {
        returnedConfig["attributes"] = {}
      }
      returnedConfig["attributes"]["valueProvider"] = avp;
      var merging = returnedConfig["attributes"];
      if(merging.hasOwnProperty("values")) {
        merging = merging["values"]
      }
      for(var mkey in attributes) {
        merging[mkey] = attributes[mkey]
      }
      returnedConfig["localId"] = config["localId"];
      returnedConfig["flavor"] = config["flavor"];
      var error;
      try {
        newComp = this.$createComponentPriv$(returnedConfig)
      }catch(e) {
        status = "ERROR";
        statusMessage = e.message;
        error = e
      }
      if($A["util"].$isFunction$(callback)) {
        callback(newComp, status, statusMessage, index, error)
      }
    }else {
      var errors = a.getError();
      statusMessage = errors && errors[0] ? errors[0].message : "Unknown Error.";
      if(statusMessage !== "Event fired") {
        if(!returnNullOnError) {
          newComp = this.$createComponentPriv$({"componentDef":{"descriptor":"markup://aura:text"}, "attributes":{"values":{"value":statusMessage}}})
        }
        if($A["util"].$isFunction$(callback)) {
          callback(newComp, status, statusMessage, index)
        }
      }
    }
  });
  action.$setParams$({"name":config["componentDef"]["descriptor"], "attributes":atts});
  return action
};
AuraComponentService.prototype.$computeValue$ = function(value, valueProvider) {
  if($A["util"].$isExpression$(value)) {
    value = value.evaluate(valueProvider)
  }
  if($A["util"].$isComponent$(value)) {
    return null
  }
  if($A["util"].isArray(value)) {
    var newValue = [];
    var c = 0;
    for(var length = value.length;c < length;c++) {
      if(!$A["util"].$isComponent$(value[c])) {
        newValue.push(value[c])
      }
    }
    value = newValue
  }
  return value
};
goog.$exportProperty$(AuraComponentService.prototype, "computeValue", AuraComponentService.prototype.$computeValue$);
AuraComponentService.prototype.$getComponentConfigs$ = function(config, attributeValueProvider) {
  var configuration;
  var configAttributes;
  var def;
  var desc;
  var configKey;
  var attributeKey;
  if(config && $A["util"].$isString$(config)) {
    config = {"componentDef":config}
  }
  if(attributeValueProvider) {
    configuration = {};
    for(configKey in config) {
      if(config.hasOwnProperty(configKey)) {
        configuration[configKey] = config[configKey]
      }
    }
    configAttributes = config["attributes"];
    configuration["attributes"] = {};
    if(configAttributes) {
      for(attributeKey in configAttributes) {
        if(configAttributes.hasOwnProperty(attributeKey)) {
          configuration["attributes"][attributeKey] = configAttributes[attributeKey]
        }
      }
    }
    configuration["attributes"]["valueProvider"] = attributeValueProvider
  }else {
    configuration = config
  }
  var componentDef = configuration["componentDef"];
  def = this.$getDef$(componentDef);
  if(!def && componentDef[Json.$ApplicationKey$.$ATTRIBUTEDEFS$]) {
    def = this.$createComponentDef$(componentDef)
  }
  if(def) {
    desc = def.$getDescriptor$().toString()
  }else {
    desc = componentDef[Json.$ApplicationKey$.$DESCRIPTOR$] ? componentDef[Json.$ApplicationKey$.$DESCRIPTOR$] : componentDef
  }
  return{"configuration":configuration, "definition":def, "descriptor":desc}
};
AuraComponentService.prototype.$indexComponent$ = function(component) {
  this.$indexes$.$globalId$[component.$globalId$] = component
};
AuraComponentService.prototype.$hasDefinition$ = function(descriptor) {
  return!!this.$getDef$(descriptor)
};
AuraComponentService.prototype.$getUnusedDefinitions$ = function() {
  return Object.keys(this.$savedComponentConfigs$)
};
goog.$exportProperty$(AuraComponentService.prototype, "getUnusedDefinitions", AuraComponentService.prototype.$getUnusedDefinitions$);
AuraComponentService.prototype.$getDefinition$ = function(descriptor, callback) {
  var def = this.$getComponentDef$(this.$createDescriptorConfig$(descriptor));
  if(def) {
    if(!$A.$clientService$.$allowAccess$(def)) {
      var message = "Access Check Failed! ComponentService.getDef():'" + def.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        callback(null);
        return
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
    callback(def);
    return
  }
  var action = $A.get("c.aura://ComponentController.getComponentDef");
  action.$setParams$({"name":descriptor});
  action.$setCallback$(this, function(actionResponse) {
    if(actionResponse.$getState$() === "SUCCESS") {
      callback(this.$getDef$(descriptor))
    }else {
      if(actionResponse.$getState$() === "ERROR") {
        actionResponse.getError().forEach(function(e) {
          $A.$warning$(e.message)
        });
        callback(null)
      }else {
        callback(null)
      }
    }
  });
  $A.$enqueueAction$(action)
};
AuraComponentService.prototype.$getComponentDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var definition = this.$componentDefRegistry$[descriptor];
  if(!definition && this.$savedComponentConfigs$[descriptor]) {
    return this.$createFromSavedComponentConfigs$(config)
  }else {
    if(!definition && this.$moduleDefRegistry$[descriptor]) {
      return this.$createInteropComponentDef$(descriptor)
    }
  }
  return definition
};
AuraComponentService.prototype.$getCachedComponentDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  return this.$componentDefRegistry$[descriptor]
};
AuraComponentService.prototype.$hasDefinition$ = function(descriptor) {
  return!!this.$getDef$(descriptor)
};
AuraComponentService.prototype.$hasModuleDefinition$ = function(moduleName) {
  return!!this.$moduleDefRegistry$[moduleName]
};
AuraComponentService.prototype.$getModuleDescriptorForElementName$ = function(elementName) {
  var descriptors = Object.keys(this.$moduleDefRegistry$);
  var i = 0;
  for(var len = descriptors.length;i < len;i++) {
    var key = descriptors[i];
    var module = this.$moduleDefRegistry$[key];
    if(module[Json.$ApplicationKey$.$CUSTOMELEMENT$] === elementName) {
      return module.$descriptor$
    }
  }
};
AuraComponentService.prototype.$getDef$ = function(descriptor) {
  $A.assert(descriptor, "No ComponentDef descriptor specified");
  var def = this.$getComponentDef$(this.$createDescriptorConfig$(descriptor));
  if(def && !$A.$clientService$.$allowAccess$(def)) {
    var message = "Access Check Failed! ComponentService.getDef():'" + def.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return undefined
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return def
};
goog.$exportProperty$(AuraComponentService.prototype, "getDef", AuraComponentService.prototype.$getDef$);
AuraComponentService.prototype.$addComponent$ = function(descriptor, exporter) {
  this.$savedComponentConfigs$[descriptor] = exporter
};
goog.$exportProperty$(AuraComponentService.prototype, "addComponent", AuraComponentService.prototype.$addComponent$);
AuraComponentService.prototype.$hydrateComponent$ = function(descriptor, exporter) {
  var script = $A.$clientService$.$uncommentExporter$(exporter);
  exporter = $A.$clientService$.$evalExporter$(script, descriptor);
  if(!exporter) {
    var defDescriptor = new Aura.$System$.$DefDescriptor$(descriptor);
    var includeComponentSource = defDescriptor.$getPrefix$() === "layout" || defDescriptor.$getPrefix$() === "sitelayout" || $A.$clientService$.$isInternalNamespace$(defDescriptor.$getNamespace$());
    var errorMessage = !includeComponentSource ? "Hydrating the component" + descriptor + " failed." : "Hydrating the component" + descriptor + " failed.\n Exporter code: " + script;
    var auraError = new $A.$auraError$(errorMessage, null, $A.severity.$QUIET$);
    auraError.$setComponent$(descriptor);
    throw auraError;
  }
  return exporter()
};
AuraComponentService.prototype.$createFromSavedComponentConfigs$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var cmpConfig = this.$savedComponentConfigs$[descriptor];
  var definition = typeof cmpConfig === "function" ? this.$hydrateComponent$(descriptor, cmpConfig) : cmpConfig;
  var alreadyHasConstructor = this.$componentClassRegistry$.$classConstructors$[descriptor] || this.$componentClassRegistry$.$classExporter$[descriptor];
  var hasBuiltInConstructor = cmpConfig && cmpConfig.hasOwnProperty(Json.$ApplicationKey$.$COMPONENTCLASS$);
  if(alreadyHasConstructor || hasBuiltInConstructor) {
    var def = new ComponentDef(definition);
    this.$componentDefRegistry$[descriptor] = def;
    delete this.$savedComponentConfigs$[descriptor];
    return def
  }
  return null
};
AuraComponentService.prototype.$createComponentDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var definition = this.$componentDefRegistry$[descriptor];
  if(!definition) {
    if(this.$savedComponentConfigs$[descriptor]) {
      definition = this.$createFromSavedComponentConfigs$(config)
    }else {
      if(!!this.$componentClassRegistry$.$classConstructors$[descriptor] || !!this.$componentClassRegistry$.$classExporter$[descriptor]) {
        definition = new ComponentDef(config);
        this.$componentDefRegistry$[descriptor] = definition
      }
    }
  }
  return definition
};
AuraComponentService.prototype.$getControllerDef$ = function(descriptor) {
  return this.$controllerDefRegistry$[descriptor]
};
AuraComponentService.prototype.$createControllerDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var def = this.$controllerDefRegistry$[descriptor];
  if(!def) {
    def = new ControllerDef(config);
    delete this.$controllerDefRelationship$[descriptor];
    this.$controllerDefRegistry$[descriptor] = def
  }
  return def
};
AuraComponentService.prototype.$getActionDef$ = function(descriptor) {
  return this.$actionDefRegistry$[descriptor]
};
AuraComponentService.prototype.$createActionDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var def = this.$actionDefRegistry$[descriptor];
  if(!def) {
    def = new ActionDef(config);
    delete this.$actionDefRelationship$[descriptor];
    this.$actionDefRegistry$[descriptor] = def
  }
  return def
};
AuraComponentService.prototype.$getModelDef$ = function(descriptor) {
  return this.$modelDefRegistry$[descriptor]
};
AuraComponentService.prototype.$createModelDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var def = this.$modelDefRegistry$[descriptor];
  if(!def) {
    def = new ModelDef(config);
    this.$modelDefRegistry$[descriptor] = def
  }
  return def
};
AuraComponentService.prototype.$hasLibrary$ = function(descriptor) {
  return this.$libraryRegistry$.$hasLibrary$(descriptor)
};
AuraComponentService.prototype.$saveLibraryConfig$ = function(config) {
  this.$libraryRegistry$.$addLibrary$(config["descriptor"], config["includes"]);
  if(config.hasOwnProperty("includeClasses")) {
    var trustedScript = $A.$lockerService$.$trusted$["createScript"](config["includeClasses"]);
    var includeClasses = $A["util"].$globalEval$(trustedScript, config["descriptor"], "lib");
    includeClasses()
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "saveLibraryConfig", AuraComponentService.prototype.$saveLibraryConfig$);
AuraComponentService.prototype.$addLibraryExporter$ = function(descriptor, exporter) {
  this.$libraryIncludeRegistry$.$addLibraryExporter$(descriptor, exporter)
};
goog.$exportProperty$(AuraComponentService.prototype, "addLibraryExporter", AuraComponentService.prototype.$addLibraryExporter$);
AuraComponentService.prototype.$getLibrary$ = function(descriptor) {
  return this.$libraryRegistry$.$getLibrary$(descriptor)
};
AuraComponentService.prototype.$getLibraryAsModule$ = function(descriptor) {
  return this.$libraryRegistry$.$getLibrary$(descriptor) && this.$moduleDefRegistry$[descriptor]
};
AuraComponentService.prototype.$addLibraryInclude$ = function(descriptor, dependencies, exporter, sourceMap) {
  this.$libraryIncludeRegistry$.$addLibraryInclude$(descriptor, dependencies, exporter);
  if(sourceMap) {
    this.$sourceMapRegistry$.$addSourceMapEntry$(descriptor, sourceMap, "library")
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "addLibraryInclude", AuraComponentService.prototype.$addLibraryInclude$);
AuraComponentService.prototype.$getLibraryInclude$ = function(descriptor) {
  return this.$libraryIncludeRegistry$.$getLibraryInclude$(descriptor)
};
AuraComponentService.prototype.$destroy$ = function(components) {
  if(!$A["util"].isArray(components)) {
    components = [components]
  }
  for(var i = 0;i < components.length;i++) {
    var cmp = components[i];
    if(cmp && cmp.$destroy$) {
      cmp.$destroy$()
    }
  }
};
AuraComponentService.prototype.$deIndex$ = function(globalId) {
  delete this.$indexes$.$globalId$[globalId]
};
AuraComponentService.prototype.$getRegisteredComponentDescriptors$ = function() {
  var ret = [];
  var name;
  var componentDefs = this.$componentDefRegistry$;
  for(name in componentDefs) {
    ret.push(name)
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getRegisteredComponentDescriptors", AuraComponentService.prototype.$getRegisteredComponentDescriptors$);
AuraComponentService.prototype.$getRegisteredLibraries$ = function() {
  return this.$libraryRegistry$.$getLibraryDescriptors$()
};
goog.$exportProperty$(AuraComponentService.prototype, "getRegisteredLibraries", AuraComponentService.prototype.$getRegisteredLibraries$);
AuraComponentService.prototype.$getRegisteredModuleDescriptors$ = function() {
  var ret = [];
  var name;
  var moduleDef;
  var componentDefs = this.$moduleDefRegistry$;
  for(name in componentDefs) {
    moduleDef = componentDefs[name];
    if(moduleDef.$ns$) {
      ret.push(name)
    }
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getRegisteredModuleDescriptors", AuraComponentService.prototype.$getRegisteredModuleDescriptors$);
AuraComponentService.prototype.$getDynamicNamespaces$ = function() {
  return this.$dynamicNamespaces$
};
AuraComponentService.prototype.$getIndex$ = function() {
  var ret = "";
  var index = this.$indexes$.$globalId$;
  for(var globalId in index) {
    if(globalId.indexOf(":1") > -1) {
      var cmp = index[globalId];
      var par = "";
      var vp = cmp.$getComponentValueProvider$();
      if(vp) {
        par = vp.$getGlobalId$() + " : " + vp.$getDef$().toString()
      }
      ret = ret + globalId + " : ";
      ret = ret + cmp.$getDef$().toString();
      ret = ret + " [ " + par + " ] ";
      ret = ret + "\n"
    }
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getIndex", AuraComponentService.prototype.$getIndex$);
AuraComponentService.prototype.$isConfigDescriptor$ = function(config) {
  return config && config["descriptor"]
};
AuraComponentService.prototype.$saveComponentConfig$ = function(config) {
  var componentDescriptor = this.$getDescriptorFromConfig$(config);
  if(componentDescriptor in this.$savedComponentConfigs$ || componentDescriptor in this.$componentDefRegistry$) {
    return
  }
  this.$savedComponentConfigs$[componentDescriptor] = config;
  var controllerDef = config[Json.$ApplicationKey$.$CONTROLLERDEF$];
  if(controllerDef) {
    if(controllerDef[Json.$ApplicationKey$.$DESCRIPTOR$]) {
      this.$controllerDefRelationship$[controllerDef[Json.$ApplicationKey$.$DESCRIPTOR$]] = componentDescriptor
    }
    if(controllerDef[Json.$ApplicationKey$.$ACTIONDEFS$]) {
      var actionDefs = controllerDef[Json.$ApplicationKey$.$ACTIONDEFS$];
      var len = actionDefs.length;
      var i;
      for(i = 0;i < len;i++) {
        var actionDef = actionDefs[i];
        if(actionDef[Json.$ApplicationKey$.$DESCRIPTOR$]) {
          this.$actionDefRelationship$[actionDef[Json.$ApplicationKey$.$DESCRIPTOR$]] = componentDescriptor
        }
      }
    }
  }
};
AuraComponentService.prototype.$restoreDefsFromStorage$ = function(context) {
  var defStorage = this.$componentDefStorage$.$getStorage$();
  if(!defStorage || !defStorage.$isPersistent$()) {
    this.$componentDefStorage$.$restoreAll$(context);
    return Promise["resolve"]()
  }
  return this.$componentDefStorage$.$restoreAll$(context)
};
AuraComponentService.prototype.$clearDefsFromStorage$ = function(metricsPayload) {
  return this.$componentDefStorage$.clear(metricsPayload)["then"](function clearActionStorageSuccess() {
    return this.$actionStorage$.clear()
  }.bind(this))
};
AuraComponentService.prototype.$getComponentDefStorageName$ = function() {
  return this.$componentDefStorage$.$STORAGE_NAME$
};
AuraComponentService.prototype.$saveDefsToStorage$ = function(config, context) {
  var cmpConfigs = config["componentDefs"] || [];
  var libConfigs = config["libraryDefs"] || [];
  var evtConfigs = config["eventDefs"] || [];
  var moduleConfigs = config["moduleDefs"] || [];
  if(cmpConfigs.length === 0 && libConfigs.length === 0 && evtConfigs.length === 0 && moduleConfigs.length === 0) {
    return Promise["resolve"]()
  }
  var defStorage = this.$componentDefStorage$.$getStorage$();
  if(!defStorage) {
    return Promise["resolve"]()
  }
  var self = this;
  var defSizeKb = $A["util"].$estimateSize$(cmpConfigs) / 1024;
  var libSizeKb = $A["util"].$estimateSize$(libConfigs) / 1024;
  var evtSizeKb = $A["util"].$estimateSize$(evtConfigs) / 1024;
  var moduleSizeKb = $A["util"].$estimateSize$(moduleConfigs) / 1024;
  return self.$pruneDefsFromStorage$(defSizeKb + libSizeKb + evtSizeKb + moduleSizeKb)["then"](function pruneDefsFromStorageSuccess(cleared) {
    if(!cleared) {
      return self.$componentDefStorage$.$storeDefs$(cmpConfigs, libConfigs, evtConfigs, moduleConfigs, context)
    }
  })["then"](undefined, function pruneDefsFromStorageError(e) {
    var metricsPayload = {"cause":"saveDefsToStorage", "defsRequiredSize":defSizeKb + libSizeKb + evtSizeKb, "error":e};
    return self.$clearDefsFromStorage$(metricsPayload)
  })
};
AuraComponentService.prototype.$createComponentPrivAsync$ = function(config, callback, infiniteLoopProtection) {
  var descriptor = this.$getDescriptorFromConfig$(config["componentDef"]);
  var def = this.$getComponentDef$({"descriptor":descriptor});
  $A.assert(callback && typeof callback === "function", "Callback");
  if(def || !$A.getContext().$uriAddressableDefsEnabled$) {
    if(def && !def.$hasRemoteDependencies$()) {
      this.$createComponentPriv$(config, callback);
      return
    }else {
      var action;
      action = this.$requestComponent$(callback, config, null, null, true);
      action.$setAbortable$();
      $A.$enqueueAction$(action)
    }
  }else {
    var self = this;
    this.$componentDefLoader$.$loadComponentDef$(descriptor, null, $A.$getCallback$(function(err) {
      if(infiniteLoopProtection) {
        err = "infinite loop error on fetching component definition for: " + descriptor;
        $A.$deprecated$(err, "New definition needs to be created on the server", "infiniteLoopProtection:" + descriptor)
      }
      if(err) {
        var errMsg = err.message ? err.message : err;
        var errState = "ERROR";
        if($A["util"].$isString$(errMsg) && errMsg.indexOf(AuraComponentService.$UNKNOWN_ERROR_MESSAGE_PREFIX$) === 0) {
          errState = "INCOMPLETE";
          var additionalData = err.$getAdditionalData$();
          if(additionalData) {
            errMsg += " Additional Data: " + JSON.stringify(additionalData)
          }
        }
        try {
          callback(null, errState, errMsg)
        }catch(callbackError) {
          var auraError = callbackError;
          if(!(callbackError instanceof $A.$auraError$)) {
            auraError = new $A.$auraError$(callbackError.message ? callbackError.message : callbackError, callbackError)
          }
          auraError.$setComponent$(descriptor);
          throw auraError;
        }
      }else {
        try {
          self.$createComponentPrivAsync$(config, callback, true)
        }catch(e) {
          callback(null, "ERROR", e)
        }
      }
    }))
  }
};
AuraComponentService.prototype.$createComponentPriv$ = function(config, callback) {
  var descriptor = this.$getDescriptorFromConfig$(config["componentDef"]);
  var def = this.$getComponentDef$({"descriptor":descriptor});
  var cmp = null;
  var createMark;
  var profilerCmpFullName;
  var currentAccessCmp = $A.$clientService$.$currentAccess$;
  var currentAccessCmpDef = currentAccessCmp && currentAccessCmp.$getDef$();
  if(!this.$trackingCreate$ && descriptor.indexOf("markup://aura") < 0) {
    createMark = $A.$metricsService$["mark"]("component", "create", {"name":def && def.$getDescriptor$().$getFullName$()});
    this.$trackingCreate$ = true
  }
  if(AuraProfilerServiceProfilerEnabled) {
    profilerCmpFullName = def && def.$getDescriptor$().$getFullName$();
    AuraProfilerServiceLogOperationStart(0, profilerCmpFullName)
  }
  try {
    if($A.$clientService$.$allowAccess$(def)) {
      var minVersion = def.$getMinVersion$();
      var currAccessCmpApiVer = currentAccessCmpDef && currentAccessCmpDef.$getApiVersion$();
      if(minVersion && currAccessCmpApiVer && parseInt(minVersion) > parseInt(currAccessCmpApiVer)) {
        var mveMessage = $A["util"].$format$("Component API version is too old: '{0}' must be set to API version '{1}' or later to use component '{2}'", currentAccessCmpDef.$getDescriptor$().$getQualifiedName$(), minVersion, descriptor);
        var minVersionValidationError = new $A.$auraError$(mveMessage);
        minVersionValidationError.$setComponent$(currentAccessCmpDef.$getDescriptor$().$getQualifiedName$());
        throw minVersionValidationError;
      }
      var classConstructor = this.$getComponentClass$(descriptor, def);
      if(!classConstructor) {
        var errorMessage = $A["util"].$format$("Component class not found: {0}\n hasClassConstructor: {1}\n hasClassExporter: {2}\n hasSavedComponentConfigs: {3}\n hasComponentDefCreated: {4}", descriptor, !!$A.$componentService$.$componentClassRegistry$.$classConstructors$[descriptor], !!$A.$componentService$.$componentClassRegistry$.$classExporter$[descriptor], !!$A.$componentService$.$savedComponentConfigs$[descriptor], !!$A.$componentService$.$componentDefRegistry$[descriptor]);
        var auraError = new $A.$auraError$(errorMessage, null, $A.severity.$QUIET$);
        auraError.$setComponent$(descriptor);
        throw auraError;
      }
      cmp = new classConstructor(config)
    }else {
      if(def) {
        var message = "Access Check Failed! AuraComponentService.createComponentFromConfig(): '" + descriptor + "' is not visible to '" + currentAccessCmp + "'.";
        if($A.$clientService$.$enableAccessChecks$) {
          if($A.$clientService$.$logAccessFailures$) {
            $A.error(null, new $A.$auraError$(message))
          }
          if(!callback || !$A["util"].$isFunction$(callback)) {
            throw new Error(message);
          }
        }else {
          if($A.$clientService$.$logAccessFailures$) {
            $A.$warning$(message)
          }
          cmp = new (this.$getComponentClass$(descriptor, def))(config)
        }
      }
    }
    if(callback && $A["util"].$isFunction$(callback)) {
      if(cmp !== null) {
        callback(cmp, "SUCCESS")
      }else {
        callback(null, "ERROR", "Unknown component '" + descriptor + "'.")
      }
      return undefined
    }else {
      if(cmp !== null) {
        return cmp
      }
    }
    this.$componentDefStorage$.clear();
    throw new Error("Definition does not exist on the client for descriptor:" + descriptor + ". Client side caches have been cleared. Please reload the page.");
  }finally {
    if(createMark) {
      this.$trackingCreate$ = false;
      createMark["duration"] = $A.$metricsService$.time() - createMark["ts"]
    }
    if(AuraProfilerServiceProfilerEnabled) {
      AuraProfilerServiceLogOperationStop(0, profilerCmpFullName, cmp)
    }
  }
};
AuraComponentService.prototype.$findDependencies$ = function(key, defConfig, storedDeps) {
  var dependencies = [];
  var i;
  if($A["util"].isArray(defConfig)) {
    for(i = 0;i < defConfig.length;i++) {
      dependencies.push.apply(dependencies, this.$findDependencies$(key, defConfig[i], storedDeps))
    }
  }else {
    if($A["util"].$isObject$(defConfig)) {
      for(var attr in defConfig) {
        var value = defConfig[attr];
        if(attr === "descriptor") {
          if(value !== key && storedDeps.indexOf(value) !== -1) {
            dependencies.push(value)
          }
        }else {
          dependencies.push.apply(dependencies, this.$findDependencies$(key, value, storedDeps))
        }
      }
    }
  }
  return dependencies
};
AuraComponentService.prototype.$buildDependencyGraph$ = function() {
  var actionsDenylist = ["globalValueProviders", "aura://ComponentController/ACTION$getApplication"];
  var promises = [];
  var actionStorage = $A.$clientService$.$getActionStorage$();
  promises.push(actionStorage.$getAll$());
  promises.push(this.$componentDefStorage$.$getAll$());
  return Promise["all"](promises)["then"](function buildDependencyGraphSuccess(results) {
    function createNode(isAction, values, key) {
      var dependencies = this.$findDependencies$(key, values[key], defKeys);
      nodes[key] = {"id":key, "dependencies":dependencies, "action":isAction}
    }
    var actionEntries = results[0];
    var defEntries = results[1];
    var defKeys = Object.keys(defEntries);
    var nodes = {};
    var actionKeys = Object.keys(actionEntries).filter(function(a) {
      for(var i = 0;i < actionsDenylist.length;i++) {
        if(a.key.indexOf(actionsDenylist[i]) === 0) {
          return false
        }
      }
      return true
    });
    actionKeys.forEach(createNode.bind(this, true, actionEntries));
    defKeys.forEach(createNode.bind(this, false, defEntries));
    return nodes
  }.bind(this))
};
AuraComponentService.prototype.$sortDependencyGraph$ = function(graph) {
  var sorted = [];
  var visited = {};
  Object.keys(graph).forEach(function visit(idstr, ancestors) {
    var node = graph[idstr];
    var id = node["id"];
    if(visited[idstr]) {
      return
    }
    if(!Array.isArray(ancestors)) {
      ancestors = []
    }
    ancestors.push(id);
    visited[idstr] = true;
    node["dependencies"].forEach(function(afterId) {
      if(ancestors.indexOf(afterId) >= 0) {
        throw new $A.$auraError$("AuraComponentService.sortDependencyGraph: Found a cycle in the graph: " + afterId + " is in " + id, null, $A.severity.$QUIET$);
      }
      visit(afterId.toString(), ancestors.map(function(v) {
        return v
      }))
    });
    sorted.unshift(id)
  });
  return sorted
};
AuraComponentService.prototype.$getUpstreamDependencies$ = function(rootKey, graph, upstream) {
  upstream = upstream || {};
  for(var key in graph) {
    if(key !== rootKey) {
      var nodeDependencies = graph[key]["dependencies"];
      if(nodeDependencies.indexOf(rootKey) !== -1) {
        upstream[key] = true;
        this.$getUpstreamDependencies$(key, graph, upstream)
      }
    }
  }
  upstream[rootKey] = true;
  return upstream
};
AuraComponentService.prototype.$splitComponentsAndActions$ = function(graph, keys, exclude, actions, defs) {
  for(var key in keys) {
    if(exclude.indexOf(key) === -1) {
      if(graph[key]["action"]) {
        actions.push(key)
      }else {
        defs.push(key)
      }
    }
  }
};
AuraComponentService.prototype.$evictDefsFromStorage$ = function(sortedKeys, graph, requiredSpaceKb) {
  var defStorage = this.$componentDefStorage$.$getStorage$();
  var actionStorage = $A.$clientService$.$getActionStorage$();
  var self = this;
  return defStorage.$getSize$()["then"](function defStorageGetSizeSuccess(startingSize) {
    var maxSize = defStorage.$getMaxSize$();
    var targetSize = Math.min(maxSize * self.$componentDefStorage$.$EVICTION_TARGET_LOAD$, maxSize - maxSize * self.$componentDefStorage$.$EVICTION_HEADROOM$ - requiredSpaceKb);
    var evicted = [];
    if(startingSize <= targetSize) {
      $A.log("AuraComponentService.evictDefsFromStorage: short-circuiting because current size (" + startingSize.toFixed(0) + "KB) \x3c target size (" + targetSize.toFixed(0) + "KB)");
      return Promise["resolve"]([])
    }
    return new Promise(function(resolve, reject) {
      function removeActions(actions) {
        if(!actionStorage.$isStorageEnabled$() || !actions.length) {
          $A.assert(actions.length === 0 || actionStorage.$isStorageEnabled$(), "Actions store doesn't exist but requested removal of " + actions.length + " actions");
          return Promise["resolve"]()
        }
        var promises = [];
        for(var i = 0;i < actions.length;i++) {
          promises.push(actionStorage.remove(actions[i], true))
        }
        return Promise["all"](promises)["then"](function logSuccess() {
          $A.log("AuraComponentService.evictDefsFromStorage.removeActions(): removed " + promises.length + " actions")
        })
      }
      function evictRecursively(keysToEvict, currentSize) {
        var key = keysToEvict.pop();
        if(!key || currentSize <= targetSize) {
          resolve(evicted);
          return
        }
        var upstreamKeys = self.$getUpstreamDependencies$(key, graph);
        var actions = [];
        var defs = [];
        self.$splitComponentsAndActions$(graph, upstreamKeys, evicted, actions, defs);
        if(actions.length === 0 && defs.length === 0) {
          evictRecursively(keysToEvict, currentSize);
          return
        }
        removeActions(actions)["then"](function pushEvictedAction() {
          evicted.push.apply(evicted, actions)
        })["then"](function removeDef() {
          return self.$componentDefStorage$.$removeDefs$(defs)
        })["then"](function pushEvictedDefs() {
          evicted.push.apply(evicted, defs);
          return defStorage.$getSize$()
        })["then"](function evictRecursivelyWrapper(newSize) {
          evictRecursively(keysToEvict, newSize)
        }, function removeActionsError(e) {
          $A.log("AuraComponentService.evictDefsFromStorage(): error during component def or action removal", e);
          reject(e)
        })
      }
      $A.log("AuraComponentService.evictDefsFromStorage: evicting because current size (" + startingSize.toFixed(0) + "KB) \x3e target size (" + targetSize.toFixed(0) + "KB)");
      evictRecursively(sortedKeys, startingSize)
    })
  })
};
AuraComponentService.prototype.$pruneDefsFromStorage$ = function(requiredSpaceKb) {
  var self = this;
  var defStorage = this.$componentDefStorage$.$getStorage$();
  if(!defStorage) {
    return Promise["resolve"]()
  }
  var currentSize = 0;
  var newSize = 0;
  return defStorage.$getSize$()["then"](function defStorageGetSizeSuccess2(size) {
    currentSize = size;
    var maxSize = defStorage.$getMaxSize$();
    newSize = currentSize + requiredSpaceKb + maxSize * self.$componentDefStorage$.$EVICTION_HEADROOM$;
    if(newSize < maxSize) {
      return false
    }
    var metricsPayload = {"cause":"sizeAboveThreshold", "defsRequiredSize":requiredSpaceKb, "storageCurrentSize":currentSize, "storageRequiredSize":newSize};
    return self.$clearDefsFromStorage$(metricsPayload)["then"](function returnTrue() {
      return true
    })
  })
};
AuraComponentService.prototype.$inFlightComponents$ = function() {
  return this.$componentDefLoader$.$loading$
};
goog.$exportProperty$(AuraComponentService.prototype, "inFlightComponents", AuraComponentService.prototype.$inFlightComponents$);
AuraComponentService.prototype.$getSelfGlobalId$ = function(component) {
  if(component !== undefined && $A["util"].$isComponent$(component)) {
    return component.$globalId$
  }
  return null
};
goog.$exportProperty$(AuraComponentService.prototype, "getSelfGlobalId", AuraComponentService.prototype.$getSelfGlobalId$);
AuraComponentService.prototype.$getAttributeExpression$ = function(component, key) {
  if(component !== undefined && $A["util"].$isComponent$(component)) {
    var value;
    if(component instanceof Aura.$Component$.$InteropComponent$) {
      value = component.attributes[key]
    }else {
      value = component.$attributeSet$.$values$[key]
    }
    if($A["util"].$isExpression$(value)) {
      return value.toString()
    }
  }
  return null
};
goog.$exportProperty$(AuraComponentService.prototype, "getAttributeExpression", AuraComponentService.prototype.$getAttributeExpression$);
AuraComponentService.prototype.$createScriptElement$ = function(uri, onload, onerror) {
  return this.$componentDefLoader$.$createScriptElement$(uri, onload, onerror)
};
goog.$exportProperty$(AuraComponentService.prototype, "createScriptElement", AuraComponentService.prototype.$createScriptElement$);
Aura.$Services$.$AuraComponentService$ = AuraComponentService;
function AuraRenderingService() {
  this.$visited$ = undefined;
  this.$afterRenderStack$ = [];
  this.$dirtyComponents$ = {};
  this.$dirtyComponentIds$ = [];
  this.$needsCleaning$ = false;
  this.$markerToReferencesMap$ = {};
  this.$renderFacetTopVisit$ = true;
  this.$rerenderFacetTopVisit$ = true;
  this.$DATA_UID_KEY$ = "data-rendering-service-uid";
  this.uid = 1
}
goog.$exportSymbol$("AuraRenderingService", AuraRenderingService);
var recordArsO11yMetrics = Aura.$Utils$.$Util$.prototype.$getO11yMetricRecordingFunction$("ars");
AuraRenderingService.prototype.$render$ = function(components, parent) {
  var expectedError = false;
  try {
    components = this.$getArray$(components);
    var elements = [];
    var cmpProfilerName;
    for(var i = 0;i < components.length;i++) {
      var cmp = components[i];
      if(!$A["util"].$isComponent$(cmp)) {
        if($A.$componentService$.$isComponentDefRef$(cmp)) {
          cmp = $A.$componentService$.$createComponentPriv$(cmp);
          components[i] = cmp
        }else {
          $A.$warning$("AuraRenderingService.render: 'component[" + i + "]' was not a valid component, found '" + cmp + "'.");
          continue
        }
      }
      if(!cmp.$isValid$()) {
        continue
      }
      if(AuraProfilerServiceProfilerEnabled) {
        cmpProfilerName = cmp.$getType$();
        AuraProfilerServiceLogOperationStart(1, cmpProfilerName, cmp)
      }
      $A.$clientService$.$setCurrentAccess$(cmp);
      try {
        var renderedElements = cmp["render"]();
        renderedElements = this.$finishRender$(cmp, renderedElements);
        Array.prototype.push.apply(elements, this.$getArray$(renderedElements))
      }catch(e) {
        expectedError = true;
        if(!(e instanceof $A.$auraError$) || !e["component"]) {
          var auraError = new $A.$auraError$("render threw an error in '" + cmp.$getType$() + "'", e);
          $A.$lastKnownError$ = auraError;
          throw auraError;
        }
        throw e;
      }finally {
        $A.$clientService$.$releaseCurrentAccess$();
        if(AuraProfilerServiceProfilerEnabled) {
          AuraProfilerServiceLogOperationStop(1, cmpProfilerName, cmp)
        }
      }
    }
    if(parent) {
      $A["util"].appendChild(elements, parent)
    }
    recordArsO11yMetrics("render", ["SUCCESS"]);
    return elements
  }catch(err) {
    if(!expectedError) {
      recordArsO11yMetrics("render", ["ERROR"])
    }
    throw err;
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "render", AuraRenderingService.prototype.$render$);
AuraRenderingService.prototype.$rerender$ = function(components) {
  var expectedError = false;
  try {
    var cmpProfilerName;
    var topVisit = false;
    var visited = this.$visited$;
    if(!visited) {
      visited = this.$visited$ = {};
      topVisit = true
    }
    var elements = [];
    components = this.$getArray$(components);
    for(var i = 0;i < components.length;i++) {
      var cmp = components[i];
      var id = cmp.$getGlobalId$();
      if(!cmp.$isValid$()) {
        this.$cleanComponent$(id);
        continue
      }
      var rerenderedElements = undefined;
      if(!visited[id]) {
        if(!cmp.$isRendered$()) {
          throw new $A.$auraError$("AuraRenderingService.rerender: attempt to rerender component that has not been rendered.", null, $A.severity.$QUIET$);
        }
        if(AuraProfilerServiceProfilerEnabled) {
          cmpProfilerName = cmp.$getType$();
          AuraProfilerServiceLogOperationStart(3, cmpProfilerName, cmp)
        }
        $A.$clientService$.$setCurrentAccess$(cmp);
        try {
          rerenderedElements = cmp["rerender"]()
        }catch(e) {
          this.$renderingError$ = true;
          expectedError = true;
          if(!(e instanceof $A.$auraError$) || !e["component"]) {
            var auraError = new $A.$auraError$("rerender threw an error in '" + cmp.$getType$() + "'", e);
            $A.$lastKnownError$ = auraError;
            throw auraError;
          }
          throw e;
        }finally {
          this.$cleanComponent$(id);
          visited[id] = true;
          $A.$clientService$.$releaseCurrentAccess$();
          if(this.$renderingError$ && topVisit) {
            this.$visited$ = undefined;
            this.$afterRenderStack$.length = 0;
            this.$renderingError$ = false
          }
          if(AuraProfilerServiceProfilerEnabled) {
            AuraProfilerServiceLogOperationStop(3, cmpProfilerName, cmp)
          }
        }
      }
      if(rerenderedElements === undefined) {
        Array.prototype.push.apply(elements, this.$getElements$(cmp))
      }else {
        Array.prototype.push.apply(elements, this.$getArray$(rerenderedElements))
      }
    }
    if(topVisit) {
      this.$visited$ = undefined;
      try {
        this.$afterRender$(this.$afterRenderStack$)
      }finally {
        this.$afterRenderStack$.length = 0
      }
      for(var r = 0;r < components.length;r++) {
        components[r].$fire$("render")
      }
    }
    recordArsO11yMetrics("rerender", ["SUCCESS"]);
    return elements
  }catch(err) {
    if(!expectedError) {
      recordArsO11yMetrics("rerender", ["ERROR"])
    }
    throw err;
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "rerender", AuraRenderingService.prototype.$rerender$);
AuraRenderingService.prototype.$afterRender$ = function(components) {
  components = this.$getArray$(components);
  var cmpProfilerName;
  for(var i = 0;i < components.length;i++) {
    var cmp = components[i];
    if(!$A["util"].$isComponent$(cmp)) {
      $A.$warning$("AuraRenderingService.afterRender: 'cmp' must be a valid Component, found '" + cmp + "'.", null, $A.severity.$QUIET$);
      continue
    }
    if(cmp.$isValid$()) {
      if(AuraProfilerServiceProfilerEnabled) {
        cmpProfilerName = cmp.$getType$();
        AuraProfilerServiceLogOperationStart(2, cmpProfilerName, cmp)
      }
      $A.$clientService$.$setCurrentAccess$(cmp);
      try {
        cmp["afterRender"]();
        cmp.$fire$("render")
      }catch(e) {
        expectedError = true;
        if(!(e instanceof $A.$auraError$) || !e["component"]) {
          var auraError = new $A.$auraError$("afterRender threw an error in '" + cmp.$getType$() + "'", e);
          $A.$lastKnownError$ = auraError;
          throw auraError;
        }
        throw e;
      }finally {
        $A.$clientService$.$releaseCurrentAccess$(cmp);
        if(AuraProfilerServiceProfilerEnabled) {
          AuraProfilerServiceLogOperationStop(2, cmpProfilerName, cmp)
        }
      }
    }
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "afterRender", AuraRenderingService.prototype.$afterRender$);
AuraRenderingService.prototype.$unrender$ = function(components) {
  var expectedError = false;
  try {
    if(!components) {
      return
    }
    var cmpProfilerName;
    var visited = this.$visited$;
    components = this.$getArray$(components);
    var cmp;
    var container;
    var beforeUnrenderElements;
    for(var i = 0;i < components.length;i++) {
      cmp = components[i];
      if($A["util"].$isComponent$(cmp) && cmp.$destroyed$ !== 1 && cmp.$isRendered$()) {
        if(AuraProfilerServiceProfilerEnabled) {
          cmpProfilerName = cmp.$getType$();
          AuraProfilerServiceLogOperationStart(4, cmpProfilerName, cmp)
        }
        cmp.$setUnrendering$(true);
        $A.$clientService$.$setCurrentAccess$(cmp);
        container = cmp.$getContainer$() || cmp.$getOwner$();
        if(container && !container.$getConcreteComponent$().$isUnrendering$()) {
          beforeUnrenderElements = cmp.$getElements$()
        }else {
          beforeUnrenderElements = null
        }
        try {
          cmp["unrender"]()
        }catch(e) {
          expectedError = true;
          if(!(e instanceof $A.$auraError$) || !e["component"]) {
            var auraError = new $A.$auraError$("unrender threw an error in '" + cmp.$getType$() + "'", e);
            $A.$lastKnownError$ = auraError;
            throw auraError;
          }
          throw e;
        }finally {
          $A.$clientService$.$releaseCurrentAccess$(cmp);
          var oldContainerMarker = this.$getMarker$(container);
          this.$removeElement$(this.$getMarker$(cmp), container);
          var currentContainerMarker = this.$getMarker$(container);
          if(oldContainerMarker !== currentContainerMarker) {
            this.$moveContainerReferencesToMarker$(container, oldContainerMarker, currentContainerMarker)
          }
          if(beforeUnrenderElements && beforeUnrenderElements.length) {
            for(var c = 0;c < beforeUnrenderElements.length;c++) {
              $A["util"].$removeElement$(beforeUnrenderElements[c])
            }
          }
          if(AuraProfilerServiceProfilerEnabled) {
            AuraProfilerServiceLogOperationStop(4, cmpProfilerName, cmp)
          }
          if(cmp.$destroyed$ !== 1) {
            cmp.$setRendered$(false);
            if(visited) {
              var id = cmp.$getGlobalId$();
              visited[id] = true;
              this.$cleanComponent$(id)
            }
            cmp.$setUnrendering$(false)
          }
        }
      }
    }
    recordArsO11yMetrics("unrender", ["SUCCESS"])
  }catch(err) {
    if(!expectedError) {
      recordArsO11yMetrics("unrender", ["ERROR"])
    }
    throw err;
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "unrender", AuraRenderingService.prototype.$unrender$);
AuraRenderingService.prototype.$storeFacetInfo$ = function(component, facet) {
  component.$_facetInfo$ = facet.slice(0)
};
AuraRenderingService.prototype.$getUpdatedFacetInfo$ = function(component, facet) {
  if(!$A["util"].$isComponent$(component)) {
    throw new $A.$auraError$("AuraRenderingService.getUpdatedFacetInfo: 'component' must be a valid Component. Found '" + component + "'.", null, $A.severity.$QUIET$);
  }
  if($A["util"].$isComponent$(facet)) {
    facet = [facet]
  }else {
    if(!$A["util"].isArray(facet)) {
      $A.$warning$("AuraRenderingService.getUpdatedFacetInfo: 'facet' must be a Component or an Array. Found '" + facet + "' in '" + component.$getType$() + "'.");
      facet = []
    }
  }
  var updatedFacet = {$components$:[], $unrenderedComponents$:[], $facetInfo$:[], $useFragment$:false, $fullUnrender$:false, $hasNewMarker$:false};
  var renderCount = 0;
  if(component.$_facetInfo$) {
    var jmax = -1;
    for(var i = 0;i < facet.length;i++) {
      var child = facet[i];
      if(!$A["util"].$isComponent$(child)) {
        $A.$warning$("AuraRenderingService.getUpdatedFacetInfo: all values to be rendered in an expression must be components. Found '" + child + "' in '" + component.$getType$() + "'.");
        continue
      }
      var found = false;
      for(var j = 0;j < component.$_facetInfo$.length;j++) {
        if(child === component.$_facetInfo$[j]) {
          updatedFacet.$components$.push({action:"rerender", $component$:child, $oldIndex$:j, $newIndex$:i});
          if(j !== i - renderCount && j < jmax) {
            updatedFacet.$useFragment$ = true
          }
          jmax = j;
          found = true;
          component.$_facetInfo$[j] = undefined;
          break
        }
      }
      if(!found) {
        updatedFacet.$components$.push({action:"render", $component$:child, $newIndex$:i});
        if(i === 0) {
          updatedFacet.$hasNewMarker$ = true
        }
        renderCount++
      }
      updatedFacet.$facetInfo$.push(child)
    }
    if(!updatedFacet.$components$.length) {
      updatedFacet.$fullUnrender$ = true
    }
    for(var x = 0;x < component.$_facetInfo$.length;x++) {
      if(component.$_facetInfo$[x]) {
        updatedFacet.$unrenderedComponents$.unshift({action:"unrender", $component$:component.$_facetInfo$[x], $oldIndex$:x})
      }
    }
  }
  return updatedFacet
};
AuraRenderingService.prototype.$getFacetInfo$ = function(component, facet) {
  if(!$A["util"].$isComponent$(component)) {
    throw new $A.$auraError$("AuraRenderingService.getFacetInfo: 'component' must be a valid Component. Found '" + component + "'.", null, $A.severity.$QUIET$);
  }
  var facetInfo = [];
  var containerId = component.$globalId$;
  facet = this.$getArray$(facet);
  for(var i = 0;i < facet.length;i++) {
    var cmp = facet[i];
    if(!$A["util"].$isComponent$(cmp)) {
      if($A.$componentService$.$isComponentDefRef$(cmp)) {
        cmp = $A.$componentService$.$createComponentPriv$(cmp);
        facet[i] = cmp
      }else {
        $A.$warning$("AuraRenderingService.getFacetInfo: 'component[" + i + "]' was not a valid component, found '" + cmp + "'.");
        continue
      }
    }
    facetInfo.push(cmp);
    cmp.$setContainerComponentId$(containerId)
  }
  return facetInfo
};
AuraRenderingService.prototype.$renderFacet$ = function(component, facet, parent) {
  var facetInfo = this.$getFacetInfo$(component, facet);
  this.$storeFacetInfo$(component, facetInfo);
  var topVisit = this.$renderFacetTopVisit$;
  if(topVisit === true) {
    this.$renderFacetTopVisit$ = false;
    this.$renderFacetStack$ = [];
    this.$renderFacetVisited$ = {}
  }
  var globalId = component.$getGlobalId$();
  this.$renderFacetStack$.push(component.$getConcreteComponent$().$getType$());
  if(this.$renderFacetVisited$[globalId] === undefined) {
    this.$renderFacetVisited$[globalId] = 1
  }else {
    this.$renderFacetVisited$[globalId]++
  }
  var renderedElements;
  try {
    if(this.$renderFacetVisited$[globalId] > 50) {
      var startComponent = $A.$componentService$.get(globalId);
      var owner = startComponent.$getOwner$();
      for(var ownerType = owner && owner.$getType$();ownerType && ownerType.indexOf("aura:") > -1;) {
        owner = owner.$getOwner$();
        ownerType = owner && owner.$getType$()
      }
      var auraError = new $A.$auraError$("Rendering Error: infinite recursion occured during rendering. " + "The circular reference starts on '" + startComponent.$getType$() + "'. \n" + this.$renderFacetStack$.join(" -\x3e "));
      auraError.$setComponent$(ownerType);
      auraError.$setAdditionalStacktraceGen$("[Rendering circular reference]");
      throw auraError;
    }
    renderedElements = this.$render$(facetInfo, parent);
    if(parent) {
      this.$setMarker$(component, parent)
    }else {
      if(renderedElements.length === 0) {
        renderedElements[0] = this.$createMarker$(null, "render facet: " + component.$getGlobalId$())
      }
      this.$setMarker$(component, renderedElements[0])
    }
  }finally {
    if(topVisit === true) {
      this.$renderFacetTopVisit$ = true
    }else {
      this.$renderFacetVisited$[globalId]--;
      this.$renderFacetStack$.pop()
    }
  }
  return renderedElements
};
goog.$exportProperty$(AuraRenderingService.prototype, "renderFacet", AuraRenderingService.prototype.$renderFacet$);
AuraRenderingService.prototype.$rerenderFacet$ = function(component, facet, referenceNode) {
  var updatedFacet = this.$getUpdatedFacetInfo$(component, facet);
  var ret = [];
  var marker = this.$getMarker$(component);
  var target = referenceNode || marker.parentNode;
  var calculatedPosition = 0;
  var nextSibling = null;
  var componentType = component.$getType$();
  var topVisit = this.$rerenderFacetTopVisit$;
  var beforeRerenderElements = null;
  if(topVisit) {
    this.$rerenderFacetTopVisit$ = false;
    beforeRerenderElements = this.$getAllElementsCopy$(component)
  }
  if(marker !== target) {
    calculatedPosition += this.$getInsertPosition$(component, target)
  }
  var unrenderedComponents = updatedFacet.$unrenderedComponents$;
  for(var n = 0;n < unrenderedComponents.length;n++) {
    var unrenderInfo = unrenderedComponents[n];
    var unrenderedComponent = unrenderInfo.$component$;
    if(!unrenderedComponent.$isValid$()) {
      continue
    }
    if(unrenderInfo.$oldIndex$ === 0 && component.$getType$() !== "aura:html") {
      marker = this.$getMarker$(component);
      var allElements = this.$getAllElements$(unrenderedComponent);
      if(marker === allElements[0]) {
        var newMarker;
        if(updatedFacet.$hasNewMarker$ || !marker.nextSibling || updatedFacet.$fullUnrender$) {
          newMarker = this.$createMarker$(marker, "unrender facet: " + component.$getGlobalId$());
          calculatedPosition += 1
        }else {
          var count = allElements.length - 1;
          for(nextSibling = marker.nextSibling;count && nextSibling.nextSibling;) {
            nextSibling = nextSibling.nextSibling;
            count--
          }
          newMarker = nextSibling
        }
        this.$setMarker$(component, newMarker);
        this.$moveContainerReferencesToMarker$(component, marker, newMarker)
      }
    }
    if(unrenderedComponent.$autoDestroy$()) {
      this.$cleanComponent$(unrenderedComponent.$getGlobalId$());
      unrenderedComponent.$destroy$()
    }else {
      this.$unrender$(unrenderedComponent);
      unrenderedComponent.$disassociateElements$();
      this.$cleanComponent$(unrenderedComponent.$getGlobalId$())
    }
  }
  var components = updatedFacet.$components$;
  for(var i = 0;i < components.length;i++) {
    var info = components[i];
    var facetComponent = info.$component$;
    if(!facetComponent.$isValid$()) {
      continue
    }
    var renderedElements = null;
    switch(info.action) {
      case "render":
        facetComponent.$setContainerComponentId$(component.$globalId$);
        renderedElements = this.$render$(facetComponent);
        if(updatedFacet.$useFragment$) {
          Array.prototype.push.apply(ret, renderedElements);
          calculatedPosition += renderedElements.length
        }else {
          if(renderedElements.length) {
            Array.prototype.push.apply(ret, renderedElements);
            if(!target) {
              $A.$warning$("Rendering Error: The element for the following component was removed from the DOM outside of the Aura lifecycle. " + "We cannot render any further updates to it or its children.\nComponent: " + $A.$clientService$.$getAccessStackHierarchy$() + " {" + component.$getGlobalId$() + "}")
            }else {
              nextSibling = target.childNodes[calculatedPosition];
              this.$insertElements$(renderedElements, nextSibling || target, nextSibling, nextSibling);
              calculatedPosition += renderedElements.length
            }
          }
        }
        this.$afterRenderStack$.push(facetComponent);
        break;
      case "rerender":
        if(this.$hasDirtyValue$(facetComponent)) {
          renderedElements = this.$rerender$(facetComponent)
        }else {
          renderedElements = this.$getAllElementsCopy$(facetComponent)
        }
        facetComponent.$disassociateElements$();
        this.$associateElements$(facetComponent, renderedElements);
        Array.prototype.push.apply(ret, renderedElements);
        calculatedPosition += renderedElements.length;
        break
    }
  }
  this.$storeFacetInfo$(component, updatedFacet.$facetInfo$);
  if(updatedFacet.$useFragment$) {
    nextSibling = target.childNodes[calculatedPosition];
    this.$insertElements$(ret, nextSibling || target, nextSibling, nextSibling)
  }
  if(componentType !== "aura:html") {
    marker = this.$getMarker$(component);
    if(ret.length > 0 && marker !== ret[0]) {
      this.$setMarker$(component, ret[0]);
      this.$moveContainerReferencesToMarker$(component, marker, ret[0]);
      if(this.$isCommentMarker$(marker) && ret.indexOf(marker) < 0) {
        this.$removeElement$(marker)
      }
    }else {
      if(ret.length === 0 && marker) {
        ret.push(marker)
      }
    }
    component.$disassociateElements$();
    this.$associateElements$(component, ret);
    if(topVisit) {
      this.$updateElementsOnContainers$(component, beforeRerenderElements)
    }
  }
  if(topVisit) {
    this.$rerenderFacetTopVisit$ = true
  }
  return ret
};
goog.$exportProperty$(AuraRenderingService.prototype, "rerenderFacet", AuraRenderingService.prototype.$rerenderFacet$);
AuraRenderingService.prototype.$getInsertPosition$ = function(component, targetNode) {
  var marker = this.$getMarker$(component);
  var elements = this.$getAllElements$(component);
  var length = elements.length;
  var current = marker;
  for(var totalPreSiblings = 0;current != null && current.previousSibling;) {
    totalPreSiblings++;
    current = current.previousSibling
  }
  if(!targetNode) {
    current = elements[length - 1]
  }else {
    current = this.$getLastSharedElementInCollection$(elements, targetNode.childNodes)
  }
  for(var totalElements = 0;current != null;) {
    totalElements++;
    if(current === marker) {
      break
    }
    current = current.previousSibling
  }
  return totalPreSiblings + totalElements - length
};
AuraRenderingService.prototype.$getLastSharedElementInCollection$ = function(cmpElements, domElements) {
  if(!cmpElements || !domElements) {
    return null
  }
  var lastElement = null;
  var largestIndex = -1;
  for(var i = 0;i < cmpElements.length;i++) {
    var element = cmpElements[i];
    var index = Array.prototype.indexOf.call(domElements, element);
    if(index > largestIndex) {
      largestIndex = index;
      lastElement = element
    }
  }
  return lastElement
};
AuraRenderingService.prototype.$updateElementsOnContainers$ = function(component, oldElements) {
  var container = component.$getConcreteComponent$().$getContainer$();
  if(!container) {
    return
  }
  var updatedElements = this.$getAllElements$(component);
  var foundUpdate = updatedElements.length !== oldElements.length;
  if(foundUpdate === false) {
    for(var i = 0;i < oldElements.length;i++) {
      if(oldElements[i] !== updatedElements[i]) {
        foundUpdate = true;
        break
      }
    }
  }
  if(foundUpdate === false) {
    return
  }
  var visited = {};
  visited[component.$getGlobalId$()] = true;
  for(var marker = this.$getMarker$(component);container;) {
    var concrete = container.$getConcreteComponent$();
    var globalId = concrete.$getGlobalId$();
    if(concrete.$getType$() === "aura:html" || concrete.$isRendered$() === false || visited[globalId] === true) {
      break
    }
    var containerElements = this.$getAllElementsCopy$(concrete);
    var index = containerElements.indexOf(marker);
    if(index < 0) {
      $A.log("Rendering Warning: Container is missing children's marker element. Container: " + concrete.$getType$() + ", Marker: " + marker)
    }else {
      Array.prototype.splice.apply(containerElements, [index, oldElements.length].concat(updatedElements));
      concrete.$disassociateElements$();
      this.$associateElements$(concrete, containerElements)
    }
    visited[globalId] = true;
    container = concrete.$getContainer$()
  }
};
AuraRenderingService.prototype.$unrenderFacet$ = function(cmp, facet) {
  if(cmp.$_facetInfo$) {
    var facetInfo = [];
    if(cmp.$destroyed$ === -1 && cmp.$getType$() !== "aura:expression") {
      var existing = cmp.$_facetInfo$;
      for(var i = 0;i < existing.length;i++) {
        if(existing[i].$autoDestroy$()) {
          existing[i].$destroy$()
        }else {
          facetInfo.push(existing[i])
        }
      }
    }else {
      facetInfo = cmp.$_facetInfo$
    }
    this.$unrender$(facetInfo);
    cmp.$_facetInfo$ = null
  }
  if(facet) {
    this.$unrender$(facet)
  }
  var elements = this.$getAllElements$(cmp);
  if(elements) {
    var element;
    var globalId = cmp.$getGlobalId$();
    for(var c = elements.length - 1;c >= 0;c--) {
      element = elements[c];
      this.$removeMarkerReference$(element, globalId);
      this.$removeElement$(element, cmp)
    }
  }
  cmp.$disassociateElements$()
};
goog.$exportProperty$(AuraRenderingService.prototype, "unrenderFacet", AuraRenderingService.prototype.$unrenderFacet$);
AuraRenderingService.prototype.$getMarker$ = function(cmp) {
  if(!cmp || cmp.$destroyed$ === 1) {
    return null
  }
  return cmp.$getConcreteComponent$().$_marker$
};
goog.$exportProperty$(AuraRenderingService.prototype, "getMarker", AuraRenderingService.prototype.$getMarker$);
AuraRenderingService.prototype.$setMarker$ = function(cmp, newMarker) {
  if(!cmp) {
    return
  }
  var concrete = cmp.$getConcreteComponent$();
  var oldMarker = this.$getMarker$(concrete);
  if(oldMarker === newMarker) {
    return
  }
  var globalId = concrete.$getGlobalId$();
  if(cmp.$getType$() !== "aura:html") {
    $A.$renderingService$.$addMarkerReference$(newMarker, globalId)
  }
  if(oldMarker) {
    $A.$renderingService$.$removeMarkerReference$(oldMarker, globalId)
  }
  if(!newMarker) {
    concrete.$_marker$ = null
  }else {
    concrete.$_marker$ = newMarker
  }
};
AuraRenderingService.prototype.$addDirtyValue$ = function(expression, cmp) {
  this.$needsCleaning$ = true;
  if(cmp && cmp.$isValid$() && cmp.$isRendered$()) {
    var id = cmp.$getGlobalId$();
    var list = this.$dirtyComponents$[id];
    if(!list) {
      list = this.$dirtyComponents$[id] = {};
      this.$dirtyComponentIds$.push(id)
    }
    for(;expression.indexOf(".") > -1;) {
      list[expression] = true;
      expression = expression.substring(0, expression.lastIndexOf("."))
    }
  }
};
AuraRenderingService.prototype.$hasDirtyValue$ = function(cmp) {
  return this.$dirtyComponents$.hasOwnProperty(cmp.$getGlobalId$())
};
AuraRenderingService.prototype.$isDirtyValue$ = function(expression, cmp) {
  if(cmp && cmp.$isValid$()) {
    var id = cmp.$getGlobalId$();
    var list = this.$dirtyComponents$[id];
    if(list && list[expression]) {
      return true
    }
  }
  return false
};
AuraRenderingService.prototype.$rerenderDirty$ = function(stackName) {
  if(this.$needsCleaning$) {
    for(var maxiterations = 1E3;this.$needsCleaning$ && maxiterations;) {
      var dirty = [];
      this.$needsCleaning$ = false;
      for(maxiterations--;this.$dirtyComponentIds$.length;) {
        var id = this.$dirtyComponentIds$.shift();
        var cmp = $A.$componentService$.get(id);
        if(cmp && cmp.$isValid$() && cmp.$isRendered$()) {
          if(!cmp.$isUnrendering$()) {
            dirty.push(cmp)
          }
        }else {
          this.$cleanComponent$(id)
        }
      }
      if(dirty.length) {
        this.$rerender$(dirty)
      }
    }
    $A.assert(maxiterations, "Max Callstack Exceeded: Rerendering loop resulted in to many rerenderings.");
    $A.$eventService$.$getNewEvent$("markup://aura:doneRendering").$fire$()
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "rerenderDirty", AuraRenderingService.prototype.$rerenderDirty$);
AuraRenderingService.prototype.$removeDirtyValue$ = function(value, cmp) {
  if(cmp && cmp.$isValid$()) {
    var id = cmp.$getGlobalId$();
    var dirtyAttributes = this.$dirtyComponents$[id];
    if(dirtyAttributes) {
      if(dirtyAttributes[value]) {
        delete dirtyAttributes[value]
      }
      if($A["util"].$isEmpty$(dirtyAttributes)) {
        delete this.$dirtyComponents$[id];
        for(var i = 0;i < this.$dirtyComponentIds$.length;i++) {
          if(this.$dirtyComponentIds$[i] === id) {
            return this.$dirtyComponentIds$.splice(i, 1)
          }
        }
      }
    }
  }
};
AuraRenderingService.prototype.$cleanComponent$ = function(id) {
  delete this.$dirtyComponents$[id]
};
AuraRenderingService.prototype.$getArray$ = function(things) {
  return $A["util"].isArray(things) ? things : things ? [things] : []
};
AuraRenderingService.prototype.$evalStrings$ = function(elements) {
  if($A["util"].$isString$(elements)) {
    elements = $A["util"].$createElementsFromMarkup$(elements)
  }
  return elements || []
};
AuraRenderingService.prototype.$finishRender$ = function(cmp, elements) {
  elements = this.$evalStrings$(elements);
  this.$associateElements$(cmp, elements);
  cmp.$setRendered$(true);
  this.$cleanComponent$(cmp.$getGlobalId$());
  return elements
};
AuraRenderingService.prototype.$insertElements$ = function(elements, refNode, asSibling, asFirst) {
  if(refNode) {
    if(asSibling) {
      if(asFirst) {
        $A["util"].insertBefore(elements, refNode)
      }else {
        $A["util"].$insertAfter$(elements, refNode)
      }
    }else {
      if(asFirst) {
        $A["util"].$insertFirst$(elements, refNode)
      }else {
        $A["util"].appendChild(elements, refNode)
      }
    }
  }
};
AuraRenderingService.prototype.$getFlavorClass$ = function(cmp) {
  var flavor = null;
  var staticFlavorable = cmp.$isFlavorable$();
  var dynamicFlavorable = cmp.$getDef$().$isDynamicallyFlavorable$();
  var valueProvider = dynamicFlavorable ? cmp : cmp.$getComponentValueProvider$();
  if(valueProvider && (staticFlavorable || dynamicFlavorable)) {
    if(valueProvider.$getConcreteComponent$()) {
      flavor = valueProvider.$getConcreteComponent$().$getFlavor$()
    }
    if($A["util"].$isUndefinedOrNull$(flavor)) {
      flavor = valueProvider.$getFlavor$()
    }
    if(!$A["util"].$isUndefinedOrNull$(flavor) && $A["util"].$isExpression$(flavor)) {
      flavor = flavor.evaluate()
    }
    if(staticFlavorable && !$A["util"].$isUndefinedOrNull$(flavor)) {
      return $A["util"].$buildFlavorClass$(valueProvider, flavor)
    }else {
      if(dynamicFlavorable) {
        var flavorClasses = [];
        var dynamicallyFlavorableDefs = cmp.$getDef$().$getDynamicallyFlavorable$();
        var i = 0;
        for(var len = dynamicallyFlavorableDefs.length;i < len;i++) {
          var def = dynamicallyFlavorableDefs[i];
          var defFlavor = !$A["util"].$isUndefinedOrNull$(flavor) ? flavor : def.$getDefaultFlavor$();
          if(!$A["util"].$isUndefinedOrNull$(defFlavor)) {
            flavorClasses.push($A["util"].$buildFlavorClass$(def, defFlavor))
          }
        }
        return flavorClasses.join(" ")
      }
    }
  }
  return null
};
AuraRenderingService.prototype.$addAuraClass$ = function(cmp, element) {
  var concrete = cmp.$getConcreteComponent$();
  var className = concrete.$getDef$().$getStyleClassName$();
  var flavorClassName;
  if(className) {
    flavorClassName = this.$getFlavorClass$(concrete);
    if(flavorClassName) {
      className = className + flavorClassName
    }
    $A["util"].$addClass$(element, className);
    if(element["tagName"]) {
      element.setAttribute("data-aura-class", $A["util"].$buildClass$(element.getAttribute("data-aura-class"), className))
    }
  }else {
    if(concrete.$isInstanceOf$("aura:html")) {
      flavorClassName = this.$getFlavorClass$(concrete, element);
      if(flavorClassName) {
        $A["util"].$addClass$(element, flavorClassName);
        if(element["tagName"]) {
          element.setAttribute("data-aura-class", $A["util"].$buildClass$(element.getAttribute("data-aura-class"), flavorClassName))
        }
      }
    }
  }
};
AuraRenderingService.prototype.$associateElements$ = function(cmp, elements) {
  elements = this.$getArray$(elements);
  for(var i = 0;i < elements.length;i++) {
    var element = elements[i];
    if(!this.$isCommentMarker$(element)) {
      this.$addAuraClass$(cmp, element)
    }
    cmp.$associateElement$(element)
  }
};
AuraRenderingService.prototype.$createMarker$ = function(target, reason) {
  var node = document.createComment(reason);
  node.$aura_marker$ = true;
  if(target) {
    $A["util"].insertBefore(node, target)
  }
  return node
};
AuraRenderingService.prototype.$isCommentMarker$ = function(node) {
  return node && node.$aura_marker$
};
AuraRenderingService.prototype.$getElements$ = function(component) {
  return component.$getConcreteComponent$().elements || []
};
AuraRenderingService.prototype.$getAllElements$ = function(component) {
  return component.$getConcreteComponent$().$allElements$ || []
};
AuraRenderingService.prototype.$getAllElementsCopy$ = function(component) {
  return component.$getConcreteComponent$().$allElements$.slice(0) || []
};
AuraRenderingService.prototype.$getUid$ = function(element) {
  if(element.nodeType === 1) {
    var id = $A["util"].$getDataAttribute$(element, $A.$componentService$.$renderedBy$);
    if(id !== null) {
      return id
    }
    id = $A["util"].$getDataAttribute$(element, this.$DATA_UID_KEY$);
    if(id !== null) {
      return id
    }
  }
  return element[this.$DATA_UID_KEY$]
};
AuraRenderingService.prototype.$newUid$ = function(element) {
  var nextUid = this.uid++;
  var success = null;
  if(element.nodeType === 1) {
    success = $A["util"].$setDataAttribute$(element, this.$DATA_UID_KEY$, nextUid)
  }
  if(success === null) {
    element[this.$DATA_UID_KEY$] = nextUid
  }
  return nextUid
};
AuraRenderingService.prototype.$resolveUid$ = function(element) {
  var uid = this.$getUid$(element);
  if(uid === null || uid === undefined) {
    return this.$newUid$(element)
  }
  return uid
};
AuraRenderingService.prototype.$addMarkerReference$ = function(marker, globalId) {
  if(!marker || !globalId) {
    return
  }
  var uid = this.$resolveUid$(marker);
  var existing = this.$markerToReferencesMap$[uid];
  if(!existing) {
    this.$markerToReferencesMap$[uid] = existing = new this.$ReferenceCollection$
  }
  existing.add(globalId)
};
AuraRenderingService.prototype.$removeMarkerReference$ = function(marker, globalId) {
  if(!marker || !globalId) {
    return
  }
  var resolvedMarker = this.$resolveUid$(marker);
  var references = this.$markerToReferencesMap$[resolvedMarker];
  if(!$A["util"].$isUndefinedOrNull$(references)) {
    references.$delete$(globalId, function(refs) {
      this.$removeMarkerFromReferenceMap$(resolvedMarker, refs)
    }.bind(this))
  }
};
AuraRenderingService.prototype.$removeMarkerFromReferenceMap$ = function(resolvedMarker, refs) {
  if(!resolvedMarker) {
    return
  }
  if($A["util"].$isUndefinedOrNull$(refs) || $A["util"].$isEmpty$(refs)) {
    this.$markerToReferencesMap$[resolvedMarker] = null;
    delete this.$markerToReferencesMap$[resolvedMarker]
  }
};
AuraRenderingService.prototype.$getMarkerReferences$ = function(marker) {
  if(!marker) {
    return null
  }
  return this.$markerToReferencesMap$[this.$resolveUid$(marker)]
};
AuraRenderingService.prototype.$removeElement$ = function(marker, container) {
  var concrete = container && container.$getConcreteComponent$();
  if(!concrete || !concrete.$isUnrendering$()) {
    if(this.$isSharedMarker$(marker)) {
      if(this.$isCommentMarker$(marker)) {
        return
      }
      this.$moveReferencesToMarker$(marker)
    }else {
      if(concrete && concrete.$destroyed$ === -1 && !this.$isCommentMarker$(marker)) {
        return
      }
    }
    $A["util"].$removeElement$(marker)
  }
};
AuraRenderingService.prototype.$moveContainerReferencesToMarker$ = function(component, oldMarker, newMarker) {
  for(var container = component.$getConcreteComponent$().$getContainer$();container;) {
    var concrete = container.$getConcreteComponent$();
    if(concrete.$getType$() === "aura:html" || concrete.$isRendered$() === false) {
      break
    }
    if(this.$getMarker$(concrete) === oldMarker) {
      this.$setMarker$(concrete, newMarker)
    }
    this.$replaceMarkerElement$(concrete, oldMarker, newMarker);
    container = concrete.$getContainer$()
  }
};
AuraRenderingService.prototype.$moveReferencesToMarker$ = function(marker, newMarker) {
  var references = this.$getMarkerReferences$(marker);
  var isSwap = !!newMarker;
  newMarker = newMarker || this.$createMarker$(null, "unrender marker: " + marker.nodeValue);
  if(references) {
    var collection = references.get();
    for(var c = collection.length - 1;c >= 0;c--) {
      var cmp = $A.$getComponent$(collection[c]);
      if(!cmp || cmp.$destroyed$) {
        continue
      }
      this.$setMarker$(cmp, newMarker);
      this.$replaceMarkerElement$(cmp, marker, newMarker)
    }
  }
  if(!isSwap && this.$isSharedMarker$(newMarker)) {
    $A["util"].insertBefore(newMarker, marker)
  }
};
AuraRenderingService.prototype.$replaceMarkerElement$ = function(component, oldMarker, newMarker) {
  var concrete = component.$getConcreteComponent$();
  var allElements = concrete.$allElements$;
  if(!allElements) {
    concrete.$allElements$ = [newMarker];
    concrete.elements = [];
    if(!this.$isCommentMarker$(newMarker)) {
      concrete.elements.push(newMarker)
    }
    return
  }
  if(allElements.indexOf(newMarker) > -1) {
    return
  }
  var position = allElements.indexOf(oldMarker);
  if(position === -1) {
    $A.$warning$("AuraRenderingService.replaceMarkerElement(): Missing marker on component " + component);
    position = allElements.length
  }
  allElements[position] = newMarker;
  var filteredElements = [];
  for(var i = 0;i < allElements.length;i++) {
    if(!this.$isCommentMarker$(allElements[i])) {
      filteredElements.push(allElements[i])
    }
  }
  concrete.elements = filteredElements
};
AuraRenderingService.prototype.$isSharedMarker$ = function(marker) {
  var references = this.$getMarkerReferences$(marker);
  return references ? references.size() > 0 : false
};
AuraRenderingService.prototype.$ReferenceCollection$ = function() {
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.$isCollection$ = false;
AuraRenderingService.prototype.$ReferenceCollection$.prototype.add = function(value) {
  if(typeof value !== "string") {
    return
  }
  if(this.$has$(value)) {
    return
  }
  if(!this.$references$) {
    this.$references$ = value
  }else {
    if(!this.$isCollection$) {
      if(this.$references$ !== value) {
        this.$references$ = [this.$references$, value];
        this.$isCollection$ = true
      }
    }else {
      this.$references$.push(value)
    }
  }
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.$delete$ = function(value, callback) {
  if(typeof value !== "string") {
    return
  }
  if(this.$isCollection$) {
    var index = this.$references$.indexOf(value);
    if(index > -1) {
      this.$references$.splice(index, 1)
    }
  }
  if(this.$references$ === value) {
    this.$references$ = null
  }
  callback(this.$references$)
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.$has$ = function(value) {
  if(!this.$isCollection$) {
    return this.$references$ === value
  }
  if(this.$references$) {
    return this.$references$.indexOf(value) !== -1
  }
  return false
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.size = function() {
  if(this.$references$) {
    if(typeof this.$references$ === "string") {
      return 1
    }else {
      return this.$references$.length
    }
  }
  return 0
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.get = function(index) {
  if(index === undefined) {
    if(this.$isCollection$) {
      return this.$references$
    }else {
      return[this.$references$]
    }
  }
  return this.$references$[index]
};
Aura.$Services$.$AuraRenderingService$ = AuraRenderingService;
function AuraExpressionService() {
  this.$references$ = {}
}
goog.$exportSymbol$("AuraExpressionService", AuraExpressionService);
AuraExpressionService.$PRIMITIVE_SEPARATOR$ = "__";
AuraExpressionService.$AURA_IF$ = "aura:if";
AuraExpressionService.$AURA_ITERATION$ = "aura:iteration";
AuraExpressionService.prototype.$getReference$ = function(expression, valueProvider) {
  expression = $A.$expressionService$.normalize(expression);
  var isGlobal = expression.charAt(0) === "$";
  var target = null;
  if(isGlobal) {
    target = this.$references$
  }else {
    var id = valueProvider.$getGlobalId$();
    if(!this.$references$.hasOwnProperty(id)) {
      this.$references$[id] = {}
    }
    target = this.$references$[id]
  }
  if(!target.hasOwnProperty(expression)) {
    target[expression] = {$reference$:new PropertyReferenceValue(expression, isGlobal ? null : valueProvider), $consumers$:{}}
  }
  return target[expression].$reference$
};
AuraExpressionService.prototype.$clearReferences$ = function(valueProvider) {
  if($A["util"].$isComponent$(valueProvider)) {
    var globalId = valueProvider.$getGlobalId$();
    var target = this.$references$[globalId];
    if(target) {
      for(var expression in target) {
        var reference = target[expression];
        if(reference && reference.$consumers$) {
          for(var consumer in reference.$consumers$) {
            var component = $A.$getComponent$(consumer);
            for(var targetExpression in reference.$consumers$[consumer]) {
              component.$clearReference$(targetExpression)
            }
          }
        }
      }
    }
    delete this.$references$[globalId]
  }
};
AuraExpressionService.prototype.$updateGlobalReference$ = function(expression, oldValue, value) {
  expression = $A.$expressionService$.normalize(expression);
  var reference = this.$references$[expression];
  if(reference && reference.$consumers$ && reference.$reference$ && reference.$reference$.$lastResult$ !== value) {
    reference.$reference$.evaluate();
    for(var consumer in reference.$consumers$) {
      var component = $A.$getComponent$(consumer);
      if(component) {
        for(var targetExpression in reference.$consumers$[consumer]) {
          component.$markDirty$(targetExpression);
          component.$fireChangeEvent$(targetExpression, reference.$reference$.$lastResult$ || oldValue, value)
        }
      }
    }
  }
};
AuraExpressionService.prototype.$updateGlobalReferences$ = function(type, newValues) {
  function updateNestedValue(expression, values, newValuesInside) {
    if(!values) {
      values = {}
    }
    for(var value in newValuesInside) {
      var targetExpression = expression + "." + value;
      $A.$expressionService$.$updateGlobalReference$(targetExpression, values[value], newValuesInside[value]);
      if($A["util"].$isObject$(newValuesInside[value])) {
        updateNestedValue(targetExpression, values[value], newValuesInside[value])
      }
    }
  }
  var gvpValues = $A.get(type);
  updateNestedValue(type, gvpValues, newValues)
};
AuraExpressionService.prototype.$addExpressionListener$ = function(reference, expression, valueProvider) {
  expression = $A.$expressionService$.normalize(expression);
  var consumers = null;
  if(reference.$valueProvider$) {
    consumers = this.$references$[reference.$valueProvider$.$getGlobalId$()][reference.$expression$].$consumers$
  }else {
    consumers = this.$references$[reference.$expression$].$consumers$
  }
  var globalId = valueProvider.$getGlobalId$();
  if(!consumers.hasOwnProperty(globalId)) {
    consumers[globalId] = {}
  }
  consumers[globalId][expression] = true
};
AuraExpressionService.prototype.$removeExpressionListener$ = function(reference, expression, valueProvider) {
  expression = $A.$expressionService$.normalize(expression);
  var consumers = null;
  if(reference.$valueProvider$) {
    consumers = this.$references$[reference.$valueProvider$.$getGlobalId$()][reference.$expression$].$consumers$
  }else {
    consumers = this.$references$[reference.$expression$].$consumers$
  }
  var globalId = valueProvider.$getGlobalId$();
  if(consumers.hasOwnProperty(globalId)) {
    delete consumers[globalId][expression];
    if(!Object.keys(consumers[globalId]).length) {
      delete consumers[globalId]
    }
  }
};
AuraExpressionService.prototype.create = function(valueProvider, config) {
  return valueFactory.create(config, valueProvider)
};
goog.$exportProperty$(AuraExpressionService.prototype, "create", AuraExpressionService.prototype.create);
AuraExpressionService.prototype.$createPassthroughValue$ = function(primaryProviders, cmp) {
  $A.$deprecated$("$A.createPassthroughValue and $A.expressionService.createPassthroughValue are not supported.", "Use 'component.addValueProvider;'.", "AuraExpressionService.createPassthroughValue");
  return new PassthroughValue(primaryProviders, cmp)
};
goog.$exportProperty$(AuraExpressionService.prototype, "createPassthroughValue", AuraExpressionService.prototype.$createPassthroughValue$);
AuraExpressionService.prototype.normalize = function(expression) {
  if(typeof expression === "string") {
    expression = expression.trim();
    if(expression.charAt(0) === "{" && expression.charAt(expression.length - 1) === "}" && (expression.charAt(1) === "!" || expression.charAt(1) === "#")) {
      expression = expression.slice(2, -1).trim()
    }
    for(var startBrace = expression.indexOf("[");startBrace > -1;) {
      var endBrace = expression.indexOf("]", startBrace + 1);
      if(endBrace > -1) {
        expression = expression.substring(0, startBrace) + "." + expression.substring(startBrace + 1, endBrace) + expression.substring(endBrace + 1);
        startBrace = expression.indexOf("[", endBrace - 1)
      }else {
        startBrace = -1
      }
    }
  }
  return expression
};
goog.$exportProperty$(AuraExpressionService.prototype, "normalize", AuraExpressionService.prototype.normalize);
AuraExpressionService.prototype.$resolve$ = function(expression, container, rawValue) {
  var target = container;
  var path = expression;
  if(!$A["util"].isArray(path)) {
    path = path.split(".")
  }
  for(var segment;!$A["util"].$isUndefinedOrNull$(target) && path.length;) {
    segment = path.shift();
    target = target[segment];
    if(!rawValue && $A["util"].$isExpression$(target)) {
      target = target.evaluate()
    }
  }
  return target
};
goog.$exportProperty$(AuraExpressionService.prototype, "resolve", AuraExpressionService.prototype.$resolve$);
AuraExpressionService.prototype.$resolveLocatorContext$ = function(cmp, locatorDef) {
  if(!locatorDef) {
    return undefined
  }
  var contextDefs = locatorDef["context"];
  if(!contextDefs) {
    return undefined
  }
  var context = {};
  if(cmp.$isValid$()) {
    try {
      $A.$clientService$.$setCurrentAccess$(cmp);
      for(var key in contextDefs) {
        var expression = this.create(cmp, contextDefs[key]);
        if(expression) {
          context[key] = typeof expression === "string" ? expression : expression.evaluate()
        }
      }
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
  return context
};
AuraExpressionService.prototype.$getContainer$ = function(cmp) {
  if(!cmp) {
    return undefined
  }
  var owner = cmp.$getOwner$();
  var ownerName = owner.$getType$();
  for(var prevOwner = undefined;ownerName === AuraExpressionService.$AURA_ITERATION$ || ownerName === AuraExpressionService.$AURA_IF$ || owner.$isInstanceOf$("ui:virtualComponent") || owner.$isInstanceOf$("ui:abstractList") || owner.$isInstanceOf$("ui:abstractDataGrid");) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$();
    if(owner === prevOwner) {
      break
    }
    prevOwner = owner
  }
  return owner
};
AuraExpressionService.prototype.$findLocatorDefInSuperChain$ = function(cmp, targetId) {
  var locatorDefs;
  for(var locatorDef;!locatorDef && cmp;) {
    locatorDefs = cmp.$getDef$().$getLocatorDefs$();
    locatorDef = locatorDefs && (locatorDefs[targetId] || locatorDefs["*"]);
    if(!locatorDef) {
      cmp = cmp.$getSuper$()
    }
  }
  return locatorDef
};
AuraExpressionService.prototype.$resolveLocator$ = function(parent, root, includeMetadata, primitiveFound) {
  var locator;
  var parentId = parent && parent.$getLocalId$();
  var rootId = root && root.$getLocalId$();
  if(!rootId) {
    return locator
  }
  var rootLocatorDef = this.$findLocatorDefInSuperChain$(parent, rootId);
  if(!primitiveFound && rootLocatorDef && rootLocatorDef["isPrimitive"]) {
    primitiveFound = {};
    primitiveFound["target"] = rootLocatorDef["alias"] || rootId;
    primitiveFound["resolvedContext"] = this.$resolveLocatorContext$(parent, rootLocatorDef);
    root = parent;
    parent = this.$getContainer$(parent).$getConcreteComponent$();
    return this.$resolveLocator$(parent, root, includeMetadata, primitiveFound)
  }
  var grandparent = this.$getContainer$(parent).$getConcreteComponent$();
  var parentLocatorDef = this.$findLocatorDefInSuperChain$(grandparent, parentId);
  if(!rootLocatorDef || !parentLocatorDef) {
    return locator
  }
  locator = {};
  var rootContext = this.$resolveLocatorContext$(parent, rootLocatorDef);
  var parentContext = this.$resolveLocatorContext$(grandparent, parentLocatorDef);
  var primitiveContext = primitiveFound && primitiveFound["resolvedContext"];
  var context = $A["util"].apply(parentContext || {}, rootContext);
  context = $A["util"].apply(context, primitiveContext);
  if(!$A["util"].$isEmpty$(context)) {
    locator["context"] = context
  }
  locator["target"] = rootLocatorDef["alias"] || rootId;
  locator["scope"] = parentLocatorDef["alias"] || parentId;
  if(primitiveFound) {
    locator["target"] = locator["target"] + AuraExpressionService.$PRIMITIVE_SEPARATOR$ + primitiveFound["target"]
  }
  if(includeMetadata) {
    locator["metadata"] = {"root":root.$getDef$().toString(), "rootId":rootId, "parent":parent.$getDef$().toString(), "parentId":parentId, "grandparent":grandparent.$getDef$().toString()};
    if(rootLocatorDef["description"]) {
      locator["metadata"]["targetDescription"] = rootLocatorDef["description"];
      locator["metadata"]["scopeDescription"] = parentLocatorDef["description"]
    }
  }
  return locator
};
Aura.$Services$.$AuraExpressionService$ = AuraExpressionService;
function AuraHistoryService() {
  this.history = [];
  this.$currentIndex$ = -1;
  this.$evt$ = null
}
goog.$exportSymbol$("AuraHistoryService", AuraHistoryService);
AuraHistoryService.prototype.set = function(token) {
  if(token) {
    if(this.$usePushState$()) {
      window.history.pushState({"hash":token}, null, "#" + token);
      this.$changeHandler$()
    }else {
      if($A["util"].$isIOSWebView$()) {
        var historyLength = this.history.length;
        if(this.$currentIndex$ < historyLength - 1) {
          this.history.splice(this.$currentIndex$ + 1, historyLength - this.$currentIndex$)
        }
        this.$currentIndex$++;
        this.history.push(token)
      }
      window.location.hash = "#" + token
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "set", AuraHistoryService.prototype.set);
AuraHistoryService.prototype.replace = function(token) {
  if(token) {
    if(this.$usePushState$()) {
      window.history.replaceState({"hash":token}, null, "#" + token);
      this.$changeHandler$()
    }else {
      if($A["util"].$isIOSWebView$()) {
        var historyLength = this.history.length;
        if(this.$currentIndex$ < historyLength - 1) {
          this.history.splice(this.$currentIndex$ + 1, historyLength - this.$currentIndex$)
        }
        this.history[this.$currentIndex$] = token
      }
      if(window.location.replace) {
        window.location.replace("#" + token)
      }else {
        window.location.hash = "#" + token
      }
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "replace", AuraHistoryService.prototype.replace);
AuraHistoryService.prototype.get = function() {
  var token = this.$getLocationHash$() || this.$getHistoryState$() || "";
  return this.$parseLocation$(token)
};
goog.$exportProperty$(AuraHistoryService.prototype, "get", AuraHistoryService.prototype.get);
AuraHistoryService.prototype.back = function() {
  if(!$A["util"].$isIOSWebView$()) {
    window.history.go(-1)
  }else {
    if(this.$currentIndex$ > 0) {
      var hash = this.history[--this.$currentIndex$];
      window.location.hash = "#" + hash
    }else {
      this.reset();
      window.location.hash = ""
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "back", AuraHistoryService.prototype.back);
AuraHistoryService.prototype.$setTitle$ = function(title) {
  document.title = title
};
goog.$exportProperty$(AuraHistoryService.prototype, "setTitle", AuraHistoryService.prototype.$setTitle$);
AuraHistoryService.prototype.forward = function() {
  if(!$A["util"].$isIOSWebView$()) {
    window.history.go(1)
  }else {
    var historyLength = this.history.length;
    if(this.$currentIndex$ < historyLength - 1) {
      window.location.hash = "#" + this.history[++this.$currentIndex$]
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "forward", AuraHistoryService.prototype.forward);
AuraHistoryService.prototype.reset = function() {
  this.history = [];
  this.$currentIndex$ = -1
};
goog.$exportProperty$(AuraHistoryService.prototype, "reset", AuraHistoryService.prototype.reset);
AuraHistoryService.prototype.$usePushState$ = function() {
  if(this.$_usePushState$ === undefined) {
    var ua = window.navigator.userAgent;
    this.$_usePushState$ = !!window.history.pushState && !(ua.indexOf("Android ") > -1 && ua.indexOf("Mozilla/5.0") > -1 && ua.indexOf("AppleWebKit") > -1 && ua.indexOf("Chrome") === -1) && !$A["util"].$isIOSWebView$()
  }
  return this.$_usePushState$
};
AuraHistoryService.prototype.$init$ = function() {
  var that = this;
  if(this.$usePushState$()) {
    window.addEventListener("popstate", function() {
      that.$changeHandler$()
    })
  }else {
    var hash = this.$getLocationHash$();
    this.history.push(hash);
    this.$currentIndex$++;
    var docMode = document["documentMode"];
    var hasOnHashChangeEvent = "onhashchange" in window && (docMode === undefined || docMode > 7);
    if(hasOnHashChangeEvent) {
      window["onhashchange"] = function() {
        that.$changeHandler$()
      }
    }else {
      var watch = function() {
        setTimeout(function executeChangeHandlerAndWatch() {
          var newHash = that.$getLocationHash$();
          if(newHash !== hash) {
            hash = newHash;
            that.$changeHandler$()
          }
          watch()
        }, 300)
      };
      watch()
    }
  }
  this.$changeHandler$();
  delete this.$init$
};
AuraHistoryService.prototype.$getEvent$ = function() {
  if(!this.$evt$) {
    this.$evt$ = $A.$getRoot$().$getDef$().$getLocationChangeEvent$()
  }
  return this.$evt$
};
AuraHistoryService.prototype.$changeHandler$ = function() {
  var loc = this.$getLocationHash$() || this.$getHistoryState$();
  $A.$clientService$.$setCurrentAccess$($A.$getRoot$());
  var event;
  try {
    event = $A.$eventService$.$newEvent$(this.$getEvent$())
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
  if(!event) {
    throw new $A.$auraError$("The event specified on the app for the locationChange (" + this.$getEvent$() + ") was not found.", null, $A.severity.$QUIET$);
  }
  if(loc) {
    var parsedHash = this.$parseLocation$(loc);
    var parameters = {};
    var attributes = event.$getDef$().$getAttributeDefs$().$getNames$();
    var attribute;
    var c = 0;
    for(var length = attributes.length;c < length;c++) {
      attribute = attributes[c];
      if(parsedHash.hasOwnProperty(attribute)) {
        parameters[attribute] = parsedHash[attribute]
      }
    }
    event.$setParams$(parameters)
  }
  event.$fire$()
};
AuraHistoryService.prototype.$parseLocation$ = function(location) {
  if(location.indexOf("#") === 0) {
    location = location.substring(1)
  }
  if(location.indexOf("\x3d") > -1) {
    var position = location.indexOf("?");
    if(position === -1) {
      return{"token":location, "querystring":""}
    }
    var token = location.substring(0, position);
    var querystring = location.substring(position + 1);
    var decoded = this.$parseQueryString$(querystring);
    decoded["token"] = token;
    decoded["querystring"] = querystring;
    return decoded
  }else {
    return{"token":location, "querystring":""}
  }
};
AuraHistoryService.prototype.$parseQueryString$ = function(querystring) {
  var ret = {};
  var pairs = querystring.split("\x26");
  var position;
  var pair;
  for(var i = 0;i < pairs.length;i++) {
    pair = pairs[i];
    position = pair.indexOf("\x3d");
    if(position === -1) {
      ret[pair] = undefined
    }else {
      ret[pair.substring(0, position)] = decodeURIComponent(pair.substring(position + 1))
    }
  }
  return ret
};
AuraHistoryService.prototype.$getLocationHash$ = function() {
  var href = window.location["href"];
  var hashPosition = href.indexOf("#");
  if(hashPosition === -1) {
    return""
  }
  return href.substr(hashPosition)
};
AuraHistoryService.prototype.$getHistoryState$ = function() {
  var historyState = null;
  try {
    historyState = window.history["state"] && window.history["state"]["hash"]
  }catch(e) {
  }
  return historyState
};
Aura.$Services$.$AuraHistoryService$ = AuraHistoryService;
function AuraEventService() {
  this.$eventDispatcher$ = {};
  this.$eventDefRegistry$ = {};
  this.$savedEventConfigs$ = {};
  this.$componentHandlers$ = {}
}
goog.$exportSymbol$("AuraEventService", AuraEventService);
AuraEventService.$Phase$ = {$CAPTURE$:"capture", $BUBBLE$:"bubble", $DEFAULT$:"default"};
AuraEventService.$validatePhase$ = function(phase, defaultPhase) {
  if(phase) {
    if(phase !== AuraEventService.$Phase$.$BUBBLE$ && phase !== AuraEventService.$Phase$.$CAPTURE$ && phase !== AuraEventService.$Phase$.$DEFAULT$) {
      throw new Error("AuraEventService.validatePhase(): 'phase' must be omitted, or one of '" + AuraEventService.$Phase$.$BUBBLE$ + "', '" + AuraEventService.$Phase$.$CAPTURE$ + "', or '" + AuraEventService.$Phase$.$DEFAULT$ + "'. Found '" + phase + "'.");
    }
  }else {
    phase = defaultPhase || AuraEventService.$Phase$.$DEFAULT$
  }
  return phase
};
AuraEventService.prototype.$newEvent$ = function(eventDef, eventName, sourceCmp) {
  $A.assert(eventDef, "EventDef is required");
  eventDef = this.$getDef$(eventDef);
  return this.$getNewEvent$(eventDef, eventName, sourceCmp)
};
goog.$exportProperty$(AuraEventService.prototype, "newEvent", AuraEventService.prototype.$newEvent$);
AuraEventService.prototype.$getNewEvent$ = function(eventDefinition, eventName, sourceCmp) {
  var eventDef = eventDefinition;
  if(typeof eventDefinition === "string") {
    eventDef = this.$getEventDef$(eventDefinition)
  }
  if(eventDef) {
    var config = {};
    config["eventDef"] = eventDef;
    if(eventDef.$getEventType$() === "COMPONENT") {
      config["name"] = eventName;
      config["component"] = sourceCmp && sourceCmp.$getConcreteComponent$()
    }else {
      config["eventDispatcher"] = this.$eventDispatcher$
    }
    return new Aura.$Event$.$Event$(config)
  }
};
AuraEventService.prototype.$collectBubblePath$ = function(cmp, queue, visited, isOwner) {
  if(!cmp || cmp.$destroyed$ === 1) {
    return queue
  }
  if(visited[cmp.$globalId$]) {
    if(!isOwner) {
      queue.push({$cmp$:cmp, $isMarker$:true})
    }
    return queue
  }
  queue.push({$cmp$:cmp, $isOwner$:isOwner});
  visited[cmp.$globalId$] = true;
  var superCmp = cmp.$getSuper$();
  if(superCmp) {
    this.$collectBubblePath$(superCmp, queue, visited, isOwner && true)
  }
  var next = cmp;
  for(var queueIndex = queue.length;next;) {
    next = next.$getOwner$();
    if(next === cmp || !$A["util"].$isComponent$(next)) {
      break
    }
    if(next.$getGlobalId$() !== cmp.$getGlobalId$()) {
      this.$collectBubblePath$(next, queue, visited, isOwner && true);
      break
    }else {
      cmp = next
    }
  }
  if(cmp.$isConcrete$()) {
    var concreteCmpContainerComponent = cmp.$getContainer$();
    if(concreteCmpContainerComponent) {
      var containerComponentQueue = this.$collectBubblePath$(concreteCmpContainerComponent, [], visited, false);
      var intersectionPoint = null;
      for(var pStopIdx = 0;pStopIdx < containerComponentQueue.length;pStopIdx++) {
        if(containerComponentQueue[pStopIdx].$isMarker$) {
          intersectionPoint = containerComponentQueue[pStopIdx].$cmp$;
          break
        }
      }
      var intersectionIndex = queueIndex;
      if(intersectionPoint) {
        for(var j = 0;j < queue.length;j++) {
          if(queue[j].$cmp$ === intersectionPoint) {
            intersectionIndex = j;
            break
          }
        }
      }
      queue.splice.apply(queue, [intersectionIndex, 0].concat(containerComponentQueue.slice(0, pStopIdx)))
    }
  }
  return queue
};
AuraEventService.prototype.$getEventPhaseCmpIterator$ = function() {
  function EventPhaseCmpIterator(cmp, eventService) {
    var queue = eventService.$collectBubblePath$(cmp, [], {}, true);
    queue = queue.slice().reverse().concat(queue);
    var queueIndex = 0;
    var phaseSwitchIndex = queue.length / 2;
    var phase = AuraEventService.$Phase$.$CAPTURE$;
    var currentValue;
    var done = false;
    this.next = function() {
      for(;!done;) {
        if(queueIndex < queue.length) {
          if(queueIndex === phaseSwitchIndex) {
            phase = AuraEventService.$Phase$.$BUBBLE$
          }
          var qval = queue[queueIndex++];
          currentValue = {$cmp$:qval.$cmp$, $isOwner$:qval.$isOwner$, $phase$:phase};
          break
        }else {
          done = true;
          currentValue = undefined
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  return function(cmp) {
    return new EventPhaseCmpIterator(cmp, this)
  }
}();
AuraEventService.prototype.$getPhasedEventHandlerIterator$ = function() {
  function PhasedEventHandlerIterator(evt, eventPhaseCmpIterator, handlerSupplierFn) {
    function moveCmpCursor() {
      currentHandlersIndex = 0;
      var res = eventPhaseCmpIterator.next();
      if(res.$done$) {
        currentHandlers = currentLocation = null
      }else {
        currentLocation = res.value;
        currentHandlers = handlerSupplierFn(evt, currentLocation.$cmp$, currentLocation.$phase$, currentLocation.$isOwner$);
        currentHandlersIndex = 0
      }
    }
    var done = false;
    var currentValue;
    var currentLocation = null;
    var currentHandlers = null;
    var currentHandlersIndex = 0;
    moveCmpCursor();
    this.next = function() {
      for(;!done;) {
        if(!currentLocation) {
          done = true;
          currentValue = undefined
        }else {
          if(currentHandlersIndex < currentHandlers.length) {
            currentValue = {$cmp$:currentLocation.$cmp$, $phase$:currentLocation.$phase$, $handler$:currentHandlers[currentHandlersIndex++]};
            break
          }else {
            if(evt.$eventStopPropagation$) {
              return this.$return$({$cmp$:currentValue.$cmp$, $phase$:currentValue.$phase$})
            }else {
              moveCmpCursor()
            }
          }
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  return function(evt, handlerSupplierFn) {
    return new PhasedEventHandlerIterator(evt, this.$getEventPhaseCmpIterator$(evt.$getSource$()), handlerSupplierFn)
  }
}();
AuraEventService.prototype.$getComponentEventHandlerIterator$ = function() {
  return function(evt) {
    return this.$getPhasedEventHandlerIterator$(evt, this.$getComponentEventHandlers$.bind(this))
  }
}();
AuraEventService.prototype.$eventStopPropagationHandler$ = function(evt) {
  evt.stopPropagation()
};
AuraEventService.prototype.$getComponentEventHandlers$ = function(evt, cmp, phase, isOwner) {
  var handlers;
  var eventName = evt.getName();
  var dispatcher = cmp.$destroyed$ !== 1 && cmp.$getEventDispatcher$();
  if(dispatcher) {
    var dispatcherHandlers = dispatcher[eventName];
    if(dispatcherHandlers) {
      var phasedHandlers = dispatcherHandlers[phase];
      if(phasedHandlers && phasedHandlers.length) {
        handlers = [];
        var cmpHandlerDefs = cmp.$getDef$().$getCmpHandlerDefs$();
        var includedHandlers = false;
        if(cmpHandlerDefs) {
          for(var i = 0;i < cmpHandlerDefs.length && !includedHandlers;i++) {
            for(var evtDef = evt.$getDef$();evtDef;evtDef = evtDef.$getSuperDef$()) {
              var hDef = cmpHandlerDefs[i]["eventDef"];
              if(cmpHandlerDefs[i]["name"] === eventName && (!hDef || hDef === evtDef)) {
                for(var j = 0;j < phasedHandlers.length;j++) {
                  if(isOwner || phasedHandlers[j].$includeFacets$) {
                    handlers.push(phasedHandlers[j])
                  }
                }
                includedHandlers = true;
                break
              }
              if(!hDef && isOwner) {
                handlers.push(this.$eventStopPropagationHandler$)
              }
            }
          }
        }
        if(!includedHandlers && cmp.$getDef$().$getEventDef$(eventName) && isOwner) {
          handlers.push(this.$eventStopPropagationHandler$);
          handlers.push.apply(handlers, phasedHandlers)
        }
      }
    }
  }
  return handlers || []
};
AuraEventService.prototype.$getNonBubblingComponentEventHandlers$ = function(cmp, evt, phase) {
  var handlers;
  if(cmp.$destroyed$ !== 1 && cmp.$getDef$().$getEventDef$(evt.getName())) {
    var dispatcher = cmp.$getEventDispatcher$();
    if(dispatcher) {
      var handlersObj = dispatcher[evt.getName()];
      handlers = handlersObj && handlersObj[phase]
    }
  }
  return handlers || []
};
AuraEventService.prototype.$getNonBubblingComponentEventHandlerIterator$ = function() {
  function NonBubblingComponentHandlerIterator(evt, componentEventHandlersSupplierFn) {
    function getHandlers() {
      for(;cmp;) {
        currentCmp = cmp;
        var evtHandlers = componentEventHandlersSupplierFn(currentCmp, evt, PHASE);
        cmp = cmp.$getSuper$();
        if(evtHandlers) {
          handlerIndex = 0;
          return evtHandlers
        }
      }
    }
    var done = false;
    var currentValue;
    var cmp = evt.$getSource$();
    var currentCmp = cmp;
    var handlerIndex = 0;
    var handlers = getHandlers();
    this.next = function() {
      for(;!done;) {
        if(!handlers) {
          done = true;
          currentValue = undefined
        }else {
          if(handlerIndex < handlers.length) {
            currentValue = {$cmp$:currentCmp, $phase$:PHASE, $handler$:handlers[handlerIndex++]};
            break
          }else {
            handlers = getHandlers()
          }
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  var PHASE = AuraEventService.$Phase$.$BUBBLE$;
  return function(evt) {
    return new NonBubblingComponentHandlerIterator(evt, this.$getNonBubblingComponentEventHandlers$)
  }
}();
AuraEventService.prototype.$getValueHandlerIterator$ = function() {
  function ValueHandlerIterator(evt) {
    var done = false;
    var currentValue;
    var queue = [];
    var queueIndex = 0;
    var cmp = evt.$getSource$();
    var evtDef = evt.$eventDef$;
    for(var eventDispatcher = evt.$eventDispatcher$;evtDef;) {
      var qname = evtDef.$getDescriptor$().$getQualifiedName$();
      var handlers = eventDispatcher[qname] && eventDispatcher[qname][PHASE];
      if(handlers) {
        if($A["util"].isArray(handlers)) {
          for(var i = 0;i < handlers.length;i++) {
            queue.push({$cmp$:cmp, $phase$:PHASE, $handler$:handlers[i]})
          }
        }
      }
      evtDef = evtDef.$getSuperDef$()
    }
    this.next = function() {
      for(;!done;) {
        if(queueIndex < queue.length) {
          currentValue = queue[queueIndex++];
          break
        }else {
          done = true;
          currentValue = undefined
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  var PHASE = AuraEventService.$Phase$.$DEFAULT$;
  return function(evt) {
    return new ValueHandlerIterator(evt)
  }
}();
AuraEventService.prototype.$getPhasedApplicationEventHandlers$ = function(evt, cmp, phase, isOwner) {
  var evtDef = evt.$eventDef$;
  var eventDispatcher = evt.$eventDispatcher$;
  var globalId = cmp.$globalId$;
  var phasedEvtHandlers = [];
  if(cmp.$destroyed$ !== 1) {
    for(;evtDef;) {
      var qname = evtDef.$getDescriptor$().$getQualifiedName$();
      var handlers = eventDispatcher[qname];
      var cmpPhasedHandlers = handlers && handlers[phase] && handlers[phase][globalId];
      if(cmpPhasedHandlers) {
        for(var i = 0;i < cmpPhasedHandlers.length;i++) {
          if(isOwner || cmpPhasedHandlers[i].$includeFacets$) {
            phasedEvtHandlers.push(cmpPhasedHandlers[i])
          }
        }
      }
      evtDef = evtDef.$getSuperDef$()
    }
  }
  return phasedEvtHandlers
};
AuraEventService.prototype.$applicationEventHasPhasedHandlers$ = function() {
  function hasHandlers(phasedHandlerMap) {
    for(var globalId in phasedHandlerMap) {
      if(phasedHandlerMap.hasOwnProperty(globalId) && phasedHandlerMap[globalId] && phasedHandlerMap[globalId].length) {
        return true
      }
    }
    return false
  }
  return function(evt) {
    var evtDef = evt.$eventDef$;
    for(var eventDispatcher = evt.$eventDispatcher$;evtDef;) {
      var qname = evtDef.$getDescriptor$().$getQualifiedName$();
      var handlers = eventDispatcher[qname];
      if(handlers && (hasHandlers(handlers[AuraEventService.$Phase$.$BUBBLE$]) || hasHandlers(handlers[AuraEventService.$Phase$.$CAPTURE$]))) {
        return true
      }
      evtDef = evtDef.$getSuperDef$()
    }
    return false
  }
}();
AuraEventService.prototype.$getAppEventHandlerIterator$ = function() {
  function AppEventDefaultPhaseHandlerIterator(evt, rootId) {
    function fillQueue() {
      queue = [];
      var evtDef = evt.$eventDef$;
      for(var eventDispatcher = evt.$eventDispatcher$;evtDef;) {
        var qname = evtDef.$getDescriptor$().$getQualifiedName$();
        var handlers = eventDispatcher[qname];
        var defaultHandlersMap = handlers && handlers[AuraEventService.$Phase$.$DEFAULT$];
        var cmpHandlers;
        if(defaultHandlersMap) {
          for(var globalId in defaultHandlersMap) {
            if(defaultHandlersMap.hasOwnProperty(globalId)) {
              var cmp = $A.$getComponent$(globalId);
              if(cmp && cmp.$destroyed$ === 1) {
                delete defaultHandlersMap[globalId];
                continue
              }
              if(rootCmp) {
                var containsResult = $A.$componentService$.$containsComponent$(rootCmp, cmp);
                if(!containsResult.result) {
                  continue
                }
              }
              cmpHandlers = defaultHandlersMap[globalId];
              for(var i = 0;i < cmpHandlers.length;i++) {
                queue.push({$cmp$:cmp, $phase$:AuraEventService.$Phase$.$DEFAULT$, $handler$:cmpHandlers[i]})
              }
            }
          }
        }
        evtDef = evtDef.$getSuperDef$()
      }
    }
    var done = false;
    var queue = null;
    var queueIndex = 0;
    var currentValue;
    var rootCmp = rootId && $A.$getComponent$(rootId);
    this.next = function() {
      for(;!done;) {
        if(!queue) {
          fillQueue()
        }
        if(queueIndex < queue.length) {
          currentValue = queue[queueIndex++];
          break
        }else {
          done = true;
          currentValue = null
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  function AppEventHandlerIterator(evt, eventService) {
    var defaultEventHandlerIterator = null;
    var currentPhase = AuraEventService.$Phase$.$CAPTURE$;
    var currentValue = null;
    var done = false;
    var phasedEventHandlerIterator;
    if(!eventService.$applicationEventHasPhasedHandlers$(evt)) {
      currentPhase = AuraEventService.$Phase$.$DEFAULT$;
      defaultEventHandlerIterator = new AppEventDefaultPhaseHandlerIterator(evt)
    }else {
      phasedEventHandlerIterator = eventService.$getPhasedEventHandlerIterator$(evt, eventService.$getPhasedApplicationEventHandlers$)
    }
    this.next = function() {
      for(;!done;) {
        if(currentPhase === AuraEventService.$Phase$.$CAPTURE$ || currentPhase === AuraEventService.$Phase$.$BUBBLE$) {
          var phaseRes = phasedEventHandlerIterator.next();
          if(!phaseRes.$done$) {
            currentValue = phaseRes.value;
            currentPhase = currentValue.$phase$;
            break
          }else {
            if(evt.defaultPrevented) {
              currentValue = undefined;
              currentPhase = AuraEventService.$Phase$.$DEFAULT$;
              done = true
            }else {
              currentPhase = AuraEventService.$Phase$.$DEFAULT$;
              var bcastRootId = null;
              if(evt.$eventStopPropagation$ && phaseRes.value) {
                bcastRootId = phaseRes.value.$cmp$.$globalId$
              }
              defaultEventHandlerIterator = new AppEventDefaultPhaseHandlerIterator(evt, bcastRootId)
            }
          }
        }else {
          var defaultRes = defaultEventHandlerIterator.next();
          if(!defaultRes.$done$) {
            currentValue = defaultRes.value;
            break
          }
          currentValue = undefined;
          done = true
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  return function(evt) {
    return new AppEventHandlerIterator(evt, this)
  }
}();
AuraEventService.prototype.get = function(name, callback) {
  var newEvent = this.$newEvent$(name);
  if(callback) {
    if(newEvent) {
      return callback(newEvent)
    }
    return this.$getDefinition$(name, callback)
  }
  return newEvent
};
AuraEventService.prototype.$expressionHandler$ = function(expression, event) {
  if(expression) {
    var expressionValue = expression;
    var target = null;
    if($A["util"].$isExpression$(expressionValue)) {
      target = expressionValue.$valueProvider$;
      expressionValue = expressionValue.evaluate()
    }
    if($A["util"].$isAction$(expressionValue)) {
      expressionValue.$run$(event)
    }
    if($A["util"].$isFunction$(expressionValue)) {
      expressionValue(target, event)
    }
  }
};
AuraEventService.prototype.$addEventHandler$ = function(component, eventDef, handler, phase, includeFacets) {
  if(!$A["util"].$isComponent$(component)) {
    throw new Error("AuraEventService.addEventHandler: 'component' must be a valid Component.");
  }
  if(!(eventDef instanceof EventDef)) {
    throw new Error("AuraEventService.addEventHandler: 'eventDef' must be a valid Event definition.");
  }
  if($A["util"].$isExpression$(handler)) {
    var reference = handler;
    handler = this.$expressionHandler$.bind(this, handler);
    handler.$reference$ = reference
  }
  if(!$A["util"].$isFunction$(handler)) {
    throw new Error("AuraEventService.addEventHandler: 'handler' must be a valid Function or a reference to a controller action, e.g., 'cmp.getReference(\"c.myAction\");'");
  }
  phase = AuraEventService.$validatePhase$(phase);
  var event = eventDef.$descriptor$.$qualifiedName$;
  var handlers = this.$eventDispatcher$[event];
  if(!handlers) {
    this.$eventDispatcher$[event] = handlers = {}
  }
  var phaseHandlers = handlers[phase];
  if(!phaseHandlers) {
    handlers[phase] = phaseHandlers = {}
  }
  var globalId = component.$globalId$;
  var cmpHandlers = phaseHandlers[globalId];
  if(!cmpHandlers) {
    phaseHandlers[globalId] = cmpHandlers = []
  }
  if(!this.$componentHandlers$[globalId]) {
    this.$componentHandlers$[globalId] = []
  }
  if(includeFacets) {
    handler.$includeFacets$ = true
  }
  for(var i = 0;i < cmpHandlers.length;i++) {
    if(cmpHandlers[i] === handler || cmpHandlers[i].$reference$ && cmpHandlers[i].$reference$ === handler.$reference$) {
      return
    }
  }
  cmpHandlers.push(handler);
  this.$componentHandlers$[globalId].push({"event":event, "phase":phase})
};
AuraEventService.prototype.$addHandler$ = function(config) {
  var includeFacets = config["includeFacets"];
  includeFacets = includeFacets !== undefined && includeFacets !== null && includeFacets !== false && includeFacets !== 0 && includeFacets !== "false" && includeFacets !== "" && includeFacets !== "f";
  var component = $A.$getComponent$(config["globalId"]);
  if(!component) {
    component = Object.create(Aura.$Component$.$Component$.prototype, {$globalId$:{value:"1:0"}});
    $A.$warning$("$A.eventService.addHandler: Unknown component with globalId '" + config["globalId"] + "'. Does this component exist?")
  }
  var eventDef = this.$getEventDef$(config["event"]);
  if(!eventDef) {
    eventDef = Object.create(Aura.$Event$.$EventDef$.prototype, {$descriptor$:{value:{$qualifiedName$:config["event"]}}});
    $A.$warning$("$A.eventService.addHandler: Unknown event with name '" + config["event"] + "'. Do you have a missing dependency?")
  }
  this.$addEventHandler$(component, eventDef, config["handler"], config["phase"], includeFacets)
};
goog.$exportProperty$(AuraEventService.prototype, "addHandler", AuraEventService.prototype.$addHandler$);
AuraEventService.prototype.$removeEventHandler$ = function(component, eventDef, handler, phase) {
  if(!$A["util"].$isComponent$(component)) {
    throw new Error("AuraEventService.removeEventHandler: 'component' must be a valid Component.");
  }
  if(!(eventDef instanceof EventDef)) {
    throw new Error("AuraEventService.removeEventHandler: 'eventDef' must be a valid Event definition.");
  }
  phase = AuraEventService.$validatePhase$(phase);
  var event = eventDef.$descriptor$.$qualifiedName$;
  var handlers = this.$eventDispatcher$[event];
  if(handlers) {
    var phaseHandlers = handlers[phase];
    if(phaseHandlers) {
      var globalId = component.$globalId$;
      if(!globalId && $A.$finishedInit$) {
        throw new Error("$A.removeEventHandler: Unable to find current component target. Are you running in Aura scope?");
      }
      var cmpHandlers = phaseHandlers[globalId];
      if(cmpHandlers) {
        for(var i = 0;i < cmpHandlers.length;i++) {
          if(cmpHandlers[i] === handler || cmpHandlers[i].$reference$ === handler) {
            delete cmpHandlers[i].$reference$;
            cmpHandlers.splice(i, 1);
            break
          }
        }
      }
    }
  }
};
goog.$exportProperty$(AuraEventService.prototype, "removeEventHandler", AuraEventService.prototype.$removeEventHandler$);
AuraEventService.prototype.$removeHandler$ = function(config) {
  var globalId = config["globalId"];
  var component = $A.$getComponent$(globalId);
  if(!component) {
    globalId = "1:0"
  }
  var def = this.$getEventDef$(config["event"]);
  var handlers = this.$eventDispatcher$[def.$descriptor$.$qualifiedName$];
  if(handlers) {
    var phase = config["phase"] || "default";
    var phaseHandlers = handlers[phase];
    if(phaseHandlers) {
      delete phaseHandlers[globalId]
    }
  }
};
goog.$exportProperty$(AuraEventService.prototype, "removeHandler", AuraEventService.prototype.$removeHandler$);
AuraEventService.prototype.$removeHandlersByComponentId$ = function(globalId) {
  var references = this.$componentHandlers$[globalId];
  if(references) {
    var dispatcher = this.$eventDispatcher$;
    var c = 0;
    for(var reference;c < references.length;c++) {
      reference = references[c];
      if(dispatcher[reference["event"]] && dispatcher[reference["event"]][reference["phase"]] && dispatcher[reference["event"]][reference["phase"]][globalId]) {
        delete dispatcher[reference["event"]][reference["phase"]][globalId]
      }
    }
    delete this.$componentHandlers$[globalId]
  }
};
AuraEventService.prototype.$addHandlerOnce$ = function(config) {
  var handler = config["handler"];
  var component = $A.$getComponent$(config["globalId"]);
  if(!component) {
    component = Object.create($A.$Component$.prototype, {$globalId$:{value:"1:0"}})
  }
  var def = this.$getEventDef$(config["event"]);
  config["handler"] = $A.$getCallback$(function() {
    this.$removeEventHandler$(component, def, config["handler"], config["phase"]);
    handler()
  }.bind(this));
  this.$addEventHandler$(component, def, config["handler"], config["phase"], config["includeFacets"])
};
goog.$exportProperty$(AuraEventService.prototype, "addHandlerOnce", AuraEventService.prototype.$addHandlerOnce$);
AuraEventService.prototype.$getEventDef$ = function(config) {
  var descConfig = this.$createDescriptorConfig$(config);
  var descriptor = this.$getDescriptorFromConfig$(descConfig);
  var definition = this.$eventDefRegistry$[descriptor];
  if(!definition && this.$savedEventConfigs$[descriptor]) {
    definition = this.$createFromSavedConfigs$(descConfig)
  }
  return definition
};
AuraEventService.prototype.$getDef$ = function(descriptor) {
  $A.assert(descriptor, "No EventDefinition was descriptor specified.");
  var definition = this.$getEventDef$(descriptor);
  if(definition && !$A.$clientService$.$allowAccess$(definition)) {
    var message = "Access Check Failed! EventService.getEventDef():'" + definition.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return undefined
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return definition
};
AuraEventService.prototype.$hasDefinition$ = function(descriptor) {
  var definition = this.$getEventDef$(descriptor);
  if(definition && !$A.$clientService$.$allowAccess$(definition)) {
    var message = "Access Check Failed! EventService.hasDefinition():'" + definition.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return false
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return!!definition
};
AuraEventService.prototype.$createDescriptorConfig$ = function(descriptor) {
  descriptor = typeof descriptor === "string" ? descriptor : descriptor[Json.$ApplicationKey$.$DESCRIPTOR$].toString();
  descriptor = descriptor.indexOf("://") < 0 ? "markup://" + descriptor : descriptor;
  return{"descriptor":descriptor}
};
AuraEventService.prototype.$getDefinition$ = function(descriptor, callback) {
  var descriptorName = descriptor.replace("e.", "");
  var def = this.$getDef$(descriptorName);
  if(def === null || def) {
    callback(def);
    return
  }
  var action = $A.get("c.aura://ComponentController.getEventDef");
  action.$setParams$({"name":descriptorName});
  action.$setCallback$(this, function(actionReponse) {
    var definition = null;
    var state = actionReponse.$getState$();
    if(state === "SUCCESS") {
      definition = this.$getDef$(descriptorName)
    }
    callback(definition)
  });
  $A.$enqueueAction$(action)
};
AuraEventService.prototype.$getDescriptorFromConfig$ = function(descriptorConfig) {
  var descriptor = descriptorConfig && descriptorConfig[Json.$ApplicationKey$.$DESCRIPTOR$];
  $A.assert(descriptor, "Event Descriptor for Config required for registration");
  return descriptor
};
AuraEventService.prototype.$createFromSavedConfigs$ = function(config) {
  var descriptor = config[Json.$ApplicationKey$.$DESCRIPTOR$];
  if(!descriptor && config["getDescriptor"]) {
    descriptor = config.$getDescriptor$()
  }
  var def = new EventDef(this.$savedEventConfigs$[descriptor]);
  this.$eventDefRegistry$[descriptor] = def;
  delete this.$savedEventConfigs$[descriptor];
  return def
};
AuraEventService.prototype.$createEventDef$ = function(config) {
  var descConfig = this.$createDescriptorConfig$(config);
  var descriptor = this.$getDescriptorFromConfig$(descConfig);
  var definition = this.$eventDefRegistry$[descriptor];
  if(!definition) {
    if(this.$savedEventConfigs$[descriptor]) {
      definition = this.$createFromSavedConfigs$(descConfig)
    }else {
      definition = new EventDef(config);
      this.$eventDefRegistry$[descriptor] = definition
    }
  }
  return definition
};
AuraEventService.prototype.$saveEventConfig$ = function(config) {
  $A.assert(config && config[Json.$ApplicationKey$.$DESCRIPTOR$], "Event config required for registration");
  this.$savedEventConfigs$[config[Json.$ApplicationKey$.$DESCRIPTOR$]] = config
};
AuraEventService.prototype.$hasHandlers$ = function(name) {
  var qualifiedName = DefDescriptor.normalize(name);
  var phases = this.$eventDispatcher$[qualifiedName];
  if(phases) {
    for(var phase in phases) {
      if(!$A["util"].$isEmpty$(phases[phase])) {
        return true
      }
    }
  }
  return false
};
goog.$exportProperty$(AuraEventService.prototype, "hasHandlers", AuraEventService.prototype.$hasHandlers$);
AuraEventService.prototype.$getRegisteredEvents$ = function() {
  return Object.keys(this.$eventDefRegistry$)
};
goog.$exportProperty$(AuraEventService.prototype, "getRegisteredEvents", AuraEventService.prototype.$getRegisteredEvents$);
Aura.$Services$.$AuraEventService$ = AuraEventService;
function AuraLocalizationService() {
  this.$numberFormat$ = undefined;
  this.$percentFormat$ = undefined;
  this.$currencyFormat$ = undefined;
  this.ZERO = "0";
  this.$momentLanguages$ = {"iw":"he", "in":"id", "no":"nb"};
  this.$momentLocaleCache$ = {};
  this.$intlLocaleCache$ = {"no":"nb", "no_NO":"nb", "tl_PH":"fil", "sh_BA":"hr", "sh_ME":"hr", "sh_CS":"hr"};
  this.$timeZoneFormatCache$ = {};
  this.$dateTimeFormatCache$ = {};
  this.$localeCache$ = {};
  this.$cache$ = {$format$:{}, $strictModeFormat$:{}};
  this.$dateTimeUnitAlias$ = {};
  this.$timeZoneMap$ = {"US/Alaska":"America/Anchorage", "US/Aleutian":"America/Adak", "US/Arizona":"America/Phoenix", "US/Central":"America/Chicago", "US/East-Indiana":"America/Fort_Wayne", "US/Eastern":"America/New_York", "US/Hawaii":"Pacific/Honolulu", "US/Indiana-Starke":"America/Indiana/Knox", "US/Michigan":"America/Detroit", "US/Mountain":"America/Denver", "US/Pacific":"America/Los_Angeles", "US/Samoa":"Pacific/Pago_Pago", "Pacific-New":"America/Los_Angeles"};
  this.$ISO_REGEX$ = /^\s*((?:\d{4})-(?:\d\d-\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:\.\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  this.$ISO_REGEX_NO_DASH$ = /^\s*((?:\d{4})(?:\d\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:\.\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  this.$ISO_TIME_REGEX$ = /^\s*(\d\d:\d\d(?::\d\d(?:\.\d+)?)?)((?:[\+\-]\d\d(?::?\d\d)?)|(?:\s*Z))?$/;
  this.$ISO_OFFSET_PATTERN$ = /(Z)|([+-]\d\d):?(\d\d)/;
  this.$ISO_DATE_PATTERNS$ = [/(\d{4})-(\d\d)-(\d\d)/, /(\d{4})-(\d\d)/, /(\d{4})(\d\d)(\d\d)/, /(\d{4})/];
  this.$ISO_TIME_PATTERNS$ = [/(\d\d):(\d\d):(\d\d)\.(\d+)/, /(\d\d):(\d\d):(\d\d)/, /(\d\d):(\d\d)/, /(\d\d)(\d\d)(\d\d)\.(\d+)/, /(\d\d)(\d\d)(\d\d)/, /(\d\d)(\d\d)/, /(\d\d)/];
  this.$UNSIGNED_NUMBER$ = /\d+/;
  this.$DIGIT1$ = /\d/;
  this.$DIGIT2$ = /\d\d/;
  this.$DIGIT3$ = /\d{3}/;
  this.$DIGIT4$ = /\d{4}/;
  this.$DIGIT1_2$ = /\d{1,2}/;
  this.$DIGIT1_3$ = /\d{1,3}/;
  this.$DIGIT1_4$ = /\d{1,4}/;
  this.$HOUR_MIN$ = /(\d{1,2})(\d\d)/;
  this.$HOUR_MIN_SEC$ = /(\d{1,2})(\d\d)(\d\d)/;
  this.$enUsDateTimePatterns$ = {$primaryPattern$:{$REG_EXP$:/(\d{1,2})\/(\d{1,2})\/(\d{4})\D+(\d{1,2}):(\d{1,2})/, $MONTH$:1, $DAY$:2, $YEAR$:3, $HOUR$:4, $MINUTE$:5}, $secondaryPattern$:{$REG_EXP$:/(\d{4})-(\d{1,2})-(\d{1,2})\D+(\d{1,2}):(\d{1,2})/, $MONTH$:2, $DAY$:3, $YEAR$:1, $HOUR$:4, $MINUTE$:5}, $swap$:function() {
    var tmp = this.$primaryPattern$;
    this.$primaryPattern$ = this.$secondaryPattern$;
    this.$secondaryPattern$ = tmp
  }}
}
goog.$exportSymbol$("AuraLocalizationService", AuraLocalizationService);
AuraLocalizationService.prototype.$formatNumber$ = function(number) {
  return this.$getDefaultNumberFormat$().$format$(number)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatNumber", AuraLocalizationService.prototype.$formatNumber$);
AuraLocalizationService.prototype.$formatPercent$ = function(number) {
  return this.$getDefaultPercentFormat$().$format$(number)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatPercent", AuraLocalizationService.prototype.$formatPercent$);
AuraLocalizationService.prototype.$formatCurrency$ = function(number) {
  return this.$getDefaultCurrencyFormat$().$format$(number)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatCurrency", AuraLocalizationService.prototype.$formatCurrency$);
AuraLocalizationService.prototype.$getNumberFormat$ = function(format, symbols) {
  return new Aura.$Utils$.$NumberFormat$(format, symbols)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getNumberFormat", AuraLocalizationService.prototype.$getNumberFormat$);
AuraLocalizationService.prototype.$getDefaultNumberFormat$ = function() {
  if(!this.$numberFormat$) {
    this.$numberFormat$ = new Aura.$Utils$.$NumberFormat$($A.get("$Locale.numberFormat"))
  }
  return this.$numberFormat$
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDefaultNumberFormat", AuraLocalizationService.prototype.$getDefaultNumberFormat$);
AuraLocalizationService.prototype.$getDefaultPercentFormat$ = function() {
  if(!this.$percentFormat$) {
    this.$percentFormat$ = new Aura.$Utils$.$NumberFormat$($A.get("$Locale.percentFormat"))
  }
  return this.$percentFormat$
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDefaultPercentFormat", AuraLocalizationService.prototype.$getDefaultPercentFormat$);
AuraLocalizationService.prototype.$getDefaultCurrencyFormat$ = function() {
  if(!this.$currencyFormat$) {
    this.$currencyFormat$ = new Aura.$Utils$.$NumberFormat$($A.get("$Locale.currencyFormat"))
  }
  return this.$currencyFormat$
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDefaultCurrencyFormat", AuraLocalizationService.prototype.$getDefaultCurrencyFormat$);
AuraLocalizationService.prototype.$displayDuration$ = function(duration, withSuffix) {
  if(!this.$isValidDuration$(duration)) {
    return"Invalid Duration"
  }
  return duration.$displayDuration$(withSuffix)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDuration", AuraLocalizationService.prototype.$displayDuration$);
AuraLocalizationService.prototype.$displayDurationInDays$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("day") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInDays", AuraLocalizationService.prototype.$displayDurationInDays$);
AuraLocalizationService.prototype.$displayDurationInHours$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("hour") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInHours", AuraLocalizationService.prototype.$displayDurationInHours$);
AuraLocalizationService.prototype.$displayDurationInMilliseconds$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("millisecond") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInMilliseconds", AuraLocalizationService.prototype.$displayDurationInMilliseconds$);
AuraLocalizationService.prototype.$displayDurationInMinutes$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("minute") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInMinutes", AuraLocalizationService.prototype.$displayDurationInMinutes$);
AuraLocalizationService.prototype.$displayDurationInMonths$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("month") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInMonths", AuraLocalizationService.prototype.$displayDurationInMonths$);
AuraLocalizationService.prototype.$displayDurationInSeconds$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("second") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInSeconds", AuraLocalizationService.prototype.$displayDurationInSeconds$);
AuraLocalizationService.prototype.$displayDurationInYears$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$asUnit$("year") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInYears", AuraLocalizationService.prototype.$displayDurationInYears$);
AuraLocalizationService.prototype.duration = function(num, unit) {
  return new Aura.$Utils$.$Duration$(num, unit, this.$moment$)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "duration", AuraLocalizationService.prototype.duration);
AuraLocalizationService.prototype.$formatDate$ = function(date, formatString, locale) {
  if(this.$moment$["isMoment"](date)) {
    $A.$deprecated$("$A.localizationService.formatDate: 'date' is required to be an ISO 8601 string, or a number, or a Date object. A moment object for the date parameter is not supported.", null, "AuraLocalizationService.formatDate(moment)");
    date = date["toDate"]()
  }
  return this.$formatDateTimeInternal$(date, formatString || $A.get("$Locale.dateFormat"), locale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDate", AuraLocalizationService.prototype.$formatDate$);
AuraLocalizationService.prototype.$formatTime$ = function(date, formatString, locale) {
  if(this.$moment$["isMoment"](date)) {
    $A.$deprecated$("$A.localizationService.formatTime: 'date' is required to be an ISO 8601 string, or a number, or a Date object. A moment object for the date parameter is not supported.", null, "AuraLocalizationService.formatTime(moment)");
    date = date["toDate"]()
  }
  return this.$formatDateTimeInternal$(date, formatString || $A.get("$Locale.timeFormat"), locale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatTime", AuraLocalizationService.prototype.$formatTime$);
AuraLocalizationService.prototype.$formatDateTimeInternal$ = function(date, formatString, locale) {
  if(typeof date === "string") {
    date = this.$parseDateTimeISO8601$(date)
  }else {
    date = this.$normalizeDateTimeInput$(date)
  }
  if(!this.$isValidDateObject$(date)) {
    return"Invalid Date"
  }
  if(!locale) {
    locale = $A.get("$Locale.datetimeLocale")
  }
  return this.$formatDateTimeToString$(date, formatString, locale, false)
};
AuraLocalizationService.prototype.$formatDateTime$ = function(date, formatString, locale) {
  if(this.$moment$["isMoment"](date)) {
    $A.$deprecated$("$A.localizationService.formatDateTime: 'date' is required to be an ISO 8601 string, or a number, or a Date object. A moment object for the date parameter is not supported.", null, "AuraLocalizationService.formatDateTime(moment)");
    date = date["toDate"]()
  }
  return this.$formatDateTimeInternal$(date, formatString || $A.get("$Locale.datetimeFormat"), locale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDateTime", AuraLocalizationService.prototype.$formatDateTime$);
AuraLocalizationService.prototype.$formatDateUTC$ = function(date, formatString, locale) {
  if(this.$moment$["isMoment"](date)) {
    $A.$deprecated$("$A.localizationService.formatDateUTC: 'date' is required to be an ISO 8601 string, or a number, or a Date object. A moment object for the date parameter is not supported.", null, "AuraLocalizationService.formatDateUTC(moment)");
    date = date["toDate"]()
  }
  return this.$formatDateTimeUTCInternal$(date, formatString || $A.get("$Locale.dateFormat"), locale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDateUTC", AuraLocalizationService.prototype.$formatDateUTC$);
AuraLocalizationService.prototype.$formatTimeUTC$ = function(date, formatString, locale) {
  if(this.$moment$["isMoment"](date)) {
    $A.$deprecated$("$A.localizationService.formatTimeUTC: 'date' is required to be an ISO 8601 string, or a number, or a Date object. A moment object for the date parameter is not supported.", null, "AuraLocalizationService.formatTimeUTC(moment)");
    date = date["toDate"]()
  }
  return this.$formatDateTimeUTCInternal$(date, formatString || $A.get("$Locale.timeFormat"), locale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatTimeUTC", AuraLocalizationService.prototype.$formatTimeUTC$);
AuraLocalizationService.prototype.$formatDateTimeUTCInternal$ = function(date, formatString, locale) {
  if(typeof date === "string") {
    var config = this.$parseISOStringToConfig$(date);
    if(config === null) {
      return"Invalid Date"
    }
    var minute = config["minute"];
    if(config["utcOffset"] !== undefined) {
      minute -= config["utcOffset"]
    }
    date = new Date(config["year"], config["month"] - 1, config["day"], config["hour"], minute, config["second"], config["millisecond"])
  }else {
    date = this.$normalizeDateTimeInput$(date);
    date = new Date(date.valueOf());
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset())
  }
  if(!this.$isValidDateObject$(date)) {
    return"Invalid Date"
  }
  if(!locale) {
    locale = $A.get("$Locale.datetimeLocale")
  }
  return this.$formatDateTimeToString$(date, formatString, locale, true)
};
AuraLocalizationService.prototype.$formatDateTimeUTC$ = function(date, formatString, locale) {
  if(this.$moment$["isMoment"](date)) {
    $A.$deprecated$("$A.localizationService.formatDateTimeUTC: 'date' is required to be an ISO 8601 string, or a number, or a Date object. A moment object for the date parameter is not supported.", null, "AuraLocalizationService.formatDateTimeUTC(moment)");
    date = date["toDate"]()
  }
  return this.$formatDateTimeUTCInternal$(date, formatString || $A.get("$Locale.datetimeFormat"), locale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDateTimeUTC", AuraLocalizationService.prototype.$formatDateTimeUTC$);
AuraLocalizationService.prototype.$getDaysInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("day") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDaysInDuration", AuraLocalizationService.prototype.$getDaysInDuration$);
AuraLocalizationService.prototype.$getHoursInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("hour") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getHoursInDuration", AuraLocalizationService.prototype.$getHoursInDuration$);
AuraLocalizationService.prototype.$getMillisecondsInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("millisecond") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getMillisecondsInDuration", AuraLocalizationService.prototype.$getMillisecondsInDuration$);
AuraLocalizationService.prototype.$getMinutesInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("minute") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getMinutesInDuration", AuraLocalizationService.prototype.$getMinutesInDuration$);
AuraLocalizationService.prototype.$getMonthsInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("month") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getMonthsInDuration", AuraLocalizationService.prototype.$getMonthsInDuration$);
AuraLocalizationService.prototype.$getSecondsInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("second") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getSecondsInDuration", AuraLocalizationService.prototype.$getSecondsInDuration$);
AuraLocalizationService.prototype.$getYearsInDuration$ = function(duration) {
  if(!this.$isValidDuration$(duration)) {
    return 0
  }
  return duration.$getUnit$("year") || 0
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getYearsInDuration", AuraLocalizationService.prototype.$getYearsInDuration$);
AuraLocalizationService.prototype.$getLocalizedDateTimeLabels$ = function() {
  $A.$deprecated$("$A.localizationService.getLocalizedDateTimeLabels(): The labels from this method are no longer supported. This method will be removed in an upcoming release.", null, "AuraLocalizationService.getLocalizedDateTimeLabels");
  var datetimeLocale = $A.get("$Locale.datetimeLocale");
  return this.$moment$["localeData"](this.$getAvailableMomentLocale$(datetimeLocale))
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getLocalizedDateTimeLabels", AuraLocalizationService.prototype.$getLocalizedDateTimeLabels$);
AuraLocalizationService.prototype.$getToday$ = function(timezone, callback) {
  this.$getDateStringBasedOnTimezone$(timezone, new Date, callback)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getToday", AuraLocalizationService.prototype.$getToday$);
AuraLocalizationService.prototype.$getDateStringBasedOnTimezone$ = function(timeZone, date, callback) {
  $A.assert(date instanceof Date, "AuraLocalizationService.getDateStringBasedOnTimezone(): 'date' must be a Date object.");
  $A.assert(typeof callback === "function", "AuraLocalizationService.getDateStringBasedOnTimezone(): 'callback' must be a function.");
  if(!this.$isValidDateObject$(date)) {
    callback("Invalid Date");
    return
  }
  timeZone = this.$normalizeTimeZone$(timeZone);
  var dateTimeString = this.$formatDateToEnUSString$(date, timeZone);
  var match = this.$enUsDateTimePatterns$.$primaryPattern$.$REG_EXP$.exec(dateTimeString);
  if(match === null) {
    match = this.$enUsDateTimePatterns$.$secondaryPattern$.$REG_EXP$.exec(dateTimeString);
    if(match === null) {
      callback(null);
      return
    }
    this.$enUsDateTimePatterns$.$swap$()
  }
  callback(match[this.$enUsDateTimePatterns$.$primaryPattern$.$YEAR$] + "-" + match[this.$enUsDateTimePatterns$.$primaryPattern$.$MONTH$] + "-" + match[this.$enUsDateTimePatterns$.$primaryPattern$.$DAY$])
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDateStringBasedOnTimezone", AuraLocalizationService.prototype.$getDateStringBasedOnTimezone$);
AuraLocalizationService.prototype.$isPeriodTimeView$ = function(pattern) {
  $A.$deprecated$("$A.localizationService.isPeriodTimeView(): The method is no longer supported by framework, and will be removed in an upcoming release.", null, "AuraLocalizationService.isPeriodTimeView");
  if(typeof pattern !== "string") {
    return false
  }
  var shouldEscape = false;
  for(var i = 0;i < pattern.length;i++) {
    var c = pattern.charAt(i);
    if(c === "h" && shouldEscape === false) {
      return true
    }
    if(c === "[") {
      shouldEscape = true
    }else {
      if(c === "]") {
        shouldEscape = false
      }
    }
  }
  return false
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isPeriodTimeView", AuraLocalizationService.prototype.$isPeriodTimeView$);
AuraLocalizationService.prototype.$isAfter$ = function(date1, date2, unit) {
  var normalizedDate1 = this.$normalizeDateTimeInput$(date1);
  var normalizedDate2 = this.$normalizeDateTimeInput$(date2);
  if(!this.$isValidDateObject$(normalizedDate1) || !this.$isValidDateObject$(normalizedDate2)) {
    return false
  }
  unit = this.$normalizeDateTimeUnit$(unit) || "millisecond";
  if(unit === "millisecond") {
    return normalizedDate1.getTime() > normalizedDate2.getTime()
  }else {
    return this.$startOf$(normalizedDate1, unit).getTime() > this.$startOf$(normalizedDate2, unit).getTime()
  }
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isAfter", AuraLocalizationService.prototype.$isAfter$);
AuraLocalizationService.prototype.$isBefore$ = function(date1, date2, unit) {
  var normalizedDate1 = this.$normalizeDateTimeInput$(date1);
  var normalizedDate2 = this.$normalizeDateTimeInput$(date2);
  if(!this.$isValidDateObject$(normalizedDate1) || !this.$isValidDateObject$(normalizedDate2)) {
    return false
  }
  unit = this.$normalizeDateTimeUnit$(unit) || "millisecond";
  if(unit === "millisecond") {
    return normalizedDate1.getTime() < normalizedDate2.getTime()
  }else {
    return this.$startOf$(normalizedDate1, unit).getTime() < this.$startOf$(normalizedDate2, unit).getTime()
  }
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isBefore", AuraLocalizationService.prototype.$isBefore$);
AuraLocalizationService.prototype.$isSame$ = function(date1, date2, unit) {
  var normalizedDate1 = this.$normalizeDateTimeInput$(date1);
  var normalizedDate2 = this.$normalizeDateTimeInput$(date2);
  if(!this.$isValidDateObject$(normalizedDate1) || !this.$isValidDateObject$(normalizedDate2)) {
    return false
  }
  unit = this.$normalizeDateTimeUnit$(unit) || "millisecond";
  if(unit === "millisecond") {
    return normalizedDate1.getTime() === normalizedDate2.getTime()
  }else {
    return this.$startOf$(normalizedDate1, unit).getTime() === this.$startOf$(normalizedDate2, unit).getTime()
  }
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isSame", AuraLocalizationService.prototype.$isSame$);
AuraLocalizationService.prototype.$isBetween$ = function(date, fromDate, toDate, unit) {
  return!this.$isBefore$(date, fromDate, unit) && !this.$isAfter$(date, toDate, unit)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isBetween", AuraLocalizationService.prototype.$isBetween$);
AuraLocalizationService.prototype.$parseDateTime$ = function(dateTimeString, parseFormat, locale, strictParsing) {
  if(!dateTimeString) {
    return null
  }
  var datetimeLocale = locale;
  if(typeof locale === "boolean") {
    strictParsing = locale;
    datetimeLocale = $A.get("$Locale.datetimeLocale")
  }else {
    if(locale !== undefined || strictParsing !== undefined) {
      $A.$deprecated$("$A.localizationService.parseDateTime(dateTimeString, parseFormat, locale, strictParsing) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.parseDateTime(dateTimeString, parseFormat, strictParsing)");
      if(locale && !this.$isAvailableLocale$(locale)) {
        datetimeLocale = $A.get("$Locale.datetimeLocale");
        $A.$warning$("AuraLocalizationService.parseDateTime(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.datetimeLocale: " + datetimeLocale)
      }
    }
  }
  if(!datetimeLocale) {
    datetimeLocale = $A.get("$Locale.datetimeLocale")
  }
  var format = strictParsing ? this.$getStrictModeFormat$(parseFormat) : this.$getNormalizedFormat$(parseFormat);
  var value = strictParsing ? this.$getStrictModeDateTimeString$(dateTimeString) : dateTimeString;
  var mDate = this.$moment$(value, format, this.$getAvailableMomentLocale$(datetimeLocale), strictParsing);
  if(!mDate || !mDate["isValid"]()) {
    if($A["util"].$isUndefinedOrNull$(parseFormat)) {
      return null
    }
    datetimeLocale = typeof locale === "string" ? locale : $A.get("$Locale.datetimeLocale");
    var dateTimeFormat = this.$createDateTimeFormat$(parseFormat, datetimeLocale);
    return dateTimeFormat.parse(dateTimeString, strictParsing)
  }
  return mDate["toDate"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "parseDateTime", AuraLocalizationService.prototype.$parseDateTime$);
AuraLocalizationService.prototype.$parseDateTimeISO8601$ = function(dateTimeString) {
  if(!dateTimeString) {
    return null
  }
  var date = null;
  if(this.$isISO8601DateTimeString$(dateTimeString)) {
    var config = this.$parseISOStringToConfig$(dateTimeString);
    if(config === null) {
      return null
    }
    if(config["utcOffset"] !== undefined) {
      var minute = config["minute"] - config["utcOffset"];
      date = new Date(Date.UTC(config["year"], config["month"] - 1, config["day"], config["hour"], minute, config["second"], config["millisecond"]))
    }else {
      date = new Date(config["year"], config["month"] - 1, config["day"], config["hour"], config["minute"], config["second"], config["millisecond"])
    }
  }else {
    $A.$warning$("LocalizationService.parseDateTimeISO8601: The provided datetime string is not in ISO8601 format. " + "It will be parsed by native Date(), which may have different results across browsers and versions. " + dateTimeString);
    date = new Date(dateTimeString)
  }
  return this.$isValidDateObject$(date) ? date : null
};
goog.$exportProperty$(AuraLocalizationService.prototype, "parseDateTimeISO8601", AuraLocalizationService.prototype.$parseDateTimeISO8601$);
AuraLocalizationService.prototype.$parseDateTimeUTC$ = function(dateTimeString, parseFormat, locale, strictParsing) {
  if(!dateTimeString) {
    return null
  }
  var datetimeLocale = locale;
  if(typeof locale === "boolean") {
    strictParsing = locale;
    datetimeLocale = $A.get("$Locale.datetimeLocale")
  }else {
    if(locale !== undefined || strictParsing !== undefined) {
      $A.$deprecated$("$A.localizationService.parseDateTimeUTC(dateTimeString, parseFormat, locale, strictParsing) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.parseDateTimeUTC(dateTimeString, parseFormat, strictParsing)");
      if(locale && !this.$isAvailableLocale$(locale)) {
        datetimeLocale = $A.get("$Locale.datetimeLocale");
        $A.$warning$("AuraLocalizationService.parseDateTimeUTC(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.datetimeLocale: " + datetimeLocale)
      }
    }
  }
  if(!datetimeLocale) {
    datetimeLocale = $A.get("$Locale.datetimeLocale")
  }
  var format = strictParsing ? this.$getStrictModeFormat$(parseFormat) : this.$getNormalizedFormat$(parseFormat);
  var value = strictParsing ? this.$getStrictModeDateTimeString$(dateTimeString) : dateTimeString;
  var mDate = this.$moment$["utc"](value, format, this.$getAvailableMomentLocale$(datetimeLocale), strictParsing);
  if(!mDate || !mDate["isValid"]()) {
    if($A["util"].$isUndefinedOrNull$(parseFormat)) {
      return null
    }
    datetimeLocale = typeof locale === "string" ? locale : $A.get("$Locale.datetimeLocale");
    var dateTimeFormat = this.$createDateTimeFormat$(parseFormat, datetimeLocale);
    return dateTimeFormat.parse(dateTimeString, strictParsing, true)
  }
  return mDate["toDate"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "parseDateTimeUTC", AuraLocalizationService.prototype.$parseDateTimeUTC$);
AuraLocalizationService.prototype.$startOf$ = function(date, unit) {
  var normalizedDate = date instanceof Date ? new Date(date.getTime()) : this.$normalizeDateTimeInput$(date);
  unit = this.$normalizeDateTimeUnit$(unit);
  if(!unit || !this.$isValidDateObject$(normalizedDate)) {
    return normalizedDate
  }
  switch(unit) {
    case "year":
      normalizedDate.setMonth(0);
    case "month":
      normalizedDate.setDate(1);
    case "week":
    ;
    case "day":
      normalizedDate.setHours(0);
    case "hour":
      normalizedDate.setMinutes(0);
    case "minute":
      normalizedDate.setSeconds(0);
    case "second":
      normalizedDate.setMilliseconds(0)
  }
  if(unit === "week") {
    var firstDayOfWeek = $A.get("$Locale.firstDayOfWeek") - 1;
    var weekday = (normalizedDate.getDay() + 7 - firstDayOfWeek) % 7;
    var offset = weekday * 864E5;
    normalizedDate.setTime(normalizedDate.getTime() - offset)
  }
  return normalizedDate
};
goog.$exportProperty$(AuraLocalizationService.prototype, "startOf", AuraLocalizationService.prototype.$startOf$);
AuraLocalizationService.prototype.$endOf$ = function(date, unit) {
  var normalizedDate = this.$startOf$(date, unit);
  unit = this.$normalizeDateTimeUnit$(unit);
  if(!unit || !this.$isValidDateObject$(normalizedDate)) {
    return normalizedDate
  }
  this.$addSubtract$(normalizedDate, 1, unit, false);
  this.$addSubtract$(normalizedDate, 1, "millisecond", true);
  return normalizedDate
};
goog.$exportProperty$(AuraLocalizationService.prototype, "endOf", AuraLocalizationService.prototype.$endOf$);
AuraLocalizationService.prototype.toISOString = function(date) {
  $A.$deprecated$("$A.localizationService.toISOString(): The method is no longer supported by framework, and will be removed in an upcoming release.", "Use native method Date.toISOString() instead", "AuraLocalizationService.toISOString");
  return this.$isValidDateObject$(date) ? date.toISOString() : date
};
goog.$exportProperty$(AuraLocalizationService.prototype, "toISOString", AuraLocalizationService.prototype.toISOString);
AuraLocalizationService.prototype.$translateFromLocalizedDigits$ = function(input) {
  if(!input) {
    return input
  }
  var localizedZero = $A.get("$Locale.zero");
  var zeroCharCodeOffset = localizedZero.charCodeAt(0) - this.ZERO.charCodeAt(0);
  if(!zeroCharCodeOffset) {
    return input
  }
  var charArray = input.split("");
  for(var i = 0;i < charArray.length;i++) {
    var charCode = charArray[i].charCodeAt(0);
    if(charCode <= localizedZero.charCodeAt(0) + 9 && charCode >= localizedZero.charCodeAt(0)) {
      charArray[i] = String.fromCharCode(charCode - zeroCharCodeOffset)
    }
  }
  return charArray.join("")
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateFromLocalizedDigits", AuraLocalizationService.prototype.$translateFromLocalizedDigits$);
AuraLocalizationService.prototype.$translateFromOtherCalendar$ = function(date) {
  if(!date) {
    return date
  }
  var userLocaleLang = $A.get("$Locale.userLocaleLang");
  var userLocaleCountry = $A.get("$Locale.userLocaleCountry");
  if(userLocaleLang === "th" && userLocaleCountry === "TH") {
    date.setFullYear(date.getFullYear() - 543)
  }
  return date
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateFromOtherCalendar", AuraLocalizationService.prototype.$translateFromOtherCalendar$);
AuraLocalizationService.prototype.$translateToLocalizedDigits$ = function(input) {
  if(!input) {
    return input
  }
  var localizedZero = $A.get("$Locale.zero");
  var zeroCharCodeOffset = localizedZero.charCodeAt(0) - this.ZERO.charCodeAt(0);
  if(!zeroCharCodeOffset) {
    return input
  }
  var charArray = input.split("");
  for(var i = 0;i < charArray.length;i++) {
    var charCode = charArray[i].charCodeAt(0);
    if(charCode <= "9".charCodeAt(0) && charCode >= "0".charCodeAt(0)) {
      charArray[i] = String.fromCharCode(charCode + zeroCharCodeOffset)
    }
  }
  return charArray.join("")
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateToLocalizedDigits", AuraLocalizationService.prototype.$translateToLocalizedDigits$);
AuraLocalizationService.prototype.$translateToOtherCalendar$ = function(date) {
  if(!date) {
    return date
  }
  var userLocaleLang = $A.get("$Locale.userLocaleLang");
  var userLocaleCountry = $A.get("$Locale.userLocaleCountry");
  if(userLocaleLang === "th" && userLocaleCountry === "TH") {
    date.setFullYear(date.getFullYear() + 543)
  }
  return date
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateToOtherCalendar", AuraLocalizationService.prototype.$translateToOtherCalendar$);
AuraLocalizationService.prototype.$UTCToWallTime$ = function(date, timezone, callback) {
  $A.assert(date instanceof Date, "AuraLocalizationService.UTCToWallTime(): 'date' must be a Date object.");
  $A.assert(typeof callback === "function", "AuraLocalizationService.UTCToWallTime(): 'callback' must be a function.");
  timezone = this.$normalizeTimeZone$(timezone);
  if(timezone === "UTC" || !this.$isValidDateObject$(date)) {
    callback(date);
    return
  }
  var data = this.$createDateTimeData$(date, "UTC");
  var convertedData = this.$setDataToZone$(data, timezone);
  var dateTime = convertedData["config"];
  var ts = Date.UTC(dateTime["year"], dateTime["month"] - 1, dateTime["day"], dateTime["hour"], dateTime["minute"]);
  var wallTimeDate = new Date(ts);
  wallTimeDate.setSeconds(date.getSeconds());
  wallTimeDate.setMilliseconds(date.getMilliseconds());
  callback(wallTimeDate)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "UTCToWallTime", AuraLocalizationService.prototype.$UTCToWallTime$);
AuraLocalizationService.prototype.$WallTimeToUTC$ = function(date, timezone, callback) {
  $A.assert(date instanceof Date, "AuraLocalizationService.WallTimeToUTC(): 'date' must be a Date object.");
  $A.assert(typeof callback === "function", "AuraLocalizationService.WallTimeToUTC(): callback must be a function.");
  timezone = this.$normalizeTimeZone$(timezone);
  if(timezone === "UTC" || !this.$isValidDateObject$(date)) {
    callback(date);
    return
  }
  var data = this.$createDateTimeData$(date, timezone);
  var convertedData = this.$setDataToZone$(data, "UTC");
  var dateTime = convertedData["config"];
  var ts = Date.UTC(dateTime["year"], dateTime["month"] - 1, dateTime["day"], dateTime["hour"], dateTime["minute"]);
  var utcDate = new Date(ts);
  utcDate.setUTCSeconds(date.getSeconds(), date.getMilliseconds());
  callback(utcDate)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "WallTimeToUTC", AuraLocalizationService.prototype.$WallTimeToUTC$);
AuraLocalizationService.prototype.$init$ = function() {
  if(Aura["moment"] === undefined) {
    $A.$warning$("moment is required to initialize Localization Service.");
    return
  }
  if(Aura["loadLocaleData"]) {
    Aura["loadLocaleData"](Aura["moment"]);
    Aura["loadLocaleData"] = undefined
  }
  this.$moment$ = Aura["moment"];
  var langLocale = $A.get("$Locale.langLocale");
  var userLocale = $A.get("$Locale.userLocaleLang") + "_" + $A.get("$Locale.userLocaleCountry");
  var ltngLocale = $A.get("$Locale.language") + "_" + $A.get("$Locale.userLocaleCountry");
  var datetimeLocale = $A.get("$Locale.datetimeLocale");
  this.$momentLocaleCache$[langLocale] = this.$normalizeToMomentLocale$(langLocale);
  this.$momentLocaleCache$[userLocale] = this.$normalizeToMomentLocale$(userLocale);
  this.$momentLocaleCache$[ltngLocale] = this.$normalizeToMomentLocale$(ltngLocale);
  this.$momentLocaleCache$[datetimeLocale] = this.$normalizeToMomentLocale$(datetimeLocale);
  this.$moment$.locale(this.$momentLocaleCache$[datetimeLocale]);
  this.$setupDateTimeUnitAlias$()
};
AuraLocalizationService.prototype.$normalizeTimeZone$ = function(timeZone) {
  var normalizedTimeZone = timeZone;
  if(!timeZone) {
    normalizedTimeZone = $A.get("$Locale.timezone")
  }
  if(normalizedTimeZone === "GMT" || normalizedTimeZone === "UTC") {
    return"UTC"
  }
  if(this.$timeZoneMap$.hasOwnProperty(normalizedTimeZone)) {
    return this.$timeZoneMap$[normalizedTimeZone]
  }
  var timeZoneFormat = this.$createEnUSDateTimeFormat$(normalizedTimeZone);
  if(timeZoneFormat !== null) {
    return normalizedTimeZone
  }
  if(timeZone) {
    normalizedTimeZone = $A.get("$Locale.timezone");
    $A.$warning$("Unsupported time zone: " + timeZone + ". Fallback to default time zone: " + normalizedTimeZone);
    if(normalizedTimeZone === "GMT" || normalizedTimeZone === "UTC") {
      this.$timeZoneMap$[timeZone] = "UTC";
      return"UTC"
    }
    timeZoneFormat = this.$createEnUSDateTimeFormat$(normalizedTimeZone);
    if(timeZoneFormat !== null) {
      this.$timeZoneMap$[timeZone] = normalizedTimeZone;
      return normalizedTimeZone
    }
  }else {
    timeZone = normalizedTimeZone
  }
  var message = "Unsupported time zone value in GVP: " + normalizedTimeZone;
  $A.$warning$(message);
  $A.$logger$.$reportError$(new $A.$auraError$(message), undefined, "WARNING");
  this.$timeZoneMap$[timeZone] = "UTC";
  return"UTC"
};
AuraLocalizationService.prototype.$createDateTimeData$ = function(date, timeZone) {
  var config = {"year":date.getUTCFullYear(), "month":date.getUTCMonth() + 1, "day":date.getUTCDate(), "hour":date.getUTCHours(), "minute":date.getUTCMinutes()};
  var zoneInfo = this.$getZoneInfo$(config, timeZone);
  return{"config":config, "offset":zoneInfo[1], "timestamp":zoneInfo[0], "timeZone":timeZone}
};
AuraLocalizationService.prototype.$setDataToZone$ = function(data, timeZone) {
  var timestamp = data["timestamp"];
  var offset = this.$zoneOffset$(timestamp, timeZone);
  timestamp += offset * 6E4;
  var date = new Date(timestamp);
  var config = {"year":date.getUTCFullYear(), "month":date.getUTCMonth() + 1, "day":date.getUTCDate(), "hour":date.getUTCHours(), "minute":date.getUTCMinutes()};
  return{"timestamp":timestamp, "config":config, "timeZone":timeZone, "offset":offset}
};
AuraLocalizationService.prototype.$getZoneInfo$ = function(config, timeZone) {
  var nowOffset = this.$zoneOffset$(Date.now(), timeZone);
  var localTs = Date.UTC(config["year"], config["month"] - 1, config["day"], config["hour"], config["minute"]);
  var utcGuess = localTs - nowOffset * 6E4;
  var guessOffset = this.$zoneOffset$(utcGuess, timeZone);
  if(nowOffset === guessOffset) {
    return[utcGuess, guessOffset]
  }
  utcGuess -= (guessOffset - nowOffset) * 6E4;
  var guessOffset2 = this.$zoneOffset$(utcGuess, timeZone);
  if(guessOffset === guessOffset2) {
    return[utcGuess, guessOffset]
  }
  return[localTs - Math.max(guessOffset, guessOffset2) * 6E4, Math.max(guessOffset, guessOffset2)]
};
AuraLocalizationService.prototype.$zoneOffset$ = function(timestamp, timeZone) {
  if(timeZone === "UTC") {
    return 0
  }
  var date = new Date(timestamp);
  date.setSeconds(0, 0);
  var dateTimeString = this.$formatDateToEnUSString$(date, timeZone);
  var zoneTs = this.$parseEnUSDateTimeString$(dateTimeString);
  return(zoneTs - date.getTime()) / 6E4
};
AuraLocalizationService.prototype.$formatDateToEnUSString$ = function(date, timeZone) {
  var timeZoneFormat = this.$createEnUSDateTimeFormat$(timeZone);
  var dateString = timeZoneFormat ? this.$format$(timeZoneFormat, date) : null;
  return dateString !== null ? dateString : this.$formatDateTime$(date, "MM/dd/yyyy, hh:mm")
};
AuraLocalizationService.prototype.$parseEnUSDateTimeString$ = function(dateTimeString) {
  var match = this.$enUsDateTimePatterns$.$primaryPattern$.$REG_EXP$.exec(dateTimeString);
  if(match === null) {
    match = this.$enUsDateTimePatterns$.$secondaryPattern$.$REG_EXP$.exec(dateTimeString);
    if(match === null) {
      return null
    }
    this.$enUsDateTimePatterns$.$swap$()
  }
  return Date.UTC(parseInt(match[this.$enUsDateTimePatterns$.$primaryPattern$.$YEAR$], 10), parseInt(match[this.$enUsDateTimePatterns$.$primaryPattern$.$MONTH$], 10) - 1, parseInt(match[this.$enUsDateTimePatterns$.$primaryPattern$.$DAY$], 10), parseInt(match[this.$enUsDateTimePatterns$.$primaryPattern$.$HOUR$], 10), parseInt(match[this.$enUsDateTimePatterns$.$primaryPattern$.$MINUTE$], 10))
};
AuraLocalizationService.prototype.$format$ = function(dateTimeFormat, date) {
  if(this.$formatErrorFromIntl$) {
    return null
  }
  try {
    return dateTimeFormat["format"](date).replace(/[\u200E\u200F]/g, "")
  }catch(e) {
    $A.$warning$("Intl API throws an unexpected error.", e);
    this.$formatErrorFromIntl$ = true;
    return null
  }
};
AuraLocalizationService.prototype.$createEnUSDateTimeFormat$ = function(timeZone) {
  var timeZoneFormat = this.$timeZoneFormatCache$[timeZone];
  if(timeZoneFormat !== undefined) {
    return timeZoneFormat
  }
  try {
    var testDateTime = Intl["DateTimeFormat"]("en-US", {"hour12":false, "timeZone":"America/New_York", "year":"numeric", "month":"2-digit", "day":"2-digit", "hour":"2-digit", "minute":"2-digit", "second":"2-digit"});
    var testDateTimeFormatted = testDateTime["format"](new Date("2014-06-25T04:00:00.123Z"));
    if(testDateTimeFormatted === "06/25/2014, 00:00:00" || testDateTimeFormatted === "\u200e06\u200e/\u200e25\u200e/\u200e2014\u200e \u200e00\u200e:\u200e00\u200e:\u200e00") {
      timeZoneFormat = Intl["DateTimeFormat"]("en-US", {"hour12":false, "timeZone":timeZone, "year":"numeric", "month":"2-digit", "day":"2-digit", "hour":"2-digit", "minute":"2-digit", "second":"2-digit"})
    }else {
      timeZoneFormat = Intl["DateTimeFormat"]("en-US", {"hourCycle":"h23", "timeZone":timeZone, "year":"numeric", "month":"2-digit", "day":"2-digit", "hour":"2-digit", "minute":"2-digit", "second":"2-digit"})
    }
  }catch(e) {
    timeZoneFormat = null
  }
  this.$timeZoneFormatCache$[timeZone] = timeZoneFormat;
  return timeZoneFormat
};
AuraLocalizationService.prototype.$createDateTimeFormat$ = function(formatString, localeName) {
  localeName = this.$normalizeToIntlLocale$(localeName);
  var singleQuoteMatches = formatString.match(/'.*?'/g);
  if(singleQuoteMatches) {
    for(var i = 0;i < singleQuoteMatches.length;i++) {
      formatString = formatString.replace(singleQuoteMatches[i], "[" + singleQuoteMatches[i].slice(1, -1) + "]")
    }
  }
  var cacheKey = localeName + ":" + formatString;
  var dateTimeFormat = this.$dateTimeFormatCache$[cacheKey];
  if(dateTimeFormat === undefined) {
    var locale = this.$createLocale$(localeName);
    dateTimeFormat = new Aura.$Utils$.$DateTimeFormat$(formatString, locale);
    this.$dateTimeFormatCache$[cacheKey] = dateTimeFormat
  }
  return dateTimeFormat
};
AuraLocalizationService.prototype.$createLocale$ = function(localeName) {
  var locale = this.$localeCache$[localeName];
  if(locale === undefined) {
    locale = new Aura.$Utils$.$Locale$(localeName);
    this.$localeCache$[localeName] = locale
  }
  return locale
};
AuraLocalizationService.prototype.$normalizeToMomentLocale$ = function(locale) {
  if(!locale) {
    return locale
  }
  var locales = this.$moment$["locales"]();
  var momentLocale;
  var normalized = this.$normalizeLocale$(locale);
  var tokens = normalized.split("-", 2);
  if(this.$momentLanguages$[tokens[0]]) {
    tokens[0] = this.$momentLanguages$[tokens[0]]
  }
  if(tokens.length > 1) {
    momentLocale = tokens.join("-");
    if(locales.indexOf(momentLocale) > -1) {
      return momentLocale
    }
  }
  momentLocale = tokens[0];
  if(locales.indexOf(momentLocale) > -1) {
    return momentLocale
  }
  return"en"
};
AuraLocalizationService.prototype.$normalizeLocale$ = function(locale) {
  return locale ? locale.toLowerCase().replace("_", "-") : locale
};
AuraLocalizationService.prototype.$getAvailableMomentLocale$ = function(locale) {
  var momentLocale = this.$momentLocaleCache$[locale];
  return momentLocale ? momentLocale : "en"
};
AuraLocalizationService.prototype.$isAvailableLocale$ = function(locale) {
  if(!locale) {
    return false
  }
  if(this.$momentLocaleCache$.hasOwnProperty(locale)) {
    return true
  }
  var momentLocale = this.$normalizeToMomentLocale$(locale);
  var language = this.$normalizeLocale$(locale).split("-")[0];
  if(momentLocale === "en" && language !== "en") {
    return false
  }else {
    this.$momentLocaleCache$[locale] = momentLocale;
    return true
  }
};
AuraLocalizationService.prototype.$formatDateTimeToString$ = function(date, formatString, locale, isUTCDate) {
  var dateTimeFormat = this.$createDateTimeFormat$(formatString, locale);
  var utcOffset = isUTCDate === true ? 0 : date.getTimezoneOffset() * -1;
  return dateTimeFormat["format"](date, utcOffset)
};
AuraLocalizationService.prototype.$canFormatToParts$ = function() {
  if(this.$supportFormatToParts$ === undefined) {
    var dateTimeFormat = new Intl["DateTimeFormat"];
    if(dateTimeFormat["formatToParts"] === undefined) {
      this.$supportFormatToParts$ = false
    }else {
      try {
        dateTimeFormat["formatToParts"](new Date);
        this.$supportFormatToParts$ = true
      }catch(e) {
        $A.log("The browser does not support Intl.DateTimeFormat.formatToParts", e);
        this.$supportFormatToParts$ = false
      }
    }
  }
  return this.$supportFormatToParts$
};
AuraLocalizationService.prototype.$normalizeToIntlLocale$ = function(locale) {
  var intlLocale = this.$intlLocaleCache$[locale];
  if(intlLocale === undefined) {
    intlLocale = locale.replace("_", "-").replace(/[-_](EURO|STROKE|PINYIN|SLE|UZ|USD)/, "");
    var supported = Intl["DateTimeFormat"]["supportedLocalesOf"](intlLocale);
    if(supported.length === 0) {
      $A.$warning$("LocalizationService: Unknown locale: " + locale + ". Falls back to 'en-US'.");
      intlLocale = "en-US"
    }else {
      intlLocale = supported[0]
    }
    this.$intlLocaleCache$[locale] = intlLocale
  }
  return intlLocale
};
AuraLocalizationService.prototype.$getLocalizedDateTimeField$ = function(date, dateTimeFormat, field) {
  var parts = dateTimeFormat["formatToParts"](date);
  return this.$findField$(parts, field) || ""
};
AuraLocalizationService.prototype.$findField$ = function(parts, type) {
  for(var i = 0;i < parts.length;i++) {
    var part = parts[i];
    if(type && part["type"] && part["type"].toLowerCase() === type.toLowerCase()) {
      return part["value"]
    }
  }
  return null
};
AuraLocalizationService.prototype.$getNormalizedFormat$ = function(format) {
  if(format) {
    if(!this.$cache$.$format$[format]) {
      var normalizedFormat = format.replace(/y/g, "Y").replace(/(\b|[^Y])Y(?!Y)/g, "$1YYYY").replace(/d/g, "D").replace(/E/g, "d").replace(/a/g, "A");
      this.$cache$.$format$[format] = normalizedFormat
    }
    return this.$cache$.$format$[format]
  }
  return format
};
AuraLocalizationService.prototype.$getStrictModeFormat$ = function(format) {
  if(format) {
    if(!this.$cache$.$strictModeFormat$[format]) {
      var normalizedFormat = this.$getNormalizedFormat$(format);
      if(normalizedFormat) {
        var strictModeFormat = normalizedFormat.replace(/(\b|[^D])D{2}(?!D)/g, "$1D").replace(/(\b|[^M])M{2}(?!M)/g, "$1M").replace(/(\b|[^h])h{2}(?!h)/g, "$1h").replace(/(\b|[^H])H{2}(?!H)/g, "$1H").replace(/(\b|[^m])m{2}(?!m)/g, "$1m").replace(/(\b|[^s])s{2}(?!s)/g, "$1s").replace(/\s*A/g, " A").trim();
        this.$cache$.$strictModeFormat$[format] = strictModeFormat
      }
    }
    return this.$cache$.$strictModeFormat$[format]
  }
  return format
};
AuraLocalizationService.prototype.$getStrictModeDateTimeString$ = function(dateTimeString) {
  if(dateTimeString) {
    return dateTimeString.replace(/(\d)([AaPp][Mm])/g, "$1 $2")
  }
  return dateTimeString
};
AuraLocalizationService.prototype.$addSubtract$ = function(date, num, unit, isSubtract) {
  if(isSubtract) {
    num = -1 * num
  }
  switch(unit) {
    case "year":
      date.setFullYear(date.getFullYear() + num);
      break;
    case "month":
      date.setMonth(date.getMonth() + num);
      break;
    case "week":
      date.setDate(date.getDate() + num * 7);
      break;
    case "day":
      date.setDate(date.getDate() + num);
      break;
    case "hour":
      date.setHours(date.getHours() + num);
      break;
    case "minute":
      date.setMinutes(date.getMinutes() + num);
      break;
    case "second":
      date.setSeconds(date.getSeconds() + num);
      break;
    case "millisecond":
      date.setMilliseconds(date.getMilliseconds() + num)
  }
};
AuraLocalizationService.prototype.$normalizeDateTimeInput$ = function(datetime) {
  if(typeof datetime === "string") {
    datetime = this.$parseDateTimeISO8601$(datetime)
  }else {
    if(typeof datetime === "number") {
      datetime = new Date(datetime)
    }
  }
  if(!this.$isValidDateObject$(datetime)) {
    return new Date(NaN)
  }
  return datetime
};
AuraLocalizationService.prototype.$quarterInYear$ = function(date) {
  return Math.floor(date.getMonth() / 3) + 1
};
AuraLocalizationService.prototype.$weekInYear$ = function(date) {
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var year = date.getFullYear();
  var month = date.getMonth() + 1;
  var day = date.getDate();
  var ordinal = day + (this.$isLeapYear$(year) ? leapLadder : nonLeapLadder)[month - 1];
  var weekday = date.getDay();
  if(weekday === 0) {
    weekday = 7
  }
  var weekNumber = Math.floor((ordinal - weekday + 10) / 7);
  return weekNumber
};
AuraLocalizationService.prototype.$isLeapYear$ = function(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)
};
AuraLocalizationService.prototype.$parseOffset$ = function(offsetString) {
  var tokens = this.$ISO_OFFSET_PATTERN$.exec(offsetString);
  if(tokens === null) {
    return null
  }
  if(tokens[0] === "Z") {
    return 0
  }else {
    var offsetInMinute = parseInt(tokens[2], 10) * 60 + parseInt(tokens[3], 10);
    if(!this.$isValidOffset$(offsetInMinute)) {
      return null
    }
    return offsetInMinute
  }
};
AuraLocalizationService.prototype.$parseISOStringToConfig$ = function(dateTimeString) {
  var i;
  var tokens;
  var year = 0;
  var month = 0;
  var day = 0;
  var timeOnly = false;
  var match = this.$ISO_REGEX$.exec(dateTimeString) || this.$ISO_REGEX_NO_DASH$.exec(dateTimeString);
  if(match === null) {
    match = this.$ISO_TIME_REGEX$.exec(dateTimeString);
    if(match === null) {
      return null
    }
    timeOnly = true;
    var date = new Date;
    year = date.getFullYear();
    month = date.getMonth() + 1;
    day = date.getDate()
  }else {
    var dateString = match[1];
    for(i = 0;i < this.$ISO_DATE_PATTERNS$.length;i++) {
      var datePattern = this.$ISO_DATE_PATTERNS$[i];
      tokens = datePattern.exec(dateString);
      if(tokens) {
        year = parseInt(tokens[1], 10);
        month = parseInt(tokens[2], 10) || 1;
        day = parseInt(tokens[3], 10) || 1;
        break
      }
    }
    if(!this.$isValidDate$(year, month, day)) {
      return null
    }
  }
  var hour;
  var minute;
  var second;
  var millisecond;
  hour = minute = second = millisecond = 0;
  var timeString = timeOnly === false ? match[3] : match[1];
  if(timeString !== undefined) {
    for(i = 0;i < this.$ISO_TIME_PATTERNS$.length;i++) {
      var timePattern = this.$ISO_TIME_PATTERNS$[i];
      tokens = timePattern.exec(timeString);
      if(tokens) {
        hour = parseInt(tokens[1], 10) || 0;
        minute = parseInt(tokens[2], 10) || 0;
        second = parseInt(tokens[3], 10) || 0;
        millisecond = tokens[4] ? parseInt(tokens[4].substring(0, 3), 10) : 0;
        break
      }
    }
    if(!this.$isValidTime$(hour, minute, second, millisecond)) {
      return null
    }
  }
  var utcOffset = undefined;
  var offsetString = timeOnly === false ? match[4] : match[2];
  if(offsetString !== undefined) {
    utcOffset = this.$parseOffset$(offsetString);
    if(utcOffset === null) {
      return null
    }
  }
  return{"year":year, "month":month, "day":day, "hour":hour, "minute":minute, "second":second, "millisecond":millisecond, "utcOffset":utcOffset}
};
AuraLocalizationService.prototype.$daysInMonth$ = function(year, month) {
  switch(month) {
    case 2:
      return year % 4 === 0 && year % 100 || year % 400 === 0 ? 29 : 28;
    case 4:
    ;
    case 6:
    ;
    case 9:
    ;
    case 11:
      return 30;
    default:
      return 31
  }
};
AuraLocalizationService.prototype.$isValidDate$ = function(year, month, day) {
  return month >= 1 && month <= 13 && day >= 1 && day <= this.$daysInMonth$(year, month)
};
AuraLocalizationService.prototype.$isValidTime$ = function(hour, minute, second, millisecond) {
  return(hour >= 0 && hour < 24 || hour === 24 && minute === 0 && second === 0 && millisecond === 0) && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond <= 999
};
AuraLocalizationService.prototype.$isValidOffset$ = function(offsetInMinute) {
  return offsetInMinute >= -720 && offsetInMinute <= 840
};
AuraLocalizationService.prototype.$isISO8601DateTimeString$ = function(dateTimeString) {
  return this.$ISO_REGEX$.test(dateTimeString) || this.$ISO_REGEX_NO_DASH$.test(dateTimeString) || this.$ISO_TIME_REGEX$.test(dateTimeString)
};
AuraLocalizationService.prototype.$normalizeDateTimeUnit$ = function(unit) {
  return $A["util"].$isString$(unit) ? this.$dateTimeUnitAlias$[unit] || this.$dateTimeUnitAlias$[unit.toLowerCase()] || null : null
};
AuraLocalizationService.prototype.$addDateTimeUnitAlias$ = function(unit, short) {
  var lowerCase = unit.toLowerCase();
  this.$dateTimeUnitAlias$[lowerCase] = this.$dateTimeUnitAlias$[lowerCase + "s"] = this.$dateTimeUnitAlias$[short] = unit
};
AuraLocalizationService.prototype.$setupDateTimeUnitAlias$ = function() {
  this.$addDateTimeUnitAlias$("year", "y");
  this.$addDateTimeUnitAlias$("month", "M");
  this.$addDateTimeUnitAlias$("week", "w");
  this.$addDateTimeUnitAlias$("day", "d");
  this.$addDateTimeUnitAlias$("hour", "h");
  this.$addDateTimeUnitAlias$("minute", "m");
  this.$addDateTimeUnitAlias$("second", "s");
  this.$addDateTimeUnitAlias$("millisecond", "ms")
};
AuraLocalizationService.prototype.$isValidDateObject$ = function(date) {
  return date instanceof Date && !isNaN(date.getTime())
};
AuraLocalizationService.prototype.$isValidDuration$ = function(duration) {
  return duration instanceof Aura.$Utils$.$Duration$
};
Aura.$Services$.$AuraLocalizationService$ = AuraLocalizationService;
function AuraStyleService() {
  this.$styleUtil$ = new Aura.$Utils$.$Style$;
  this.$added$ = []
}
goog.$exportSymbol$("AuraStyleService", AuraStyleService);
AuraStyleService.prototype.$applyTokens$ = function(descriptor, config) {
  $A.assert(!$A["util"].$isUndefinedOrNull$(descriptor), "applyTokens() cannot be given a null or undefined descriptor argument");
  this.$applyAllTokens$([descriptor], config)
};
goog.$exportProperty$(AuraStyleService.prototype, "applyTokens", AuraStyleService.prototype.$applyTokens$);
AuraStyleService.prototype.$applyAllTokens$ = function(descriptors, config) {
  $A.assert($A["util"].isArray(descriptors), "applyAllTokens() expects the 'descriptors' arg to be an array of strings");
  var that = this;
  config = config || {};
  $A.$run$(function() {
    var action = $A.get("c.aura://StyleController.applyTokens");
    action.$setParams$({"descriptors":descriptors, "extraStyles":config["extraStyles"] || []});
    if($A["util"].$isUndefined$(config["storable"]) || config["storable"]) {
      action.$setStorable$()
    }
    action.$setCallback$(this, function(a) {
      var state = a.$getState$();
      if(state === "SUCCESS") {
        var cssToInject = a.$getReturnValue$();
        if($A["util"].$isFunction$(config["customHandler"])) {
          config["customHandler"](cssToInject);
          return
        }
        var node = that.$styleUtil$.apply(cssToInject);
        if($A["util"].$isUndefinedOrNull$(config["replaceExisting"]) || $A["util"].$getBooleanValue$(config["replaceExisting"]) === true) {
          that.$removeTokens$();
          that.$added$ = [node]
        }else {
          that.$added$.push(node)
        }
      }else {
        if(state === "INCOMPLETE") {
          var offlineMessageEvt = $A.$getEvt$("markup://force:showOfflineMessage");
          if(offlineMessageEvt) {
            offlineMessageEvt.$setParams$({$retryAction$:action}).$fire$()
          }
        }else {
          if(state === "ERROR") {
            var errors = a.getError();
            var e;
            if(errors && errors[0] && errors[0].message) {
              e = new Error(errors[0].message)
            }else {
              e = new Error("Unable to apply tokens, action state \x3d " + a.$getState$())
            }
            e["reported"] = true;
            throw e;
          }
        }
      }
      if($A["util"].$isFunction$(config["callback"])) {
        config["callback"]()
      }
    });
    $A.$clientService$.$enqueueAction$(action)
  }, "applyAllTokens")
};
goog.$exportProperty$(AuraStyleService.prototype, "applyAllTokens", AuraStyleService.prototype.$applyAllTokens$);
AuraStyleService.prototype.$removeTokens$ = function() {
  var head = this.$styleUtil$.$getHead$();
  var i = 0;
  for(var len = this.$added$.length;i < len;i++) {
    head.removeChild(this.$added$[i])
  }
};
goog.$exportProperty$(AuraStyleService.prototype, "removeTokens", AuraStyleService.prototype.$removeTokens$);
Aura.$Services$.$AuraStyleService$ = AuraStyleService;
Aura.$Services$.$MetricsServiceWatcher$ = function MetricsServiceWatcher() {
  this.$eventsBuffer$ = [];
  this.$MAX_BUFFER_SIZE$ = 1E3;
  this.$dispatcher$ = function(event) {
    if(this.$eventsBuffer$.length >= this.$MAX_BUFFER_SIZE$) {
      $A.warn("MetricsServiceWatcher: Buffer is full. Dropping events")
    }else {
      this.$eventsBuffer$.push(event)
    }
  }.bind(this)
};
Aura.$Services$.$MetricsServiceWatcher$.prototype.$success$ = function(operation) {
  this.$dispatcher$({"operation":operation, "status":0})
};
Aura.$Services$.$MetricsServiceWatcher$.prototype.error = function(operation) {
  this.$dispatcher$({"operation":operation, "status":1})
};
Aura.$Services$.$MetricsServiceWatcher$.prototype.$attachDispatcher$ = function(dispatcherIn) {
  $A.assert($A["util"].$isFunction$(dispatcherIn), "Dispatcher must be a function");
  $A.assert(this.$eventsBuffer$ !== undefined, "Dispatcher can only be attached once");
  this.$dispatcher$ = dispatcherIn;
  $A.log("MetricsServiceWatcher: Pushing buffered events to dispatcher: " + this.$eventsBuffer$.length);
  for(var i = 0;i < this.$eventsBuffer$.length;i++) {
    this.$dispatcher$(this.$eventsBuffer$[i])
  }
  this.$eventsBuffer$ = undefined
};
Aura.$Services$.$MetricsService$ = function MetricsService() {
  this.$collector$ = {"default":[]};
  this.$globalHandlers$ = {"transactionEnd":[], "transactionsKilled":[], "transactionCreate":[]};
  this.$bootstrap$ = {"cache":{}};
  this.$registeredPlugins$ = {};
  this.$pluginInstances$ = {};
  this.$beaconProviders$ = {};
  this.$transactions$ = {};
  this.$cacheStats$ = {};
  this.$periodicLoggers$ = {};
  this.$doneBootstrap$ = false;
  this.$pluginsInitialized$ = false;
  this.$clearCompleteTransactions$ = true;
  this.$shouldLogBootstrap$ = true;
  this.$markThreshold$ = -1;
  this.$onAdditionalMarksCallback$ = undefined;
  this.$markCount$ = 0;
  this.$periodicLoggerKey$ = -1;
  this.$configurePerformanceAPILogging$();
  this["PAGE_IN_DOM"] = "PageInDOM";
  this["PAGE_HAS_ERROR"] = "PageHasError";
  this["PAGE_NOT_LOADED"] = "PageNotLoaded";
  this["PREVIOUS_PAGE_NOT_LOADED"] = "PreviousPageNotLoaded";
  this["INTERACTION_BEFORE_PAGE_LOADED"] = "InteractionBeforePageLoaded";
  this["PAGE_IN_BACKGROUND_BEFORE_LOADED"] = "PageInBackgroundBeforeLoaded"
};
goog.$exportSymbol$("Aura.Services.MetricsService", Aura.$Services$.$MetricsService$);
Aura.$Services$.$MetricsService$.VERSION = "2.2.0";
Aura.$Services$.$MetricsService$.$PERFTIME$ = !!(window.performance && window.performance.now);
Aura.$Services$.$MetricsService$.$TIMER$ = Aura.$Services$.$MetricsService$.$PERFTIME$ ? function() {
  return Math.floor(window.performance.now() * 100) / 100
} : Date.now.bind(Date);
Aura.$Services$.$MetricsService$.$START$ = "start";
Aura.$Services$.$MetricsService$.$END$ = "end";
Aura.$Services$.$MetricsService$.$STAMP$ = "stamp";
Aura.$Services$.$MetricsService$.$DEFAULT$ = "default";
Aura.$Services$.$MetricsService$.$MAXTIME$ = 3E4;
Aura.$Services$.$MetricsService$.$CUSTOM_MARKS$ = "custom";
Aura.$Services$.$MetricsService$.$WARM$ = "WARM";
Aura.$Services$.$MetricsService$.$COLD$ = "COLD";
Aura.$Services$.$MetricsService$.$WARM_ESTIMATE$ = "WARM_ESTIMATE";
Aura.$Services$.$MetricsService$.$COLD_ESTIMATE$ = "COLD_ESTIMATE";
Aura.$Services$.$MetricsService$.$UNKNOWN$ = "UNKNOWN";
Aura.$Services$.$MetricsService$.$WARM_SIZE$ = 3E3;
Aura.$Services$.$MetricsService$.$HITS$ = "hits";
Aura.$Services$.$MetricsService$.$MISSES$ = "misses";
Aura.$Services$.$MetricsService$.$PLUGIN_MARK_LIMIT$ = 1E3;
Aura.$Services$.$MetricsService$.$watcher$ = new Aura.$Services$.$MetricsServiceWatcher$;
function AuraMetricsServiceWatchExecution(func, name) {
  var hadException = true;
  try {
    var ret = func();
    Aura.$Services$.$MetricsService$.$watcher$.$success$(name);
    hadException = false;
    return ret
  }finally {
    if(hadException) {
      Aura.$Services$.$MetricsService$.$watcher$.error(name)
    }
  }
}
Aura.$Services$.$MetricsService$.prototype.$initialize$ = function() {
  this.$getPageStartTime$();
  this.$transactionStart$("aura", "bootstrap");
  this.$initializePlugins$();
  window.addEventListener("load", this.$emitBootstrapTransaction$.bind(this))
};
Aura.$Services$.$MetricsService$.prototype.$configurePerformanceAPILogging$ = function() {
  var windowPerformance = window.performance || {};
  var noop = function() {
  };
  this.performance = {"mark":(windowPerformance["mark"] || noop).bind(windowPerformance), $measure$:(windowPerformance["measure"] || noop).bind(windowPerformance), $clearMeasures$:(windowPerformance["clearMeasures"] || noop).bind(windowPerformance), $clearMarks$:(windowPerformance["clearMarks"] || noop).bind(windowPerformance)}
};
Aura.$Services$.$MetricsService$.prototype.$instrument$ = function(instance, method, ns, async, before, after, override) {
  var self = this;
  var original = instance[method];
  var beforeFn = typeof before === "function";
  var afterFn = typeof after === "function";
  instance[method] = function() {
    var mark = !override && self.$markStart$(ns, method);
    var ret;
    if(beforeFn) {
      Array.prototype.unshift.call(arguments, mark);
      before.apply(this, arguments);
      Array.prototype.shift.call(arguments)
    }
    if(override) {
      var xargs = Array.prototype.slice.call(arguments);
      xargs.unshift(original);
      ret = override.apply(this, xargs)
    }else {
      ret = original.apply(this, arguments)
    }
    if(async) {
      return ret
    }
    mark = !override && self.$markEnd$(ns, method);
    if(afterFn) {
      Array.prototype.unshift.call(arguments, mark);
      after.apply(this, arguments)
    }
    return ret
  };
  instance[method]["__original"] = original
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "instrument", Aura.$Services$.$MetricsService$.prototype.$instrument$);
Aura.$Services$.$MetricsService$.prototype.$unInstrument$ = function(instance, method) {
  var original = instance[method]["__original"];
  delete instance[method]["__original"];
  instance[method] = original
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "unInstrument", Aura.$Services$.$MetricsService$.prototype.$unInstrument$);
Aura.$Services$.$MetricsService$.prototype.$initializePlugins$ = function() {
  for(var plugin in this.$registeredPlugins$) {
    this.$initializePlugin$(plugin, this.$registeredPlugins$[plugin])
  }
  this.$pluginsInitialized$ = true
};
Aura.$Services$.$MetricsService$.prototype.$initializePlugin$ = function(pluginName, PluginContructor) {
  var pluginInstance = typeof PluginContructor === "function" ? new PluginContructor : PluginContructor;
  this.$pluginInstances$[pluginName] = pluginInstance;
  this.$collector$[pluginName] = [];
  pluginInstance["initialize"](this)
};
Aura.$Services$.$MetricsService$.prototype.$applicationReady$ = function() {
  Aura.$bootstrapMark$("bootstrapEPT");
  this.$applicationReadyTime$ = this.time();
  this.$emitBootstrapTransaction$();
  if(!this.$inTransaction$()) {
    this.$clearMarks$()
  }
};
Aura.$Services$.$MetricsService$.prototype.$emitBootstrapTransaction$ = function() {
  var domReady = window.document && window.document.readyState;
  if(!this.$_emittedBootstrap$ && this.$applicationReadyTime$ && domReady === "complete") {
    this.$_emittedBootstrap$ = true;
    if(!this.$shouldLogBootstrap$) {
      return
    }
    setTimeout(function deferedTransactionEnd() {
      var bootstrap = this.$getBootstrapMetrics$();
      var appReady = this.$applicationReadyTime$;
      this.$transactionEnd$("aura", "bootstrap", function(transaction) {
        var bootstrapStart = Aura.$Services$.$MetricsService$.$PERFTIME$ ? 0 : transaction["pageStartTime"];
        bootstrap["visibilityStateEnd"] = document.visibilityState;
        transaction["context"] = {"eventType":"bootstrap", "eventSource":"framework", "attributes":bootstrap};
        transaction["ts"] = bootstrapStart;
        transaction["duration"] = parseInt(appReady - bootstrapStart, 10)
      })
    }.bind(this), 0)
  }
};
Aura.$Services$.$MetricsService$.prototype.$syntheticTransactionStart$ = function(ns, name, originalTrx) {
  var trx = this.$createTransaction$(ns, name, originalTrx["config"] || originalTrx);
  $A["util"].apply(this.$transactions$[trx], originalTrx, true, true);
  this.$transactions$[trx]["offsets"] = originalTrx["offsets"] || this.$transactions$[trx]["offsets"];
  return trx
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "syntheticTransactionStart", Aura.$Services$.$MetricsService$.prototype.$syntheticTransactionStart$);
Aura.$Services$.$MetricsService$.prototype.$onTransactionCreate$ = function(callback) {
  this.$globalHandlers$["transactionCreate"].push(callback)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "onTransactionCreate", Aura.$Services$.$MetricsService$.prototype.$onTransactionCreate$);
Aura.$Services$.$MetricsService$.prototype.$onTransactionEnd$ = function(callback) {
  this.$globalHandlers$["transactionEnd"].push(callback)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "onTransactionEnd", Aura.$Services$.$MetricsService$.prototype.$onTransactionEnd$);
Aura.$Services$.$MetricsService$.prototype.$detachOnTransactionEnd$ = function(callback) {
  this.$detachHandlerOfType$(callback, "transactionEnd")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "detachOnTransactionEnd", Aura.$Services$.$MetricsService$.prototype.$detachOnTransactionEnd$);
Aura.$Services$.$MetricsService$.prototype.$onTransactionsKilled$ = function(callback) {
  this.$globalHandlers$["transactionsKilled"].push(callback)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "onTransactionsKilled", Aura.$Services$.$MetricsService$.prototype.$onTransactionsKilled$);
Aura.$Services$.$MetricsService$.prototype.$detachOnKilledTransactions$ = function(callback) {
  this.$detachHandlerOfType$(callback, "transactionsKilled")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "detachOnKilledTransactions", Aura.$Services$.$MetricsService$.prototype.$detachOnKilledTransactions$);
Aura.$Services$.$MetricsService$.prototype.$detachHandlerOfType$ = function(callback, name) {
  var handlers = this.$globalHandlers$[name];
  var position = handlers.indexOf(callback);
  if(position > -1) {
    handlers.splice(position, 1)
  }
};
Aura.$Services$.$MetricsService$.prototype.$inTransaction$ = function(ignorePageTransactions) {
  $A["util"].$isEmpty$(this.$transactions$);
  if(!ignorePageTransactions) {
    return!$A["util"].$isEmpty$(this.$transactions$)
  }
  if(this.$getCurrentPageTransaction$()) {
    return Object.keys(this.$transactions$).length > 1
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "inTransaction", Aura.$Services$.$MetricsService$.prototype.$inTransaction$);
Aura.$Services$.$MetricsService$.prototype.transaction = function(ns, name, config) {
  AuraMetricsServiceWatchExecution(function() {
    config = config || {};
    var postProcess = typeof config === "function" ? config : config["postProcess"];
    this.$createTransaction$(ns, name, config);
    this.$transactionEndImpl$(ns, name, function(t) {
      t["duration"] = 0;
      if(postProcess) {
        postProcess(t)
      }
    })
  }.bind(this), "transaction")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transaction", Aura.$Services$.$MetricsService$.prototype.transaction);
Aura.$Services$.$MetricsService$.prototype.$transactionUpdate$ = function(ns, name, config) {
  config = config || {};
  var id = (ns || Aura.$Services$.$MetricsService$.$DEFAULT$) + ":" + name;
  var transaction = this.$transactions$[id];
  if(transaction) {
    transaction["config"] = $A["util"].apply(transaction["config"], config, true, true)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transactionUpdate", Aura.$Services$.$MetricsService$.prototype.$transactionUpdate$);
Aura.$Services$.$MetricsService$.prototype.$transactionStart$ = function(ns, name, config) {
  AuraMetricsServiceWatchExecution(function() {
    return this.$createTransaction$(ns, name, config)
  }.bind(this), "transactionStart")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transactionStart", Aura.$Services$.$MetricsService$.prototype.$transactionStart$);
Aura.$Services$.$MetricsService$.prototype.$transactionEndImpl$ = function(ns, name, config, postProcess) {
  var id = ns + ":" + name;
  var transaction = this.$transactions$[id];
  var transactionCfg = $A["util"].apply(transaction && transaction["config"] || {}, config, true, true);
  var beacon = this.$beaconProviders$[ns] || this.$beaconProviders$[Aura.$Services$.$MetricsService$.$DEFAULT$];
  postProcess = typeof config === "function" ? config : postProcess || transactionCfg["postProcess"];
  if(transaction) {
    try {
      this.performance.$measure$(id, id)
    }catch(e) {
    }
    this.performance.$clearMeasures$(id);
    this.performance.$clearMarks$(id)
  }
  if(transaction && (beacon || postProcess || !this.$clearCompleteTransactions$)) {
    var parsedTransaction = {"id":id, "ts":transaction["ts"], "duration":parseInt(this.time() - transaction["ts"]), "pageStartTime":this.$pageStartTime$, "marks":{}, "context":transactionCfg["context"] || {}, "owner":transaction["owner"], "unixTS":!Aura.$Services$.$MetricsService$.$PERFTIME$};
    for(var plugin in this.$collector$) {
      var instance = this.$pluginInstances$[plugin];
      if(this.$collector$[plugin].length) {
        var pluginCollector = this.$collector$[plugin];
        var initialOffset = transaction["offsets"] && (transaction["offsets"][plugin] || 0);
        var tMarks = pluginCollector.slice(initialOffset);
        var pluginPostProcess = instance && instance["postProcess"];
        var parsedMarks = pluginPostProcess ? instance["postProcess"](tMarks, transactionCfg) : tMarks;
        var pluginName = instance ? plugin : Aura.$Services$.$MetricsService$.$CUSTOM_MARKS$;
        if(!pluginPostProcess && tMarks.length) {
          parsedMarks = this.$defaultPostProcessing$(tMarks)
        }
        if(parsedMarks && parsedMarks.length) {
          parsedTransaction["marks"][pluginName] = parsedTransaction["marks"][pluginName] || [];
          var limit = Math.min(parsedMarks.length, Aura.$Services$.$MetricsService$.$PLUGIN_MARK_LIMIT$);
          if(limit === Aura.$Services$.$MetricsService$.$PLUGIN_MARK_LIMIT$) {
            parsedTransaction["context"]["attributes"] = parsedTransaction["context"]["attributes"] || {};
            parsedTransaction["context"]["attributes"]["marksTruncated"] = parsedTransaction["context"]["attributes"]["marksTruncated"] || {};
            parsedTransaction["context"]["attributes"]["marksTruncated"][plugin] = parsedMarks.length - limit
          }
          for(var x = 0;x < limit;++x) {
            parsedTransaction["marks"][pluginName].push(parsedMarks[x])
          }
        }
      }
    }
    if(postProcess) {
      postProcess(parsedTransaction)
    }
    if(beacon && beacon["middleware"]) {
      beacon["middleware"](parsedTransaction, this.$resetAllCacheStats$.bind(this))
    }
    if(this.$globalHandlers$["transactionEnd"].length) {
      this.$callHandlers$("transactionEnd", parsedTransaction)
    }
    if(beacon) {
      beacon["sendData"](parsedTransaction["id"], parsedTransaction)
    }
    if(!this.$clearCompleteTransactions$) {
      var newId = id + ":" + parseInt(parsedTransaction["ts"], 10);
      parsedTransaction["config"] = transactionCfg;
      this.$transactions$[newId] = parsedTransaction;
      parsedTransaction["id"] = newId
    }
    delete this.$transactions$[id];
    if(!this.$inTransaction$()) {
      this.$clearMarks$()
    }else {
      this.$killLongRunningTransactions$()
    }
  }else {
    delete this.$transactions$[id]
  }
};
Aura.$Services$.$MetricsService$.prototype.$transactionEnd$ = function(ns, name, config, postProcess) {
  AuraMetricsServiceWatchExecution(function() {
    this.$transactionEndImpl$(ns, name, config, postProcess)
  }.bind(this), "transactionEnd")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transactionEnd", Aura.$Services$.$MetricsService$.prototype.$transactionEnd$);
Aura.$Services$.$MetricsService$.prototype.$clearTransactions$ = function() {
  this.$transactions$ = {}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "clearTransactions", Aura.$Services$.$MetricsService$.prototype.$clearTransactions$);
Aura.$Services$.$MetricsService$.prototype.$callHandlers$ = function(type, t) {
  var handlers = this.$globalHandlers$[type];
  if(handlers) {
    for(var i = 0;i < handlers.length;i++) {
      handlers[i](t)
    }
  }
};
Aura.$Services$.$MetricsService$.prototype.$killLongRunningTransactions$ = function() {
  var now = this.time();
  var transactionsKilled = [];
  for(var i in this.$transactions$) {
    var transaction = this.$transactions$[i];
    var dontKill = transaction["config"]["pageTransaction"] || transaction["config"]["dontKill"];
    if(!dontKill && now - transaction["ts"] > Aura.$Services$.$MetricsService$.$MAXTIME$) {
      transactionsKilled.push(transaction);
      delete this.$transactions$[i]
    }
  }
  if(transactionsKilled.length && this.$globalHandlers$["transactionsKilled"].length) {
    this.$callHandlers$("transactionsKilled", transactionsKilled)
  }
};
Aura.$Services$.$MetricsService$.prototype.$getCurrentPageTransaction$ = function() {
  for(var i in this.$transactions$) {
    if(this.$transactions$[i]["config"]["pageTransaction"]) {
      return this.$transactions$[i]
    }
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getCurrentPageTransaction", Aura.$Services$.$MetricsService$.prototype.$getCurrentPageTransaction$);
Aura.$Services$.$MetricsService$.prototype.$updateCurrentPageTransaction$ = function(config) {
  var trx = this.$getCurrentPageTransaction$();
  if(trx) {
    trx["config"] = $A["util"].apply(trx["config"], config, true, true)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "updateCurrentPageTransaction", Aura.$Services$.$MetricsService$.prototype.$updateCurrentPageTransaction$);
Aura.$Services$.$MetricsService$.prototype.$getCurrentMarks$ = function() {
  return $A["util"].apply({}, this.$collector$, true, true)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getCurrentMarks", Aura.$Services$.$MetricsService$.prototype.$getCurrentMarks$);
Aura.$Services$.$MetricsService$.prototype.$getVersion$ = function(includePlugins) {
  var msVersion = Aura.$Services$.$MetricsService$.VERSION;
  if(!includePlugins) {
    return msVersion
  }
  var pluginsVersion = {};
  for(var p in this.$registeredPlugins$) {
    pluginsVersion[p] = this.$registeredPlugins$["VERSION"]
  }
  return{"metricsService":msVersion, "plugins":pluginsVersion}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getVersion", Aura.$Services$.$MetricsService$.prototype.$getVersion$);
Aura.$Services$.$MetricsService$.prototype.$defaultPostProcessing$ = function(customMarks) {
  var procesedMarks = [];
  var queue = {};
  for(var i = 0;i < customMarks.length;i++) {
    var id = customMarks[i]["ns"] + customMarks[i]["name"];
    var phase = customMarks[i]["phase"];
    if(phase === "stamp") {
      procesedMarks.push(customMarks[i])
    }else {
      if(phase === "start") {
        queue[id] = customMarks[i]
      }else {
        if(phase === "end" && queue[id]) {
          var mark = $A["util"].apply({}, queue[id], true, true);
          if(mark) {
            mark["context"] = $A["util"].apply(mark["context"] || {}, customMarks[i]["context"] || {});
            mark["duration"] = parseInt(customMarks[i]["ts"] - mark["ts"]);
            delete mark["phase"];
            procesedMarks.push(mark);
            queue[id] = null
          }
        }
      }
    }
  }
  return procesedMarks
};
Aura.$Services$.$MetricsService$.prototype.$getTransactions$ = function() {
  var transactions = [];
  for(var i in this.$transactions$) {
    transactions.push(this.$transactions$[i])
  }
  return transactions
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getTransactions", Aura.$Services$.$MetricsService$.prototype.$getTransactions$);
Aura.$Services$.$MetricsService$.prototype.$getTransaction$ = function(ns, id) {
  if(!id) {
    id = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var key = id.indexOf(":") === -1 ? ns + ":" + id : id;
  for(var i in this.$transactions$) {
    var t = this.$transactions$[i];
    if(t["id"].indexOf(key) === 0) {
      return t
    }
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getTransaction", Aura.$Services$.$MetricsService$.prototype.$getTransaction$);
Aura.$Services$.$MetricsService$.prototype.$setClearCompletedTransactions$ = function(value) {
  this.$clearCompleteTransactions$ = value
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "setClearCompletedTransactions", Aura.$Services$.$MetricsService$.prototype.$setClearCompletedTransactions$);
Aura.$Services$.$MetricsService$.prototype.$createTransaction$ = function(ns, name, config) {
  var id = (ns || Aura.$Services$.$MetricsService$.$DEFAULT$) + ":" + name;
  var transaction = {"id":id, "offsets":{}, "ts":Math.round(this.time() * 100) / 100, "config":config || {}, "owner":$A.$clientService$.$currentAccess$ ? $A.$clientService$.$currentAccess$.type : null};
  var offsets = transaction["offsets"];
  for(var c in this.$collector$) {
    offsets[c] = this.$collector$[c].length
  }
  this.$transactions$[id] = transaction;
  this.performance["mark"](id);
  if(this.$globalHandlers$["transactionCreate"].length) {
    this.$callHandlers$("transactionCreate", transaction)
  }
  return id
};
Aura.$Services$.$MetricsService$.prototype["mark"] = function(ns, name, context) {
  if(!name) {
    name = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var mark = this.$createMarkNode$(ns, name, Aura.$Services$.$MetricsService$.$STAMP$, context);
  var nsCollector = this.$collector$[ns];
  var collector = nsCollector ? nsCollector : this.$collector$[ns] = [];
  collector.push(mark);
  return mark
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "mark", Aura.$Services$.$MetricsService$.prototype["mark"]);
Aura.$Services$.$MetricsService$.prototype.$markStart$ = function(ns, name, context) {
  if(!name) {
    name = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var mark = this.$createMarkNode$(ns, name, Aura.$Services$.$MetricsService$.$START$, context);
  var nsCollector = this.$collector$[ns];
  var collector = nsCollector ? nsCollector : this.$collector$[ns] = [];
  collector.push(mark);
  return mark
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "markStart", Aura.$Services$.$MetricsService$.prototype.$markStart$);
Aura.$Services$.$MetricsService$.prototype.$onAdditionalMarks$ = function(delta, callback) {
  this.$markThreshold$ = this.$markCount$ + delta;
  this.$onAdditionalMarksCallback$ = callback
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "onAdditionalMarks", Aura.$Services$.$MetricsService$.prototype.$onAdditionalMarks$);
Aura.$Services$.$MetricsService$.prototype.$markEnd$ = function(ns, name, context) {
  if(!name) {
    name = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var mark = this.$createMarkNode$(ns, name, Aura.$Services$.$MetricsService$.$END$, context);
  var nsCollector = this.$collector$[ns];
  var collector = nsCollector ? nsCollector : this.$collector$[ns] = [];
  collector.push(mark);
  return mark
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "markEnd", Aura.$Services$.$MetricsService$.prototype.$markEnd$);
Aura.$Services$.$MetricsService$.prototype.$createMarkNode$ = function(ns, name, eventType, options) {
  var context = options ? options["context"] || options : null;
  var shouldLogOwner = !this.$pluginInstances$[ns];
  var mark = {"ns":ns, "name":name, "phase":eventType, "ts":Aura.$Services$.$MetricsService$.$TIMER$(), "context":context};
  if(shouldLogOwner && $A.$clientService$.$currentAccess$) {
    mark["owner"] = $A.$clientService$.$currentAccess$.type
  }
  this.$markCount$++;
  if(this.$markThreshold$ > 0 && this.$markCount$ >= this.$markThreshold$) {
    this.$markThreshold$ = -1;
    this.$onAdditionalMarksCallback$ && this.$onAdditionalMarksCallback$();
    this.$onAdditionalMarksCallback$ = undefined
  }
  return mark
};
Aura.$Services$.$MetricsService$.prototype.$clearMarks$ = function(ns) {
  if(ns) {
    if(this.$collector$[ns]) {
      this.$collector$[ns] = []
    }
  }else {
    for(var i in this.$collector$) {
      this.$collector$[i] = []
    }
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "clearMarks", Aura.$Services$.$MetricsService$.prototype.$clearMarks$);
Aura.$Services$.$MetricsService$.prototype.$getPageStartTime$ = function() {
  if(!this.$pageStartTime$) {
    var p = window.performance;
    var pst;
    if(p && p.timing && p.timing.navigationStart) {
      pst = p.timing.navigationStart
    }else {
      pst = window["pageStartTime"]
    }
    this.$pageStartTime$ = pst
  }
  return this.$pageStartTime$
};
Aura.$Services$.$MetricsService$.prototype.time = function() {
  return Aura.$Services$.$MetricsService$.$TIMER$()
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "time", Aura.$Services$.$MetricsService$.prototype.time);
Aura.$Services$.$MetricsService$.prototype.$microsecondsResolution$ = function() {
  return Aura.$Services$.$MetricsService$.$PERFTIME$
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "microsecondsResolution", Aura.$Services$.$MetricsService$.prototype.$microsecondsResolution$);
Aura.$Services$.$MetricsService$.prototype.$disablePlugins$ = function() {
  for(var p in this.$pluginInstances$) {
    this.$disablePlugin$(p)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "disablePlugins", Aura.$Services$.$MetricsService$.prototype.$disablePlugins$);
Aura.$Services$.$MetricsService$.prototype.$disablePlugin$ = function(name) {
  var plugin = this.$pluginInstances$[name];
  if(plugin && plugin.disable) {
    plugin["disable"]()
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "disablePlugin", Aura.$Services$.$MetricsService$.prototype.$disablePlugin$);
Aura.$Services$.$MetricsService$.prototype.$enablePlugins$ = function() {
  for(var p in this.$pluginInstances$) {
    this.$enablePlugin$(p)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "enablePlugins", Aura.$Services$.$MetricsService$.prototype.$enablePlugins$);
Aura.$Services$.$MetricsService$.prototype.$enablePlugin$ = function(name) {
  var plugin = this.$pluginInstances$[name];
  if(plugin && plugin.enable) {
    plugin["enable"]()
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "enablePlugin", Aura.$Services$.$MetricsService$.prototype.$enablePlugin$);
Aura.$Services$.$MetricsService$.prototype.$registerPlugin$ = function(pluginConfig) {
  var pluginName = pluginConfig["name"];
  var PluginContructor = pluginConfig["plugin"];
  this.$registeredPlugins$[pluginName] = PluginContructor;
  if(this.$pluginsInitialized$) {
    this.$initializePlugin$(pluginName, PluginContructor)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "registerPlugin", Aura.$Services$.$MetricsService$.prototype.$registerPlugin$);
Aura.$Services$.$MetricsService$.prototype.$registerBeacon$ = function(beacon) {
  this.$beaconProviders$[beacon["name"] || Aura.$Services$.$MetricsService$.$DEFAULT$] = beacon["beacon"] || beacon;
  return{"executePeriodicLoggers":this.$beaconPrivExecutePeriodicLoggers$.bind(this)}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "registerBeacon", Aura.$Services$.$MetricsService$.prototype.$registerBeacon$);
Aura.$Services$.$MetricsService$.prototype.$summarizeResourcePerfInfo$ = function(r) {
  var serverTiming = r["serverTiming"];
  if(serverTiming && $A["util"].isArray(serverTiming)) {
    var totalTiming = serverTiming.filter(function(t) {
      return t.name && t.name.toLowerCase() === "total"
    })[0];
    var serverTime = totalTiming && totalTiming["duration"]
  }
  var timing = {"name":r.name, "initiatorType":r.initiatorType, "nextHopProtocol":r["nextHopProtocol"], "duration":parseInt(r.responseEnd - r.startTime, 10), "startTime":parseInt(r.startTime, 10), "fetchStart":parseInt(r.fetchStart, 10), "serverTime":serverTime, "redirect":parseInt(r.redirectEnd - r.redirectStart, 10), "requestStart":parseInt(r.requestStart, 10), "incompleteTimings":false, "transferSize":r["transferSize"], "encodedBodySize":r["encodedBodySize"], "decodedBodySize":r["decodedBodySize"]};
  var potentialIncompleteTimings = {"dns":this.$calculateTimingOverZero$(r.domainLookupEnd, r.domainLookupStart), "tcp":this.$calculateTimingOverZero$(r.connectEnd, r.connectStart), "ttfb":r.responseStart > 0 ? parseInt(r.responseStart - r.startTime, 10) : undefined, "transfer":this.$calculateTimingOverZero$(r.responseEnd, r.responseStart)};
  for(var index in potentialIncompleteTimings) {
    if(potentialIncompleteTimings[index] === undefined) {
      timing["incompleteTimings"] = true;
      break
    }
  }
  Object.assign(timing, potentialIncompleteTimings);
  return timing
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "summarizeResourcePerfInfo", Aura.$Services$.$MetricsService$.prototype.$summarizeResourcePerfInfo$);
Aura.$Services$.$MetricsService$.prototype.$calculateTimingOverZero$ = function(first, second) {
  return first > 0 && second > 0 ? parseInt(first - second, 10) : undefined
};
Aura.$Services$.$MetricsService$.prototype.$findAndSummarizeResourcePerfInfo$ = function(uri, startTime, endTime) {
  if(window.performance && window.performance.getEntriesByType) {
    var allResources = window.performance.getEntriesByType("resource");
    var r = allResources.filter(function(res) {
      return res.name.indexOf(uri) !== -1 && res.startTime >= startTime && res.responseEnd <= endTime
    })[0]
  }
  if(r) {
    return this.$summarizeResourcePerfInfo$(r)
  }
  return null
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "findAndSummarizeResourcePerfInfo", Aura.$Services$.$MetricsService$.prototype.$findAndSummarizeResourcePerfInfo$);
Aura.$Services$.$MetricsService$.prototype.$skipBootstrapLogging$ = function() {
  this.$shouldLogBootstrap$ = false
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "skipBootstrapLogging", Aura.$Services$.$MetricsService$.prototype.$skipBootstrapLogging$);
Aura.$Services$.$MetricsService$.prototype.$createFrameworkRequestsSummary$ = function() {
  var frameworkRequests = {"requestBootstrapJs":{name:"bootstrap.js", $trackWarmCold$:false}, "requestInlineJs":{name:"inline.js", $trackWarmCold$:false}, "requestAppCss":{name:"app.css", $trackWarmCold$:true}, "requestAuraJs":{name:"/aura_", $trackWarmCold$:true}};
  var ready = Aura["appJsReady"] || [];
  if(ready.length === 1) {
    frameworkRequests["requestAppJs"] = {name:"app.js", $trackWarmCold$:true}
  }else {
    if(ready.length === 2) {
      frameworkRequests["requestAppJs"] = {name:"app.js", $trackWarmCold$:true};
      frameworkRequests["requestAppCoreJs"] = {name:"appcore.js", $trackWarmCold$:true}
    }else {
      ready.forEach(function(b, i) {
        frameworkRequests["requestAppJs" + (i + 1)] = {name:"apppart" + (i + 1) + "-" + ready.length + ".js", $trackWarmCold$:true}
      })
    }
  }
  return frameworkRequests
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "createFrameworkRequestsSummary", Aura.$Services$.$MetricsService$.prototype.$createFrameworkRequestsSummary$);
Aura.$Services$.$MetricsService$.prototype.$getBootstrapMetrics$ = function() {
  var bootstrap = this.$bootstrap$;
  var pageStartTime = this.$getPageStartTime$();
  var context = $A.getContext();
  for(var m in Aura["bootstrap"]) {
    bootstrap[m] = parseInt(Aura["bootstrap"][m], 10)
  }
  bootstrap["visibilityStateStart"] = Aura["bootstrap"]["visibilityStateStart"];
  bootstrap["cdnEnabled"] = context.$isCDNEnabled$();
  bootstrap["mode"] = context.$getMode$();
  bootstrap["maxAllowedParallelXHRCounts"] = $A.$clientService$.$maxAllowedParallelXHRCounts$();
  bootstrap["pageStartTime"] = pageStartTime;
  if(window.performance && window.performance.timing) {
    var p = window.performance;
    var pt = p.timing;
    if(!bootstrap["timing"]) {
      bootstrap["timing"] = {"navigationStart":pt.navigationStart, "fetchStart":pt.fetchStart, "readyStart":pt.fetchStart - pt.navigationStart, "dnsStart":pt.domainLookupStart, "dnsEnd":pt.domainLookupEnd, "lookupDomainTime":pt.domainLookupEnd - pt.domainLookupStart, "connectStart":pt.connectStart, "connectEnd":pt.connectEnd, "connectTime":pt.connectEnd - pt.connectStart, "requestStart":pt.requestStart, "responseStart":pt.responseStart, "responseEnd":pt.responseEnd, "requestTime":pt.responseEnd - 
      pt.requestStart, "domLoading":pt.domLoading, "domInteractive":pt.domInteractive, "initDomTreeTime":pt.domInteractive - pt.responseEnd, "contentLoadStart":pt.domContentLoadedEventStart, "contentLoadEnd":pt.domContentLoadedEventEnd, "domComplete":pt.domComplete, "domReadyTime":pt.domComplete - pt.domInteractive, "loadEventStart":pt.loadEventStart, "loadEventEnd":pt.loadEventEnd, "loadEventTime":pt.loadEventEnd - pt.loadEventStart, "loadTime":pt.loadEventEnd - pt.fetchStart, "unloadEventStart":pt.unloadEventStart, 
      "unloadEventEnd":pt.unloadEventEnd, "unloadEventTime":pt.unloadEventEnd - pt.unloadEventStart, "appCacheTime":pt.domainLookupStart - pt.fetchStart, "redirectTime":pt.redirectEnd - pt.redirectStart}
    }
    bootstrap["cache"]["appCache"] = bootstrap["timing"]["appCache"] === 0 && window.applicationCache && window.applicationCache.status !== window.applicationCache.UNCACHED;
    bootstrap["cache"]["gvps"] = $A.$clientService$.$gvpsFromStorage$;
    var frameworkRequests = this.$createFrameworkRequestsSummary$();
    if(p.getEntries && (!bootstrap["allRequests"] || !bootstrap["allRequests"].length)) {
      bootstrap["type"] = Aura.$Services$.$MetricsService$.$UNKNOWN$;
      var coldResources = 0;
      var totalRequestsToTrackWarmCold = 0;
      var canTrackWarmCold = undefined;
      var canTrackTransferSize = undefined;
      bootstrap["allRequests"] = [];
      $A["util"].forEach(p.getEntries(), function processResource(resource) {
        if(resource.responseEnd < bootstrap["bootstrapEPT"]) {
          var summaryRequest = this.$summarizeResourcePerfInfo$(resource);
          bootstrap["allRequests"].push(summaryRequest);
          for(var i in frameworkRequests) {
            if(resource.name.indexOf(frameworkRequests[i].name) !== -1) {
              if(frameworkRequests[i].$trackWarmCold$) {
                if(canTrackWarmCold === undefined) {
                  canTrackTransferSize = resource["transferSize"] !== undefined;
                  canTrackWarmCold = canTrackTransferSize || $A["util"].$isLocalStorageEnabled$()
                }
                if(canTrackWarmCold) {
                  totalRequestsToTrackWarmCold++;
                  if(this.$wasResourceFetchedFromServer$(i, resource)) {
                    coldResources++
                  }
                }
              }
              summaryRequest.name = frameworkRequests[i].name;
              bootstrap[i] = summaryRequest;
              continue
            }
          }
        }
      }, this);
      if(canTrackWarmCold && coldResources === totalRequestsToTrackWarmCold) {
        bootstrap["type"] = canTrackTransferSize ? Aura.$Services$.$MetricsService$.$COLD$ : Aura.$Services$.$MetricsService$.$COLD_ESTIMATE$
      }else {
        if(canTrackWarmCold && coldResources === 0) {
          bootstrap["type"] = canTrackTransferSize ? Aura.$Services$.$MetricsService$.$WARM$ : Aura.$Services$.$MetricsService$.$WARM_ESTIMATE$
        }
      }
    }
    var navigator = window["navigator"];
    var conn = navigator && navigator["connection"];
    if(conn && !bootstrap["connection"]) {
      bootstrap["connection"] = {"rtt":conn["rtt"], "downlink":conn["downlink"]}
    }
  }
  return bootstrap
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getBootstrapMetrics", Aura.$Services$.$MetricsService$.prototype.$getBootstrapMetrics$);
Aura.$Services$.$MetricsService$.prototype.$wasResourceFetchedFromServer$ = function(key, resource) {
  if(resource["transferSize"] !== undefined) {
    return resource["transferSize"] > Aura.$Services$.$MetricsService$.$WARM_SIZE$
  }else {
    if(localStorage.getItem(key) === resource.name) {
      return false
    }else {
      localStorage.setItem(key, resource.name);
      return true
    }
  }
};
Aura.$Services$.$MetricsService$.prototype.$registerCacheStats$ = function(name) {
  if(name in this.$cacheStats$) {
    throw Error("Cache name : " + name + " is already registered to track cache stats");
  }
  this.$cacheStats$[name] = this.$initCacheStats$(name);
  var that = this;
  return{"logHits":function(count) {
    that.$updateCacheStats$(name, Aura.$Services$.$MetricsService$.$HITS$, count)
  }, "logMisses":function(count) {
    that.$updateCacheStats$(name, Aura.$Services$.$MetricsService$.$MISSES$, count)
  }, "unRegister":function() {
    delete that.$cacheStats$[name]
  }}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "registerCacheStats", Aura.$Services$.$MetricsService$.prototype.$registerCacheStats$);
Aura.$Services$.$MetricsService$.prototype.$getAllCacheStats$ = function() {
  var self = this;
  var filteredStats = {};
  Object.keys(this.$cacheStats$).forEach(function(key) {
    var stats = self.$cacheStats$[key];
    if(stats[Aura.$Services$.$MetricsService$.$HITS$] > 0 || stats[Aura.$Services$.$MetricsService$.$MISSES$] > 0) {
      filteredStats[key] = $A["util"].apply({}, stats)
    }
  });
  return filteredStats
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getAllCacheStats", Aura.$Services$.$MetricsService$.prototype.$getAllCacheStats$);
Aura.$Services$.$MetricsService$.prototype.$resetAllCacheStats$ = function() {
  var self = this;
  Object.keys(this.$cacheStats$).forEach(function(key) {
    self.$initCacheStats$(key)
  })
};
Aura.$Services$.$MetricsService$.prototype.$initCacheStats$ = function(key) {
  var stats = this.$cacheStats$[key] || {};
  stats[Aura.$Services$.$MetricsService$.$HITS$] = 0;
  stats[Aura.$Services$.$MetricsService$.$MISSES$] = 0;
  return stats
};
Aura.$Services$.$MetricsService$.prototype.$checkCacheKey$ = function(key) {
  var stats = this.$cacheStats$[key];
  if(!stats) {
    throw Error("Cache name : " + name + " is not registered or unregistered");
  }
  return stats
};
Aura.$Services$.$MetricsService$.prototype.$updateCacheStats$ = function(cacheName, statName, count) {
  var stats = this.$checkCacheKey$(cacheName);
  if(typeof count === "number") {
    stats[statName] += count
  }else {
    stats[statName]++
  }
};
Aura.$Services$.$MetricsService$.prototype.$registerPeriodicLogger$ = function(name, callback) {
  if($A["util"].$isEmpty$(name)) {
    throw new Error("Periodic logger must be registered with a name");
  }
  if(!$A["util"].$isFunction$(callback)) {
    throw new Error("Periodic logger must have a valid callback function");
  }
  this.$periodicLoggerKey$++;
  this.$periodicLoggers$[this.$periodicLoggerKey$] = {name:name, $callback$:callback};
  return this.$periodicLoggerKey$
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "registerPeriodicLogger", Aura.$Services$.$MetricsService$.prototype.$registerPeriodicLogger$);
Aura.$Services$.$MetricsService$.prototype.$removePeriodicLogger$ = function(id) {
  delete this.$periodicLoggers$[id]
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "removePeriodicLogger", Aura.$Services$.$MetricsService$.prototype.$removePeriodicLogger$);
Aura.$Services$.$MetricsService$.prototype.$beaconPrivExecutePeriodicLoggers$ = function() {
  var loggersExecuted = [];
  var loggers = this.$periodicLoggers$;
  for(var key in loggers) {
    if(loggers.hasOwnProperty(key)) {
      loggers[key].$callback$();
      loggersExecuted.push(loggers[key].name)
    }
  }
  return loggersExecuted
};
Aura.$ServiceApi$ = {"replaceModule":function(targetCtor, replacementCtor) {
  var targetDef;
  var replacementDef;
  Object.keys($A.$componentService$.$moduleDefRegistry$).some(function(key) {
    var def = $A.$componentService$.$moduleDefRegistry$[key];
    if(def.$ns$ === targetCtor) {
      targetDef = def
    }else {
      if(def.$ns$ === replacementCtor) {
        replacementDef = def
      }
    }
    return targetDef && replacementDef
  });
  $A.assert(targetDef && replacementDef, "Definitions could not be found");
  $A.assert(targetDef.$access$ === replacementDef.$access$, "Access checks do not match");
  $A.$componentService$.$moduleDefRegistry$[targetDef.$moduleName$] = replacementDef
}, "registerScopedModuleResolver":function(scope, resolver) {
  $A.$clientService$.$addScopedModuleResolver$(scope, resolver)
}, "reifyActions":function(actions, functionsWithDefDependencies) {
  return $A.$clientService$.$reifyActions$(actions, functionsWithDefDependencies)
}, "prepareRequest":function(actions) {
  return $A.$clientService$.$prepareRequest$(actions)
}, "getPathPrefix":function() {
  return $A.getContext().$getPathPrefix$()
}, "getToken":function(name) {
  return $A.$getToken$(name)
}, "getLocale":function() {
  return $A.get("$Locale")
}, "getLocalizationService":function() {
  return $A.$localizationService$
}, "sanitizeDOM":function(dirty, config) {
  return $A["util"].$sanitizeDOM$(dirty, config)
}, "getFormFactor":function() {
  return $A.get("$Browser.formFactor")
}, "getInitializer":function(name) {
  if($A.$initializers$) {
    return $A.$initializers$[name]
  }
}, "getCSSVar":function(cssVarName) {
  return $A.$clientService$.$cssVars$[cssVarName]
}, "getDefaultLoaderResolver":function() {
  return $A.$clientService$.$defaultLoaderResolver$()
}, "cleanUpBeforeReload":function(metricsPayload) {
  return $A.$clientService$.$cleanUpBeforeReload$(metricsPayload)
}, "replaceComponentDefLoader":function(method) {
  $A.$componentService$.$componentDefLoader$.$setScriptGenerator$(method)
}, "profilerControl":Aura.$Services$.$ProfilerService$, "attachDispatcherForAMSWatcher":function(dispatcher) {
  return Aura.$Services$.$MetricsService$.$watcher$.$attachDispatcher$(dispatcher)
}};
var INTEROP_FIND_OWNER = "aurainteropfindowner";
var findOwner = function(element) {
  var owner;
  if(element) {
    var interopCreateEvent = new CustomEvent(INTEROP_FIND_OWNER, {"composed":true, "bubbles":true, "cancelable":false, "detail":{"claimOwnership":function(actualOwner) {
      owner = actualOwner
    }}});
    element.dispatchEvent(interopCreateEvent)
  }
  return owner
};
Aura.$ExportsModule$ = {"dispatchGlobalEvent":function(eventName, eventParams, element) {
  var owner = findOwner(element) || $A.$getRoot$();
  $A.$clientService$.$setCurrentAccess$(owner);
  try {
    $A.$eventService$.$newEvent$(eventName).$setParams$(eventParams).$fire$()
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
}, "getEventDef":function(eventDef, eventName, sourceCmp) {
  return $A.$eventService$.$newEvent$(eventDef, eventName, sourceCmp)
}, "executeGlobalController":function(endpoint, params, options) {
  return $A.$clientService$.$unstable_executeGlobalControllerInternal$(endpoint, params, options, false)
}, "unstable_executeGlobalControllerPrivileged":function(endpoint, params, options) {
  return $A.$clientService$.$unstable_executeGlobalControllerInternal$(endpoint, params, options, true)
}, "executeGlobalControllerRawResponse":function(endpoint, params, options) {
  return $A.$clientService$.$unstable_executeGlobalControllerInternal$(endpoint, params, options, false, true, true)
}, "registerModule":function(module) {
  $A.$componentService$.$initModuleDefs$([module]);
  return module["descriptor"]
}, "hasModule":function(moduleName) {
  return $A.$componentService$.$hasModuleDefinition$(moduleName)
}, "getModule":function(moduleName) {
  return $A.$componentService$.$evaluateModuleDef$(moduleName)
}, "sanitizeDOM":function(dirty, config) {
  return $A["util"].$sanitizeDOM$(dirty, config)
}, "INTEROP_FIND_OWNER":INTEROP_FIND_OWNER, "createComponent":function(componentName, attributes, callback, hotspot, element) {
  var owner = findOwner(element) || $A.$getRoot$();
  $A.$clientService$.$setCurrentAccess$(owner);
  try {
    $A.$run$(function() {
      if(hotspot) {
        $A.$executeHotspot$(function() {
          $A.$createComponent$(componentName, attributes, $A.$getCallback$(callback))
        })
      }else {
        $A.$createComponent$(componentName, attributes, $A.$getCallback$(callback))
      }
    })
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
}, "getDefinition":function(definition, callback, hotspot, accessDescriptor) {
  var access = $A.$getRoot$();
  if(accessDescriptor) {
    var cachedDef = $A.$componentService$.$getCachedComponentDef$(accessDescriptor);
    if(cachedDef) {
      access = cachedDef
    }
  }
  $A.$clientService$.$setCurrentAccess$(access);
  try {
    $A.$run$(function() {
      if(hotspot) {
        $A.$executeHotspot$(function() {
          $A.$getDefinition$(definition, $A.$getCallback$(callback))
        })
      }else {
        $A.$getDefinition$(definition, $A.$getCallback$(callback))
      }
    })
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
}, "renderComponent":function(cmp, element) {
  var owner = findOwner(element);
  if(owner) {
    cmp.$setAttributeValueProvider$(owner)
  }
  $A.$render$(cmp, element);
  $A.$afterRender$(cmp)
}, "unrenderComponent":function(cmp) {
  $A.$unrender$(cmp)
}};
Aura.$ExportsStorage$ = {"getStorage":function(name) {
  return $A.$storageService$.$getStorage$(name)
}, "getStorages":function() {
  return $A.$storageService$.$getStorages$()
}, "initStorage":function(config) {
  return $A.$storageService$.$initStorage$(config)
}, "deleteStorage":function(name) {
  return $A.$storageService$.$deleteStorage$(name)
}};
Logger = {"log":noop, "logError":function(message) {
  var error = typeof message === "string" ? new $A.$auraError$(message) : message;
  if($A["util"].$hasSourceURL$() && !$A.$logger$.$isExternalError$(error)) {
    $A.$clientService$.$setCurrentAccess$($A.$getRoot$());
    try {
      $A.$logger$.$reportError$(error)
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
  console.error(message)
}};
Logger.log = function log() {
  window.console.log.apply(window.console, arguments)
};
Aura.$ExportsLogger$ = Logger;
var assert = noop;
assert = function(condition, message) {
  $A.assert(condition, message)
};
Aura.$ExportsAssert$ = assert;
var LTNG = "ltng";
var PERF = "performance";
var INTERACTION = "interaction";
var ERROR = "error";
var USER = "user";
var CLICK = "click";
Aura.$ExportsMetricsService$ = {"perfStart":function(name, attributes, eventSource) {
  return $A.$metricsService$.$transactionStart$(LTNG, PERF + ":" + name, {"context":{"eventSource":eventSource || name, "attributes":attributes}})
}, "perfEnd":function(name, attributes, eventSource) {
  return $A.$metricsService$.$transactionEnd$(LTNG, PERF + ":" + name, {"context":{"eventSource":eventSource || name, "attributes":attributes}})
}, "mark":function(ns, name, ctx) {
  return $A.$metricsService$["mark"](ns, name, ctx)
}, "markStart":function(ns, name, ctx) {
  return $A.$metricsService$.$markStart$(ns, name, ctx)
}, "markEnd":function(ns, name, ctx) {
  return $A.$metricsService$.$markEnd$(ns, name, ctx)
}, "time":function() {
  return $A.$metricsService$.time()
}, "interaction":function(target, scope, context, eventSource, eventType, attributes) {
  return $A.$metricsService$.transaction(LTNG, INTERACTION, {"context":{"eventSource":eventSource || CLICK, "eventType":eventType || USER, "locator":{"target":target, "scope":scope, "context":context}, "attributes":attributes}})
}, "registerCacheStats":function(name) {
  return $A.$metricsService$.$registerCacheStats$(name)
}, "error":function(attributes, eventSource, eventType) {
  return $A.$metricsService$.transaction(LTNG, ERROR, {"context":{"attributes":attributes, "eventSource":eventSource || ERROR, "eventType":eventType || ERROR}})
}, "registerPeriodicLogger":function(name, callback) {
  return $A.$metricsService$.$registerPeriodicLogger$(name, callback)
}, "removePeriodicLogger":function(id) {
  return $A.$metricsService$.$removePeriodicLogger$(id)
}, "registerPlugin":function(pluginConfig) {
  return $A.$metricsService$.$registerPlugin$(pluginConfig)
}, "enablePlugin":function(name) {
  return $A.$metricsService$.$enablePlugin$(name)
}, "disablePlugin":function(name) {
  return $A.$metricsService$.$disablePlugin$(name)
}};
function LockerService() {
  function createDescriptor(moduleDefinitionEntry) {
    var DESCRIPTOR = Json.$ApplicationKey$.$DESCRIPTOR$;
    var ACCESS = Json.$ApplicationKey$.$ACCESS$;
    var REQUIRELOCKER = Json.$ApplicationKey$.$REQUIRELOCKER$;
    var RUNTIME_NAMESPACE = Json.$ApplicationKey$.$RUNTIME_NAMESPACE$;
    var LOCKER_REFERENCE_INFO = Json.$ApplicationKey$.$LOCKER_REFERENCE_INFO$;
    var descriptor = new DefDescriptor(moduleDefinitionEntry[DESCRIPTOR] || moduleDefinitionEntry.$descriptor$);
    descriptor["access"] = moduleDefinitionEntry[ACCESS];
    descriptor["requireLocker"] = moduleDefinitionEntry[REQUIRELOCKER];
    descriptor["runtimeNamespace"] = moduleDefinitionEntry[RUNTIME_NAMESPACE];
    descriptor["depList"] = moduleDefinitionEntry[LOCKER_REFERENCE_INFO];
    return descriptor
  }
  function isLockerNextEnabledForComponent(component) {
    if(component && component.$componentDef$) {
      return!!component.$componentDef$.$lockerNext$
    }
    return false
  }
  function isLWSInternalNamespace(namespaceName, componentName) {
    var context = $A.getContext();
    if(context) {
      var isIncludedNamespace = context.$lockerAuraRuntimeIncludedNamespaces$.indexOf(namespaceName) !== -1;
      var isExcludedComponent = context.$lockerAuraRuntimeExcludedComponents$.indexOf(componentName) !== -1;
      return isIncludedNamespace && !isExcludedComponent
    }
    return false
  }
  function getComponentNamespace(component) {
    if(component && component.$componentDef$) {
      var namespace = component.$componentDef$.$descriptor$.$namespace$;
      var qualifiedName = component.$componentDef$.$descriptor$.$qualifiedName$;
      if(isLWSInternalNamespace(namespace.toLowerCase(), qualifiedName.toLowerCase())) {
        return CORE_SANDBOX_KEY
      }
      return namespace
    }
    throw new Error("Invalid component argument.");
  }
  function selectLib(lib) {
    var restricted = {"createScript":function(cmp, dirty) {
      if(!getComponentNamespace(cmp)) {
        throw new Error("Invalid component argument.");
      }
      return lib["trusted"]["createScript"](dirty)
    }};
    CORE_SANDBOX_KEY = lib["CORE_SANDBOX_KEY"] || CORE_SANDBOX_KEY;
    service.create = lib["create"];
    service.$createDescriptor$ = createDescriptor;
    service.$createForDef$ = lib["createForDef"];
    service.$createForDefNext$ = lib["createForDefNext"];
    service.$createForModule$ = lib["createForModule"];
    service.$evaluateInCoreSandbox$ = lib["evaluateInCoreSandbox"];
    service.$evaluateInSandbox$ = lib["evaluateInSandbox"];
    service.$evaluateModuleInSandbox$ = lib["evaluateModuleInSandbox"];
    service.$getEnv$ = lib["getEnv"];
    service.$getComponentNamespace$ = getComponentNamespace;
    service.$getEnvForSecureObject$ = lib["getEnvForSecureObject"];
    service.$getKeyForNamespace$ = lib["getKeyForNamespace"];
    service.$getRaw$ = lib["getRaw"];
    service.$injectO11yDependency$ = lib["injectO11yDependency"];
    service.$instanceOf$ = lib["instanceOf"];
    service.isEnabled = lib["isEnabled"];
    service.$isLockerNextEnabledForComponent$ = isLockerNextEnabledForComponent;
    service.$isLWSInternalNamespace$ = isLWSInternalNamespace;
    service.$isSecureLightningElement$ = lib["isSecureLightningElement"];
    service.$lwsAuraPolicy$ = lib["lwsAuraPolicy"];
    service.$markLiveObject$ = lib["markLiveObject"];
    service.$runScript$ = lib["runScript"];
    service.$trust$ = lib["trust"];
    service.$unwrap$ = lib["unwrap"];
    service.$wrap$ = lib["wrap"];
    service.$wrapComponent$ = lib["wrapComponent"];
    service.$wrapComponentEvent$ = lib["wrapComponentEvent"];
    service.$createForLibNext$ = lib["createForLibNext"];
    service.$trusted$ = lib["trusted"];
    service["create"] = service.create;
    service["createForDef"] = service.$createForDef$;
    service["createForDefNext"] = service.$createForDefNext$;
    service["getComponentNamespace"] = getComponentNamespace;
    service["getEnv"] = service.$getEnv$;
    service["getEnvForSecureObject"] = service.$getEnvForSecureObject$;
    service["getKeyForNamespace"] = service.$getKeyForNamespace$;
    service["isLockerNextEnabledForComponent"] = isLockerNextEnabledForComponent;
    service["injectO11yDependency"] = service.$injectO11yDependency$;
    service["lwsAuraPolicy"] = service.$lwsAuraPolicy$;
    service["markLiveObject"] = service.$markLiveObject$;
    service["restricted"] = restricted;
    service["runScript"] = service.$runScript$;
    service["trust"] = service.$trust$;
    service["wrapComponent"] = service.$wrapComponent$
  }
  function getPublicMethodNames(component) {
    var methodsNames = [];
    if(component instanceof Aura.$Component$.$InteropComponent$) {
      methodsNames = component.$getPublicMethodNames$()
    }else {
      var defs = component.$getDef$().$methodDefs$;
      if(defs && defs.length) {
        methodsNames = defs.map(function getDefDescriptorName(method) {
          var descriptor = new DefDescriptor(method.name);
          return descriptor.getName()
        })
      }
    }
    return methodsNames
  }
  function warn(message) {
    $A.$warning$(message)
  }
  function initialize(context) {
    if(isInitialized) {
      return
    }
    context = context || {};
    var defaultNamespace = context[Json.$ApplicationKey$.$DEFAULT_NAMESPACE$];
    var isEnabled = context[Json.$ApplicationKey$.$LOCKER_ENABLED$];
    var isNextInstrumentationEnabled = context[Json.$ApplicationKey$.$LOCKER_NEXT_INSTRUMENTATION$];
    var isStrictCSP = context[Json.$ApplicationKey$.$LOCKER_STRICT_CSP$];
    var isFrozenRealm = context[Json.$ApplicationKey$.$LOCKER_FROZEN_REALM$];
    var isSafeConfig = context[Json.$ApplicationKey$.$AURARUNTIMESECUREEVAL$];
    var lockerAPIVersion = context[Json.$ApplicationKey$.$LOCKER_API_VERSION$];
    var lockerGaterEnabledFeatures = context[Json.$ApplicationKey$.$LOCKER_GATER_ENABLED_FEATURES$];
    var runtimeNamespaces = context[Json.$ApplicationKey$.$RUNTIME_NAMESPACES$];
    if(isEnabled && !!window["AuraLocker"]) {
      var types = {"Action":Aura.$Controller$.$Action$, "Component":Aura.$Component$.$Component$, "Event":Aura.$Event$.$Event$, "PropertyReferenceValue":Aura.$Value$.$PropertyReferenceValue$};
      var api = {"AuraInstance":$A, "isSafeConfig":isSafeConfig, "getPublicMethodNames":getPublicMethodNames, "runtimeNamespaces":runtimeNamespaces, "defaultNamespace":defaultNamespace, "apiVersion":lockerAPIVersion, "isNextInstrumentationEnabled":isNextInstrumentationEnabled, "isStrictCSP":isStrictCSP, "isFrozenRealm":isFrozenRealm, "lockerGaterEnabledFeatures":lockerGaterEnabledFeatures, "warn":warn, "error":$A.$auraError$, "severity":$A.severity};
      if($A.$componentService$.$moduleEngine$) {
        var lwcApi = {"unwrap":$A.$componentService$.$moduleEngine$["unwrap"], "lwcIsNodeFromTemplate":$A.$componentService$.$moduleEngine$["isNodeFromTemplate"], "lwcUnwrap":$A.$componentService$.$moduleEngine$["unwrap"], "lwcGetComponentDef":$A.$componentService$.$moduleEngine$["getComponentDef"], "lwcGetComponentConstructor":$A.$componentService$.$moduleEngine$["getComponentConstructor"], "LightningElement":$A.$componentService$.$moduleEngine$["LightningElement"]};
        Object.assign(api, lwcApi)
      }
      var lib = window["AuraLocker"];
      selectLib(lib);
      lib["initialize"](types, api)
    }
    Object.freeze(service);
    isInitialized = true
  }
  var isInitialized = false;
  var CORE_SANDBOX_KEY = "lws-core-sandbox";
  var service = {};
  selectLib(window["AuraLockerDisabled"]);
  service.$initialize$ = initialize;
  service["initialize"] = service.$initialize$;
  return service
}
Aura.$Services$.$LockerService$ = LockerService;
function AuraInstance() {
  this.$globalValueProviders$ = {};
  this.$displayErrors$ = true;
  this.$initializers$ = {};
  this.$logger$ = new Aura.$Utils$.$Logger$;
  this["util"] = new Aura.$Utils$.$Util$;
  this["util"] = this["util"];
  this.$auraError$ = Aura.$Errors$.$AuraError$;
  this.$auraFriendlyError$ = Aura.$Errors$.$AuraFriendlyError$;
  this.$isDisplayableError$ = Aura.$Errors$.$isDisplayableError$;
  this["isDisplayableError"] = this.$isDisplayableError$;
  this.severity = {$ALERT$:"ALERT", $FATAL$:"FATAL", $QUIET$:"QUIET"};
  this.$lastKnownError$ = null;
  this.$localizationService$ = new Aura.$Services$.$AuraLocalizationService$;
  this.$clientService$ = new Aura.$Services$.$AuraClientService$(this["util"]);
  this.$componentService$ = new Aura.$Services$.$AuraComponentService$;
  this.$renderingService$ = new Aura.$Services$.$AuraRenderingService$;
  this.$expressionService$ = new Aura.$Services$.$AuraExpressionService$;
  this.$historyService$ = new Aura.$Services$.$AuraHistoryService$;
  this.$eventService$ = new Aura.$Services$.$AuraEventService$;
  this.$storageService$ = new Aura.$Services$.$AuraStorageService$;
  this.$styleService$ = new Aura.$Services$.$AuraStyleService$;
  this.$metricsService$ = new Aura.$Services$.$MetricsService$;
  this.$profilerService$ = Aura.$Services$.$ProfilerService$;
  this.$lockerService$ = new Aura.$Services$.$LockerService$;
  this.$injectedServices$ = {"localization":this.$localizationService$, "metrics":this.$metricsService$};
  this.$services$ = {$rendering$:this.$renderingService$, event:this.$eventService$, $component$:this.$componentService$, $client$:this.$clientService$, history:this.$historyService$, $storage$:this.$storageService$, $cmp$:this.$componentService$, $e$:this.$eventService$, style:this.$styleService$, $metrics$:this.$metricsService$, $locker$:this.$lockerService$, get:function(key) {
    var ret = $A.$services$[key];
    if(!ret && key === "root") {
      return $A.$getRoot$()
    }
    return ret
  }};
  this.$Component$ = Component;
  this.$enqueueAction$ = this.$clientService$.$enqueueAction$.bind(this.$clientService$);
  this.$deferPendingActions$ = this.$clientService$.$deferPendingActions$.bind(this.$clientService$);
  this.$runAfterInit$ = this.$clientService$.$runAfterInitDefs$.bind(this.$clientService$);
  this.$render$ = this.$renderingService$.$render$.bind(this.$renderingService$);
  this.$rerender$ = this.$renderingService$.$rerender$.bind(this.$renderingService$);
  this.$unrender$ = this.$renderingService$.$unrender$.bind(this.$renderingService$);
  this.$afterRender$ = this.$renderingService$.$afterRender$.bind(this.$renderingService$);
  this.$getCmp$ = this.$componentService$.get.bind(this.$componentService$);
  this.$getComponent$ = this.$componentService$.$getComponent$.bind(this.$componentService$);
  this.$createComponent$ = this.$componentService$["createComponent"].bind(this.$componentService$);
  this.$createComponents$ = this.$componentService$["createComponents"].bind(this.$componentService$);
  this.$createComponentFromConfig$ = this.$componentService$.$createComponentFromConfig$.bind(this.$componentService$);
  this.$getEvt$ = this.$eventService$.$newEvent$.bind(this.$eventService$);
  this.$newCmp$ = this.$componentService$["newComponentDeprecated"].bind(this.$componentService$);
  this.$newCmpDeprecated$ = this.$componentService$["newComponentDeprecated"].bind(this.$componentService$);
  this.$newCmpAsync$ = this.$componentService$["newComponentAsync"].bind(this.$componentService$);
  this.$pushCreationPath$ = function(creationPath) {
    var ctx = this.getContext();
    if(!ctx) {
      return
    }
    var act = ctx.$getCurrentAction$();
    if(!act) {
      return
    }
    act.$pushCreationPath$(creationPath)
  };
  this.$popCreationPath$ = function(creationPath) {
    var ctx = this.getContext();
    if(!ctx) {
      return
    }
    var act = ctx.$getCurrentAction$();
    if(!act) {
      return
    }
    act.$popCreationPath$(creationPath)
  };
  this.$setCreationPathIndex$ = function(idx) {
    var ctx = this.getContext();
    if(!ctx) {
      return
    }
    var act = ctx.$getCurrentAction$();
    if(!act) {
      return
    }
    act.$setCreationPathIndex$(idx)
  };
  this["runAfterInit"] = this.$runAfterInit$;
  this["clientService"] = this.$clientService$;
  this["componentService"] = this.$componentService$;
  this["renderingService"] = this.$renderingService$;
  this["expressionService"] = this.$expressionService$;
  this["historyService"] = this.$historyService$;
  this["localizationService"] = this.$localizationService$;
  this["eventService"] = this.$eventService$;
  this["layoutService"] = this.$layoutService$;
  this["metricsService"] = this.$metricsService$;
  this["profilerService"] = this.$profilerService$;
  this["lockerService"] = this.$lockerService$;
  this["storageService"] = this.$storageService$;
  this["styleService"] = this.$styleService$;
  this["services"] = this.$services$;
  this["enqueueAction"] = this.$enqueueAction$;
  this["deferPendingActions"] = this.$deferPendingActions$;
  this["render"] = this.$render$;
  this["rerender"] = this.$rerender$;
  this["unrender"] = this.$unrender$;
  this["afterRender"] = this.$afterRender$;
  this["logger"] = this.$logger$;
  this["getCmp"] = this.$getCmp$;
  this["getComponent"] = this.$getComponent$;
  this["pushCreationPath"] = this.$pushCreationPath$;
  this["popCreationPath"] = this.$popCreationPath$;
  this["setCreationPathIndex"] = this.$setCreationPathIndex$;
  this["createComponent"] = this.$createComponent$;
  this["createComponents"] = this.$createComponents$;
  this["createComponentFromConfig"] = this.$createComponentFromConfig$;
  this["getEvt"] = this.$getEvt$;
  this["Component"] = this.$Component$;
  this["auraFriendlyError"] = this.$auraFriendlyError$;
  this["severity"] = this.severity;
  this["severity"]["ALERT"] = this.severity.$ALERT$;
  this["severity"]["FATAL"] = this.severity.$FATAL$;
  this["severity"]["QUIET"] = this.severity.$QUIET$;
  this["severity"] = Object.freeze(this["severity"]);
  this["hasDefinition"] = this.$hasDefinition$;
  this["getDefinition"] = this.$getDefinition$;
  this["getDefinitions"] = this.$getDefinitions$;
  this["newCmp"] = this.$newCmp$;
  this["newCmpDeprecated"] = this.$newCmpDeprecated$;
  this["newCmpAsync"] = this.$newCmpAsync$;
  var services = this.$services$;
  services["rendering"] = services.$rendering$;
  services["event"] = services.event;
  services["component"] = services.$component$;
  services["client"] = services.$client$;
  services["history"] = services.history;
  services["storage"] = services.$storage$;
  services["metrics"] = services.$metrics$;
  services["cmp"] = services.$cmp$;
  services["e"] = services.$e$;
  services["c"] = {get:function(name) {
    var path = (name || "").split(".");
    var controllerDef = path.shift();
    var action = path.shift();
    return services.$component$.$getControllerDef$(controllerDef).get(action)
  }}
}
AuraInstance.prototype.$beforeInitHooks$ = function() {
  var fncs = Aura["beforeFrameworkInit"];
  if(fncs && fncs.length) {
    for(var i = 0;i < fncs.length;i++) {
      fncs[i]()
    }
  }
};
AuraInstance.prototype.$afterInitHooks$ = function() {
  var fncs = Aura["afterFrameworkInit"];
  if(fncs && fncs.length) {
    for(var i = 0;i < fncs.length;i++) {
      fncs[i]()
    }
  }
};
AuraInstance.prototype.$initAsync$ = function(config) {
  Aura.$bootstrapMark$("runInitAsync");
  this.$beforeInitHooks$();
  this.$clientService$.$setNamespacePrivileges$(config["ns"]);
  this.$clientService$.$setQueueSize$(config["MaxParallelXHRCount"]);
  this.$clientService$.$setXHRExclusivity$(config["XHRExclusivity"]);
  this.$clientService$.$setBoxcarReduction$(config["boxcarReduction"]);
  this.$clientService$.$setLabelsFromStorage$(config["LabelsFromStorage"]);
  this.$clientService$.$setBootstrapInlined$(config["bootstrapInlined"]);
  this.$clientService$.$setAuraCmpDefBaseURI$(config["auraCmpDefBaseURI"], config["auraCmpDefBaseURIAuth"]);
  this.$clientService$.$setCdnEnabledForLatestDefRequest$(config["cdnForLatestDef"]);
  this.$clientService$.$setIsLiveEnabledForRestrictedDefRequest$(config["isLive"]);
  this.$clientService$.$setComponentUids$(config["componentUids"]);
  this.$clientService$.$setAuraBundlingDisabled$(config["disableAuraBundling"]);
  this.$clientService$.$setCsrfV2Enabled$(!!config["csrfV2"]);
  this.$initializers$ = config["initializers"];
  $A.$context$ = new Aura.$Context$.$AuraContext$(config["context"], function(context) {
    function reportError(e) {
      $A.$reportError$("Error initializing the application", e)
    }
    function initializeApp() {
      return $A.$clientService$.$initializeApplication$()["then"](function initializeApplicationSuccess(bootConfig) {
        $A.$run$(function() {
          $A.$initPriv$(bootConfig)
        })
      }, reportError)
    }
    function ensureCssLoaded() {
      return new Promise(function(resolve) {
        if(Aura["bootstrap"]["appCssLoading"]) {
          Aura["bootstrap"]["appCssLoadedCallback"] = resolve
        }else {
          resolve()
        }
      })
    }
    function gvpLoadPromise() {
      if(context.$uriAddressableDefsEnabled$) {
        return Promise["resolve"]()
      }else {
        return context.$globalValueProviders$.$loadFromStorage$()
      }
    }
    $A.$context$ = context;
    $A.$clientService$.$reloadPointPassed$ = true;
    if($A.$clientService$.$reloadFunction$) {
      $A.$clientService$.$reloadFunction$();
      return
    }
    if(context.$uriAddressableDefsEnabled$) {
      Aura.$Component$.$ComponentDefStorage$.prototype.$useDefStore$ = false
    }
    $A.$clientService$.$initHost$(config["host"]);
    if(config["token"]) {
      $A.$clientService$.$setToken$(config["token"])
    }else {
      if(config["eikoocnekot"]) {
        $A.$clientService$.$setToken$($A.$clientService$.$buildToken$(config["eikoocnekot"], true))
      }
    }
    $A.$clientService$.$initStaticResourceDomainAndGVP$(config["staticResourceDomain"]);
    $A.$metricsService$.$initialize$();
    gvpLoadPromise()["then"](function gvpLoadPromiseSuccess() {
      $A.$clientService$.$gvpsFromStorage$ = context.$globalValueProviders$.$LOADED_FROM_PERSISTENT_STORAGE$;
      if(!$A.$clientService$.$gvpsFromStorage$) {
        $A.log("Aura.initAsync: GVP not loaded from storage so not loading defs or actions either");
        ensureCssLoaded()["then"](initializeApp)["then"](undefined, reportError)
      }else {
        Promise["all"]([$A.$componentService$.$restoreDefsFromStorage$(context), $A.$clientService$.$populateActionsFilter$(), ensureCssLoaded()])["then"](initializeApp, function clearActionsAndInitApp(err) {
          $A.log("Aura.initAsync: failed to load defs, get bootstrap or actions from storage", err);
          $A.$clientService$.$clearActionsFilter$();
          return initializeApp()
        })["then"](undefined, reportError)
      }
    })
  });
  this.$clientService$.$initDefs$();
  $A.$executeExternalLibraries$()
};
AuraInstance.prototype.$executeExternalLibraries$ = function() {
  if(Aura["externalLibraries"]) {
    Aura["externalLibraries"].call(window)
  }
};
AuraInstance.prototype.$initConfig$ = function(config, useExisting, doNotInitializeServices) {
  this.$clientService$.$setNamespacePrivileges$(config["ns"]);
  this.$clientService$.$setQueueSize$(config["MaxParallelXHRCount"]);
  this.$clientService$.$setXHRExclusivity$(config["XHRExclusivity"]);
  this.$clientService$.$setLabelsFromStorage$(config["LabelsFromStorage"]);
  this.$clientService$.$setAuraCmpDefBaseURI$(config["auraCmpDefBaseURI"], config["auraCmpDefBaseURIAuth"]);
  this.$clientService$.$setCdnEnabledForLatestDefRequest$(config["cdnForLatestDef"]);
  this.$clientService$.$setIsLiveEnabledForRestrictedDefRequest$(config["isLive"]);
  this.$initializers$ = config["initializers"];
  this.$beforeInitHooks$();
  $A.$executeExternalLibraries$();
  if(!useExisting || $A["util"].$isUndefined$($A.getContext())) {
    $A.$clientService$.$initHost$(config["host"], config["sid"]);
    $A.$context$ = new Aura.$Context$.$AuraContext$(config["context"], function(context) {
      $A.$context$ = context;
      if(context.$uriAddressableDefsEnabled$) {
        Aura.$Component$.$ComponentDefStorage$.prototype.$useDefStore$ = false
      }
      $A.$clientService$.$initDefs$();
      $A.$clientService$.$initStaticResourceDomainAndGVP$(config["staticResourceDomain"]);
      $A.$metricsService$.$initialize$();
      $A.$initPriv$(config["instance"], config["token"], null, doNotInitializeServices);
      $A.$context$.$clearComponentConfigs$($A.$context$.$getCurrentAction$().$getId$());
      $A.$context$.$setCurrentAction$(null)
    })
  }else {
    $A.getContext()["mergeContext"](config["context"])
  }
};
AuraInstance.prototype.$initPriv$ = function(config, token, container, doNotInitializeServices) {
  Aura.$bootstrapMark$("AuraFrameworkEPT");
  if(!$A["hasErrors"]) {
    $A.$addTearDownHandler$();
    $A.$clientService$.$initializeClientLibraries$();
    $A.$clientService$.$initializeInjectedServices$($A.$context$.$moduleServices$);
    $A.$localizationService$.$init$();
    var app = $A.$clientService$["init"](config, token, $A["util"].$getElement$(container));
    $A.$setRoot$(app);
    if(!$A.$initialized$) {
      $A.$initialized$ = true;
      $A.$addDefaultEventHandlers$(app);
      $A.$afterInitHooks$();
      $A.$finishInit$(doNotInitializeServices)
    }
  }
};
AuraInstance.prototype.$addTearDownHandler$ = function() {
  window.addEventListener("unload", $A.$getCallback$(function beaconingWrapper() {
    var actions = [];
    if(this.$deprecatedBeaconing$) {
      var deprecatedAction = this.$deprecatedBeaconing$.$generateAction$();
      if(deprecatedAction) {
        actions.push(deprecatedAction)
      }
    }
    if(this.$usageBeaconing$) {
      var usageAction = this.$usageBeaconing$.$generateAction$();
      if(usageAction) {
        actions.push(usageAction)
      }
    }
    if(actions.length) {
      $A.$clientService$.$sendBeacon$(actions)
    }
  }.bind(this)));
  window.addEventListener("unload", $A.$getCallback$($A.$clientService$.$tearDown$.bind($A.$clientService$)))
};
AuraInstance.prototype.$addDefaultEventHandlers$ = function(app) {
  app.$addEventHandler$("aura:clientRedirect", $A.$defaultRedirectHandler$);
  app.$addEventHandler$("aura:systemError", $A.$defaultErrorHandler$);
  app.$addEventHandler$("aura:customerError", $A.$defaultErrorHandler$)
};
AuraInstance.prototype.$defaultErrorHandler$ = function(event) {
  if(event["handled"]) {
    return
  }
  $A.message(event.$getParam$("message"), event.$getParam$("auraError"));
  event["handled"] = true
};
AuraInstance.prototype.$defaultRedirectHandler$ = function(evt) {
  var url = evt.$getParam$("url");
  if(url != null) {
    var protocolDenylist = ["javascript", "data"];
    var doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
    var testXSSLink = doc.createElement("a");
    testXSSLink.setAttribute("href", url);
    if(testXSSLink.protocol != null) {
      for(var i = 0;i < protocolDenylist.length;i++) {
        if(testXSSLink.protocol.indexOf(protocolDenylist[i]) === 0) {
          url = encodeURIComponent(url);
          break
        }
      }
    }
    window.location = url
  }
};
AuraInstance.prototype.$finishInit$ = function(doNotInitializeServices) {
  if(!this["finishedInit"]) {
    $A["util"].$removeClass$(document.body, "loading");
    delete $A.$globalValueProviders$;
    this["finishedInit"] = true;
    $A.$metricsService$.$applicationReady$();
    $A.$eventService$.$getNewEvent$("markup://aura:initialized").$fire$();
    $A.$clientService$.$clearReloadCount$()
  }
  if(!doNotInitializeServices && !Aura["disableHistoryService"]) {
    $A.$historyService$.$init$()
  }
  var readyCallbacks = Aura["afterAppReady"];
  for(var i in readyCallbacks) {
    readyCallbacks[i]()
  }
  delete Aura["afterAppReady"];
  Aura["applicationReady"] = true
};
AuraInstance.prototype.error = function(msg, e) {
  this.$logger$.$logError$(msg, e)
};
AuraInstance.prototype.$showErrors$ = function(toggle) {
  if(toggle !== undefined) {
    this.$displayErrors$ = !!toggle
  }
  return this.$displayErrors$
};
var errorHistoryStorage;
AuraInstance.prototype.handleError = function(message, e) {
  var ctx = $A.getContext();
  var dispMsg = message;
  var evtArgs = {"message":dispMsg, "error":null, "auraError":null};
  if(e) {
    if(e["handled"]) {
      return
    }else {
      e["handled"] = true
    }
    if(e instanceof $A.$auraFriendlyError$) {
      e.severity = e.severity || this.severity.$QUIET$;
      evtArgs = {"message":e["message"], "error":e["name"], "auraError":e}
    }else {
      if(e instanceof $A.$auraError$) {
        var format = "This page has an error. You might just need to refresh it.\n{0}";
        e.severity = e.severity || this.severity["ALERT"];
        var displayMessage = e.message || e.name;
        displayMessage += "\n" + (e["component"] ? "Failing descriptor: {" + e["component"] + "}" : "");
        dispMsg = $A["util"].$format$(format, displayMessage);
        evtArgs = {"message":dispMsg, "error":null, "auraError":e}
      }else {
        e = new $A.$auraError$(null, e);
        var component = e.$findComponentFromStackTrace$();
        e.$setComponent$(component);
        evtArgs = {"message":dispMsg, "error":null, "auraError":e}
      }
    }
  }
  var isCustomerError = $A.$isCustomerError$(e);
  if(ctx && ctx.$isErrorExperienceEnabled$()) {
    evtArgs["timestamp"] = Date.now();
    evtArgs["isCustomerError"] = isCustomerError;
    if(!errorHistoryStorage && $A.$storageService$) {
      errorHistoryStorage = $A.$storageService$.$getStorage$("ErrorHistory")
    }
    if(errorHistoryStorage) {
      errorHistoryStorage.set(evtArgs.timestamp.toString(), evtArgs)
    }
  }
  if($A.$initialized$) {
    window.setTimeout(function fireDeferedError() {
      if(isCustomerError) {
        $A.$eventService$.$getNewEvent$("markup://aura:customerError").$fire$(evtArgs)
      }else {
        $A.$eventService$.$getNewEvent$("markup://aura:systemError").$fire$(evtArgs)
      }
    }, 0)
  }else {
    if($A.$showErrors$()) {
      $A.message(dispMsg, e)
    }
  }
};
AuraInstance.prototype.$isCustomerError$ = function(e) {
  if(e && e instanceof $A.$auraError$) {
    if(e["component"]) {
      if($A.$isCustomerComponent$(e["component"])) {
        return true
      }else {
        if(e["componentStack"]) {
          if($A.$isCustomerComponentStack$(e["componentStack"])) {
            return true
          }
        }
      }
    }
    if(e["stacktraceIdGen"] && /\$\/c\/./g.test(e["stacktraceIdGen"])) {
      return true
    }
  }
  return false
};
AuraInstance.prototype.$isCustomerComponent$ = function(cmp) {
  if(!$A["util"].$isEmpty$(cmp)) {
    var descriptor = $A.$componentService$.$createDescriptorConfig$(cmp.split("$", 1)[0]);
    var componentDef = $A.$componentService$.$getComponentDef$(descriptor);
    if(!$A["util"].$isUndefinedOrNull$(componentDef)) {
      descriptor = componentDef.$getDescriptor$()
    }else {
      descriptor = new DefDescriptor(descriptor[Json.$ApplicationKey$.$DESCRIPTOR$])
    }
    var namespace = descriptor.$getNamespace$();
    var internal = $A.$clientService$.$isInternalNamespace$(namespace);
    var privileged = $A.$clientService$.$isPrivilegedNamespace$(namespace);
    if(!$A["util"].$isEmpty$(namespace) && !internal && !privileged) {
      return true
    }
  }
  return false
};
AuraInstance.prototype.$isCustomerComponentStack$ = function(cmpStack) {
  if(!$A["util"].$isEmpty$(cmpStack)) {
    var stack = cmpStack.split("\x3e");
    for(var i = stack.length - 1;i >= 0;i--) {
      var cmp = stack[i];
      if(!$A["util"].$isUndefinedOrNull$(cmp)) {
        cmp = cmp.trim().replace(new RegExp("^\\[|\\]$", "g"), "");
        if($A.$isCustomerComponent$(cmp)) {
          return true
        }
      }
    }
  }
  return false
};
AuraInstance.prototype.$reportError$ = function(message, error) {
  if($A.$logger$.$isExternalError$(error)) {
    return false
  }
  error = error || (this.$lastKnownError$ && message && message.indexOf(this.$lastKnownError$.message) > -1 ? this.$lastKnownError$ : null) || new $A.$auraError$("[NoErrorObjectAvailable] " + message);
  $A.handleError(message, error);
  if($A.$initialized$ && $A["util"].$hasSourceURL$()) {
    $A.$getCallback$(function() {
      if(error && message) {
        if(message !== error.message && message.indexOf(error.message) > -1) {
          error.message = message + ". Caused by: " + error.message
        }
      }
      var reportingLevel = $A.$logger$.$isExternalRaisedError$(error) ? "WARNING" : "ERROR";
      $A.$logger$.$reportError$(error, null, reportingLevel)
    })();
    $A.$clientService$.$postProcess$()
  }
  this.$lastKnownError$ = null;
  return true
};
AuraInstance.prototype.$warning$ = function(w, e) {
  this.$logger$.$warning$(w, e)
};
AuraInstance.prototype.message = function(msg, error, showReload) {
  if(!this.$displayErrors$) {
    return
  }
  var message = $A["util"].$getElement$("auraErrorMessage");
  message.innerHTML = "";
  message.appendChild(document.createTextNode(msg));
  $A["util"].$removeClass$(document.body, "loading");
  if(showReload) {
    $A["util"].$addClass$($A["util"].$getElement$("auraErrorReload"), "show")
  }
  $A["util"].$addClass$($A["util"].$getElement$("auraErrorMask"), "auraForcedErrorBox")
};
AuraInstance.prototype.$getCallback$ = function(callback) {
  function callbackWrapper() {
    $A.$clientService$.$setCurrentAccess$(context);
    $A.$clientService$.$pushStack$("$A.getCallback()");
    try {
      return callback.apply(this, Array.prototype.slice.call(arguments))
    }catch(e) {
      if(e instanceof $A.$auraError$) {
        throw e;
      }else {
        var syntheticStackFrame = "";
        if(arguments.length === 2) {
          var action = arguments[0];
          if($A["util"].$isAction$(action)) {
            var actionDef = action.$getDef$();
            if(actionDef) {
              syntheticStackFrame = actionDef.$getDescriptor$().toString()
            }
          }
          var actionComponent = arguments[1];
          var actionComponentDefDescriptor = null;
          if($A["util"].$isComponent$(actionComponent)) {
            var actionComponentDef = actionComponent.$getDef$();
            if(actionComponentDef) {
              actionComponentDefDescriptor = actionComponentDef.$getDescriptor$().toString()
            }
          }
          if(syntheticStackFrame) {
            syntheticStackFrame = syntheticStackFrame + (actionComponentDefDescriptor ? "@" + actionComponentDefDescriptor : "") + "\n"
          }
        }
        var errorWrapper = new $A.$auraError$("Error in $A.getCallback()", e);
        if(syntheticStackFrame) {
          errorWrapper.$setStackTrace$(syntheticStackFrame + errorWrapper.$stackTrace$)
        }
        $A.$lastKnownError$ = errorWrapper;
        throw errorWrapper;
      }
    }finally {
      try {
        $A.$clientService$.$popStack$("$A.getCallback()")
      }finally {
        $A.$clientService$.$releaseCurrentAccess$()
      }
    }
  }
  $A.assert($A["util"].$isFunction$(callback), "$A.getCallback(): 'callback' must be a valid Function");
  var context = $A.$clientService$.$currentAccess$;
  if(callback.$reference$ && callback.toString() === callbackWrapper.toString()) {
    return callback
  }
  callbackWrapper.$reference$ = callback;
  return callbackWrapper
};
AuraInstance.prototype.$executeHotspot$ = function(callback) {
  if(!$A["util"].$isFunction$(callback)) {
    throw new Error("$A.executeHotspot: 'callback' must be a valid Function.");
  }
  this.$clientService$.$allowFlowthrough$ = true;
  try {
    callback()
  }finally {
    this.$clientService$.$allowFlowthrough$ = false
  }
};
AuraInstance.prototype.$getToken$ = function(token) {
  var context = $A.getContext();
  var tokens = context && context.$getTokens$();
  if(tokens) {
    if(tokens.hasOwnProperty(token)) {
      return tokens[token]
    }
    throw new $A.$auraError$("Unknown token: '" + token + "'. Are you missing a tokens file or declaration?");
  }
};
AuraInstance.prototype.$getService$ = function(name) {
  return this.$injectedServices$[name]
};
goog.$exportSymbol$("AuraInstance.prototype.getService", AuraInstance.prototype.$getService$);
AuraInstance.prototype.get = function(key, callback) {
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  var root = path.shift();
  var valueProvider = $A.$services$[root] || $A.$getValueProvider$(root);
  if(valueProvider) {
    if(path.length) {
      if(valueProvider.get) {
        return valueProvider.get(path.join("."), callback)
      }else {
        return $A.$expressionService$.$resolve$(path, valueProvider)
      }
    }
    return valueProvider.$getValues$ ? valueProvider.$getValues$() : valueProvider
  }
};
AuraInstance.prototype.set = function(key, value) {
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  var root = path.shift();
  var valueProvider = $A.$getValueProvider$(root);
  if(!valueProvider) {
    $A.assert(false, "Unable to set value for key '" + key + "'. No value provider was found for '" + root + "'.")
  }
  if(!valueProvider["set"]) {
    $A.assert(false, "Unable to set value for key '" + key + "'. Value provider does not implement 'set(key, value)'.")
  }
  var oldValue = $A.get(key);
  var result = valueProvider["set"](path.join("."), value);
  $A.$expressionService$.$updateGlobalReference$(key, oldValue, value);
  return result
};
AuraInstance.prototype.$getReference$ = function(key) {
  return $A.$expressionService$.$getReference$(key)
};
goog.$exportSymbol$("AuraInstance.prototype.getReference", AuraInstance.prototype.$getReference$);
Aura.$OverrideMap$Instance$ = undefined;
AuraInstance.prototype.$installOverride$ = function(name, fn, scope, priority) {
  if(Aura.$OverrideMap$Instance$ === undefined) {
    Aura.$OverrideMap$Instance$ = new Aura.$OverrideMap$
  }
  if(priority === undefined) {
    priority = 50
  }
  var override = Aura.$OverrideMap$Instance$.map[name];
  if(!override) {
    throw new $A.$auraError$("$A.installOverride: Invalid name: " + name, null, $A.severity.$QUIET$);
  }
  $A.assert(fn && $A["util"].$isFunction$(fn), "Function must be a defined function");
  override.$install$(fn, scope, priority)
};
AuraInstance.prototype.$uninstallOverride$ = function(name, fn) {
  if(Aura.$OverrideMap$Instance$ === undefined) {
    Aura.$OverrideMap$Instance$ = new Aura.$OverrideMap$
  }
  var override = Aura.$OverrideMap$Instance$.map[name];
  if(!override) {
    throw new $A.$auraError$("$A.uninstallOverride: Invalid name: " + name, null, $A.severity.$QUIET$);
  }
  override.$uninstall$(fn)
};
AuraInstance.prototype.$getRoot$ = function() {
  return this.root
};
goog.$exportSymbol$("AuraInstance.prototype.getRoot", AuraInstance.prototype.$getRoot$);
AuraInstance.prototype.$setRoot$ = function(root) {
  this.root = root
};
AuraInstance.prototype.getContext = function() {
  return this.$context$
};
AuraInstance.prototype.$run$ = function(func, name) {
  $A.assert(func && $A["util"].$isFunction$(func), "The parameter 'func' for $A.run() must be a function!");
  if(name === undefined) {
    name = "$A.run()"
  }
  var nested = $A.$clientService$.$inAuraLoop$();
  $A.$clientService$.$pushStack$(name);
  try {
    return func()
  }catch(e) {
    if(nested || e instanceof $A.$auraFriendlyError$) {
      throw e;
    }else {
      throw e instanceof $A.$auraError$ ? e : new $A.$auraError$("Uncaught error in " + name, e);
    }
  }finally {
    $A.$clientService$.$popStack$(name)
  }
  return undefined
};
AuraInstance.prototype.assert = function(condition, assertMessage) {
  if(!condition) {
    this.$logger$.log(this.$logger$.$ASSERT$, "Assertion Failed!: " + assertMessage + " : " + condition)
  }
};
AuraInstance.prototype.$userAssert$ = function(condition, msg) {
  $A.assert(condition, msg)
};
AuraInstance.prototype.log = function(value, error) {
  this.$logger$.info(value, error)
};
AuraInstance.prototype.trace = function() {
  if(window["console"] && window["console"]["trace"]) {
    window["console"]["trace"]()
  }
};
function Beaconing(actionEndPoint) {
  this.$_actionEndPoint$ = actionEndPoint;
  this.$_signatures$ = {};
  this.$_hasData$ = false
}
Beaconing.prototype.$queue$ = function(apiToLog, caller) {
  var callers = this.$_signatures$[apiToLog];
  if(callers === undefined) {
    callers = {};
    this.$_signatures$[apiToLog] = callers;
    this.$_hasData$ = true
  }
  callers[caller] = callers[caller] ? callers[caller] + 1 : 1;
  if(!this.$_beaconingTimeoutId$) {
    var callback = $A.$getCallback$(function reportUsage() {
      if(this.$_flushToServer$()) {
        for(var api in this.$_signatures$) {
          delete this.$_signatures$[api]
        }
        this.$_hasData$ = false
      }
      this.$_beaconingTimeoutId$ = setTimeout(callback, 1E4)
    }).bind(this);
    this.$_beaconingTimeoutId$ = setTimeout(callback, 1E4)
  }
};
Beaconing.prototype.$generateAction$ = function(immediately) {
  if(this.$_hasData$) {
    var reportAction = $A.get(this.$_actionEndPoint$);
    reportAction.$setParams$({"usages":$A["util"].apply({}, this.$_signatures$)});
    immediately || reportAction.$setCaboose$();
    return reportAction
  }
  return null
};
Beaconing.prototype.$_flushToServer$ = function() {
  var reportAction = this.$generateAction$();
  if(reportAction) {
    $A.$clientService$.$enqueueAction$(reportAction);
    return true
  }
  return false
};
AuraInstance.prototype.$_reportUsageHelper$ = function(isDeprecated, reportSignature, message, workaround) {
  var callingCmp = $A.$clientService$.$getCurrentAccessName$();
  if(/^(ui|aura):\w+$/.test(callingCmp)) {
    return
  }
  var callStack = (new Error).stack;
  if(!callStack) {
    return
  }
  var frames = callStack.split("\n", 5);
  var caller = frames[3];
  if(!caller) {
    return
  }
  if(caller.indexOf("Proxy.SecureFunction") > -1) {
    caller = frames[4]
  }
  if(caller.indexOf("/aura_") > -1 && callStack.indexOf("$LWS") === -1) {
    return
  }
  if(isDeprecated) {
    if(workaround) {
      message += ". Workaround: " + workaround
    }
    $A.$warning$("Deprecation warning: " + message)
  }
  if(reportSignature) {
    if(!isDeprecated) {
      if(!this.$usageBeaconing$) {
        this.$usageBeaconing$ = new Beaconing("c.aura://ComponentController.reportUsages")
      }
      this.$usageBeaconing$.$queue$(reportSignature, callingCmp || caller.trim() || "UNKNOWN")
    }
  }
};
AuraInstance.prototype.$deprecated$ = function(message, workaround, reportSignature) {
  this.$_reportUsageHelper$(true, reportSignature, message, workaround)
};
AuraInstance.prototype.$logUsageOf$ = function(reportSignature) {
  this.$_reportUsageHelper$(false, reportSignature)
};
AuraInstance.prototype.$setMode$ = function(mode) {
  this.mode = mode;
  this.$enableAssertions$ = mode !== "PROD" && mode !== "PTEST"
};
AuraInstance.prototype.$getValueProvider$ = function(type) {
  return this.getContext().$getGlobalValueProvider$(type)
};
AuraInstance.prototype.$addValueProvider$ = function(type, valueProvider) {
  $A.assert($A["util"].$isString$(type), "$A.addValueProvider(): 'type' must be a valid String.");
  $A.assert(type.charAt(0) === "$", "$A.addValueProvider(): 'type' must start with '$'.");
  $A.assert(",$browser,$label,$locale,".indexOf("," + type.toLowerCase() + ",") === -1, "$A.addValueProvider(): '" + type + "' is a reserved valueProvider.");
  $A.assert(!$A["util"].$isUndefinedOrNull$(valueProvider), "$A.addValueProvider(): 'valueProvider' is required.");
  var context = this.getContext();
  if(context) {
    $A.assert(this.$getValueProvider$(type) == null, "$A.addValueProvider(): '" + type + "' has already been registered.");
    context.$addGlobalValueProvider$(type, valueProvider)
  }else {
    $A.assert(this.$globalValueProviders$[type] == null, "$A.addValueProvider(): '" + type + "' has already been registered.");
    this.$globalValueProviders$[type] = valueProvider
  }
};
AuraInstance.prototype.$getDefinition$ = function(descriptor, callback) {
  $A.assert($A["util"].$isString$(descriptor), "'descriptor' must be an event or component descriptor such as 'prefix:name' or 'e.prefix:name'.");
  $A.assert($A["util"].$isFunction$(callback), "'callback' must be a valid function.");
  if(this.getContext().$uriAddressableDefsEnabled$) {
    $A.$getDefinitions$([descriptor], function unpackDefinition(defs) {
      callback(defs[0])
    });
    return
  }
  if(descriptor.indexOf("e.") !== -1) {
    this.$eventService$.$getDefinition$(descriptor, callback);
    return
  }
  this.$componentService$.$getDefinition$(descriptor, callback)
};
AuraInstance.prototype.$getDefinitions$ = function(descriptors, callback) {
  $A.assert($A["util"].isArray(descriptors), "'descriptors' must be an array of definition descriptors to retrieve.");
  $A.assert($A["util"].$isFunction$(callback), "'callback' must be a valid function.");
  if(this.getContext().$uriAddressableDefsEnabled$) {
    var that = this;
    var idx;
    var descriptorMap = {};
    for(idx = 0;idx < descriptors.length;idx++) {
      var desc = descriptors[idx];
      if(desc) {
        var eventIndex = desc.indexOf("e.");
        if(eventIndex !== -1) {
          desc = desc.substr(eventIndex + 2);
          descriptors[idx] = desc
        }
        descriptorMap[desc] = undefined
      }
    }
    this.$componentService$.$loadComponentDefs$(descriptorMap, $A.$getCallback$(function collectDefinitions() {
      var definitions = [];
      for(idx = 0;idx < descriptors.length;idx++) {
        definitions.push(that.$componentService$.$getDefinitionOfAnyType$(descriptors[idx]))
      }
      callback(definitions)
    }));
    return
  }
  var pendingMap = {};
  var returnDefinitions = [];
  var requestDefinitions = [];
  var descriptor;
  var def;
  var isEvent;
  var c = 0;
  for(var length = descriptors.length;c < length;c++) {
    descriptor = descriptors[c];
    if(descriptor && descriptor.indexOf("e.") !== -1) {
      descriptor = descriptor.replace("e.", "");
      isEvent = true;
      def = this.$eventService$.$getDef$(descriptor)
    }else {
      def = this.$componentService$.$getDef$(descriptor);
      isEvent = false
    }
    if(def) {
      returnDefinitions[c] = def
    }else {
      if(isEvent && !this.$eventService$.$getEventDef$(descriptor) || !isEvent && !this.$componentService$.$getComponentDef$(this.$componentService$.$createDescriptorConfig$(descriptor))) {
        requestDefinitions.push(descriptors[c]);
        pendingMap[descriptor] = {"position":c, "isEvent":isEvent}
      }else {
        returnDefinitions[c] = null
      }
    }
  }
  if(!requestDefinitions.length) {
    callback(returnDefinitions)
  }else {
    var action = $A.get("c.aura://ComponentController.getDefinitions");
    action.$setParams$({"names":requestDefinitions});
    action.$setCallback$(this, function getDefintions$callback() {
      var pendingInfo;
      for(var requestedDescriptor in pendingMap) {
        if(pendingMap.hasOwnProperty(requestedDescriptor)) {
          pendingInfo = pendingMap[requestedDescriptor];
          if(pendingInfo["isEvent"]) {
            returnDefinitions[pendingInfo["position"]] = this.$eventService$.$getDef$(requestedDescriptor) || null
          }else {
            returnDefinitions[pendingInfo["position"]] = this.$componentService$.$getDef$(requestedDescriptor) || null
          }
        }
      }
      callback(returnDefinitions)
    });
    $A.$enqueueAction$(action)
  }
};
AuraInstance.prototype.$hasDefinition$ = function(descriptor) {
  $A.assert($A["util"].$isString$(descriptor), "'descriptor' must be an event or component descriptor such as 'prefix:name' or 'e.prefix:name'.");
  if(descriptor.indexOf("e.") !== -1) {
    return this.$eventService$.$hasDefinition$(descriptor.replace("e.", ""))
  }
  return this.$componentService$.$hasDefinition$(descriptor)
};
var PerfLogLevel = {"DEBUG":{name:"DEBUG", value:1}, "INTERNAL":{name:"INTERNAL", value:2}, "PRODUCTION":{name:"PRODUCTION", value:3}, "DISABLED":{name:"DISABLED", value:4}};
goog.$exportSymbol$("PerfLogLevel", PerfLogLevel);
var PerfConstants = {"PAGE_START_MARK":"PageStart", "PERF_PAYLOAD_PARAM":"bulkPerf", "MARK_NAME":"mark", "MEASURE_NAME":"measure", "MARK_START_TIME":"st", "MARK_LAST_TIME":"lt", "PAGE_NAME":"pn", "ELAPSED_TIME":"et", "REFERENCE_TIME":"rt", "Perf_LOAD_DONE":"loadDone"};
goog.$exportSymbol$("PerfConstants", PerfConstants);
PerfConstants["STATS"] = {"NAME":"stat", "SERVER_ELAPSED":"internal_serverelapsed", "DB_TOTAL_TIME":"internal_serverdbtotaltime", "DB_CALLS":"internal_serverdbcalls", "DB_FETCHES":"internal_serverdbfetches"};
var PerfShim = {"currentLogLevel":PerfLogLevel["DISABLED"], "mark":function(id, logLevel) {
  return this
}, "endMark":function(id, logLevel) {
  return this
}, "updateMarkName":function(oldName, newName) {
  return this
}, "measureToJson":function(measure) {
  return""
}, "toJson":function(includeMarks) {
  return""
}, "setTimer":function(timer_name, timer_delta, logLevel) {
  return this
}, "toPostVar":function() {
  return""
}, "getMeasures":function() {
  return[]
}, "getBeaconData":function() {
  return null
}, "setBeaconData":function(beaconData) {
}, "clearBeaconData":function() {
}, "removeStats":function() {
}, "stat":function(label, elapsedMillis) {
  return this
}, "getStat":function(label) {
  return-1
}, "onLoad":function() {
}, "startTransaction":function(tName) {
  return this
}, "endTransaction":function(tName) {
  return this
}, "updateTransaction":function(oldName, newName) {
  return this
}, "isOnLoadFired":function() {
  return false
}, "util":{"setCookie":function(name, value, expires, path) {
}}, enabled:false};
AuraInstance.prototype.$Perf$ = window["Perf"] || PerfShim;
AuraInstance.prototype["addValueProvider"] = AuraInstance.prototype.$addValueProvider$;
AuraInstance.prototype["initAsync"] = AuraInstance.prototype.$initAsync$;
AuraInstance.prototype["initConfig"] = AuraInstance.prototype.$initConfig$;
AuraInstance.prototype["error"] = AuraInstance.prototype.error;
AuraInstance.prototype["warning"] = AuraInstance.prototype.$warning$;
AuraInstance.prototype["message"] = AuraInstance.prototype.message;
AuraInstance.prototype["enqueueAction"] = AuraInstance.prototype.$enqueueAction$;
AuraInstance.prototype["executeHotspot"] = AuraInstance.prototype.$executeHotspot$;
AuraInstance.prototype["get"] = AuraInstance.prototype.get;
AuraInstance.prototype["getReference"] = AuraInstance.prototype.$getReference$;
AuraInstance.prototype["getRoot"] = AuraInstance.prototype.$getRoot$;
AuraInstance.prototype["getCallback"] = AuraInstance.prototype.$getCallback$;
AuraInstance.prototype["getContext"] = AuraInstance.prototype.getContext;
AuraInstance.prototype["getToken"] = AuraInstance.prototype.$getToken$;
AuraInstance.prototype["getService"] = AuraInstance.prototype.$getService$;
AuraInstance.prototype["run"] = AuraInstance.prototype.$run$;
AuraInstance.prototype["set"] = AuraInstance.prototype.set;
AuraInstance.prototype["assert"] = AuraInstance.prototype.assert;
AuraInstance.prototype["userAssert"] = AuraInstance.prototype.$userAssert$;
AuraInstance.prototype["log"] = AuraInstance.prototype.log;
AuraInstance.prototype["trace"] = AuraInstance.prototype.trace;
AuraInstance.prototype["reportError"] = AuraInstance.prototype.$reportError$;
AuraInstance.prototype["Perf"] = AuraInstance.prototype.$Perf$;
AuraInstance.prototype["mark"] = AuraInstance.prototype.$Perf$["mark"];
AuraInstance.prototype["endMark"] = AuraInstance.prototype.$Perf$["endMark"];
AuraInstance.prototype["startTransaction"] = AuraInstance.prototype.$Perf$["startTransaction"];
AuraInstance.prototype["endTransaction"] = AuraInstance.prototype.$Perf$["endTransaction"];
AuraInstance.prototype["updateTransaction"] = AuraInstance.prototype.$Perf$["updateTransaction"];
AuraInstance.prototype["toJson"] = AuraInstance.prototype.$Perf$["toJson"];
AuraInstance.prototype["setBeaconData"] = AuraInstance.prototype.$Perf$["setBeaconData"];
AuraInstance.prototype["getBeaconData"] = AuraInstance.prototype.$Perf$["getBeaconData"];
AuraInstance.prototype["clearBeaconData"] = AuraInstance.prototype.$Perf$["clearBeaconData"];
AuraInstance.prototype["removeStats"] = AuraInstance.prototype.$Perf$["removeStats"];
AuraInstance.prototype["isLoadFired"] = AuraInstance.prototype.$Perf$.$isLoadFired$;
AuraInstance.prototype["installOverride"] = AuraInstance.prototype.$installOverride$;
AuraInstance.prototype["uninstallOverride"] = AuraInstance.prototype.$uninstallOverride$;
Aura.$OverrideMap$ = function OverrideMap() {
  this.map = {"enqueueAction":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$enqueueAction$, false, function(bound) {
    $A.$enqueueAction$ = bound;
    $A["enqueueAction"] = bound;
    $A.$clientService$.$enqueueAction$ = bound;
    $A.$clientService$["enqueueAction"] = bound
  }, function(orig, bound) {
    $A.$enqueueAction$ = bound;
    $A["enqueueAction"] = bound;
    $A.$clientService$.$enqueueAction$ = orig;
    $A.$clientService$["enqueueAction"] = orig
  }), "ClientService.decode":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$decode$, false, function(bound) {
    $A.$clientService$.$decode$ = bound
  }, function(orig) {
    $A.$clientService$.$decode$ = orig
  }), "ClientService.send":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.send, false, function(bound) {
    $A.$clientService$.send = bound
  }, function(orig) {
    $A.$clientService$.send = orig
  }), "ClientService.collectServerAction":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$collectServerAction$, false, function(bound) {
    $A.$clientService$.$collectServerAction$ = bound
  }, function(orig) {
    $A.$clientService$.$collectServerAction$ = orig
  }), "ClientService.receive":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$receive$, false, function(bound) {
    $A.$clientService$.$receive$ = bound
  }, function(orig) {
    $A.$clientService$.$receive$ = orig
  }), "ClientService.clientLibraryLoadComplete":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$clientLibraryLoadComplete$, false, function(bound) {
    $A.$clientService$.$clientLibraryLoadComplete$ = bound
  }, function(orig) {
    $A.$clientService$.$clientLibraryLoadComplete$ = orig
  }), "ComponentService.createComponentPriv":new Aura.$Utils$.$Override$($A.$componentService$, $A.$componentService$.$createComponentPriv$, false, function(bound) {
    $A.$componentService$.$createComponentPriv$ = bound
  }, function(orig) {
    $A.$componentService$.$createComponentPriv$ = orig
  }), "ClientService.processResponses":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$processResponses$, false, function(bound) {
    $A.$clientService$.$processResponses$ = bound
  }, function(orig) {
    $A.$clientService$.$processResponses$ = orig
  }), "ClientService.getAvailableXHR":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$getAvailableXHR$, false, function(bound) {
    $A.$clientService$.$getAvailableXHR$ = bound
  }, function(orig) {
    $A.$clientService$.$getAvailableXHR$ = orig
  }), "Action.finishAction":new Aura.$Utils$.$Override$(null, Aura.$Controller$.$Action$.prototype.$finishAction$, true, function(bound) {
    Aura.$Controller$.$Action$.prototype.$finishAction$ = bound
  }, function(orig) {
    Aura.$Controller$.$Action$.prototype.$finishAction$ = orig
  }), "Action.abort":new Aura.$Utils$.$Override$(null, Aura.$Controller$.$Action$.prototype.abort, true, function(bound) {
    Aura.$Controller$.$Action$.prototype.abort = bound
  }, function(orig) {
    Aura.$Controller$.$Action$.prototype.abort = orig
  }), "Action.runDeprecated":new Aura.$Utils$.$Override$(null, Aura.$Controller$.$Action$.prototype.$runDeprecated$, true, function(bound) {
    Aura.$Controller$.$Action$.prototype.$runDeprecated$ = bound;
    Aura.$Controller$.$Action$.prototype["runDeprecated"] = bound;
    Aura.$Controller$.$Action$.prototype["getComponent"] = function() {
      return this.$cmp$
    }
  }, function(orig) {
    Aura.$Controller$.$Action$.prototype.$runDeprecated$ = orig;
    Aura.$Controller$.$Action$.prototype["runDeprecated"] = orig;
    delete Aura.$Controller$.$Action$.prototype["getComponent"]
  }), "Event.fire":new Aura.$Utils$.$Override$(null, Aura.$Event$.$Event$.prototype.$fire$, true, function(bound) {
    Aura.$Event$.$Event$.prototype.$fire$ = bound;
    Aura.$Event$.$Event$.prototype["fire"] = bound
  }, function(orig) {
    Aura.$Event$.$Event$.prototype.$fire$ = orig;
    Aura.$Event$.$Event$.prototype["fire"] = orig
  }), "outputComponent":new Aura.$Utils$.$Override$(null, Aura.$Component$.$Component$.prototype.toJSON, true, function(bound) {
    Aura.$Component$.$Component$.prototype.toJSON = bound;
    Aura.$Component$.$Component$.prototype["toJSON"] = bound
  }, function(orig) {
    Aura.$Component$.$Component$.prototype.toJSON = orig;
    Aura.$Component$.$Component$.prototype["toJSON"] = orig
  }), "StorageService.selectAdapter":new Aura.$Utils$.$Override$($A.$storageService$, $A.$storageService$.$selectAdapter$, false, function(bound) {
    $A.$storageService$.$selectAdapter$ = bound
  }, function(orig) {
    $A.$storageService$.$selectAdapter$ = orig
  }), "RenderingService.addDirtyValue":new Aura.$Utils$.$Override$($A.$renderingService$, $A.$renderingService$.$addDirtyValue$, false, function(bound) {
    $A.$renderingService$.$addDirtyValue$ = bound
  }, function(orig) {
    $A.$renderingService$.$addDirtyValue$ = orig
  }), "MetricsService.transaction":new Aura.$Utils$.$Override$($A.$metricsService$, $A.$metricsService$.transaction, false, function(bound) {
    $A.$metricsService$.transaction = bound
  }, function(orig) {
    $A.$metricsService$.transaction = orig
  }), "HtmlComopnent.dispatchAction":new Aura.$Utils$.$Override$(null, Aura.$Component$.$HtmlComponent$.prototype["helper"].$dispatchAction$, true, function(bound) {
    HtmlComponent.prototype["helper"].$dispatchAction$ = bound
  }, function(orig) {
    HtmlComponent.prototype["helper"].$dispatchAction$ = orig
  }), "ComponentService.indexComponent":new Aura.$Utils$.$Override$($A.$componentService$, $A.$componentService$.$indexComponent$, false, function(bound) {
    $A.$componentService$.$indexComponent$ = bound
  }, function(orig) {
    $A.$componentService$.$indexComponent$ = orig
  }), "ComponentDefLoader.loadingComplete":new Aura.$Utils$.$Override$(null, Aura.$Component$.$ComponentDefLoader$.prototype.$loadingComplete$, true, function(bound) {
    Aura.$Component$.$ComponentDefLoader$.prototype.$loadingComplete$ = bound
  }, function(orig) {
    Aura.$Component$.$ComponentDefLoader$.prototype.$loadingComplete$ = orig
  })}
};
(function bootstrap() {
  Aura.$bootstrapMark$("execAuraJs");
  window["$A"] = new AuraInstance
})();
$A = aura = window["aura"] = window["$A"];
var MemoryAdapter = function MemoryAdapter(config) {
  this.reset();
  this.$maxSize$ = config["maxSize"];
  this.$instanceName$ = config["name"];
  this.$debugLogging$ = config["debugLogging"]
};
MemoryAdapter["NAME"] = "memory";
MemoryAdapter.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
MemoryAdapter.prototype.reset = function() {
  this.$backingStore$ = {};
  this.$mru$ = [];
  this.$cachedSize$ = 0
};
MemoryAdapter.prototype.getName = function() {
  return MemoryAdapter["NAME"]
};
MemoryAdapter.prototype.$initialize$ = function() {
  return Promise["resolve"]()
};
MemoryAdapter.prototype.$getSize$ = function() {
  return Promise["resolve"](this.$cachedSize$)
};
MemoryAdapter.prototype.$getItems$ = function(keys) {
  var that = this;
  return new Promise(function(resolve) {
    var store = that.$backingStore$;
    var updateMru = true;
    if(!Array.isArray(keys) || keys.length === 0) {
      keys = Object.keys(store);
      updateMru = false
    }
    var results = {};
    var key;
    var value;
    var innerItem;
    for(var i = 0;i < keys.length;i++) {
      key = keys[i];
      value = store[key];
      if(value) {
        innerItem = value.getItem();
        try {
          innerItem = JSON.parse($A["util"].$json$.$encode$(innerItem))
        }catch(ignore) {
        }
        results[key] = innerItem;
        if(updateMru) {
          that.$updateMRU$(key)
        }
      }
    }
    resolve(results)
  })
};
MemoryAdapter.prototype.$updateMRU$ = function(key) {
  var index = this.$mru$.indexOf(key);
  if(index > -1) {
    this.$mru$.splice(index, 1);
    this.$mru$.push(key)
  }
};
MemoryAdapter.prototype.$setItems$ = function(tuples) {
  var that = this;
  return new Promise(function(resolve) {
    var key;
    var item;
    var size;
    var existingItem;
    var mruIndex;
    var sizeDelta = 0;
    for(var i = 0;i < tuples.length;i++) {
      key = tuples[i][0];
      item = tuples[i][1];
      size = tuples[i][2];
      existingItem = that.$backingStore$[key];
      sizeDelta += size - (existingItem ? existingItem.$getSize$() : 0);
      that.$backingStore$[key] = new MemoryAdapter.$Entry$(item, size);
      mruIndex = that.$mru$.indexOf(key);
      if(mruIndex > -1) {
        that.$mru$.splice(mruIndex, 1)
      }
      that.$mru$.push(key)
    }
    that.$cachedSize$ += sizeDelta;
    var spaceNeeded = that.$cachedSize$ - that.$maxSize$;
    if(spaceNeeded > 0) {
      that.$expireCache$(spaceNeeded)["then"](undefined, function expireCacheError(e) {
        that.log(MemoryAdapter.$LOG_LEVEL$.$WARNING$, "setItems(): error during eviction", e)
      })
    }
    resolve()
  })
};
MemoryAdapter.prototype.$removeItems$ = function(keys) {
  var that = this;
  return new Promise(function(resolve) {
    for(var i = 0;i < keys.length;i++) {
      that.$removeItemInternal$(keys[i])
    }
    resolve()
  })
};
MemoryAdapter.prototype.$removeItemInternal$ = function(key) {
  var item = this.$backingStore$[key];
  if(item) {
    var index = this.$mru$.indexOf(key);
    if(index > -1) {
      this.$mru$.splice(index, 1)
    }
    this.$cachedSize$ -= item.$getSize$();
    delete this.$backingStore$[key]
  }
  return item
};
MemoryAdapter.prototype.clear = function() {
  var that = this;
  return new Promise(function(resolve) {
    that.reset();
    resolve()
  })
};
MemoryAdapter.prototype.$expireCache$ = function(spaceNeeded) {
  if(this.$mru$.length <= 0) {
    return Promise["resolve"]()
  }
  var that = this;
  return new Promise(function(resolve) {
    var spaceReclaimed = 0;
    var key;
    var item;
    var now = (new Date).getTime();
    for(key in that.$backingStore$) {
      var expires = that.$backingStore$[key].getItem()["expires"];
      if(now > expires) {
        item = that.$removeItemInternal$(key);
        spaceReclaimed += item.$getSize$();
        that.log(MemoryAdapter.$LOG_LEVEL$.$INFO$, "evict(): evicted expired item with key " + key)
      }
    }
    for(;spaceReclaimed < spaceNeeded && that.$mru$.length > 0;) {
      key = that.$mru$[0];
      item = that.$removeItemInternal$(key);
      spaceReclaimed += item.$getSize$();
      that.log(MemoryAdapter.$LOG_LEVEL$.$INFO$, "evict(): evicted for size item with key " + key)
    }
    resolve()
  })
};
MemoryAdapter.prototype.$getMRU$ = function() {
  return Promise["resolve"](this.$mru$)
};
MemoryAdapter.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= MemoryAdapter.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("MemoryAdapter['" + this.$instanceName$ + "'] " + msg, obj)
  }
};
MemoryAdapter.prototype.$sweep$ = function() {
  return this.$expireCache$(0)
};
MemoryAdapter.prototype.$deleteStorage$ = function() {
  this.reset();
  return Promise["resolve"]()
};
MemoryAdapter.prototype.$isSecure$ = function() {
  return true
};
MemoryAdapter.prototype.$isPersistent$ = function() {
  return false
};
MemoryAdapter.$Entry$ = function Entry(item, size) {
  this.item = JSON.parse($A["util"].$json$.$encode$(item));
  this.size = size
};
MemoryAdapter.$Entry$.prototype.getItem = function() {
  return this.item
};
MemoryAdapter.$Entry$.prototype.$getSize$ = function() {
  return this.size
};
$A.$storageService$.$registerAdapter$({"name":MemoryAdapter["NAME"], "adapterClass":MemoryAdapter, "secure":true});
Aura.$Storage$.$MemoryAdapter$ = MemoryAdapter;
var IndexedDBAdapter = function IndexedDBAdapter(config) {
  this.$instanceName$ = config["name"];
  this.$sizeMax$ = config["maxSize"];
  this.$debugLogging$ = config["debugLogging"];
  this.$keyPrefix$ = config["keyPrefix"];
  this.db = undefined;
  this.$ready$ = undefined;
  this.$initializePromise$ = undefined;
  this.$sizeLastReal$ = 0;
  this.$sizeGuess$ = 0;
  this.$sizeErrorBar$ = 0;
  this.$sizeAge$ = 1E6;
  this.$sizeAvg$ = 100;
  this.$sizeMistake$ = 0;
  this.$sizeMistakeMax$ = 0;
  this.$sizeMistakeCount$ = 0;
  this.$sizeOutsideErrorBar$ = 0;
  this.$lastSweep$ = 0;
  this.$sweepInterval$ = 15 * 60 * 1E3;
  this.$expiresFudge$ = 1E4;
  this.$limitSweepHigh$ = 0.9 * this.$sizeMax$;
  this.$limitSweepLow$ = 0.7 * this.$sizeMax$;
  this.$limitError$ = 0.5 * this.$sizeMax$;
  var context = $A.getContext();
  var tableName = config["partitionName"] || context && (context.$app$ || context.$cmp$);
  tableName = tableName || window["Aura"]["app"];
  this.$tableName$ = tableName || "store";
  this.$sweepingSuspended$ = false;
  this.$initializeTimeoutId$ = undefined
};
IndexedDBAdapter["NAME"] = "indexeddb";
IndexedDBAdapter.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
IndexedDBAdapter.$INITIALIZE_TIMEOUT$ = 30 * 1E3;
IndexedDBAdapter.$OBJECTSTORE__TRANSACTION_THRESHOLD$ = 500;
IndexedDBAdapter.prototype.getName = function() {
  return IndexedDBAdapter["NAME"]
};
IndexedDBAdapter.prototype.$initialize$ = function() {
  if(this.$initializePromise$) {
    return this.$initializePromise$
  }
  var that = this;
  this.$initializePromise$ = new Promise(function(resolve, reject) {
    that.$initializePromiseResolve$ = resolve;
    that.$initializePromiseReject$ = reject
  });
  this.$initializeInternal$();
  return this.$initializePromise$
};
IndexedDBAdapter.prototype.$initializeInternal$ = function(version, transactionTimer) {
  var dbRequest;
  var that = this;
  if(!transactionTimer) {
    transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-open-transaction");
    transactionTimer.info = {"wasBlocked":false, "wasUpgraded":false}
  }
  if(!this.$initializeTimeoutId$) {
    this.$initializeTimeoutId$ = setTimeout(function handleDBTimeout() {
      var message = "initializeInternal(): timed out setting up DB";
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      transactionTimer.info["failureCause"] = "timedout";
      that.$initializeComplete$(false, message, transactionTimer)
    }, IndexedDBAdapter.$INITIALIZE_TIMEOUT$)
  }
  if(version) {
    dbRequest = window.indexedDB.open(this.$instanceName$, version)
  }else {
    dbRequest = window.indexedDB.open(this.$instanceName$)
  }
  dbRequest.onupgradeneeded = function(e) {
    that.$createTables$(e);
    transactionTimer.info["wasUpgraded"] = true
  };
  dbRequest.onsuccess = function(e) {
    that.$setupDB$(e, transactionTimer)
  };
  dbRequest.onerror = function(e) {
    var message = "initializeInternal(): error opening DB";
    message += e.target.error && e.target.error.message ? ": " + e.target.error.message : "";
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
    transactionTimer.info["failureCause"] = "error";
    that.$initializeComplete$(false, message, transactionTimer);
    e.preventDefault && e.preventDefault()
  };
  dbRequest.onblocked = function() {
    var message = "initializeInternal(): blocked from opening DB, most likely by another open browser tab";
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
    transactionTimer.info["wasBlocked"] = true
  }
};
IndexedDBAdapter.prototype.$getTransaction$ = function(mode) {
  var that = this;
  return new Promise(function(resolve, reject) {
    try {
      var transaction = that.db.transaction([that.$tableName$], mode);
      resolve(transaction)
    }catch(e) {
      if(e.message && (e.message.indexOf("The database connection is closing") !== -1 || e.message.indexOf("A mutation operation was attempted on a database that did not allow mutations") !== -1 || e.message.indexOf("InvalidStateError") !== -1)) {
        that.$ready$ = undefined;
        that.$initialize$().$then$(function afterInitialize() {
          try {
            resolve(that.db.transaction([that.$tableName$], mode))
          }catch(e2) {
            reject(e2)
          }
        }, reject)
      }else {
        reject(e)
      }
    }
  })
};
IndexedDBAdapter.prototype.$getObjectStore$ = function() {
  try {
    return this.transaction.objectStore(this.$tableName$)
  }catch(e) {
    this.transaction = this.db.transaction([this.$tableName$], this.transaction["mode"]);
    return this.transaction.objectStore(this.$tableName$)
  }
};
IndexedDBAdapter.prototype.$getSize$ = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.getSize() called with this.ready\x3d" + this.$ready$);
  var that = this;
  if(this.$sizeAge$ < 50) {
    return Promise["resolve"](this.$sizeGuess$)
  }else {
    return new Promise(function(resolve, reject) {
      that.$walkInternal$(resolve, reject, false)
    })
  }
};
IndexedDBAdapter.prototype.$getItems$ = function(keys) {
  $A.assert(this.$ready$, "IndexedDBAdapter.getItems() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    if(!Array.isArray(keys) || keys.length === 0) {
      that.$walkInternal$(resolve, reject, true)
    }else {
      that.$getItemsInternal$(keys, resolve, reject)
    }
  })
};
IndexedDBAdapter.prototype.$suspendSweeping$ = function() {
  this.$sweepingSuspended$ = true
};
IndexedDBAdapter.prototype.$resumeSweeping$ = function() {
  this.$sweepingSuspended$ = false
};
IndexedDBAdapter.prototype.$isSecure$ = function() {
  return false
};
IndexedDBAdapter.prototype.$isPersistent$ = function() {
  return true
};
IndexedDBAdapter.prototype.$sweep$ = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.sweep() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    that.$expireCache$(0, resolve, reject)
  })
};
IndexedDBAdapter.prototype.$setupDB$ = function(event, transactionTimer) {
  var db = event.target.result;
  var that = this;
  this.db = db;
  this.db.onerror = function(e) {
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, "setupDB(): error event received", e)
  };
  this.db.onabort = function(e) {
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, "setupDB(): abort event received", e)
  };
  this.db.onversionchange = function(e) {
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "setupDB(): onversionchanged event received", e);
    e.target.close()
  };
  if(!db.objectStoreNames.contains(this.$tableName$)) {
    var currentVersion = db["version"];
    db.close();
    this.$initializeInternal$(currentVersion + 1, transactionTimer)
  }else {
    this.$initializeComplete$(true, null, transactionTimer)
  }
};
IndexedDBAdapter.prototype.$createTables$ = function(event) {
  var db = event.target.result;
  var transaction = event.target.transaction;
  var objectStore;
  if(!db.objectStoreNames.contains(this.$tableName$)) {
    objectStore = db.createObjectStore(this.$tableName$, {"keyPath":"key"})
  }else {
    if(transaction) {
      objectStore = transaction.objectStore(this.$tableName$)
    }
  }
  if(objectStore) {
    if(!objectStore.indexNames.contains("expires")) {
      objectStore.createIndex("expires", "expires", {"unique":false})
    }
  }
};
IndexedDBAdapter.prototype.$initializeComplete$ = function(ready, errorMessage, transactionTimer) {
  if(this.$ready$ !== undefined) {
    return
  }
  this.$ready$ = !!ready;
  transactionTimer.info["initSucceeded"] = this.$ready$;
  var initializationInfo = {};
  initializationInfo["wasUpgraded"] = transactionTimer.info["wasUpgraded"] || false;
  transactionTimer.end(transactionTimer.info);
  clearTimeout(this.$initializeTimeoutId$);
  if(this.$ready$) {
    this.$initializePromiseResolve$(initializationInfo)
  }else {
    this.$initializePromiseReject$(new Error(errorMessage))
  }
  delete this.$initializePromiseResolve$;
  delete this.$initializePromiseReject$;
  delete this.$initializePromise$
};
IndexedDBAdapter.prototype.$cleanseKeys$ = function(keys) {
  var cleansed = [];
  for(var k = 0;k < keys.length;k++) {
    var key = keys[k];
    if(typeof key === "string") {
      key = key.replace(/{.*}/, "PARAMS_REMOVED")
    }
    cleansed.push(key)
  }
  return cleansed
};
IndexedDBAdapter.prototype.$getItemsInternal$ = function(keys, resolve, reject) {
  var transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-getItems-read-transaction");
  var that = this;
  this.$getTransaction$("readonly").$then$(function afterAquiringTransaction(transaction) {
    function collector(event) {
      var stored = event.target.result || {};
      var key = stored["key"];
      var item = stored["item"];
      if(key) {
        results[key] = item
      }
      collected++;
      if(collected === keys.length) {
        transactionTimer.end({"keys":that.$cleanseKeys$(keys), "collected":collected});
        resolve(results)
      }
    }
    that.transaction = transaction;
    var objectStore = that.$getObjectStore$();
    var results = {};
    var collected = 0;
    transaction.onabort = function() {
      var message = "getItemsInternal(): transaction aborted for keys [" + keys + "]: " + transaction.error;
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    transaction.onerror = function() {
      var message = "getItemsInternal(): transaction error for keys [" + keys + "]: " + transaction.error;
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    var objectStoreRequest;
    for(var i = 0;i < keys.length;i++) {
      objectStoreRequest = objectStore.get(keys[i]);
      objectStoreRequest.onsuccess = collector
    }
  }, reject)
};
IndexedDBAdapter.prototype.$walkInternal$ = function(resolve, reject, sendResult) {
  var transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-walkInternal-read-transaction");
  var that = this;
  this.$getTransaction$("readonly").$then$(function afterAquiringTransaction2(transaction) {
    that.transaction = transaction;
    var objectStore = that.$getObjectStore$();
    var cursor = objectStore.openCursor();
    var result = {};
    var count = 0;
    var size = 0;
    cursor.onsuccess = function(event) {
      var icursor = event.target.result;
      if(icursor) {
        var stored = icursor.value;
        if(stored) {
          size += stored["size"];
          count += 1;
          if(sendResult && stored["key"].indexOf(that.$keyPrefix$) === 0) {
            result[stored["key"]] = stored["item"]
          }
        }
        icursor["continue"]()
      }else {
        transactionTimer.end({"count":count, "size":size, "name":that.$instanceName$});
        that.$refreshSize$(size, count);
        if(that.$sizeGuess$ > that.$limitSweepHigh$) {
          that.$expireCache$(0)
        }
        if(sendResult) {
          resolve(result)
        }else {
          resolve(that.$sizeGuess$)
        }
      }
    };
    cursor.onerror = function(event) {
      reject(new Error("IndexedDBAdapter.walkInternal: Transaction failed: " + event.error))
    };
    cursor.onabort = function(event) {
      reject(new Error("IndexedDBAdapter.walkInternal: Transaction aborted: " + event.error))
    }
  }, reject)
};
IndexedDBAdapter.prototype.$setItems$ = function(tuples) {
  $A.assert(this.$ready$, "IndexedDBAdapter.setItems() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    var i;
    var sizes = 0;
    var storables = [];
    var storable;
    for(i = 0;i < tuples.length;i++) {
      storable = that.$encodeStorable$(tuples[i]);
      sizes += storable["size"];
      storables.push(storable)
    }
    if(sizes + that.$sizeGuess$ + that.$sizeErrorBar$ > that.$limitSweepHigh$ || that.$sizeErrorBar$ > that.$limitError$) {
      that.$expireCache$(sizes)
    }
    var transactionTimer = that.$thresholdMetricTimer$("performance:storage-indexeddb-setItems-write-transaction");
    return that.$getTransaction$("readwrite").$then$(function afterAquiringTransaction3(transaction) {
      function collector() {
        collected++;
        if(collected === tuples.length) {
          transactionTimer.end({"collected":collected, "storables":storables.length, "first_key":that.$cleanseKeys$(tuples[0])[0]});
          that.$updateSize$(sizes / 2, sizes / 2);
          resolve()
        }
      }
      that.transaction = transaction;
      var objectStore = that.$getObjectStore$();
      var collected = 0;
      transaction.onabort = function() {
        var keys = tuples.map(function(tuple) {
          return tuple[0]
        });
        var message = "setItemsInternal(): transaction aborted for keys [" + keys + "]: " + transaction.error;
        that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
        reject(new Error("IndexedDBAdapter." + message))
      };
      transaction.onerror = function() {
        var keys = tuples.map(function(tuple) {
          return tuple[0]
        });
        var message = "setItemsInternal(): transaction error for keys [" + keys + "]: " + transaction.error;
        that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
        reject(new Error("IndexedDBAdapter." + message))
      };
      var objectStoreRequest;
      for(i = 0;i < storables.length;i++) {
        try {
          objectStoreRequest = objectStore.put(storables[i]);
          objectStoreRequest.onsuccess = collector
        }catch(e) {
          reject(e);
          return
        }
      }
    }, reject)
  })
};
IndexedDBAdapter.prototype.$removeItems$ = function(keys) {
  $A.assert(this.$ready$, "IndexedDBAdapter.removeItems() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    var transactionTimer = that.$thresholdMetricTimer$("performance:storage-indexeddb-removeItems-write-transaction");
    return that.$getTransaction$("readwrite").$then$(function afterAquiringTransaction4(transaction) {
      function collector() {
        collected++;
        if(collected === keys.length) {
          transactionTimer.end({"collected":collected, "keys":that.$cleanseKeys$(keys)});
          that.$updateSize$(-sizeAvg, sizeAvg);
          resolve();
          return
        }
      }
      that.transaction = transaction;
      var objectStore = that.$getObjectStore$();
      var sizeAvg = that.$sizeAvg$;
      var collected = 0;
      transaction.onabort = function() {
        var message = "removeItemsInternal(): transaction aborted for keys [" + keys + "]: " + transaction.error;
        that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
        reject(new Error("IndexedDBAdapter." + message))
      };
      transaction.onerror = function() {
        var message = "removeItemsInternal(): transaction error for keys [" + keys + "]: " + transaction.error;
        that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
        reject(new Error("IndexedDBAdapter." + message))
      };
      var objectStoreRequest;
      for(var i = 0;i < keys.length;i++) {
        try {
          objectStoreRequest = objectStore["delete"](keys[i]);
          objectStoreRequest.onsuccess = collector
        }catch(e) {
          reject(e);
          return
        }
      }
    }, reject)
  })
};
IndexedDBAdapter.prototype.clear = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.clear() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function executeClear(resolve, reject) {
    var transactionTimer = that.$thresholdMetricTimer$("performance:storage-indexeddb-clear-write-transaction");
    return that.$getTransaction$("readwrite").$then$(function afterAquiringTransaction5(transaction) {
      that.transaction = transaction;
      var objectStore = that.$getObjectStore$();
      try {
        objectStore.clear()
      }catch(e) {
        reject(e);
        return
      }
      that.$setSize$(0, 0);
      transaction.onabort = function() {
        reject(new Error("IndexedDBAdapter.clear(): Transaction aborted: " + transaction.error))
      };
      transaction.oncomplete = function() {
        transactionTimer.end({});
        resolve()
      };
      transaction.onerror = function() {
        reject(new Error("IndexedDBAdapter.clear(): Transaction failed: " + transaction.error))
      }
    }, reject)
  })
};
IndexedDBAdapter.prototype.$expireCache$ = function(requestedSize, resolve, reject) {
  var now = (new Date).getTime();
  if(this.$sweepingSuspended$ || this.$lastSweep$ + this.$sweepInterval$ > now && this.$sizeGuess$ < this.$limitSweepHigh$) {
    if(resolve) {
      resolve()
    }
    return
  }
  var actionsDenylist = ["globalValueProviders", "$AuraClientService.token$"];
  this.$lastSweep$ = now;
  var transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-expireCache-read-transaction");
  var that = this;
  this.$getTransaction$("readonly").$then$(function afterAquiringTransaction6(transaction) {
    that.transaction = transaction;
    var objectStore = that.$getObjectStore$();
    var index = objectStore.index("expires");
    var cursor = index.openCursor();
    var count = 0;
    var size = 0;
    var expiredSize = 0;
    var expireDate = now + that.$expiresFudge$;
    var removeSize = requestedSize || 0;
    var keysToDelete = [];
    if(that.$sizeGuess$ > that.$limitSweepLow$) {
      removeSize += that.$sizeGuess$ - that.$limitSweepLow$
    }
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "expireCache(): sweeping to remove " + removeSize);
    cursor.onsuccess = function(event) {
      var icursor = event.target.result;
      if(icursor) {
        var stored = icursor.value;
        if(stored) {
          var shouldEvict = false;
          if(stored["expires"] < expireDate || expiredSize < removeSize || stored["key"].indexOf(that.$keyPrefix$) !== 0) {
            shouldEvict = true;
            if(that.$instanceName$ === "actions") {
              for(var i = 0;i < actionsDenylist.length;i++) {
                if(icursor.primaryKey.indexOf(actionsDenylist[i]) > -1) {
                  shouldEvict = false;
                  break
                }
              }
            }
          }
          if(shouldEvict) {
            that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "expireCache(): sweep removing " + icursor.primaryKey);
            keysToDelete.push(icursor.primaryKey);
            expiredSize += stored["size"]
          }else {
            size += stored["size"];
            count += 1
          }
        }
        icursor["continue"]()
      }else {
        transactionTimer.end({"size":size, "count":count});
        that.$refreshSize$(size, count);
        if(keysToDelete.length > 0) {
          that.$removeItems$(keysToDelete)
        }
        if(resolve) {
          resolve()
        }
        if(size > that.$limitSweepHigh$) {
          that.$expireCache$(0)
        }
      }
    };
    cursor.onerror = function(event) {
      if(reject) {
        reject(new Error("IndexedDBAdapter.getAll: Transaction failed: " + event.error))
      }
    };
    cursor.onabort = function(event) {
      if(reject) {
        reject(new Error("IndexedDBAdapter.getAll: Transaction aborted: " + event.error))
      }
    }
  }, reject)
};
IndexedDBAdapter.prototype.$updateSize$ = function(sizeChange, error) {
  this.$sizeGuess$ += sizeChange;
  this.$sizeErrorBar$ += error;
  this.$sizeAge$ += 1
};
IndexedDBAdapter.prototype.$refreshSize$ = function(size, count) {
  var mistake = this.$sizeGuess$ - size;
  if(mistake < 0) {
    mistake = -mistake
  }
  if(mistake > this.$sizeMistakeMax$) {
    this.$sizeMistakeMax$ = mistake
  }
  this.$sizeMistake$ += mistake;
  this.$sizeMistakeCount$ += 1;
  if(mistake > this.$sizeErrorBar$) {
    this.$sizeOutsideErrorBar$ += 1
  }
  this.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "refreshSize(): size calculation: current mistake \x3d " + mistake + ", avg mistake \x3d " + (this.$sizeMistake$ / this.$sizeMistakeCount$).toFixed(1) + ", max mistake \x3d " + this.$sizeMistakeMax$ + ", outside error bars \x3d " + this.$sizeOutsideErrorBar$);
  this.$setSize$(size, count)
};
IndexedDBAdapter.prototype.$setSize$ = function(size, count) {
  this.$sizeLastReal$ = size;
  this.$sizeGuess$ = size;
  this.$sizeErrorBar$ = 0;
  this.$sizeAge$ = 0;
  if(count > 0) {
    this.$sizeAvg$ = size / count
  }
};
IndexedDBAdapter.prototype.$decodeStorable$ = function(stored) {
  return{"key":stored["key"], "value":stored["item"]}
};
IndexedDBAdapter.prototype.$encodeStorable$ = function(tuple) {
  return{"key":tuple[0], "item":tuple[1], "size":tuple[2], "expires":tuple[1]["expires"]}
};
IndexedDBAdapter.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= IndexedDBAdapter.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("IndexedDBAdapter['" + this.$instanceName$ + "'] " + msg, obj)
  }
};
IndexedDBAdapter.prototype.$thresholdMetricTimer$ = function(name) {
  var startTime = (new Date).getTime();
  var startVisibility = document.visibilityState === "visible";
  return{end:function(info) {
    var elapsed = (new Date).getTime() - startTime;
    if(elapsed > IndexedDBAdapter.$OBJECTSTORE__TRANSACTION_THRESHOLD$) {
      info["elapsed"] = elapsed;
      info["visibilityStateStart"] = startVisibility;
      info["visibilityStateEnd"] = document.visibilityState === "visible";
      $A.$metricsService$.transaction("aura", name, {"context":{"attributes":info}})
    }
  }}
};
IndexedDBAdapter.prototype.$deleteStorage$ = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.deleteStorage() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    that.db.close();
    var dbRequest = window.indexedDB.deleteDatabase(that.$instanceName$);
    dbRequest.onerror = function() {
      var message = "deleteStorage(): delete database error";
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    dbRequest.onsuccess = function() {
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "deleteStorage(): deleted successfully");
      resolve()
    };
    dbRequest.onblocked = function() {
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "deleteStorage(): blocked from being deleted")
    }
  })
};
IndexedDBAdapter.$register$ = function() {
  if(navigator.userAgent.indexOf("Outlook-iOS") !== -1) {
    return
  }
  if(navigator.userAgent.indexOf("AppleWebKit") !== -1 && navigator.userAgent.indexOf("Chrome") === -1) {
    return
  }
  if($A.$clientService$.$getSidTokenState$()["isSidTokenEnabled"]) {
    return
  }
  if(!window.indexedDB) {
    return
  }
  $A.$storageService$.$registerAdapter$({"name":IndexedDBAdapter["NAME"], "adapterClass":IndexedDBAdapter, "persistent":true})
};
IndexedDBAdapter.$register$();
Aura.$Storage$.$IndexedDBAdapter$ = IndexedDBAdapter;
function CryptoAdapter(config) {
  this.$instanceName$ = config["name"];
  this.$debugLogging$ = config["debugLogging"];
  this.key = undefined;
  this.$encoder$ = new window["TextEncoder"];
  this.$decoder$ = new window["TextDecoder"];
  this.$initializePromise$ = undefined;
  var adapterClass = $A.$storageService$.$getAdapterConfig$(Aura.$Storage$.$IndexedDBAdapter$["NAME"])["adapterClass"];
  this.$adapter$ = new adapterClass(config);
  this.$adapterAntiObfuscation$(this.$adapter$);
  var that = this;
  this.$adapterInitializePromise$ = this.$adapter$.$initialize$()["then"](function logSuccess(initializationInfo) {
    that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "adapter.initialize(): internal IndexedDB adapter initialization completed");
    return initializationInfo
  }, function logAndThrowError(e) {
    that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "adapter.initialize(): internal IndexedDB adapter initialization failed: " + e);
    throw e;
  })
}
CryptoAdapter["NAME"] = "crypto";
CryptoAdapter.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
CryptoAdapter.$ALGO$ = "AES-CBC";
CryptoAdapter.$IV_LENGTH$ = 16;
CryptoAdapter.$SENTINEL$ = "cryptoadapter";
CryptoAdapter.$initializeEngine$ = function() {
  if(window["msCrypto"] && !window["crypto"]) {
    window["crypto"] = {};
    window["crypto"]["subtle"] = {};
    window["crypto"]["subtle"]["importKey"] = function(format, keyData, algorithm, extractable, keyUsages) {
      return new Promise(function(resolve, reject) {
        var op = window["msCrypto"]["subtle"]["importKey"](format, keyData, algorithm, extractable, keyUsages);
        op.onerror = function() {
          reject(new Error("Failed to importKey"))
        };
        op.oncomplete = function(evt) {
          resolve(evt.target.result)
        }
      })
    };
    window["crypto"]["subtle"]["encrypt"] = function(algorithm, key, buffer) {
      return new Promise(function(resolve, reject) {
        var op = window["msCrypto"]["subtle"]["encrypt"](algorithm, key, buffer);
        op.onerror = function() {
          reject(new Error("Failed to encrypt"))
        };
        op.oncomplete = function(evt) {
          resolve(evt.target.result)
        };
        if(!buffer || buffer.byteLength === 0) {
          op.finish()
        }
      })
    };
    window["crypto"]["subtle"]["decrypt"] = function(algorithm, key, buffer) {
      return new Promise(function(resolve, reject) {
        var op = window["msCrypto"]["subtle"]["decrypt"](algorithm, key, buffer);
        op.onerror = function() {
          reject(new Error("Failed to decrypt"))
        };
        op.oncomplete = function(evt) {
          resolve(evt.target.result)
        };
        if(!buffer || buffer.byteLength === 0) {
          op.finish()
        }
      })
    };
    window["crypto"]["getRandomValues"] = window["msCrypto"]["getRandomValues"].bind(window["msCrypto"])
  }
  CryptoAdapter.$engine$ = window["crypto"] && (window["crypto"]["subtle"] || window["crypto"]["webkitSubtle"])
};
CryptoAdapter.$initializeEngine$();
CryptoAdapter.key = new Promise(function(resolve, reject) {
  CryptoAdapter.$_keyResolve$ = resolve;
  CryptoAdapter.$_keyReject$ = reject
});
CryptoAdapter["setKey"] = function(rawKey) {
  var resolve = CryptoAdapter.$_keyResolve$;
  var reject = CryptoAdapter.$_keyReject$;
  var log;
  delete CryptoAdapter["setKey"];
  delete CryptoAdapter.$_keyResolve$;
  delete CryptoAdapter.$_keyReject$;
  if(!(rawKey instanceof ArrayBuffer)) {
    var type = !rawKey ? typeof rawKey : rawKey.constructor.name;
    log = "CryptoAdapter cannot import key of wrong type (" + type + "), rejecting";
    $A.$warning$(log);
    reject(new Error(log));
    return
  }
  CryptoAdapter.$engine$["importKey"]("raw", rawKey, CryptoAdapter.$ALGO$, false, ["encrypt", "decrypt"])["then"](function importKeySuccess(key) {
    if(!key) {
      log = "CryptoAdapter crypto.importKey() returned no key, rejecting";
      $A.$warning$(log);
      reject(new Error(log));
      return
    }
    $A.log("CryptoAdapter crypto.importKey() successfully imported key");
    resolve(key)
  }, function importKeyError(e) {
    log = "CryptoAdapter crypto.importKey() failed, rejecting: " + e;
    $A.$warning$(log);
    reject(new Error(log))
  })
};
CryptoAdapter["register"] = function() {
  if($A.$storageService$.$isRegisteredAdapter$(CryptoAdapter["NAME"])) {
    $A.$warning$("CryptoAdapter already registered");
    return
  }
  if(!$A.$storageService$.$isRegisteredAdapter$(Aura.$Storage$.$IndexedDBAdapter$["NAME"])) {
    $A.$warning$("CryptoAdapter cannot register because it requires IndexedDB");
    return
  }
  var secure = window.location.href.indexOf("https") === 0 || window.location.hostname === "localhost";
  if(!secure) {
    $A.$warning$("CryptoAdapter cannot register because it requires a secure origin");
    return
  }
  if(!CryptoAdapter.$engine$) {
    $A.$warning$("CryptoAdapter cannot register because it requires Web Cryptography API");
    return
  }
  $A.$storageService$.$registerAdapter$({"name":CryptoAdapter["NAME"], "adapterClass":CryptoAdapter, "secure":true, "persistent":true})
};
CryptoAdapter.prototype.getName = function() {
  return CryptoAdapter["NAME"]
};
CryptoAdapter.prototype.$initialize$ = function() {
  if(this.$initializePromise$) {
    return this.$initializePromise$
  }
  this.$initializePromise$ = this.$initializeInternal$();
  return this.$initializePromise$
};
CryptoAdapter.prototype.$initializeInternal$ = function() {
  var that = this;
  var initializationInfo;
  if(!$A["util"].$isLocalStorageEnabled$()) {
    return Promise["reject"](new Error("localStorage is disabled"))
  }
  return Promise["all"]([CryptoAdapter.key, this.$adapterInitializePromise$])["then"](function keyReceived(values) {
    var key = values[0];
    if(!key) {
      throw new Error("CryptoAdapter.key resolved with no key.");
    }
    that.key = key;
    initializationInfo = values[1] || {}
  })["then"](function verifySentinel() {
    function handleInvalidSentinel() {
      if(!initializationInfo["wasUpgraded"]) {
        that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "initialize(): encryption key is different so clearing storage");
        $A.$metricsService$.transaction("aura", "performance:cryptoStorage-keymismatch")
      }
      return that.clear()
    }
    that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "initialize(): verifying sentinel");
    return that.$getItems$([CryptoAdapter.$SENTINEL$], true)["then"](function checkIfInvalidSentinel(values) {
      if(!values[CryptoAdapter.$SENTINEL$] || values[CryptoAdapter.$SENTINEL$].value !== CryptoAdapter.$SENTINEL$) {
        return handleInvalidSentinel()
      }
    }, handleInvalidSentinel)
  })["then"](function storeSentinel() {
    return that.$setSentinelItem$()
  })
};
CryptoAdapter.prototype.$getSize$ = function() {
  return this.$adapter$.$getSize$()
};
CryptoAdapter.prototype.$getItems$ = function(keys, includeInternalKeys) {
  var that = this;
  return this.$adapter$.$getItems$(keys)["then"](function(values) {
    function decryptSucceeded(k, decryptedValue) {
      if(k !== CryptoAdapter.$SENTINEL$ || includeInternalKeys) {
        decrypted[k] = decryptedValue
      }
    }
    function decryptFailed() {
    }
    var decrypted = {};
    var promises = [];
    var promise;
    var value;
    for(var key in values) {
      value = values[key];
      if($A["util"].$isUndefinedOrNull$(value)) {
      }else {
        promise = that.$decrypt$(key, value)["then"](decryptSucceeded.bind(undefined, key), decryptFailed);
        promises.push(promise)
      }
    }
    return Promise["all"](promises)["then"](function getDecrypted() {
      return decrypted
    })
  })
};
CryptoAdapter.prototype.$decrypt$ = function(key, value) {
  var that = this;
  if(!value || !value["value"]) {
    return Promise["reject"](new Error("CryptoAdapter.decrypt() value is malformed for key" + key))
  }
  return CryptoAdapter.$engine$["decrypt"]({"name":CryptoAdapter.$ALGO$, "iv":value["value"]["iv"]}, that.key, value["value"]["cipher"])["then"](function engineDecryptSuccess(decrypted) {
    var obj = that.$arrayBufferToObject$(new Uint8Array(decrypted));
    return{"expires":value["expires"], "value":obj}
  }, function engineDecryptError(err) {
    that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "decrypt(): decryption failed for key " + key, err);
    throw new Error(err);
  })
};
CryptoAdapter.prototype.$objectToArrayBuffer$ = function(o) {
  if(o === undefined) {
    return new ArrayBuffer(0)
  }
  var str = $A["util"].$json$.$encode$(o);
  return this.$encoder$["encode"](str)
};
CryptoAdapter.prototype.$encodeValue$ = function(o) {
  return this.$objectToArrayBuffer$(o)
};
CryptoAdapter.prototype.$arrayBufferToObject$ = function(ab) {
  var str = this.$decoder$["decode"](ab);
  if(str === "") {
    return undefined
  }
  return JSON.parse(str)
};
CryptoAdapter.prototype.$setSentinelItem$ = function() {
  var now = (new Date).getTime();
  var tuple = [CryptoAdapter.$SENTINEL$, {"value":CryptoAdapter.$SENTINEL$, "created":now, "expires":now + 15768E6}, 0];
  return this.$setItems$([tuple])
};
CryptoAdapter.prototype.$encryptToTuple$ = function(tuple) {
  var that = this;
  return new Promise(function(resolve, reject) {
    var itemArrayBuffer;
    try {
      if(!tuple[1]["valueEncoded"]) {
        itemArrayBuffer = that.$objectToArrayBuffer$(tuple[1]["value"])
      }else {
        itemArrayBuffer = tuple[1]["value"]
      }
    }catch(e) {
      that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "encryptToTuple(): serialization failed for key " + tuple[0], e);
      reject(e);
      return
    }
    var iv = window["crypto"]["getRandomValues"](new Uint8Array(CryptoAdapter.$IV_LENGTH$));
    CryptoAdapter.$engine$["encrypt"]({"name":CryptoAdapter.$ALGO$, "iv":iv}, that.key, itemArrayBuffer)["then"](function engineEncryptSuccess(encrypted) {
      var storable = {"expires":tuple[1]["expires"], "value":{"iv":iv, "cipher":encrypted}};
      resolve([tuple[0], storable, tuple[2]])
    }, function engineEncryptError(err) {
      that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "encryptToTuple(): encryption failed for key " + tuple[0], err);
      reject(err)
    })
  })
};
CryptoAdapter.prototype.$setItems$ = function(tuples) {
  var promises = [];
  var tuple;
  for(var i = 0;i < tuples.length;i++) {
    tuple = tuples[i];
    promises.push(this.$encryptToTuple$(tuple))
  }
  var that = this;
  return Promise["all"](promises)["then"](function setTuples(encryptedTuples) {
    return that.$adapter$.$setItems$(encryptedTuples)
  }, function encryptToTupleError(err) {
    var keys = tuples.map(function(t) {
      return t[0]
    });
    that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "setItemsInternal(): transaction error for keys " + keys.toString(), err);
    throw err;
  })
};
CryptoAdapter.prototype.$removeItems$ = function(keys) {
  return this.$adapter$.$removeItems$(keys)
};
CryptoAdapter.prototype.clear = function() {
  var that = this;
  return this.$adapter$.clear()["then"](function setSentinelItemWrapper() {
    return that.$setSentinelItem$()
  })
};
CryptoAdapter.prototype.$sweep$ = function() {
  var that = this;
  return this.$adapter$.$sweep$()["then"](function setSentinelItemWrapper() {
    return that.$setSentinelItem$()
  })
};
CryptoAdapter.prototype.$deleteStorage$ = function() {
  return this.$adapter$.$deleteStorage$()
};
CryptoAdapter.prototype.$suspendSweeping$ = function() {
  if(this.$adapter$.$suspendSweeping$) {
    this.$adapter$.$suspendSweeping$()
  }
};
CryptoAdapter.prototype.$resumeSweeping$ = function() {
  if(this.$adapter$.$resumeSweeping$) {
    this.$adapter$.$resumeSweeping$()
  }
};
CryptoAdapter.prototype.$isSecure$ = function() {
  return true
};
CryptoAdapter.prototype.$isPersistent$ = function() {
  return true
};
CryptoAdapter.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= CryptoAdapter.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("CryptoAdapter['" + this.$instanceName$ + "']" + msg, obj)
  }
};
CryptoAdapter.prototype.$adapterAntiObfuscation$ = function(adapter) {
  adapter.$initialize$ = adapter.$initialize$ || adapter["initialize"];
  adapter.getName = adapter.getName || adapter["getName"];
  adapter.$isSecure$ = adapter.$isSecure$ || adapter["isSecure"];
  adapter.$isPersistent$ = adapter.$isPersistent$ || adapter["isPersistent"];
  adapter.$suspendSweeping$ = adapter.$suspendSweeping$ || adapter["suspendSweeping"];
  adapter.$resumeSweeping$ = adapter.$resumeSweeping$ || adapter["resumeSweeping"];
  adapter.$setItems$ = adapter.$setItems$ || adapter["setItems"];
  adapter.$getItems$ = adapter.$getItems$ || adapter["getItems"];
  adapter.$removeItems$ = adapter.$removeItems$ || adapter["removeItems"];
  adapter.clear = adapter.clear || adapter["clear"];
  adapter.$sweep$ = adapter.$sweep$ || adapter["sweep"];
  adapter.$getSize$ = adapter.$getSize$ || adapter["getSize"];
  adapter.$deleteStorage$ = adapter.$deleteStorage$ || adapter["deleteStorage"]
};
Aura.$Storage$.$CryptoAdapter$ = CryptoAdapter;
AuraStorageService.prototype["CryptoAdapter"] = CryptoAdapter;
var TransportMetricsPlugin = function TransportMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("TransportMetricsPlugin", TransportMetricsPlugin);
TransportMetricsPlugin["NAME"] = "transport";
TransportMetricsPlugin.$ORIGIN$ = window.location && window.location.origin;
TransportMetricsPlugin.$AURA_URL$ = TransportMetricsPlugin.$ORIGIN$ + "/aura";
TransportMetricsPlugin.$SERVER_TIMING_HEADER$ = "Server-Timing";
TransportMetricsPlugin.$SERVER_TIMING_TOTAL$ = "total";
TransportMetricsPlugin.$SERVER_TIMING_DURATION$ = "dur";
TransportMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "initialize", TransportMetricsPlugin.prototype.$initialize$);
TransportMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$metricsService$)
  }
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "enable", TransportMetricsPlugin.prototype.enable);
TransportMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "disable", TransportMetricsPlugin.prototype.disable);
TransportMetricsPlugin.prototype.$getServerTimingTotal$ = function(request) {
  var serverTimingHeader = request.getResponseHeader(TransportMetricsPlugin.$SERVER_TIMING_HEADER$);
  if(typeof serverTimingHeader === "string") {
    var serverTiming = this.$parseServerTimingHeader$(serverTimingHeader);
    var totalKey = serverTiming[TransportMetricsPlugin.$SERVER_TIMING_TOTAL$];
    var totalValue = totalKey && totalKey[TransportMetricsPlugin.$SERVER_TIMING_DURATION$];
    if(isNaN(totalValue)) {
      return undefined
    }else {
      return totalValue
    }
  }else {
    return undefined
  }
};
TransportMetricsPlugin.prototype.$parseServerTimingHeader$ = function(serverTimingHeader) {
  serverTimingHeader = serverTimingHeader.toLowerCase();
  var serverTiming = {};
  try {
    if(serverTimingHeader.length > 0) {
      var typeSplit = serverTimingHeader.split(",");
      for(var i = 0;i < typeSplit.length;i++) {
        var typeDetailSplit = typeSplit[i].split(";");
        var name = typeDetailSplit[0].trim();
        serverTiming[name] = {};
        for(var j = 1;j < typeDetailSplit.length;j++) {
          var metricKeyValue = typeDetailSplit[j].split("\x3d");
          if(metricKeyValue.length === 2) {
            var keyName = metricKeyValue[0].trim();
            var metricValue = metricKeyValue[1].trim();
            if(keyName === TransportMetricsPlugin.$SERVER_TIMING_DURATION$) {
              metricValue = parseInt(metricValue)
            }
            serverTiming[name][keyName] = metricValue
          }
        }
      }
    }
  }catch(e) {
  }
  return serverTiming
};
TransportMetricsPlugin.prototype.$sendOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var auraXHR = arguments[0];
  var options = arguments[3] || {};
  var sendTime = this.$metricsService$.time();
  var ret = config["fn"].apply(config["scope"], arguments);
  if(ret) {
    var startMark = this.$metricsService$["markStart"](TransportMetricsPlugin["NAME"], "request");
    startMark["ts"] = sendTime;
    var actionDefs = [];
    for(var id in auraXHR.$actions$) {
      if(auraXHR.$actions$.hasOwnProperty(id)) {
        actionDefs.push(id)
      }
    }
    startMark["context"] = {"auraXHRId":auraXHR["marker"], "requestLength":auraXHR.length, "background":!!options.background, "actionDefs":actionDefs, "requestId":auraXHR["requestId"] || options["requestId"]}
  }
  return ret
};
TransportMetricsPlugin.prototype.$receiveOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var auraXHR = arguments[0];
  var endMark = this.$metricsService$["markEnd"](TransportMetricsPlugin["NAME"], "request");
  endMark["context"] = {"auraXHRId":auraXHR["marker"], "status":auraXHR.$request$.status, "statusText":auraXHR.$request$.statusText};
  try {
    endMark["context"]["responseLength"] = auraXHR.$request$.responseText.length
  }catch(ex) {
    endMark["context"]["responseLength"] = 0
  }
  if(window.performance && window.performance.getEntriesByName) {
    var allResources = window.performance.getEntriesByType("resource");
    var r = allResources.filter(function(res) {
      return res.name.indexOf(auraXHR.url) !== -1
    })[0];
    if(r) {
      $A["util"].apply(endMark["context"], {"xhrDuration":parseInt(r.responseEnd - r.startTime, 10), "xhrStall":parseInt(r.requestStart - r.startTime, 10), "startTime":parseInt(r.startTime, 10), "fetchStart":parseInt(r.fetchStart, 10), "requestStart":parseInt(r.requestStart, 10), "dns":parseInt(r.domainLookupEnd - r.domainLookupStart, 10), "tcp":parseInt(r.connectEnd - r.connectStart, 10), "ttfb":parseInt(r.responseStart - r.startTime, 10), "transfer":parseInt(r.responseEnd - r.responseStart, 10), 
      "transferSize":r["transferSize"] || 0, "nextHopProtocol":r["nextHopProtocol"]})
    }
  }
  var serverTiming = this.$getServerTimingTotal$(auraXHR.$request$);
  if(serverTiming !== undefined) {
    endMark["context"]["serverTime"] = serverTiming
  }
  var ret = config["fn"].apply(config["scope"], arguments);
  var perfSummary = ret && ret["message"] && ret["message"]["perfSummary"];
  if(serverTiming === undefined && perfSummary && perfSummary["version"] === "core") {
    endMark["context"]["serverTime"] = perfSummary["request"]
  }
  return ret
};
TransportMetricsPlugin.prototype.bind = function() {
  $A.$installOverride$("ClientService.send", this.$sendOverride$, this);
  $A.$installOverride$("ClientService.receive", this.$receiveOverride$, this)
};
TransportMetricsPlugin.prototype.$postProcess$ = function(transportMarks) {
  var procesedMarks = [];
  var queue = {};
  for(var i = 0;i < transportMarks.length;i++) {
    var id = transportMarks[i]["context"] && (transportMarks[i]["context"]["auraXHRId"] || transportMarks[i]["context"]["defLoaderId"]);
    if(id === undefined) {
      continue
    }
    var phase = transportMarks[i]["phase"];
    if(phase === "start") {
      queue[id] = transportMarks[i]
    }else {
      if(phase === "end" && queue[id]) {
        var mark = $A["util"].apply({}, queue[id], true, true);
        var duration = parseInt(transportMarks[i]["ts"] - mark["ts"]);
        mark["context"] = $A["util"].apply(mark["context"] || {}, transportMarks[i]["context"]);
        mark["duration"] = duration;
        mark["context"]["xhrDelay"] = duration - (mark["context"]["xhrDuration"] || mark["context"]["duration"]);
        delete mark["phase"];
        delete mark["ns"];
        delete mark["name"];
        procesedMarks.push(mark);
        delete queue[id]
      }
    }
  }
  return procesedMarks
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "postProcess", TransportMetricsPlugin.prototype.$postProcess$);
TransportMetricsPlugin.prototype.$unbind$ = function() {
  $A.$uninstallOverride$("ClientService.send", this.$sendOverride$);
  $A.$uninstallOverride$("ClientService.receive", this.$receiveOverride$)
};
$A.$metricsService$.$registerPlugin$({"name":TransportMetricsPlugin["NAME"], "plugin":TransportMetricsPlugin});
var PerfMetricsPlugin = function PerfMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
PerfMetricsPlugin["NAME"] = "server";
PerfMetricsPlugin.prototype = {$initialize$:function(metricsService) {
  this.$collector$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
}, enable:function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$collector$)
  }
}, disable:function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$collector$)
  }
}, $processResponsesOverride$:function() {
  var config = Array.prototype.shift.apply(arguments);
  var auraXHR = arguments[0];
  var responseObject = arguments[1];
  var perfData = responseObject["perf"];
  var stampMark = this.$collector$["mark"](PerfMetricsPlugin["NAME"], "perf");
  if(perfData) {
    stampMark["context"] = {"id":auraXHR["marker"], "requestId":auraXHR["requestId"], "perf":perfData}
  }
  return config["fn"].apply(config["scope"], arguments)
}, bind:function() {
  $A.$installOverride$("ClientService.processResponses", this.$processResponsesOverride$, this)
}, $postProcess$:function(markList) {
  return markList
}, $unbind$:function() {
  $A.$uninstallOverride$("ClientService.processResponses", this.$processResponsesOverride$)
}};
PerfMetricsPlugin.prototype["initialize"] = PerfMetricsPlugin.prototype.$initialize$;
PerfMetricsPlugin.prototype["enable"] = PerfMetricsPlugin.prototype.enable;
PerfMetricsPlugin.prototype["disable"] = PerfMetricsPlugin.prototype.disable;
PerfMetricsPlugin.prototype["postProcess"] = PerfMetricsPlugin.prototype.$postProcess$;
$A.$metricsService$.$registerPlugin$({"name":PerfMetricsPlugin["NAME"], "plugin":PerfMetricsPlugin});
var QueuedActionsMetricsPlugin = function QueuedActionsMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("QueuedActionsMetricsPlugin", QueuedActionsMetricsPlugin);
QueuedActionsMetricsPlugin["NAME"] = "actions";
QueuedActionsMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "initialize", QueuedActionsMetricsPlugin.prototype.$initialize$);
QueuedActionsMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$metricsService$)
  }
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "enable", QueuedActionsMetricsPlugin.prototype.enable);
QueuedActionsMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "disable", QueuedActionsMetricsPlugin.prototype.disable);
QueuedActionsMetricsPlugin.prototype.$_createBaseActionMark$ = function(action, name) {
  var cmp = action.$getComponent$();
  var sourceCtx = action.$getSourceContext$();
  var cmpName = sourceCtx && sourceCtx.tagName || cmp && cmp.type || "none";
  var mark = this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], name, {"id":action.$getId$(), "abortable":action.$isAbortable$(), "storable":action.$isStorable$(), "background":action.$isBackground$(), "cmp":cmpName, "def":action.$getDef$() && action.$getDef$().toString()});
  var ctx = mark["context"];
  action.$isRefreshAction$() && (ctx["refresh"] = true);
  action.$isCaboose$() && (ctx["caboose"] = true);
  var params = action.$getLoggableParams$();
  if(!$A["util"].$isEmpty$(params)) {
    mark["params"] = params
  }
  return mark
};
QueuedActionsMetricsPlugin.prototype.$enqueueActionOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var action = arguments[0];
  if($A["util"].$isAction$(action) && action.$getDef$().$isServerAction$()) {
    this.$_createBaseActionMark$(action, "enqueue")
  }
  var ret = config["fn"].apply(config["scope"], arguments);
  return ret
};
QueuedActionsMetricsPlugin.prototype.$collectServerActionOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var action = arguments[0];
  this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "sendQueued", {"id":action.$getId$()});
  return config["fn"].apply(config["scope"], arguments)
};
QueuedActionsMetricsPlugin.prototype.$actionSendOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var actions = arguments[1];
  for(var i = 0;i < actions.length;i++) {
    var action = actions[i];
    if(action.$isRefreshAction$()) {
      this.$_createBaseActionMark$(action, "sendStart")
    }else {
      this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "sendStart", {"id":actions[i].$getId$()})
    }
  }
  return config["fn"].apply(config["scope"], arguments)
};
QueuedActionsMetricsPlugin.prototype.$actionFinishOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var action = config["self"];
  var shouldLog = action.$getDef$().$isServerAction$();
  shouldLog && this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "finishStart", {"id":action.$getId$(), "state":action.$getState$(), "cache":action.$isFromStorage$()});
  var ret = undefined;
  try {
    ret = config["fn"].apply(config["scope"], arguments)
  }finally {
    shouldLog && this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "finishEnd", {"id":action.$getId$()})
  }
  return ret
};
QueuedActionsMetricsPlugin.prototype.$actionsProcessResponses$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var message = arguments[1];
  var perfSummary = message && message["perfSummary"];
  if(perfSummary && perfSummary["version"] === "core") {
    var actions = perfSummary["actions"] || {};
    var xhrServerTime = perfSummary["request"];
    var keys = Object.keys(actions);
    var numberOfActions = keys.length;
    for(var i = 0;i < numberOfActions;i++) {
      var id = keys[i];
      var serverTime = actions[id];
      serverTime["xhrServerTime"] = xhrServerTime;
      serverTime["boxCarCount"] = numberOfActions;
      this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "receive", {"id":id, "serverTime":serverTime})
    }
  }
  return config["fn"].apply(config["scope"], arguments)
};
QueuedActionsMetricsPlugin.prototype.bind = function() {
  $A.$installOverride$("enqueueAction", this.$enqueueActionOverride$, this);
  $A.$installOverride$("ClientService.collectServerAction", this.$collectServerActionOverride$, this);
  $A.$installOverride$("ClientService.send", this.$actionSendOverride$, this);
  $A.$installOverride$("ClientService.processResponses", this.$actionsProcessResponses$, this);
  $A.$installOverride$("Action.finishAction", this.$actionFinishOverride$, this)
};
QueuedActionsMetricsPlugin.prototype.$postProcess$ = function(actionMarks) {
  var processedMarks = [];
  var queue = {};
  for(var i = 0;i < actionMarks.length;i++) {
    var actionMark = actionMarks[i];
    var id = actionMark["context"]["id"];
    var mark = queue[id];
    var name = actionMark["name"];
    if(name === "enqueue") {
      queue[id] = $A["util"].apply({}, actionMark)
    }else {
      if(!mark && name === "sendStart") {
        mark = $A["util"].apply({}, actionMark);
        queue[id] = mark;
        mark["xhrWait"] = 0;
        mark["enqueueWait"] = 0;
        continue
      }
    }
    if(mark) {
      switch(name) {
        case "sendQueued":
          mark["xhrWait"] = Math.floor(actionMark["ts"]);
          mark["enqueueWait"] = Math.floor(actionMark["ts"] - mark["ts"]);
          break;
        case "sendStart":
          if(mark["xhrWait"] === undefined || mark["context"]["caboose"]) {
            mark["xhrWait"] = 0
          }else {
            mark["xhrWait"] = Math.floor(actionMark["ts"] - mark["xhrWait"])
          }
          if(mark["enqueueWait"] === undefined) {
            mark["enqueueWait"] = Math.floor(actionMark["ts"] - mark["ts"])
          }
          break;
        case "receive":
          mark["serverTime"] = actionMark["context"]["serverTime"];
          break;
        case "finishStart":
          $A["util"].apply(mark["context"], actionMark["context"]);
          mark["callbackTime"] = actionMark["ts"];
          if(mark["enqueueWait"] === undefined) {
            mark["enqueueWait"] = Math.floor(actionMark["ts"] - mark["ts"])
          }
          break;
        case "finishEnd":
          mark["callbackTime"] = Math.floor(actionMark["ts"] - mark["callbackTime"]);
          mark["duration"] = Math.floor(actionMark["ts"] - mark["ts"]);
          delete mark["phase"];
          delete mark["ns"];
          delete mark["name"];
          processedMarks.push(mark);
          delete queue[id];
          break
      }
    }
  }
  return processedMarks
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "postProcess", QueuedActionsMetricsPlugin.prototype.$postProcess$);
QueuedActionsMetricsPlugin.prototype.$unbind$ = function() {
  $A.$uninstallOverride$("enqueueAction", this.$enqueueActionOverride$);
  $A.$uninstallOverride$("ClientService.collectServerAction", this.$collectServerActionOverride$);
  $A.$uninstallOverride$("ClientService.send", this.$actionSendOverride$, this);
  $A.$uninstallOverride$("ClientService.processResponses", this.$actionsProcessResponses$);
  $A.$uninstallOverride$("Action.finishAction", this.$actionFinishOverride$)
};
$A.$metricsService$.$registerPlugin$({"name":QueuedActionsMetricsPlugin["NAME"], "plugin":QueuedActionsMetricsPlugin});
var AuraContextPlugin = function AuraContextPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("AuraContextPlugin", AuraContextPlugin);
AuraContextPlugin["NAME"] = "defRegistry";
AuraContextPlugin.prototype.$initialize$ = function(metricsService) {
  this.$collector$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(AuraContextPlugin.prototype, "initialize", AuraContextPlugin.prototype.$initialize$);
AuraContextPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$collector$)
  }
};
goog.$exportProperty$(AuraContextPlugin.prototype, "enable", AuraContextPlugin.prototype.enable);
AuraContextPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$collector$)
  }
};
goog.$exportProperty$(AuraContextPlugin.prototype, "disable", AuraContextPlugin.prototype.disable);
AuraContextPlugin.prototype.bind = function(metricsService) {
  var method = "mergeContext";
  var defIter = function defIter(b) {
    var a = [];
    for(var i = 0;i < b.length;i++) {
      var def = b[i];
      if(def["descriptor"]) {
        a.push(def["descriptor"])
      }
    }
    return a
  };
  var hook = function(original, config) {
    var ret = original.apply(this, Array.prototype.slice.call(arguments, 1));
    var cmpDefs = config["componentDefs"];
    var evtDefs = config["eventDefs"];
    var payload = {};
    var hasDefs = cmpDefs && cmpDefs.length || evtDefs && evtDefs.length;
    if(cmpDefs) {
      payload["componentDefs"] = defIter(cmpDefs)
    }
    if(evtDefs) {
      payload["eventDefs"] = defIter(evtDefs)
    }
    if(hasDefs) {
      metricsService["transaction"]("aura", "newDefs", {"context":{"attributes":payload}})
    }
    return ret
  };
  metricsService.$instrument$(Aura.$Context$.$AuraContext$.prototype, method, AuraContextPlugin["NAME"], false, null, null, hook)
};
AuraContextPlugin.prototype.$postProcess$ = function(transportMarks) {
  return transportMarks
};
goog.$exportProperty$(AuraContextPlugin.prototype, "postProcess", AuraContextPlugin.prototype.$postProcess$);
AuraContextPlugin.prototype.$unbind$ = function(metricsService) {
  metricsService["unInstrument"](Aura.$Context$.$AuraContext$.prototype, "mergeContext")
};
$A.$metricsService$.$registerPlugin$({"name":AuraContextPlugin["NAME"], "plugin":AuraContextPlugin});
var DomHandlersPlugin = function DomHandlersPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("DomHandlersPlugin", DomHandlersPlugin);
DomHandlersPlugin["NAME"] = "domHandlers";
DomHandlersPlugin.$DEFAULT_INTERACTION_TYPE$ = "user";
DomHandlersPlugin.$ALLOWLISTEVENTS$ = {"click":true, "change":true};
DomHandlersPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind()
  }
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "initialize", DomHandlersPlugin.prototype.$initialize$);
DomHandlersPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind()
  }
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "enable", DomHandlersPlugin.prototype.enable);
DomHandlersPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "disable", DomHandlersPlugin.prototype.disable);
DomHandlersPlugin.prototype.$dispatchActionHook$ = function(action, event, root) {
  if(!(event.type in DomHandlersPlugin.$ALLOWLISTEVENTS$)) {
    return
  }
  var parent = $A.$expressionService$.$getContainer$(root).$getConcreteComponent$();
  var locator = parent.$getLocator$(root, false);
  if(locator) {
    var target = root["getElement"]();
    var meta = target && target.getAttribute("data-refid");
    var context = {"locator":locator, "eventType":DomHandlersPlugin.$DEFAULT_INTERACTION_TYPE$, "eventSource":event.type};
    if(meta) {
      locator["context"] = locator["context"] || {};
      if(!locator["context"][meta]) {
        locator["context"][meta] = target.getAttribute("data-" + meta)
      }
    }
    $A.$metricsService$.transaction("aura", "interaction", {"context":context})
  }
};
DomHandlersPlugin.prototype.$bindToMetricsService$ = function(jsObject, method) {
  var self = this;
  if(jsObject) {
    this.$metricsService$.$instrument$(jsObject, method, DomHandlersPlugin["NAME"], false, null, null, function(original) {
      var xargs = Array.prototype.slice.call(arguments, 1);
      self.$dispatchActionHook$.apply(self, xargs);
      return original.apply(this, xargs)
    })
  }
};
DomHandlersPlugin.prototype.$bindToHelper$ = function(descriptor, helperMethod) {
  var defConfig = $A.$componentService$.$createDescriptorConfig$(descriptor);
  var def = $A.$componentService$.$getComponentDef$(defConfig);
  var defHelper = def && def.$getHelper$();
  this.$bindToMetricsService$(defHelper, helperMethod)
};
DomHandlersPlugin.prototype.$bindToLib$ = function(lib, jsFile) {
  var fileObject = $A.$componentService$.$hasLibrary$(lib) && $A.$componentService$.$getLibraryInclude$(jsFile);
  if(fileObject) {
    this.$bindToMetricsService$(fileObject, "_dispatchAction")
  }
};
DomHandlersPlugin.prototype.bind = function() {
  var self = this;
  $A.$clientService$.$runAfterInitDefs$(function() {
    $A.$installOverride$("HtmlComopnent.dispatchAction", self.$instrumentCallback$, self);
    self.$bindToHelper$("markup://ui:virtualList", "_dispatchAction");
    self.$bindToHelper$("markup://ui:virtualDataGrid", "_dispatchAction");
    self.$bindToHelper$("markup://ui:virtualDataTable", "_dispatchAction");
    self.$bindToLib$("markup://ui:eventLib", "js://ui.eventLib.interactive");
    self.$bindToLib$("markup://force:virtualGridLib", "js://force.virtualGridLib.gridHelper")
  })
};
DomHandlersPlugin.prototype.$instrumentCallback$ = function() {
  var xargs = Array.prototype.slice.call(arguments, 1);
  var config = Array.prototype.shift.apply(arguments);
  this.$dispatchActionHook$.apply(this, xargs);
  return config["fn"].apply(config["scope"], arguments)
};
DomHandlersPlugin.prototype.$postProcess$ = function(transportMarks) {
  return transportMarks
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "postProcess", DomHandlersPlugin.prototype.$postProcess$);
DomHandlersPlugin.prototype.$unbind$ = function() {
  $A.$uninstallOverride$("HtmlComopnent.dispatchAction", this.$instrumentCallback$, this)
};
$A.$metricsService$.$registerPlugin$({"name":DomHandlersPlugin["NAME"], "plugin":DomHandlersPlugin});
var ComponentMetricsPlugin = function ComponentMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("ComponentMetricsPlugin", ComponentMetricsPlugin);
ComponentMetricsPlugin["NAME"] = "component";
ComponentMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "initialize", ComponentMetricsPlugin.prototype.$initialize$);
ComponentMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true
  }
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "enable", ComponentMetricsPlugin.prototype.enable);
ComponentMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false
  }
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "disable", ComponentMetricsPlugin.prototype.disable);
ComponentMetricsPlugin.prototype.$summarizeCreateInfo$ = function(cmp, duration) {
  cmp["createCount"] = cmp["createCount"] || 0;
  cmp["createTimeTotal"] = cmp["createTimeTotal"] || 0;
  cmp["createCount"]++;
  cmp["createTimeTotal"] += duration
};
ComponentMetricsPlugin.prototype.$summarizeMarks$ = function(marks) {
  var processedMarks = [];
  var uniqueCmps = {};
  var mark;
  var totalDuration = 0;
  for(var i = 0;i < marks.length;i++) {
    mark = marks[i];
    var name = mark["context"]["name"];
    var duration = mark["duration"];
    var type = mark["name"];
    var cmp = uniqueCmps[name];
    totalDuration += duration;
    if(!cmp) {
      cmp = {"name":name};
      processedMarks.push(cmp);
      uniqueCmps[name] = cmp
    }
    if(type === "create") {
      this.$summarizeCreateInfo$(cmp, duration)
    }else {
      $A.$warning$("[ComponentMetricsPlugin] Unexpected type of mark encountered in the component namespace:" + type)
    }
  }
  return{"processedMarks":processedMarks, "totalDuration":totalDuration}
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "summarizeMarks", ComponentMetricsPlugin.prototype.$summarizeMarks$);
ComponentMetricsPlugin.prototype.$findMinAndIndex$ = function(arr) {
  var min = [arr[0]["createTimeTotal"], 0];
  for(var x = 1;x < arr.length;++x) {
    var newMin = [arr[x]["createTimeTotal"], x];
    min = newMin[0] < min[0] ? newMin : min
  }
  return min
};
ComponentMetricsPlugin.prototype.$postProcess$ = function(marks) {
  if(!marks.length) {
    return[]
  }
  var processedMarksAndInfo = this.$summarizeMarks$(marks);
  var summarizedMark = {"totalCreateTime":Math.floor(processedMarksAndInfo["totalDuration"] * 100) / 100, "slowestCreates":[]};
  var minSlowest = [0, 0];
  var mark;
  var duration;
  var processedMarks = processedMarksAndInfo["processedMarks"];
  for(var i = 0;i < processedMarks.length;i++) {
    mark = processedMarks[i];
    duration = Math.floor(mark["createTimeTotal"] * 100) / 100;
    if(summarizedMark["slowestCreates"].length < 5) {
      mark["createTimeTotal"] = duration;
      summarizedMark["slowestCreates"].push(mark);
      minSlowest = this.$findMinAndIndex$(summarizedMark["slowestCreates"])
    }else {
      if(duration > minSlowest[0]) {
        mark["createTimeTotal"] = duration;
        summarizedMark["slowestCreates"][minSlowest[1]] = mark;
        minSlowest = this.$findMinAndIndex$(summarizedMark["slowestCreates"])
      }
    }
  }
  return[summarizedMark]
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "postProcess", ComponentMetricsPlugin.prototype.$postProcess$);
$A.$metricsService$.$registerPlugin$({"name":ComponentMetricsPlugin["NAME"], "plugin":ComponentMetricsPlugin});
var ComponentServiceMetricsPlugin = function ComponentServiceMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = false
};
goog.$exportSymbol$("ComponentServiceMetricsPlugin", ComponentServiceMetricsPlugin);
ComponentServiceMetricsPlugin["NAME"] = "componentService";
ComponentServiceMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "initialize", ComponentServiceMetricsPlugin.prototype.$initialize$);
ComponentServiceMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$metricsService$)
  }
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "enable", ComponentServiceMetricsPlugin.prototype.enable);
ComponentServiceMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "disable", ComponentServiceMetricsPlugin.prototype.disable);
ComponentServiceMetricsPlugin.prototype.$createComponentOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var cmpConfig = arguments[0];
  var descriptor = $A["util"].$isString$(cmpConfig) ? cmpConfig : (cmpConfig["componentDef"]["descriptor"] || cmpConfig["componentDef"]) + "";
  this.$metricsService$["markStart"](ComponentServiceMetricsPlugin["NAME"], "createComponent", {$context$:{"descriptor":descriptor}});
  var ret = config["fn"].apply(config["scope"], arguments);
  this.$metricsService$["markEnd"](ComponentServiceMetricsPlugin["NAME"], "createComponent", {$context$:{"descriptor":descriptor}});
  return ret
};
ComponentServiceMetricsPlugin.prototype.bind = function() {
  $A.$installOverride$("ComponentService.createComponentPriv", this.$createComponentOverride$, this)
};
ComponentServiceMetricsPlugin.prototype.$postProcess$ = function(componentMarks) {
  var procesedMarks = [];
  var stack = [];
  for(var i = 0;i < componentMarks.length;i++) {
    var phase = componentMarks[i]["phase"];
    if(phase === "start") {
      stack.push(componentMarks[i])
    }else {
      if(phase === "end" && stack.length) {
        var mark = $A["util"].apply({}, stack.pop(), true, true);
        if(mark["context"]["descriptor"] === componentMarks[i]["context"]["descriptor"]) {
          mark["context"] = $A["util"].apply(mark["context"], componentMarks[i]["context"]);
          mark["duration"] = componentMarks[i]["ts"] - mark["ts"];
          procesedMarks.push(mark)
        }
      }
    }
  }
  return procesedMarks
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "postProcess", ComponentServiceMetricsPlugin.prototype.$postProcess$);
ComponentServiceMetricsPlugin.prototype.$unbind$ = function() {
  $A.$unInstallOverride$("ComponentService.createComponentPriv", this.$createComponentOverride$)
};
$A.$metricsService$.$registerPlugin$({"name":ComponentServiceMetricsPlugin["NAME"], "plugin":ComponentServiceMetricsPlugin});
(function() {
  $A.$logger$.$subscribe$("WARNING", function logWarning(level, message, error) {
    if(window["console"]) {
      if(error && error.message) {
        if(message) {
          message += ". Caused by: " + error.message
        }else {
          message = error.message
        }
      }
      window["console"].warn(level + ": " + message)
    }
  });
  $A.$logger$.$subscribe$("ASSERT", function(level, message) {
    throw new $A.$auraError$(message);
  });
  $A.$logger$.$subscribe$("ERROR", function(level, message, e) {
    $A.$reportError$(message, e)
  });
  if($A.$storageService$ && !$A.$storageService$.$getStorage$("ErrorHistory")) {
    $A.$storageService$.$initStorage$({"name":"ErrorHistory", "persistent":true, "secure":false, "maxSize":524288, "expiration":3600, "autoRefreshInterval":30, "debugLogging":true, "clearOnInit":false, "version":"1.0"})
  }
  window.onerror = function() {
    var existing = window.onerror;
    var newHandler = function newErrorHandler(message, url, line, col, err) {
      if(message === "ResizeObserver loop limit exceeded" || message === "ResizeObserver loop completed with undelivered notifications.") {
        return true
      }
      if(url && line && col) {
        message = message + "\nthrows at " + url + ":" + line + ":" + col
      }
      if(!$A.$reportError$(message, err) && !existing) {
        var console_error = window.console && window.console.error.bind(window.console);
        if(console_error) {
          console_error(message, err)
        }
      }
      return true
    };
    return function errorHandlerWrapper() {
      if(existing) {
        try {
          existing.apply(this, arguments)
        }catch(e) {
          $A.$warning$("error from external onerror handler!", e)
        }
      }
      return newHandler.apply(this, arguments)
    }
  }();
  window.addEventListener("unhandledrejection", function onUnhandledrejection(event) {
    var error = event.reason;
    var validError = false;
    if(typeof $A.$auraError$ !== "undefined" && error instanceof $A.$auraError$) {
      validError = true;
      var checkError = new $A.$auraError$(null, error);
      if(!checkError.$isDisplayableError$()) {
        error.$setSeverity$($A.severity.$QUIET$)
      }
    }else {
      if(error && error.name && error.name.indexOf("Error") !== -1) {
        error = new $A.$auraError$(null, error);
        validError = true
      }else {
        if(typeof PromiseRejectionEvent !== "undefined" && event instanceof PromiseRejectionEvent) {
          error = error instanceof Error ? error : new Error("PromiseRejection: " + error);
          error = new $A.$auraError$(null, error);
          validError = true
        }
      }
    }
    if(!validError || !$A.$reportError$(null, error)) {
      var console_error = window.console && window.console.error.bind(window.console);
      if(console_error) {
        console_error(null, event.reason)
      }
    }
  })
})();
Aura["frameworkJsReady"] = true;
if(Aura["initConfig"]) {
  var initConfigContext = Aura["initConfig"]["context"];
  if(initConfigContext) {
    if(!!initConfigContext[Json.$ApplicationKey$.$DOCUMENTPATCHINGBYPASS$]) {
      document.body.setAttribute("data-global-patching-bypass", "temporary-bypass")
    }
  }
  $A.$lockerService$.$initialize$(initConfigContext);
  var scripts = Aura["inlineJsLocker"];
  if(scripts) {
    for(var i = 0;i < scripts.length;i++) {
      $A.$lockerService$.$runScript$(scripts[i]["callback"], scripts[i]["namespace"])
    }
    delete Aura["inlineJsLocker"]
  }
  setTimeout(function initConfigAsync() {
    $A.$initAsync$(Aura["initConfig"])
  }, 0)
}
;
};
Aura.externalLibraries=function(){(function(global,factory){global.moment=factory()})(window.Aura,function(){var hookCallback;function hooks(){return hookCallback.apply(null,arguments)}function setHookCallback(callback){hookCallback=callback}function isArray(input){return input instanceof Array||Object.prototype.toString.call(input)==="[object Array]"}function isObject(input){return input!=null&&Object.prototype.toString.call(input)==="[object Object]"}function isObjectEmpty(obj){if(Object.getOwnPropertyNames)return Object.getOwnPropertyNames(obj).length===
0;else{var k;for(k in obj)if(obj.hasOwnProperty(k))return false;return true}}function isUndefined(input){return input===void 0}function isNumber(input){return typeof input==="number"||Object.prototype.toString.call(input)==="[object Number]"}function isDate(input){return input instanceof Date||Object.prototype.toString.call(input)==="[object Date]"}function map(arr,fn){var res=[],i;for(i=0;i<arr.length;++i)res.push(fn(arr[i],i));return res}function hasOwnProp(a,b){return Object.prototype.hasOwnProperty.call(a,
b)}function extend(a,b){for(var i in b)if(hasOwnProp(b,i))a[i]=b[i];if(hasOwnProp(b,"toString"))a.toString=b.toString;if(hasOwnProp(b,"valueOf"))a.valueOf=b.valueOf;return a}function createUTC(input,format,locale,strict){return createLocalOrUTC(input,format,locale,strict,true).utc()}function defaultParsingFlags(){return{empty:false,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:false,invalidMonth:null,invalidFormat:false,userInvalidated:false,iso:false,parsedDateParts:[],meridiem:null,
rfc2822:false,weekdayMismatch:false}}function getParsingFlags(m){if(m._pf==null)m._pf=defaultParsingFlags();return m._pf}var some;if(Array.prototype.some)some=Array.prototype.some;else some=function(fun){var t=Object(this);var len=t.length>>>0;for(var i=0;i<len;i++)if(i in t&&fun.call(this,t[i],i,t))return true;return false};function isValid(m){if(m._isValid==null){var flags=getParsingFlags(m);var parsedParts=some.call(flags.parsedDateParts,function(i){return i!=null});var isNowValid=!isNaN(m._d.getTime())&&
flags.overflow<0&&!flags.empty&&!flags.invalidMonth&&!flags.invalidWeekday&&!flags.weekdayMismatch&&!flags.nullInput&&!flags.invalidFormat&&!flags.userInvalidated&&(!flags.meridiem||flags.meridiem&&parsedParts);if(m._strict)isNowValid=isNowValid&&flags.charsLeftOver===0&&flags.unusedTokens.length===0&&flags.bigHour===undefined;if(Object.isFrozen==null||!Object.isFrozen(m))m._isValid=isNowValid;else return isNowValid}return m._isValid}function createInvalid(flags){var m=createUTC(NaN);if(flags!=null)extend(getParsingFlags(m),
flags);else getParsingFlags(m).userInvalidated=true;return m}var momentProperties=hooks.momentProperties=[];function copyConfig(to,from){var i,prop,val;if(!isUndefined(from._isAMomentObject))to._isAMomentObject=from._isAMomentObject;if(!isUndefined(from._i))to._i=from._i;if(!isUndefined(from._f))to._f=from._f;if(!isUndefined(from._l))to._l=from._l;if(!isUndefined(from._strict))to._strict=from._strict;if(!isUndefined(from._tzm))to._tzm=from._tzm;if(!isUndefined(from._isUTC))to._isUTC=from._isUTC;if(!isUndefined(from._offset))to._offset=
from._offset;if(!isUndefined(from._pf))to._pf=getParsingFlags(from);if(!isUndefined(from._locale))to._locale=from._locale;if(momentProperties.length>0)for(i=0;i<momentProperties.length;i++){prop=momentProperties[i];val=from[prop];if(!isUndefined(val))to[prop]=val}return to}var updateInProgress=false;function Moment(config){copyConfig(this,config);this._d=new Date(config._d!=null?config._d.getTime():NaN);if(!this.isValid())this._d=new Date(NaN);if(updateInProgress===false){updateInProgress=true;hooks.updateOffset(this);
updateInProgress=false}}function isMoment(obj){return obj instanceof Moment||obj!=null&&obj._isAMomentObject!=null}function absFloor(number){if(number<0)return Math.ceil(number)||0;else return Math.floor(number)}function toInt(argumentForCoercion){var coercedNumber=+argumentForCoercion,value=0;if(coercedNumber!==0&&isFinite(coercedNumber))value=absFloor(coercedNumber);return value}function compareArrays(array1,array2,dontConvert){var len=Math.min(array1.length,array2.length),lengthDiff=Math.abs(array1.length-
array2.length),diffs=0,i;for(i=0;i<len;i++)if(dontConvert&&array1[i]!==array2[i]||!dontConvert&&toInt(array1[i])!==toInt(array2[i]))diffs++;return diffs+lengthDiff}function warn(msg){if(hooks.suppressDeprecationWarnings===false&&typeof console!=="undefined"&&console.warn)console.warn("Deprecation warning: "+msg)}function deprecate(msg,fn){var firstTime=true;return extend(function(){if(hooks.deprecationHandler!=null)hooks.deprecationHandler(null,msg);if(firstTime){var args=[];var arg;for(var i=0;i<
arguments.length;i++){arg="";if(typeof arguments[i]==="object"){arg+="\n["+i+"] ";for(var key in arguments[0])arg+=key+": "+arguments[0][key]+", ";arg=arg.slice(0,-2)}else arg=arguments[i];args.push(arg)}warn(msg+"\nArguments: "+Array.prototype.slice.call(args).join("")+"\n"+(new Error).stack);firstTime=false}return fn.apply(this,arguments)},fn)}var deprecations={};function deprecateSimple(name,msg){if(hooks.deprecationHandler!=null)hooks.deprecationHandler(name,msg);if(!deprecations[name]){warn(msg);
deprecations[name]=true}}hooks.suppressDeprecationWarnings=false;hooks.deprecationHandler=null;function isFunction(input){return input instanceof Function||Object.prototype.toString.call(input)==="[object Function]"}function set(config){var prop,i;for(i in config){prop=config[i];if(isFunction(prop))this[i]=prop;else this["_"+i]=prop}this._config=config;this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)}function mergeConfigs(parentConfig,
childConfig){var res=extend({},parentConfig),prop;for(prop in childConfig)if(hasOwnProp(childConfig,prop))if(isObject(parentConfig[prop])&&isObject(childConfig[prop])){res[prop]={};extend(res[prop],parentConfig[prop]);extend(res[prop],childConfig[prop])}else if(childConfig[prop]!=null)res[prop]=childConfig[prop];else delete res[prop];for(prop in parentConfig)if(hasOwnProp(parentConfig,prop)&&!hasOwnProp(childConfig,prop)&&isObject(parentConfig[prop]))res[prop]=extend({},res[prop]);return res}function Locale(config){if(config!=
null)this.set(config)}var keys;if(Object.keys)keys=Object.keys;else keys=function(obj){var i,res=[];for(i in obj)if(hasOwnProp(obj,i))res.push(i);return res};var defaultCalendar={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"};function calendar(key,mom,now){var output=this._calendar[key]||this._calendar["sameElse"];return isFunction(output)?output.call(mom,now):output}var defaultLongDateFormat={LTS:"h:mm:ss A",
LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};function longDateFormat(key){var format=this._longDateFormat[key],formatUpper=this._longDateFormat[key.toUpperCase()];if(format||!formatUpper)return format;this._longDateFormat[key]=formatUpper.replace(/MMMM|MM|DD|dddd/g,function(val){return val.slice(1)});return this._longDateFormat[key]}var defaultInvalidDate="Invalid date";function invalidDate(){return this._invalidDate}var defaultOrdinal="%d";
var defaultDayOfMonthOrdinalParse=/\d{1,2}/;function ordinal(number){return this._ordinal.replace("%d",number)}var defaultRelativeTime={future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function relativeTime(number,withoutSuffix,string,isFuture){var output=this._relativeTime[string];return isFunction(output)?output(number,withoutSuffix,string,isFuture):output.replace(/%d/i,
number)}function pastFuture(diff,output){var format=this._relativeTime[diff>0?"future":"past"];return isFunction(format)?format(output):format.replace(/%s/i,output)}var aliases={};function addUnitAlias(unit,shorthand){var lowerCase=unit.toLowerCase();aliases[lowerCase]=aliases[lowerCase+"s"]=aliases[shorthand]=unit}function normalizeUnits(units){return typeof units==="string"?aliases[units]||aliases[units.toLowerCase()]:undefined}function normalizeObjectUnits(inputObject){var normalizedInput={},normalizedProp,
prop;for(prop in inputObject)if(hasOwnProp(inputObject,prop)){normalizedProp=normalizeUnits(prop);if(normalizedProp)normalizedInput[normalizedProp]=inputObject[prop]}return normalizedInput}var priorities={};function addUnitPriority(unit,priority){priorities[unit]=priority}function getPrioritizedUnits(unitsObj){var units=[];for(var u in unitsObj)units.push({unit:u,priority:priorities[u]});units.sort(function(a,b){return a.priority-b.priority});return units}function zeroFill(number,targetLength,forceSign){var absNumber=
""+Math.abs(number),zerosToFill=targetLength-absNumber.length,sign=number>=0;return(sign?forceSign?"+":"":"-")+Math.pow(10,Math.max(0,zerosToFill)).toString().substr(1)+absNumber}var formattingTokens=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;var localFormattingTokens=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;var formatFunctions={};var formatTokenFunctions=
{};function addFormatToken(token,padded,ordinal,callback){var func=callback;if(typeof callback==="string")func=function(){return this[callback]()};if(token)formatTokenFunctions[token]=func;if(padded)formatTokenFunctions[padded[0]]=function(){return zeroFill(func.apply(this,arguments),padded[1],padded[2])};if(ordinal)formatTokenFunctions[ordinal]=function(){return this.localeData().ordinal(func.apply(this,arguments),token)}}function removeFormattingTokens(input){if(input.match(/\[[\s\S]/))return input.replace(/^\[|\]$/g,
"");return input.replace(/\\/g,"")}function makeFormatFunction(format){var array=format.match(formattingTokens),i,length;for(i=0,length=array.length;i<length;i++)if(formatTokenFunctions[array[i]])array[i]=formatTokenFunctions[array[i]];else array[i]=removeFormattingTokens(array[i]);return function(mom){var output="",i;for(i=0;i<length;i++)output+=isFunction(array[i])?array[i].call(mom,format):array[i];return output}}function formatMoment(m,format){if(!m.isValid())return m.localeData().invalidDate();
format=expandFormat(format,m.localeData());formatFunctions[format]=formatFunctions[format]||makeFormatFunction(format);return formatFunctions[format](m)}function expandFormat(format,locale){var i=5;function replaceLongDateFormatTokens(input){return locale.longDateFormat(input)||input}localFormattingTokens.lastIndex=0;while(i>=0&&localFormattingTokens.test(format)){format=format.replace(localFormattingTokens,replaceLongDateFormatTokens);localFormattingTokens.lastIndex=0;i-=1}return format}var match1=
/\d/;var match2=/\d\d/;var match3=/\d{3}/;var match4=/\d{4}/;var match6=/[+-]?\d{6}/;var match1to2=/\d\d?/;var match3to4=/\d\d\d\d?/;var match5to6=/\d\d\d\d\d\d?/;var match1to3=/\d{1,3}/;var match1to4=/\d{1,4}/;var match1to6=/[+-]?\d{1,6}/;var matchUnsigned=/\d+/;var matchSigned=/[+-]?\d+/;var matchOffset=/Z|[+-]\d\d:?\d\d/gi;var matchShortOffset=/Z|[+-]\d\d(?::?\d\d)?/gi;var matchTimestamp=/[+-]?\d+(\.\d{1,3})?/;var matchWord=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var regexes={};function addRegexToken(token,regex,strictRegex){regexes[token]=isFunction(regex)?regex:function(isStrict,localeData){return isStrict&&strictRegex?strictRegex:regex}}function getParseRegexForToken(token,config){if(!hasOwnProp(regexes,token))return new RegExp(unescapeFormat(token));return regexes[token](config._strict,config._locale)}function unescapeFormat(s){return regexEscape(s.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(matched,p1,p2,p3,p4){return p1||
p2||p3||p4}))}function regexEscape(s){return s.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$\x26")}var tokens={};function addParseToken(token,callback){var i,func=callback;if(typeof token==="string")token=[token];if(isNumber(callback))func=function(input,array){array[callback]=toInt(input)};for(i=0;i<token.length;i++)tokens[token[i]]=func}function addWeekParseToken(token,callback){addParseToken(token,function(input,array,config,token){config._w=config._w||{};callback(input,config._w,config,token)})}function addTimeToArrayFromToken(token,
input,config){if(input!=null&&hasOwnProp(tokens,token))tokens[token](input,config._a,config,token)}var YEAR=0;var MONTH=1;var DATE=2;var HOUR=3;var MINUTE=4;var SECOND=5;var MILLISECOND=6;var WEEK=7;var WEEKDAY=8;addFormatToken("Y",0,0,function(){var y=this.year();return y<=9999?""+y:"+"+y});addFormatToken(0,["YY",2],0,function(){return this.year()%100});addFormatToken(0,["YYYY",4],0,"year");addFormatToken(0,["YYYYY",5],0,"year");addFormatToken(0,["YYYYYY",6,true],0,"year");addUnitAlias("year","y");
addUnitPriority("year",1);addRegexToken("Y",matchSigned);addRegexToken("YY",match1to2,match2);addRegexToken("YYYY",match1to4,match4);addRegexToken("YYYYY",match1to6,match6);addRegexToken("YYYYYY",match1to6,match6);addParseToken(["YYYYY","YYYYYY"],YEAR);addParseToken("YYYY",function(input,array){array[YEAR]=input.length===2?hooks.parseTwoDigitYear(input):toInt(input)});addParseToken("YY",function(input,array){array[YEAR]=hooks.parseTwoDigitYear(input)});addParseToken("Y",function(input,array){array[YEAR]=
parseInt(input,10)});function daysInYear(year){return isLeapYear(year)?366:365}function isLeapYear(year){return year%4===0&&year%100!==0||year%400===0}hooks.parseTwoDigitYear=function(input){return toInt(input)+(toInt(input)>68?1900:2E3)};var getSetYear=makeGetSet("FullYear",true);function getIsLeapYear(){return isLeapYear(this.year())}function makeGetSet(unit,keepTime){return function(value){if(value!=null){set$1(this,unit,value);hooks.updateOffset(this,keepTime);return this}else return get(this,
unit)}}function get(mom,unit){return mom.isValid()?mom._d["get"+(mom._isUTC?"UTC":"")+unit]():NaN}function set$1(mom,unit,value){if(mom.isValid()&&!isNaN(value))if(unit==="FullYear"&&isLeapYear(mom.year())&&mom.month()===1&&mom.date()===29)mom._d["set"+(mom._isUTC?"UTC":"")+unit](value,mom.month(),daysInMonth(value,mom.month()));else mom._d["set"+(mom._isUTC?"UTC":"")+unit](value)}function stringGet(units){units=normalizeUnits(units);if(isFunction(this[units]))return this[units]();return this}function stringSet(units,
value){if(typeof units==="object"){units=normalizeObjectUnits(units);var prioritized=getPrioritizedUnits(units);for(var i=0;i<prioritized.length;i++)this[prioritized[i].unit](units[prioritized[i].unit])}else{units=normalizeUnits(units);if(isFunction(this[units]))return this[units](value)}return this}function mod(n,x){return(n%x+x)%x}var indexOf;if(Array.prototype.indexOf)indexOf=Array.prototype.indexOf;else indexOf=function(o){var i;for(i=0;i<this.length;++i)if(this[i]===o)return i;return-1};function daysInMonth(year,
month){if(isNaN(year)||isNaN(month))return NaN;var modMonth=mod(month,12);year+=(month-modMonth)/12;return modMonth===1?isLeapYear(year)?29:28:31-modMonth%7%2}addFormatToken("M",["MM",2],"Mo",function(){return this.month()+1});addFormatToken("MMM",0,0,function(format){return this.localeData().monthsShort(this,format)});addFormatToken("MMMM",0,0,function(format){return this.localeData().months(this,format)});addUnitAlias("month","M");addUnitPriority("month",8);addRegexToken("M",match1to2);addRegexToken("MM",
match1to2,match2);addRegexToken("MMM",function(isStrict,locale){return locale.monthsShortRegex(isStrict)});addRegexToken("MMMM",function(isStrict,locale){return locale.monthsRegex(isStrict)});addParseToken(["M","MM"],function(input,array){array[MONTH]=toInt(input)-1});addParseToken(["MMM","MMMM"],function(input,array,config,token){var month=config._locale.monthsParse(input,token,config._strict);if(month!=null)array[MONTH]=month;else getParsingFlags(config).invalidMonth=input});var MONTHS_IN_FORMAT=
/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;var defaultLocaleMonths="January_February_March_April_May_June_July_August_September_October_November_December".split("_");function localeMonths(m,format){if(!m)return isArray(this._months)?this._months:this._months["standalone"];return isArray(this._months)?this._months[m.month()]:this._months[(this._months.isFormat||MONTHS_IN_FORMAT).test(format)?"format":"standalone"][m.month()]}var defaultLocaleMonthsShort="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
function localeMonthsShort(m,format){if(!m)return isArray(this._monthsShort)?this._monthsShort:this._monthsShort["standalone"];return isArray(this._monthsShort)?this._monthsShort[m.month()]:this._monthsShort[MONTHS_IN_FORMAT.test(format)?"format":"standalone"][m.month()]}function handleStrictParse(monthName,format,strict){var i,ii,mom,llc=monthName.toLocaleLowerCase();if(!this._monthsParse){this._monthsParse=[];this._longMonthsParse=[];this._shortMonthsParse=[];for(i=0;i<12;++i){mom=createUTC([2E3,
i]);this._shortMonthsParse[i]=this.monthsShort(mom,"").toLocaleLowerCase();this._longMonthsParse[i]=this.months(mom,"").toLocaleLowerCase()}}if(strict)if(format==="MMM"){ii=indexOf.call(this._shortMonthsParse,llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._longMonthsParse,llc);return ii!==-1?ii:null}else if(format==="MMM"){ii=indexOf.call(this._shortMonthsParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._longMonthsParse,llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._longMonthsParse,
llc);if(ii!==-1)return ii;ii=indexOf.call(this._shortMonthsParse,llc);return ii!==-1?ii:null}}function localeMonthsParse(monthName,format,strict){var i,mom,regex;if(this._monthsParseExact)return handleStrictParse.call(this,monthName,format,strict);if(!this._monthsParse){this._monthsParse=[];this._longMonthsParse=[];this._shortMonthsParse=[]}for(i=0;i<12;i++){mom=createUTC([2E3,i]);if(strict&&!this._longMonthsParse[i]){this._longMonthsParse[i]=new RegExp("^"+this.months(mom,"").replace(".","")+"$",
"i");this._shortMonthsParse[i]=new RegExp("^"+this.monthsShort(mom,"").replace(".","")+"$","i")}if(!strict&&!this._monthsParse[i]){regex="^"+this.months(mom,"")+"|^"+this.monthsShort(mom,"");this._monthsParse[i]=new RegExp(regex.replace(".",""),"i")}if(strict&&format==="MMMM"&&this._longMonthsParse[i].test(monthName))return i;else if(strict&&format==="MMM"&&this._shortMonthsParse[i].test(monthName))return i;else if(!strict&&this._monthsParse[i].test(monthName))return i}}function setMonth(mom,value){var dayOfMonth;
if(!mom.isValid())return mom;if(typeof value==="string")if(/^\d+$/.test(value))value=toInt(value);else{value=mom.localeData().monthsParse(value);if(!isNumber(value))return mom}dayOfMonth=Math.min(mom.date(),daysInMonth(mom.year(),value));mom._d["set"+(mom._isUTC?"UTC":"")+"Month"](value,dayOfMonth);return mom}function getSetMonth(value){if(value!=null){setMonth(this,value);hooks.updateOffset(this,true);return this}else return get(this,"Month")}function getDaysInMonth(){return daysInMonth(this.year(),
this.month())}var defaultMonthsShortRegex=matchWord;function monthsShortRegex(isStrict){if(this._monthsParseExact){if(!hasOwnProp(this,"_monthsRegex"))computeMonthsParse.call(this);if(isStrict)return this._monthsShortStrictRegex;else return this._monthsShortRegex}else{if(!hasOwnProp(this,"_monthsShortRegex"))this._monthsShortRegex=defaultMonthsShortRegex;return this._monthsShortStrictRegex&&isStrict?this._monthsShortStrictRegex:this._monthsShortRegex}}var defaultMonthsRegex=matchWord;function monthsRegex(isStrict){if(this._monthsParseExact){if(!hasOwnProp(this,
"_monthsRegex"))computeMonthsParse.call(this);if(isStrict)return this._monthsStrictRegex;else return this._monthsRegex}else{if(!hasOwnProp(this,"_monthsRegex"))this._monthsRegex=defaultMonthsRegex;return this._monthsStrictRegex&&isStrict?this._monthsStrictRegex:this._monthsRegex}}function computeMonthsParse(){function cmpLenRev(a,b){return b.length-a.length}var shortPieces=[],longPieces=[],mixedPieces=[],i,mom;for(i=0;i<12;i++){mom=createUTC([2E3,i]);shortPieces.push(this.monthsShort(mom,""));longPieces.push(this.months(mom,
""));mixedPieces.push(this.months(mom,""));mixedPieces.push(this.monthsShort(mom,""))}shortPieces.sort(cmpLenRev);longPieces.sort(cmpLenRev);mixedPieces.sort(cmpLenRev);for(i=0;i<12;i++){shortPieces[i]=regexEscape(shortPieces[i]);longPieces[i]=regexEscape(longPieces[i])}for(i=0;i<24;i++)mixedPieces[i]=regexEscape(mixedPieces[i]);this._monthsRegex=new RegExp("^("+mixedPieces.join("|")+")","i");this._monthsShortRegex=this._monthsRegex;this._monthsStrictRegex=new RegExp("^("+longPieces.join("|")+")",
"i");this._monthsShortStrictRegex=new RegExp("^("+shortPieces.join("|")+")","i")}function createDate(y,m,d,h,M,s,ms){var date;if(y<100&&y>=0){date=new Date(y+400,m,d,h,M,s,ms);if(isFinite(date.getFullYear()))date.setFullYear(y)}else date=new Date(y,m,d,h,M,s,ms);return date}function createUTCDate(y){var date;if(y<100&&y>=0){var args=Array.prototype.slice.call(arguments);args[0]=y+400;date=new Date(Date.UTC.apply(null,args));if(isFinite(date.getUTCFullYear()))date.setUTCFullYear(y)}else date=new Date(Date.UTC.apply(null,
arguments));return date}function firstWeekOffset(year,dow,doy){var fwd=7+dow-doy,fwdlw=(7+createUTCDate(year,0,fwd).getUTCDay()-dow)%7;return-fwdlw+fwd-1}function dayOfYearFromWeeks(year,week,weekday,dow,doy){var localWeekday=(7+weekday-dow)%7,weekOffset=firstWeekOffset(year,dow,doy),dayOfYear=1+7*(week-1)+localWeekday+weekOffset,resYear,resDayOfYear;if(dayOfYear<=0){resYear=year-1;resDayOfYear=daysInYear(resYear)+dayOfYear}else if(dayOfYear>daysInYear(year)){resYear=year+1;resDayOfYear=dayOfYear-
daysInYear(year)}else{resYear=year;resDayOfYear=dayOfYear}return{year:resYear,dayOfYear:resDayOfYear}}function weekOfYear(mom,dow,doy){var weekOffset=firstWeekOffset(mom.year(),dow,doy),week=Math.floor((mom.dayOfYear()-weekOffset-1)/7)+1,resWeek,resYear;if(week<1){resYear=mom.year()-1;resWeek=week+weeksInYear(resYear,dow,doy)}else if(week>weeksInYear(mom.year(),dow,doy)){resWeek=week-weeksInYear(mom.year(),dow,doy);resYear=mom.year()+1}else{resYear=mom.year();resWeek=week}return{week:resWeek,year:resYear}}
function weeksInYear(year,dow,doy){var weekOffset=firstWeekOffset(year,dow,doy),weekOffsetNext=firstWeekOffset(year+1,dow,doy);return(daysInYear(year)-weekOffset+weekOffsetNext)/7}addFormatToken("w",["ww",2],"wo","week");addFormatToken("W",["WW",2],"Wo","isoWeek");addUnitAlias("week","w");addUnitAlias("isoWeek","W");addUnitPriority("week",5);addUnitPriority("isoWeek",5);addRegexToken("w",match1to2);addRegexToken("ww",match1to2,match2);addRegexToken("W",match1to2);addRegexToken("WW",match1to2,match2);
addWeekParseToken(["w","ww","W","WW"],function(input,week,config,token){week[token.substr(0,1)]=toInt(input)});function localeWeek(mom){return weekOfYear(mom,this._week.dow,this._week.doy).week}var defaultLocaleWeek={dow:0,doy:6};function localeFirstDayOfWeek(){return this._week.dow}function localeFirstDayOfYear(){return this._week.doy}function getSetWeek(input){var week=this.localeData().week(this);return input==null?week:this.add((input-week)*7,"d")}function getSetISOWeek(input){var week=weekOfYear(this,
1,4).week;return input==null?week:this.add((input-week)*7,"d")}addFormatToken("d",0,"do","day");addFormatToken("dd",0,0,function(format){return this.localeData().weekdaysMin(this,format)});addFormatToken("ddd",0,0,function(format){return this.localeData().weekdaysShort(this,format)});addFormatToken("dddd",0,0,function(format){return this.localeData().weekdays(this,format)});addFormatToken("e",0,0,"weekday");addFormatToken("E",0,0,"isoWeekday");addUnitAlias("day","d");addUnitAlias("weekday","e");addUnitAlias("isoWeekday",
"E");addUnitPriority("day",11);addUnitPriority("weekday",11);addUnitPriority("isoWeekday",11);addRegexToken("d",match1to2);addRegexToken("e",match1to2);addRegexToken("E",match1to2);addRegexToken("dd",function(isStrict,locale){return locale.weekdaysMinRegex(isStrict)});addRegexToken("ddd",function(isStrict,locale){return locale.weekdaysShortRegex(isStrict)});addRegexToken("dddd",function(isStrict,locale){return locale.weekdaysRegex(isStrict)});addWeekParseToken(["dd","ddd","dddd"],function(input,week,
config,token){var weekday=config._locale.weekdaysParse(input,token,config._strict);if(weekday!=null)week.d=weekday;else getParsingFlags(config).invalidWeekday=input});addWeekParseToken(["d","e","E"],function(input,week,config,token){week[token]=toInt(input)});function parseWeekday(input,locale){if(typeof input!=="string")return input;if(!isNaN(input))return parseInt(input,10);input=locale.weekdaysParse(input);if(typeof input==="number")return input;return null}function parseIsoWeekday(input,locale){if(typeof input===
"string")return locale.weekdaysParse(input)%7||7;return isNaN(input)?null:input}function shiftWeekdays(ws,n){return ws.slice(n,7).concat(ws.slice(0,n))}var defaultLocaleWeekdays="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");function localeWeekdays(m,format){var weekdays=isArray(this._weekdays)?this._weekdays:this._weekdays[m&&m!==true&&this._weekdays.isFormat.test(format)?"format":"standalone"];return m===true?shiftWeekdays(weekdays,this._week.dow):m?weekdays[m.day()]:weekdays}
var defaultLocaleWeekdaysShort="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");function localeWeekdaysShort(m){return m===true?shiftWeekdays(this._weekdaysShort,this._week.dow):m?this._weekdaysShort[m.day()]:this._weekdaysShort}var defaultLocaleWeekdaysMin="Su_Mo_Tu_We_Th_Fr_Sa".split("_");function localeWeekdaysMin(m){return m===true?shiftWeekdays(this._weekdaysMin,this._week.dow):m?this._weekdaysMin[m.day()]:this._weekdaysMin}function handleStrictParse$1(weekdayName,format,strict){var i,ii,mom,llc=weekdayName.toLocaleLowerCase();
if(!this._weekdaysParse){this._weekdaysParse=[];this._shortWeekdaysParse=[];this._minWeekdaysParse=[];for(i=0;i<7;++i){mom=createUTC([2E3,1]).day(i);this._minWeekdaysParse[i]=this.weekdaysMin(mom,"").toLocaleLowerCase();this._shortWeekdaysParse[i]=this.weekdaysShort(mom,"").toLocaleLowerCase();this._weekdaysParse[i]=this.weekdays(mom,"").toLocaleLowerCase()}}if(strict)if(format==="dddd"){ii=indexOf.call(this._weekdaysParse,llc);return ii!==-1?ii:null}else if(format==="ddd"){ii=indexOf.call(this._shortWeekdaysParse,
llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._minWeekdaysParse,llc);return ii!==-1?ii:null}else if(format==="dddd"){ii=indexOf.call(this._weekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._shortWeekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._minWeekdaysParse,llc);return ii!==-1?ii:null}else if(format==="ddd"){ii=indexOf.call(this._shortWeekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._weekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._minWeekdaysParse,
llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._minWeekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._weekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._shortWeekdaysParse,llc);return ii!==-1?ii:null}}function localeWeekdaysParse(weekdayName,format,strict){var i,mom,regex;if(this._weekdaysParseExact)return handleStrictParse$1.call(this,weekdayName,format,strict);if(!this._weekdaysParse){this._weekdaysParse=[];this._minWeekdaysParse=[];this._shortWeekdaysParse=[];this._fullWeekdaysParse=
[]}for(i=0;i<7;i++){mom=createUTC([2E3,1]).day(i);if(strict&&!this._fullWeekdaysParse[i]){this._fullWeekdaysParse[i]=new RegExp("^"+this.weekdays(mom,"").replace(".","\\.?")+"$","i");this._shortWeekdaysParse[i]=new RegExp("^"+this.weekdaysShort(mom,"").replace(".","\\.?")+"$","i");this._minWeekdaysParse[i]=new RegExp("^"+this.weekdaysMin(mom,"").replace(".","\\.?")+"$","i")}if(!this._weekdaysParse[i]){regex="^"+this.weekdays(mom,"")+"|^"+this.weekdaysShort(mom,"")+"|^"+this.weekdaysMin(mom,"");this._weekdaysParse[i]=
new RegExp(regex.replace(".",""),"i")}if(strict&&format==="dddd"&&this._fullWeekdaysParse[i].test(weekdayName))return i;else if(strict&&format==="ddd"&&this._shortWeekdaysParse[i].test(weekdayName))return i;else if(strict&&format==="dd"&&this._minWeekdaysParse[i].test(weekdayName))return i;else if(!strict&&this._weekdaysParse[i].test(weekdayName))return i}}function getSetDayOfWeek(input){if(!this.isValid())return input!=null?this:NaN;var day=this._isUTC?this._d.getUTCDay():this._d.getDay();if(input!=
null){input=parseWeekday(input,this.localeData());return this.add(input-day,"d")}else return day}function getSetLocaleDayOfWeek(input){if(!this.isValid())return input!=null?this:NaN;var weekday=(this.day()+7-this.localeData()._week.dow)%7;return input==null?weekday:this.add(input-weekday,"d")}function getSetISODayOfWeek(input){if(!this.isValid())return input!=null?this:NaN;if(input!=null){var weekday=parseIsoWeekday(input,this.localeData());return this.day(this.day()%7?weekday:weekday-7)}else return this.day()||
7}var defaultWeekdaysRegex=matchWord;function weekdaysRegex(isStrict){if(this._weekdaysParseExact){if(!hasOwnProp(this,"_weekdaysRegex"))computeWeekdaysParse.call(this);if(isStrict)return this._weekdaysStrictRegex;else return this._weekdaysRegex}else{if(!hasOwnProp(this,"_weekdaysRegex"))this._weekdaysRegex=defaultWeekdaysRegex;return this._weekdaysStrictRegex&&isStrict?this._weekdaysStrictRegex:this._weekdaysRegex}}var defaultWeekdaysShortRegex=matchWord;function weekdaysShortRegex(isStrict){if(this._weekdaysParseExact){if(!hasOwnProp(this,
"_weekdaysRegex"))computeWeekdaysParse.call(this);if(isStrict)return this._weekdaysShortStrictRegex;else return this._weekdaysShortRegex}else{if(!hasOwnProp(this,"_weekdaysShortRegex"))this._weekdaysShortRegex=defaultWeekdaysShortRegex;return this._weekdaysShortStrictRegex&&isStrict?this._weekdaysShortStrictRegex:this._weekdaysShortRegex}}var defaultWeekdaysMinRegex=matchWord;function weekdaysMinRegex(isStrict){if(this._weekdaysParseExact){if(!hasOwnProp(this,"_weekdaysRegex"))computeWeekdaysParse.call(this);
if(isStrict)return this._weekdaysMinStrictRegex;else return this._weekdaysMinRegex}else{if(!hasOwnProp(this,"_weekdaysMinRegex"))this._weekdaysMinRegex=defaultWeekdaysMinRegex;return this._weekdaysMinStrictRegex&&isStrict?this._weekdaysMinStrictRegex:this._weekdaysMinRegex}}function computeWeekdaysParse(){function cmpLenRev(a,b){return b.length-a.length}var minPieces=[],shortPieces=[],longPieces=[],mixedPieces=[],i,mom,minp,shortp,longp;for(i=0;i<7;i++){mom=createUTC([2E3,1]).day(i);minp=this.weekdaysMin(mom,
"");shortp=this.weekdaysShort(mom,"");longp=this.weekdays(mom,"");minPieces.push(minp);shortPieces.push(shortp);longPieces.push(longp);mixedPieces.push(minp);mixedPieces.push(shortp);mixedPieces.push(longp)}minPieces.sort(cmpLenRev);shortPieces.sort(cmpLenRev);longPieces.sort(cmpLenRev);mixedPieces.sort(cmpLenRev);for(i=0;i<7;i++){shortPieces[i]=regexEscape(shortPieces[i]);longPieces[i]=regexEscape(longPieces[i]);mixedPieces[i]=regexEscape(mixedPieces[i])}this._weekdaysRegex=new RegExp("^("+mixedPieces.join("|")+
")","i");this._weekdaysShortRegex=this._weekdaysRegex;this._weekdaysMinRegex=this._weekdaysRegex;this._weekdaysStrictRegex=new RegExp("^("+longPieces.join("|")+")","i");this._weekdaysShortStrictRegex=new RegExp("^("+shortPieces.join("|")+")","i");this._weekdaysMinStrictRegex=new RegExp("^("+minPieces.join("|")+")","i")}function hFormat(){return this.hours()%12||12}function kFormat(){return this.hours()||24}addFormatToken("H",["HH",2],0,"hour");addFormatToken("h",["hh",2],0,hFormat);addFormatToken("k",
["kk",2],0,kFormat);addFormatToken("hmm",0,0,function(){return""+hFormat.apply(this)+zeroFill(this.minutes(),2)});addFormatToken("hmmss",0,0,function(){return""+hFormat.apply(this)+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2)});addFormatToken("Hmm",0,0,function(){return""+this.hours()+zeroFill(this.minutes(),2)});addFormatToken("Hmmss",0,0,function(){return""+this.hours()+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2)});function meridiem(token,lowercase){addFormatToken(token,0,0,function(){return this.localeData().meridiem(this.hours(),
this.minutes(),lowercase)})}meridiem("a",true);meridiem("A",false);addUnitAlias("hour","h");addUnitPriority("hour",13);function matchMeridiem(isStrict,locale){return locale._meridiemParse}addRegexToken("a",matchMeridiem);addRegexToken("A",matchMeridiem);addRegexToken("H",match1to2);addRegexToken("h",match1to2);addRegexToken("k",match1to2);addRegexToken("HH",match1to2,match2);addRegexToken("hh",match1to2,match2);addRegexToken("kk",match1to2,match2);addRegexToken("hmm",match3to4);addRegexToken("hmmss",
match5to6);addRegexToken("Hmm",match3to4);addRegexToken("Hmmss",match5to6);addParseToken(["H","HH"],HOUR);addParseToken(["k","kk"],function(input,array,config){var kInput=toInt(input);array[HOUR]=kInput===24?0:kInput});addParseToken(["a","A"],function(input,array,config){config._isPm=config._locale.isPM(input);config._meridiem=input});addParseToken(["h","hh"],function(input,array,config){array[HOUR]=toInt(input);getParsingFlags(config).bigHour=true});addParseToken("hmm",function(input,array,config){var pos=
input.length-2;array[HOUR]=toInt(input.substr(0,pos));array[MINUTE]=toInt(input.substr(pos));getParsingFlags(config).bigHour=true});addParseToken("hmmss",function(input,array,config){var pos1=input.length-4;var pos2=input.length-2;array[HOUR]=toInt(input.substr(0,pos1));array[MINUTE]=toInt(input.substr(pos1,2));array[SECOND]=toInt(input.substr(pos2));getParsingFlags(config).bigHour=true});addParseToken("Hmm",function(input,array,config){var pos=input.length-2;array[HOUR]=toInt(input.substr(0,pos));
array[MINUTE]=toInt(input.substr(pos))});addParseToken("Hmmss",function(input,array,config){var pos1=input.length-4;var pos2=input.length-2;array[HOUR]=toInt(input.substr(0,pos1));array[MINUTE]=toInt(input.substr(pos1,2));array[SECOND]=toInt(input.substr(pos2))});function localeIsPM(input){return(input+"").toLowerCase().charAt(0)==="p"}var defaultLocaleMeridiemParse=/[ap]\.?m?\.?/i;function localeMeridiem(hours,minutes,isLower){if(hours>11)return isLower?"pm":"PM";else return isLower?"am":"AM"}var getSetHour=
makeGetSet("Hours",true);var baseConfig={calendar:defaultCalendar,longDateFormat:defaultLongDateFormat,invalidDate:defaultInvalidDate,ordinal:defaultOrdinal,dayOfMonthOrdinalParse:defaultDayOfMonthOrdinalParse,relativeTime:defaultRelativeTime,months:defaultLocaleMonths,monthsShort:defaultLocaleMonthsShort,week:defaultLocaleWeek,weekdays:defaultLocaleWeekdays,weekdaysMin:defaultLocaleWeekdaysMin,weekdaysShort:defaultLocaleWeekdaysShort,meridiemParse:defaultLocaleMeridiemParse};var locales={};var localeFamilies=
{};var globalLocale;function normalizeLocale(key){return key?key.toLowerCase().replace("_","-"):key}function chooseLocale(names){var i=0,j,next,locale,split;while(i<names.length){split=normalizeLocale(names[i]).split("-");j=split.length;next=normalizeLocale(names[i+1]);next=next?next.split("-"):null;while(j>0){locale=loadLocale(split.slice(0,j).join("-"));if(locale)return locale;if(next&&next.length>=j&&compareArrays(split,next,true)>=j-1)break;j--}i++}return globalLocale}function loadLocale(name){var oldLocale=
null;if(!locales[name]&&typeof module!=="undefined"&&module&&module.exports)try{oldLocale=globalLocale._abbr;var aliasedRequire=require;aliasedRequire("./locale/"+name);getSetGlobalLocale(oldLocale)}catch(e){}return locales[name]}function getSetGlobalLocale(key,values){var data;if(key){if(isUndefined(values))data=getLocale(key);else data=defineLocale(key,values);if(data)globalLocale=data;else if(typeof console!=="undefined"&&console.warn)console.warn("Locale "+key+" not found. Did you forget to load it?")}return globalLocale._abbr}
function defineLocale(name,config){if(config!==null){var locale,parentConfig=baseConfig;config.abbr=name;if(locales[name]!=null){deprecateSimple("defineLocaleOverride","use moment.updateLocale(localeName, config) to change "+"an existing locale. moment.defineLocale(localeName, "+"config) should only be used for creating a new locale "+"See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");parentConfig=locales[name]._config}else if(config.parentLocale!=null)if(locales[config.parentLocale]!=
null)parentConfig=locales[config.parentLocale]._config;else{locale=loadLocale(config.parentLocale);if(locale!=null)parentConfig=locale._config;else{if(!localeFamilies[config.parentLocale])localeFamilies[config.parentLocale]=[];localeFamilies[config.parentLocale].push({name:name,config:config});return null}}locales[name]=new Locale(mergeConfigs(parentConfig,config));if(localeFamilies[name])localeFamilies[name].forEach(function(x){defineLocale(x.name,x.config)});getSetGlobalLocale(name);return locales[name]}else{delete locales[name];
return null}}function updateLocale(name,config){if(config!=null){var locale,tmpLocale,parentConfig=baseConfig;tmpLocale=loadLocale(name);if(tmpLocale!=null)parentConfig=tmpLocale._config;config=mergeConfigs(parentConfig,config);locale=new Locale(config);locale.parentLocale=locales[name];locales[name]=locale;getSetGlobalLocale(name)}else if(locales[name]!=null)if(locales[name].parentLocale!=null)locales[name]=locales[name].parentLocale;else if(locales[name]!=null)delete locales[name];return locales[name]}
function getLocale(key){var locale;if(key&&key._locale&&key._locale._abbr)key=key._locale._abbr;if(!key)return globalLocale;if(!isArray(key)){locale=loadLocale(key);if(locale)return locale;key=[key]}return chooseLocale(key)}function listLocales(){return keys(locales)}function checkOverflow(m){var overflow;var a=m._a;if(a&&getParsingFlags(m).overflow===-2){overflow=a[MONTH]<0||a[MONTH]>11?MONTH:a[DATE]<1||a[DATE]>daysInMonth(a[YEAR],a[MONTH])?DATE:a[HOUR]<0||a[HOUR]>24||a[HOUR]===24&&(a[MINUTE]!==
0||a[SECOND]!==0||a[MILLISECOND]!==0)?HOUR:a[MINUTE]<0||a[MINUTE]>59?MINUTE:a[SECOND]<0||a[SECOND]>59?SECOND:a[MILLISECOND]<0||a[MILLISECOND]>999?MILLISECOND:-1;if(getParsingFlags(m)._overflowDayOfYear&&(overflow<YEAR||overflow>DATE))overflow=DATE;if(getParsingFlags(m)._overflowWeeks&&overflow===-1)overflow=WEEK;if(getParsingFlags(m)._overflowWeekday&&overflow===-1)overflow=WEEKDAY;getParsingFlags(m).overflow=overflow}return m}function defaults(a,b,c){if(a!=null)return a;if(b!=null)return b;return c}
function currentDateArray(config){var nowValue=new Date(hooks.now());if(config._useUTC)return[nowValue.getUTCFullYear(),nowValue.getUTCMonth(),nowValue.getUTCDate()];return[nowValue.getFullYear(),nowValue.getMonth(),nowValue.getDate()]}function configFromArray(config){var i,date,input=[],currentDate,expectedWeekday,yearToUse;if(config._d)return;currentDate=currentDateArray(config);if(config._w&&config._a[DATE]==null&&config._a[MONTH]==null)dayOfYearFromWeekInfo(config);if(config._dayOfYear!=null){yearToUse=
defaults(config._a[YEAR],currentDate[YEAR]);if(config._dayOfYear>daysInYear(yearToUse)||config._dayOfYear===0)getParsingFlags(config)._overflowDayOfYear=true;date=createUTCDate(yearToUse,0,config._dayOfYear);config._a[MONTH]=date.getUTCMonth();config._a[DATE]=date.getUTCDate()}for(i=0;i<3&&config._a[i]==null;++i)config._a[i]=input[i]=currentDate[i];for(;i<7;i++)config._a[i]=input[i]=config._a[i]==null?i===2?1:0:config._a[i];if(config._a[HOUR]===24&&config._a[MINUTE]===0&&config._a[SECOND]===0&&config._a[MILLISECOND]===
0){config._nextDay=true;config._a[HOUR]=0}config._d=(config._useUTC?createUTCDate:createDate).apply(null,input);expectedWeekday=config._useUTC?config._d.getUTCDay():config._d.getDay();if(config._tzm!=null)config._d.setUTCMinutes(config._d.getUTCMinutes()-config._tzm);if(config._nextDay)config._a[HOUR]=24;if(config._w&&typeof config._w.d!=="undefined"&&config._w.d!==expectedWeekday)getParsingFlags(config).weekdayMismatch=true}function dayOfYearFromWeekInfo(config){var w,weekYear,week,weekday,dow,doy,
temp,weekdayOverflow;w=config._w;if(w.GG!=null||w.W!=null||w.E!=null){dow=1;doy=4;weekYear=defaults(w.GG,config._a[YEAR],weekOfYear(createLocal(),1,4).year);week=defaults(w.W,1);weekday=defaults(w.E,1);if(weekday<1||weekday>7)weekdayOverflow=true}else{dow=config._locale._week.dow;doy=config._locale._week.doy;var curWeek=weekOfYear(createLocal(),dow,doy);weekYear=defaults(w.gg,config._a[YEAR],curWeek.year);week=defaults(w.w,curWeek.week);if(w.d!=null){weekday=w.d;if(weekday<0||weekday>6)weekdayOverflow=
true}else if(w.e!=null){weekday=w.e+dow;if(w.e<0||w.e>6)weekdayOverflow=true}else weekday=dow}if(week<1||week>weeksInYear(weekYear,dow,doy))getParsingFlags(config)._overflowWeeks=true;else if(weekdayOverflow!=null)getParsingFlags(config)._overflowWeekday=true;else{temp=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy);config._a[YEAR]=temp.year;config._dayOfYear=temp.dayOfYear}}var extendedIsoRegex=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;var tzRegex=/Z|[+-]\d\d(?::?\d\d)?/;var isoDates=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,false],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,false],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,
false],["YYYYDDD",/\d{7}/]];var isoTimes=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]];var aspNetJsonRegex=/^\/?Date\((\-?\d+)/i;function configFromISO(config){var i,l,string=config._i,match=extendedIsoRegex.exec(string)||basicIsoRegex.exec(string),allowTime,dateFormat,timeFormat,tzFormat;
if(match){getParsingFlags(config).iso=true;for(i=0,l=isoDates.length;i<l;i++)if(isoDates[i][1].exec(match[1])){dateFormat=isoDates[i][0];allowTime=isoDates[i][2]!==false;break}if(dateFormat==null){config._isValid=false;return}if(match[3]){for(i=0,l=isoTimes.length;i<l;i++)if(isoTimes[i][1].exec(match[3])){timeFormat=(match[2]||" ")+isoTimes[i][0];break}if(timeFormat==null){config._isValid=false;return}}if(!allowTime&&timeFormat!=null){config._isValid=false;return}if(match[4])if(tzRegex.exec(match[4]))tzFormat=
"Z";else{config._isValid=false;return}config._f=dateFormat+(timeFormat||"")+(tzFormat||"");configFromStringAndFormat(config)}else config._isValid=false}var rfc2822=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function extractFromRFC2822Strings(yearStr,monthStr,dayStr,hourStr,minuteStr,secondStr){var result=[untruncateYear(yearStr),defaultLocaleMonthsShort.indexOf(monthStr),
parseInt(dayStr,10),parseInt(hourStr,10),parseInt(minuteStr,10)];if(secondStr)result.push(parseInt(secondStr,10));return result}function untruncateYear(yearStr){var year=parseInt(yearStr,10);if(year<=49)return 2E3+year;else if(year<=999)return 1900+year;return year}function preprocessRFC2822(s){return s.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,"")}function checkWeekday(weekdayStr,parsedInput,config){if(weekdayStr){var weekdayProvided=defaultLocaleWeekdaysShort.indexOf(weekdayStr),
weekdayActual=(new Date(parsedInput[0],parsedInput[1],parsedInput[2])).getDay();if(weekdayProvided!==weekdayActual){getParsingFlags(config).weekdayMismatch=true;config._isValid=false;return false}}return true}var obsOffsets={UT:0,GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};function calculateOffset(obsOffset,militaryOffset,numOffset){if(obsOffset)return obsOffsets[obsOffset];else if(militaryOffset)return 0;else{var hm=parseInt(numOffset,10);var m=hm%100,h=
(hm-m)/100;return h*60+m}}function configFromRFC2822(config){var match=rfc2822.exec(preprocessRFC2822(config._i));if(match){var parsedArray=extractFromRFC2822Strings(match[4],match[3],match[2],match[5],match[6],match[7]);if(!checkWeekday(match[1],parsedArray,config))return;config._a=parsedArray;config._tzm=calculateOffset(match[8],match[9],match[10]);config._d=createUTCDate.apply(null,config._a);config._d.setUTCMinutes(config._d.getUTCMinutes()-config._tzm);getParsingFlags(config).rfc2822=true}else config._isValid=
false}function configFromString(config){var matched=aspNetJsonRegex.exec(config._i);if(matched!==null){config._d=new Date(+matched[1]);return}configFromISO(config);if(config._isValid===false)delete config._isValid;else return;configFromRFC2822(config);if(config._isValid===false)delete config._isValid;else return;hooks.createFromInputFallback(config)}hooks.createFromInputFallback=deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), "+
"which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are "+"discouraged and will be removed in an upcoming major release. Please refer to "+"http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(config){config._d=new Date(config._i+(config._useUTC?" UTC":""))});hooks.ISO_8601=function(){};hooks.RFC_2822=function(){};function configFromStringAndFormat(config){if(config._f===hooks.ISO_8601){configFromISO(config);return}if(config._f===hooks.RFC_2822){configFromRFC2822(config);
return}config._a=[];getParsingFlags(config).empty=true;var string=""+config._i,i,parsedInput,tokens,token,skipped,stringLength=string.length,totalParsedInputLength=0;tokens=expandFormat(config._f,config._locale).match(formattingTokens)||[];for(i=0;i<tokens.length;i++){token=tokens[i];parsedInput=(string.match(getParseRegexForToken(token,config))||[])[0];if(parsedInput){skipped=string.substr(0,string.indexOf(parsedInput));if(skipped.length>0)getParsingFlags(config).unusedInput.push(skipped);string=
string.slice(string.indexOf(parsedInput)+parsedInput.length);totalParsedInputLength+=parsedInput.length}if(formatTokenFunctions[token]){if(parsedInput)getParsingFlags(config).empty=false;else getParsingFlags(config).unusedTokens.push(token);addTimeToArrayFromToken(token,parsedInput,config)}else if(config._strict&&!parsedInput)getParsingFlags(config).unusedTokens.push(token)}getParsingFlags(config).charsLeftOver=stringLength-totalParsedInputLength;if(string.length>0)getParsingFlags(config).unusedInput.push(string);
if(config._a[HOUR]<=12&&getParsingFlags(config).bigHour===true&&config._a[HOUR]>0)getParsingFlags(config).bigHour=undefined;getParsingFlags(config).parsedDateParts=config._a.slice(0);getParsingFlags(config).meridiem=config._meridiem;config._a[HOUR]=meridiemFixWrap(config._locale,config._a[HOUR],config._meridiem);configFromArray(config);checkOverflow(config)}function meridiemFixWrap(locale,hour,meridiem){var isPm;if(meridiem==null)return hour;if(locale.meridiemHour!=null)return locale.meridiemHour(hour,
meridiem);else if(locale.isPM!=null){isPm=locale.isPM(meridiem);if(isPm&&hour<12)hour+=12;if(!isPm&&hour===12)hour=0;return hour}else return hour}function configFromStringAndArray(config){var tempConfig,bestMoment,scoreToBeat,i,currentScore;if(config._f.length===0){getParsingFlags(config).invalidFormat=true;config._d=new Date(NaN);return}for(i=0;i<config._f.length;i++){currentScore=0;tempConfig=copyConfig({},config);if(config._useUTC!=null)tempConfig._useUTC=config._useUTC;tempConfig._f=config._f[i];
configFromStringAndFormat(tempConfig);if(!isValid(tempConfig))continue;currentScore+=getParsingFlags(tempConfig).charsLeftOver;currentScore+=getParsingFlags(tempConfig).unusedTokens.length*10;getParsingFlags(tempConfig).score=currentScore;if(scoreToBeat==null||currentScore<scoreToBeat){scoreToBeat=currentScore;bestMoment=tempConfig}}extend(config,bestMoment||tempConfig)}function configFromObject(config){if(config._d)return;var i=normalizeObjectUnits(config._i);config._a=map([i.year,i.month,i.day||
i.date,i.hour,i.minute,i.second,i.millisecond],function(obj){return obj&&parseInt(obj,10)});configFromArray(config)}function createFromConfig(config){var res=new Moment(checkOverflow(prepareConfig(config)));if(res._nextDay){res.add(1,"d");res._nextDay=undefined}return res}function prepareConfig(config){var input=config._i,format=config._f;config._locale=config._locale||getLocale(config._l);if(input===null||format===undefined&&input==="")return createInvalid({nullInput:true});if(typeof input==="string")config._i=
input=config._locale.preparse(input);if(isMoment(input))return new Moment(checkOverflow(input));else if(isDate(input))config._d=input;else if(isArray(format))configFromStringAndArray(config);else if(format)configFromStringAndFormat(config);else configFromInput(config);if(!isValid(config))config._d=null;return config}function configFromInput(config){var input=config._i;if(isUndefined(input))config._d=new Date(hooks.now());else if(isDate(input))config._d=new Date(input.valueOf());else if(typeof input===
"string")configFromString(config);else if(isArray(input)){config._a=map(input.slice(0),function(obj){return parseInt(obj,10)});configFromArray(config)}else if(isObject(input))configFromObject(config);else if(isNumber(input))config._d=new Date(input);else hooks.createFromInputFallback(config)}function createLocalOrUTC(input,format,locale,strict,isUTC){var c={};if(locale===true||locale===false){strict=locale;locale=undefined}if(isObject(input)&&isObjectEmpty(input)||isArray(input)&&input.length===0)input=
undefined;c._isAMomentObject=true;c._useUTC=c._isUTC=isUTC;c._l=locale;c._i=input;c._f=format;c._strict=strict;return createFromConfig(c)}function createLocal(input,format,locale,strict){return createLocalOrUTC(input,format,locale,strict,false)}var prototypeMin=deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var other=createLocal.apply(null,arguments);if(this.isValid()&&other.isValid())return other<this?this:other;else return createInvalid()});
var prototypeMax=deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var other=createLocal.apply(null,arguments);if(this.isValid()&&other.isValid())return other>this?this:other;else return createInvalid()});function pickBy(fn,moments){var res,i;if(moments.length===1&&isArray(moments[0]))moments=moments[0];if(!moments.length)return createLocal();res=moments[0];for(i=1;i<moments.length;++i)if(!moments[i].isValid()||moments[i][fn](res))res=
moments[i];return res}function min(){var args=[].slice.call(arguments,0);return pickBy("isBefore",args)}function max(){var args=[].slice.call(arguments,0);return pickBy("isAfter",args)}var now=function(){return Date.now?Date.now():+new Date};var ordering=["year","quarter","month","week","day","hour","minute","second","millisecond"];function isDurationValid(m){for(var key in m)if(!(indexOf.call(ordering,key)!==-1&&(m[key]==null||!isNaN(m[key]))))return false;var unitHasDecimal=false;for(var i=0;i<
ordering.length;++i)if(m[ordering[i]]){if(unitHasDecimal)return false;if(parseFloat(m[ordering[i]])!==toInt(m[ordering[i]]))unitHasDecimal=true}return true}function isValid$1(){return this._isValid}function createInvalid$1(){return createDuration(NaN)}function Duration(duration){var normalizedInput=normalizeObjectUnits(duration),years=normalizedInput.year||0,quarters=normalizedInput.quarter||0,months=normalizedInput.month||0,weeks=normalizedInput.week||normalizedInput.isoWeek||0,days=normalizedInput.day||
0,hours=normalizedInput.hour||0,minutes=normalizedInput.minute||0,seconds=normalizedInput.second||0,milliseconds=normalizedInput.millisecond||0;this._isValid=isDurationValid(normalizedInput);this._milliseconds=+milliseconds+seconds*1E3+minutes*6E4+hours*1E3*60*60;this._days=+days+weeks*7;this._months=+months+quarters*3+years*12;this._data={};this._locale=getLocale();this._bubble()}function isDuration(obj){return obj instanceof Duration}function absRound(number){if(number<0)return Math.round(-1*number)*
-1;else return Math.round(number)}function offset(token,separator){addFormatToken(token,0,0,function(){var offset=this.utcOffset();var sign="+";if(offset<0){offset=-offset;sign="-"}return sign+zeroFill(~~(offset/60),2)+separator+zeroFill(~~offset%60,2)})}offset("Z",":");offset("ZZ","");addRegexToken("Z",matchShortOffset);addRegexToken("ZZ",matchShortOffset);addParseToken(["Z","ZZ"],function(input,array,config){config._useUTC=true;config._tzm=offsetFromString(matchShortOffset,input)});var chunkOffset=
/([\+\-]|\d\d)/gi;function offsetFromString(matcher,string){var matches=(string||"").match(matcher);if(matches===null)return null;var chunk=matches[matches.length-1]||[];var parts=(chunk+"").match(chunkOffset)||["-",0,0];var minutes=+(parts[1]*60)+toInt(parts[2]);return minutes===0?0:parts[0]==="+"?minutes:-minutes}function cloneWithOffset(input,model){var res,diff;if(model._isUTC){res=model.clone();diff=(isMoment(input)||isDate(input)?input.valueOf():createLocal(input).valueOf())-res.valueOf();res._d.setTime(res._d.valueOf()+
diff);hooks.updateOffset(res,false);return res}else return createLocal(input).local()}function getDateOffset(m){return-Math.round(m._d.getTimezoneOffset()/15)*15}hooks.updateOffset=function(){};function getSetOffset(input,keepLocalTime,keepMinutes){var offset=this._offset||0,localAdjust;if(!this.isValid())return input!=null?this:NaN;if(input!=null){if(typeof input==="string"){input=offsetFromString(matchShortOffset,input);if(input===null)return this}else if(Math.abs(input)<16&&!keepMinutes)input=
input*60;if(!this._isUTC&&keepLocalTime)localAdjust=getDateOffset(this);this._offset=input;this._isUTC=true;if(localAdjust!=null)this.add(localAdjust,"m");if(offset!==input)if(!keepLocalTime||this._changeInProgress)addSubtract(this,createDuration(input-offset,"m"),1,false);else if(!this._changeInProgress){this._changeInProgress=true;hooks.updateOffset(this,true);this._changeInProgress=null}return this}else return this._isUTC?offset:getDateOffset(this)}function getSetZone(input,keepLocalTime){if(input!=
null){if(typeof input!=="string")input=-input;this.utcOffset(input,keepLocalTime);return this}else return-this.utcOffset()}function setOffsetToUTC(keepLocalTime){return this.utcOffset(0,keepLocalTime)}function setOffsetToLocal(keepLocalTime){if(this._isUTC){this.utcOffset(0,keepLocalTime);this._isUTC=false;if(keepLocalTime)this.subtract(getDateOffset(this),"m")}return this}function setOffsetToParsedOffset(){if(this._tzm!=null)this.utcOffset(this._tzm,false,true);else if(typeof this._i==="string"){var tZone=
offsetFromString(matchOffset,this._i);if(tZone!=null)this.utcOffset(tZone);else this.utcOffset(0,true)}return this}function hasAlignedHourOffset(input){if(!this.isValid())return false;input=input?createLocal(input).utcOffset():0;return(this.utcOffset()-input)%60===0}function isDaylightSavingTime(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function isDaylightSavingTimeShifted(){if(!isUndefined(this._isDSTShifted))return this._isDSTShifted;
var c={};copyConfig(c,this);c=prepareConfig(c);if(c._a){var other=c._isUTC?createUTC(c._a):createLocal(c._a);this._isDSTShifted=this.isValid()&&compareArrays(c._a,other.toArray())>0}else this._isDSTShifted=false;return this._isDSTShifted}function isLocal(){return this.isValid()?!this._isUTC:false}function isUtcOffset(){return this.isValid()?this._isUTC:false}function isUtc(){return this.isValid()?this._isUTC&&this._offset===0:false}var aspNetRegex=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
var isoRegex=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function createDuration(input,key){var duration=input,match=null,sign,ret,diffRes;if(isDuration(input))duration={ms:input._milliseconds,d:input._days,M:input._months};else if(isNumber(input)){duration={};if(key)duration[key]=input;else duration.milliseconds=input}else if(!!(match=aspNetRegex.exec(input))){sign=match[1]===
"-"?-1:1;duration={y:0,d:toInt(match[DATE])*sign,h:toInt(match[HOUR])*sign,m:toInt(match[MINUTE])*sign,s:toInt(match[SECOND])*sign,ms:toInt(absRound(match[MILLISECOND]*1E3))*sign}}else if(!!(match=isoRegex.exec(input))){sign=match[1]==="-"?-1:1;duration={y:parseIso(match[2],sign),M:parseIso(match[3],sign),w:parseIso(match[4],sign),d:parseIso(match[5],sign),h:parseIso(match[6],sign),m:parseIso(match[7],sign),s:parseIso(match[8],sign)}}else if(duration==null)duration={};else if(typeof duration==="object"&&
("from"in duration||"to"in duration)){diffRes=momentsDifference(createLocal(duration.from),createLocal(duration.to));duration={};duration.ms=diffRes.milliseconds;duration.M=diffRes.months}ret=new Duration(duration);if(isDuration(input)&&hasOwnProp(input,"_locale"))ret._locale=input._locale;return ret}createDuration.fn=Duration.prototype;createDuration.invalid=createInvalid$1;function parseIso(inp,sign){var res=inp&&parseFloat(inp.replace(",","."));return(isNaN(res)?0:res)*sign}function positiveMomentsDifference(base,
other){var res={};res.months=other.month()-base.month()+(other.year()-base.year())*12;if(base.clone().add(res.months,"M").isAfter(other))--res.months;res.milliseconds=+other-+base.clone().add(res.months,"M");return res}function momentsDifference(base,other){var res;if(!(base.isValid()&&other.isValid()))return{milliseconds:0,months:0};other=cloneWithOffset(other,base);if(base.isBefore(other))res=positiveMomentsDifference(base,other);else{res=positiveMomentsDifference(other,base);res.milliseconds=-res.milliseconds;
res.months=-res.months}return res}function createAdder(direction,name){return function(val,period){var dur,tmp;if(period!==null&&!isNaN(+period)){deprecateSimple(name,"moment()."+name+"(period, number) is deprecated. Please use moment()."+name+"(number, period). "+"See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");tmp=val;val=period;period=tmp}val=typeof val==="string"?+val:val;dur=createDuration(val,period);addSubtract(this,dur,direction);return this}}function addSubtract(mom,
duration,isAdding,updateOffset){var milliseconds=duration._milliseconds,days=absRound(duration._days),months=absRound(duration._months);if(!mom.isValid())return;updateOffset=updateOffset==null?true:updateOffset;if(months)setMonth(mom,get(mom,"Month")+months*isAdding);if(days)set$1(mom,"Date",get(mom,"Date")+days*isAdding);if(milliseconds)mom._d.setTime(mom._d.valueOf()+milliseconds*isAdding);if(updateOffset)hooks.updateOffset(mom,days||months)}var add=createAdder(1,"add");var subtract=createAdder(-1,
"subtract");function getCalendarFormat(myMoment,now){var diff=myMoment.diff(now,"days",true);return diff<-6?"sameElse":diff<-1?"lastWeek":diff<0?"lastDay":diff<1?"sameDay":diff<2?"nextDay":diff<7?"nextWeek":"sameElse"}function calendar$1(time,formats){var now=time||createLocal(),sod=cloneWithOffset(now,this).startOf("day"),format=hooks.calendarFormat(this,sod)||"sameElse";var output=formats&&(isFunction(formats[format])?formats[format].call(this,now):formats[format]);return this.format(output||this.localeData().calendar(format,
this,createLocal(now)))}function clone(){return new Moment(this)}function isAfter(input,units){var localInput=isMoment(input)?input:createLocal(input);if(!(this.isValid()&&localInput.isValid()))return false;units=normalizeUnits(units)||"millisecond";if(units==="millisecond")return this.valueOf()>localInput.valueOf();else return localInput.valueOf()<this.clone().startOf(units).valueOf()}function isBefore(input,units){var localInput=isMoment(input)?input:createLocal(input);if(!(this.isValid()&&localInput.isValid()))return false;
units=normalizeUnits(units)||"millisecond";if(units==="millisecond")return this.valueOf()<localInput.valueOf();else return this.clone().endOf(units).valueOf()<localInput.valueOf()}function isBetween(from,to,units,inclusivity){var localFrom=isMoment(from)?from:createLocal(from),localTo=isMoment(to)?to:createLocal(to);if(!(this.isValid()&&localFrom.isValid()&&localTo.isValid()))return false;inclusivity=inclusivity||"()";return(inclusivity[0]==="("?this.isAfter(localFrom,units):!this.isBefore(localFrom,
units))&&(inclusivity[1]===")"?this.isBefore(localTo,units):!this.isAfter(localTo,units))}function isSame(input,units){var localInput=isMoment(input)?input:createLocal(input),inputMs;if(!(this.isValid()&&localInput.isValid()))return false;units=normalizeUnits(units)||"millisecond";if(units==="millisecond")return this.valueOf()===localInput.valueOf();else{inputMs=localInput.valueOf();return this.clone().startOf(units).valueOf()<=inputMs&&inputMs<=this.clone().endOf(units).valueOf()}}function isSameOrAfter(input,
units){return this.isSame(input,units)||this.isAfter(input,units)}function isSameOrBefore(input,units){return this.isSame(input,units)||this.isBefore(input,units)}function diff(input,units,asFloat){var that,zoneDelta,output;if(!this.isValid())return NaN;that=cloneWithOffset(input,this);if(!that.isValid())return NaN;zoneDelta=(that.utcOffset()-this.utcOffset())*6E4;units=normalizeUnits(units);switch(units){case "year":output=monthDiff(this,that)/12;break;case "month":output=monthDiff(this,that);break;
case "quarter":output=monthDiff(this,that)/3;break;case "second":output=(this-that)/1E3;break;case "minute":output=(this-that)/6E4;break;case "hour":output=(this-that)/36E5;break;case "day":output=(this-that-zoneDelta)/864E5;break;case "week":output=(this-that-zoneDelta)/6048E5;break;default:output=this-that}return asFloat?output:absFloor(output)}function monthDiff(a,b){var wholeMonthDiff=(b.year()-a.year())*12+(b.month()-a.month()),anchor=a.clone().add(wholeMonthDiff,"months"),anchor2,adjust;if(b-
anchor<0){anchor2=a.clone().add(wholeMonthDiff-1,"months");adjust=(b-anchor)/(anchor-anchor2)}else{anchor2=a.clone().add(wholeMonthDiff+1,"months");adjust=(b-anchor)/(anchor2-anchor)}return-(wholeMonthDiff+adjust)||0}hooks.defaultFormat="YYYY-MM-DDTHH:mm:ssZ";hooks.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";function toString(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function toISOString(keepOffset){if(!this.isValid())return null;var utc=keepOffset!==true;var m=utc?
this.clone().utc():this;if(m.year()<0||m.year()>9999)return formatMoment(m,utc?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");if(isFunction(Date.prototype.toISOString))if(utc)return this.toDate().toISOString();else return(new Date(this.valueOf()+this.utcOffset()*60*1E3)).toISOString().replace("Z",formatMoment(m,"Z"));return formatMoment(m,utc?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")}function inspect(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";
var func="moment";var zone="";if(!this.isLocal()){func=this.utcOffset()===0?"moment.utc":"moment.parseZone";zone="Z"}var prefix="["+func+'("]';var year=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY";var datetime="-MM-DD[T]HH:mm:ss.SSS";var suffix=zone+'[")]';return this.format(prefix+year+datetime+suffix)}function format(inputString){if(!inputString)inputString=this.isUtc()?hooks.defaultFormatUtc:hooks.defaultFormat;var output=formatMoment(this,inputString);return this.localeData().postformat(output)}
function from(time,withoutSuffix){if(this.isValid()&&(isMoment(time)&&time.isValid()||createLocal(time).isValid()))return createDuration({to:this,from:time}).locale(this.locale()).humanize(!withoutSuffix);else return this.localeData().invalidDate()}function fromNow(withoutSuffix){return this.from(createLocal(),withoutSuffix)}function to(time,withoutSuffix){if(this.isValid()&&(isMoment(time)&&time.isValid()||createLocal(time).isValid()))return createDuration({from:this,to:time}).locale(this.locale()).humanize(!withoutSuffix);
else return this.localeData().invalidDate()}function toNow(withoutSuffix){return this.to(createLocal(),withoutSuffix)}function locale(key){var newLocaleData;if(key===undefined)return this._locale._abbr;else{newLocaleData=getLocale(key);if(newLocaleData!=null)this._locale=newLocaleData;return this}}var lang=deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(key){if(key===undefined)return this.localeData();
else return this.locale(key)});function localeData(){return this._locale}var MS_PER_SECOND=1E3;var MS_PER_MINUTE=60*MS_PER_SECOND;var MS_PER_HOUR=60*MS_PER_MINUTE;var MS_PER_400_YEARS=(365*400+97)*24*MS_PER_HOUR;function mod$1(dividend,divisor){return(dividend%divisor+divisor)%divisor}function localStartOfDate(y,m,d){if(y<100&&y>=0)return new Date(y+400,m,d)-MS_PER_400_YEARS;else return(new Date(y,m,d)).valueOf()}function utcStartOfDate(y,m,d){if(y<100&&y>=0)return Date.UTC(y+400,m,d)-MS_PER_400_YEARS;
else return Date.UTC(y,m,d)}function startOf(units){var time;units=normalizeUnits(units);if(units===undefined||units==="millisecond"||!this.isValid())return this;var startOfDate=this._isUTC?utcStartOfDate:localStartOfDate;switch(units){case "year":time=startOfDate(this.year(),0,1);break;case "quarter":time=startOfDate(this.year(),this.month()-this.month()%3,1);break;case "month":time=startOfDate(this.year(),this.month(),1);break;case "week":time=startOfDate(this.year(),this.month(),this.date()-this.weekday());
break;case "isoWeek":time=startOfDate(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case "day":case "date":time=startOfDate(this.year(),this.month(),this.date());break;case "hour":time=this._d.valueOf();time-=mod$1(time+(this._isUTC?0:this.utcOffset()*MS_PER_MINUTE),MS_PER_HOUR);break;case "minute":time=this._d.valueOf();time-=mod$1(time,MS_PER_MINUTE);break;case "second":time=this._d.valueOf();time-=mod$1(time,MS_PER_SECOND);break}this._d.setTime(time);hooks.updateOffset(this,
true);return this}function endOf(units){var time;units=normalizeUnits(units);if(units===undefined||units==="millisecond"||!this.isValid())return this;var startOfDate=this._isUTC?utcStartOfDate:localStartOfDate;switch(units){case "year":time=startOfDate(this.year()+1,0,1)-1;break;case "quarter":time=startOfDate(this.year(),this.month()-this.month()%3+3,1)-1;break;case "month":time=startOfDate(this.year(),this.month()+1,1)-1;break;case "week":time=startOfDate(this.year(),this.month(),this.date()-this.weekday()+
7)-1;break;case "isoWeek":time=startOfDate(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case "day":case "date":time=startOfDate(this.year(),this.month(),this.date()+1)-1;break;case "hour":time=this._d.valueOf();time+=MS_PER_HOUR-mod$1(time+(this._isUTC?0:this.utcOffset()*MS_PER_MINUTE),MS_PER_HOUR)-1;break;case "minute":time=this._d.valueOf();time+=MS_PER_MINUTE-mod$1(time,MS_PER_MINUTE)-1;break;case "second":time=this._d.valueOf();time+=MS_PER_SECOND-mod$1(time,MS_PER_SECOND)-
1;break}this._d.setTime(time);hooks.updateOffset(this,true);return this}function valueOf(){return this._d.valueOf()-(this._offset||0)*6E4}function unix(){return Math.floor(this.valueOf()/1E3)}function toDate(){return new Date(this.valueOf())}function toArray(){var m=this;return[m.year(),m.month(),m.date(),m.hour(),m.minute(),m.second(),m.millisecond()]}function toObject(){var m=this;return{years:m.year(),months:m.month(),date:m.date(),hours:m.hours(),minutes:m.minutes(),seconds:m.seconds(),milliseconds:m.milliseconds()}}
function toJSON(){return this.isValid()?this.toISOString():null}function isValid$2(){return isValid(this)}function parsingFlags(){return extend({},getParsingFlags(this))}function invalidAt(){return getParsingFlags(this).overflow}function creationData(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}addFormatToken(0,["gg",2],0,function(){return this.weekYear()%100});addFormatToken(0,["GG",2],0,function(){return this.isoWeekYear()%100});function addWeekYearFormatToken(token,
getter){addFormatToken(0,[token,token.length],0,getter)}addWeekYearFormatToken("gggg","weekYear");addWeekYearFormatToken("ggggg","weekYear");addWeekYearFormatToken("GGGG","isoWeekYear");addWeekYearFormatToken("GGGGG","isoWeekYear");addUnitAlias("weekYear","gg");addUnitAlias("isoWeekYear","GG");addUnitPriority("weekYear",1);addUnitPriority("isoWeekYear",1);addRegexToken("G",matchSigned);addRegexToken("g",matchSigned);addRegexToken("GG",match1to2,match2);addRegexToken("gg",match1to2,match2);addRegexToken("GGGG",
match1to4,match4);addRegexToken("gggg",match1to4,match4);addRegexToken("GGGGG",match1to6,match6);addRegexToken("ggggg",match1to6,match6);addWeekParseToken(["gggg","ggggg","GGGG","GGGGG"],function(input,week,config,token){week[token.substr(0,2)]=toInt(input)});addWeekParseToken(["gg","GG"],function(input,week,config,token){week[token]=hooks.parseTwoDigitYear(input)});function getSetWeekYear(input){return getSetWeekYearHelper.call(this,input,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}
function getSetISOWeekYear(input){return getSetWeekYearHelper.call(this,input,this.isoWeek(),this.isoWeekday(),1,4)}function getISOWeeksInYear(){return weeksInYear(this.year(),1,4)}function getWeeksInYear(){var weekInfo=this.localeData()._week;return weeksInYear(this.year(),weekInfo.dow,weekInfo.doy)}function getSetWeekYearHelper(input,week,weekday,dow,doy){var weeksTarget;if(input==null)return weekOfYear(this,dow,doy).year;else{weeksTarget=weeksInYear(input,dow,doy);if(week>weeksTarget)week=weeksTarget;
return setWeekAll.call(this,input,week,weekday,dow,doy)}}function setWeekAll(weekYear,week,weekday,dow,doy){var dayOfYearData=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy),date=createUTCDate(dayOfYearData.year,0,dayOfYearData.dayOfYear);this.year(date.getUTCFullYear());this.month(date.getUTCMonth());this.date(date.getUTCDate());return this}addFormatToken("Q",0,"Qo","quarter");addUnitAlias("quarter","Q");addUnitPriority("quarter",7);addRegexToken("Q",match1);addParseToken("Q",function(input,array){array[MONTH]=
(toInt(input)-1)*3});function getSetQuarter(input){return input==null?Math.ceil((this.month()+1)/3):this.month((input-1)*3+this.month()%3)}addFormatToken("D",["DD",2],"Do","date");addUnitAlias("date","D");addUnitPriority("date",9);addRegexToken("D",match1to2);addRegexToken("DD",match1to2,match2);addRegexToken("Do",function(isStrict,locale){return isStrict?locale._dayOfMonthOrdinalParse||locale._ordinalParse:locale._dayOfMonthOrdinalParseLenient});addParseToken(["D","DD"],DATE);addParseToken("Do",
function(input,array){array[DATE]=toInt(input.match(match1to2)[0])});var getSetDayOfMonth=makeGetSet("Date",true);addFormatToken("DDD",["DDDD",3],"DDDo","dayOfYear");addUnitAlias("dayOfYear","DDD");addUnitPriority("dayOfYear",4);addRegexToken("DDD",match1to3);addRegexToken("DDDD",match3);addParseToken(["DDD","DDDD"],function(input,array,config){config._dayOfYear=toInt(input)});function getSetDayOfYear(input){var dayOfYear=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864E5)+
1;return input==null?dayOfYear:this.add(input-dayOfYear,"d")}addFormatToken("m",["mm",2],0,"minute");addUnitAlias("minute","m");addUnitPriority("minute",14);addRegexToken("m",match1to2);addRegexToken("mm",match1to2,match2);addParseToken(["m","mm"],MINUTE);var getSetMinute=makeGetSet("Minutes",false);addFormatToken("s",["ss",2],0,"second");addUnitAlias("second","s");addUnitPriority("second",15);addRegexToken("s",match1to2);addRegexToken("ss",match1to2,match2);addParseToken(["s","ss"],SECOND);var getSetSecond=
makeGetSet("Seconds",false);addFormatToken("S",0,0,function(){return~~(this.millisecond()/100)});addFormatToken(0,["SS",2],0,function(){return~~(this.millisecond()/10)});addFormatToken(0,["SSS",3],0,"millisecond");addFormatToken(0,["SSSS",4],0,function(){return this.millisecond()*10});addFormatToken(0,["SSSSS",5],0,function(){return this.millisecond()*100});addFormatToken(0,["SSSSSS",6],0,function(){return this.millisecond()*1E3});addFormatToken(0,["SSSSSSS",7],0,function(){return this.millisecond()*
1E4});addFormatToken(0,["SSSSSSSS",8],0,function(){return this.millisecond()*1E5});addFormatToken(0,["SSSSSSSSS",9],0,function(){return this.millisecond()*1E6});addUnitAlias("millisecond","ms");addUnitPriority("millisecond",16);addRegexToken("S",match1to3,match1);addRegexToken("SS",match1to3,match2);addRegexToken("SSS",match1to3,match3);var token;for(token="SSSS";token.length<=9;token+="S")addRegexToken(token,matchUnsigned);function parseMs(input,array){array[MILLISECOND]=toInt(("0."+input)*1E3)}
for(token="S";token.length<=9;token+="S")addParseToken(token,parseMs);var getSetMillisecond=makeGetSet("Milliseconds",false);addFormatToken("z",0,0,"zoneAbbr");addFormatToken("zz",0,0,"zoneName");function getZoneAbbr(){return this._isUTC?"UTC":""}function getZoneName(){return this._isUTC?"Coordinated Universal Time":""}var proto=Moment.prototype;proto.add=add;proto.calendar=calendar$1;proto.clone=clone;proto.diff=diff;proto.endOf=endOf;proto.format=format;proto.from=from;proto.fromNow=fromNow;proto.to=
to;proto.toNow=toNow;proto.get=stringGet;proto.invalidAt=invalidAt;proto.isAfter=isAfter;proto.isBefore=isBefore;proto.isBetween=isBetween;proto.isSame=isSame;proto.isSameOrAfter=isSameOrAfter;proto.isSameOrBefore=isSameOrBefore;proto.isValid=isValid$2;proto.lang=lang;proto.locale=locale;proto.localeData=localeData;proto.max=prototypeMax;proto.min=prototypeMin;proto.parsingFlags=parsingFlags;proto.set=stringSet;proto.startOf=startOf;proto.subtract=subtract;proto.toArray=toArray;proto.toObject=toObject;
proto.toDate=toDate;proto.toISOString=toISOString;proto.inspect=inspect;proto.toJSON=toJSON;proto.toString=toString;proto.unix=unix;proto.valueOf=valueOf;proto.creationData=creationData;proto.year=getSetYear;proto.isLeapYear=getIsLeapYear;proto.weekYear=getSetWeekYear;proto.isoWeekYear=getSetISOWeekYear;proto.quarter=proto.quarters=getSetQuarter;proto.month=getSetMonth;proto.daysInMonth=getDaysInMonth;proto.week=proto.weeks=getSetWeek;proto.isoWeek=proto.isoWeeks=getSetISOWeek;proto.weeksInYear=getWeeksInYear;
proto.isoWeeksInYear=getISOWeeksInYear;proto.date=getSetDayOfMonth;proto.day=proto.days=getSetDayOfWeek;proto.weekday=getSetLocaleDayOfWeek;proto.isoWeekday=getSetISODayOfWeek;proto.dayOfYear=getSetDayOfYear;proto.hour=proto.hours=getSetHour;proto.minute=proto.minutes=getSetMinute;proto.second=proto.seconds=getSetSecond;proto.millisecond=proto.milliseconds=getSetMillisecond;proto.utcOffset=getSetOffset;proto.utc=setOffsetToUTC;proto.local=setOffsetToLocal;proto.parseZone=setOffsetToParsedOffset;proto.hasAlignedHourOffset=
hasAlignedHourOffset;proto.isDST=isDaylightSavingTime;proto.isLocal=isLocal;proto.isUtcOffset=isUtcOffset;proto.isUtc=isUtc;proto.isUTC=isUtc;proto.zoneAbbr=getZoneAbbr;proto.zoneName=getZoneName;proto.dates=deprecate("dates accessor is deprecated. Use date instead.",getSetDayOfMonth);proto.months=deprecate("months accessor is deprecated. Use month instead",getSetMonth);proto.years=deprecate("years accessor is deprecated. Use year instead",getSetYear);proto.zone=deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
getSetZone);proto.isDSTShifted=deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",isDaylightSavingTimeShifted);function createUnix(input){return createLocal(input*1E3)}function createInZone(){return createLocal.apply(null,arguments).parseZone()}function preParsePostFormat(string){return string}var proto$1=Locale.prototype;proto$1.calendar=calendar;proto$1.longDateFormat=longDateFormat;proto$1.invalidDate=invalidDate;proto$1.ordinal=
ordinal;proto$1.preparse=preParsePostFormat;proto$1.postformat=preParsePostFormat;proto$1.relativeTime=relativeTime;proto$1.pastFuture=pastFuture;proto$1.set=set;proto$1.months=localeMonths;proto$1.monthsShort=localeMonthsShort;proto$1.monthsParse=localeMonthsParse;proto$1.monthsRegex=monthsRegex;proto$1.monthsShortRegex=monthsShortRegex;proto$1.week=localeWeek;proto$1.firstDayOfYear=localeFirstDayOfYear;proto$1.firstDayOfWeek=localeFirstDayOfWeek;proto$1.weekdays=localeWeekdays;proto$1.weekdaysMin=
localeWeekdaysMin;proto$1.weekdaysShort=localeWeekdaysShort;proto$1.weekdaysParse=localeWeekdaysParse;proto$1.weekdaysRegex=weekdaysRegex;proto$1.weekdaysShortRegex=weekdaysShortRegex;proto$1.weekdaysMinRegex=weekdaysMinRegex;proto$1.isPM=localeIsPM;proto$1.meridiem=localeMeridiem;function get$1(format,index,field,setter){var locale=getLocale();var utc=createUTC().set(setter,index);return locale[field](utc,format)}function listMonthsImpl(format,index,field){if(isNumber(format)){index=format;format=
undefined}format=format||"";if(index!=null)return get$1(format,index,field,"month");var i;var out=[];for(i=0;i<12;i++)out[i]=get$1(format,i,field,"month");return out}function listWeekdaysImpl(localeSorted,format,index,field){if(typeof localeSorted==="boolean"){if(isNumber(format)){index=format;format=undefined}format=format||""}else{format=localeSorted;index=format;localeSorted=false;if(isNumber(format)){index=format;format=undefined}format=format||""}var locale=getLocale(),shift=localeSorted?locale._week.dow:
0;if(index!=null)return get$1(format,(index+shift)%7,field,"day");var i;var out=[];for(i=0;i<7;i++)out[i]=get$1(format,(i+shift)%7,field,"day");return out}function listMonths(format,index){return listMonthsImpl(format,index,"months")}function listMonthsShort(format,index){return listMonthsImpl(format,index,"monthsShort")}function listWeekdays(localeSorted,format,index){return listWeekdaysImpl(localeSorted,format,index,"weekdays")}function listWeekdaysShort(localeSorted,format,index){return listWeekdaysImpl(localeSorted,
format,index,"weekdaysShort")}function listWeekdaysMin(localeSorted,format,index){return listWeekdaysImpl(localeSorted,format,index,"weekdaysMin")}getSetGlobalLocale("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(number){var b=number%10,output=toInt(number%100/10)===1?"th":b===1?"st":b===2?"nd":b===3?"rd":"th";return number+output}});hooks.lang=deprecate("moment.lang is deprecated. Use moment.locale instead.",getSetGlobalLocale);hooks.langData=deprecate("moment.langData is deprecated. Use moment.localeData instead.",
getLocale);var mathAbs=Math.abs;function abs(){var data=this._data;this._milliseconds=mathAbs(this._milliseconds);this._days=mathAbs(this._days);this._months=mathAbs(this._months);data.milliseconds=mathAbs(data.milliseconds);data.seconds=mathAbs(data.seconds);data.minutes=mathAbs(data.minutes);data.hours=mathAbs(data.hours);data.months=mathAbs(data.months);data.years=mathAbs(data.years);return this}function addSubtract$1(duration,input,value,direction){var other=createDuration(input,value);duration._milliseconds+=
direction*other._milliseconds;duration._days+=direction*other._days;duration._months+=direction*other._months;return duration._bubble()}function add$1(input,value){return addSubtract$1(this,input,value,1)}function subtract$1(input,value){return addSubtract$1(this,input,value,-1)}function absCeil(number){if(number<0)return Math.floor(number);else return Math.ceil(number)}function bubble(){var milliseconds=this._milliseconds;var days=this._days;var months=this._months;var data=this._data;var seconds,
minutes,hours,years,monthsFromDays;if(!(milliseconds>=0&&days>=0&&months>=0||milliseconds<=0&&days<=0&&months<=0)){milliseconds+=absCeil(monthsToDays(months)+days)*864E5;days=0;months=0}data.milliseconds=milliseconds%1E3;seconds=absFloor(milliseconds/1E3);data.seconds=seconds%60;minutes=absFloor(seconds/60);data.minutes=minutes%60;hours=absFloor(minutes/60);data.hours=hours%24;days+=absFloor(hours/24);monthsFromDays=absFloor(daysToMonths(days));months+=monthsFromDays;days-=absCeil(monthsToDays(monthsFromDays));
years=absFloor(months/12);months%=12;data.days=days;data.months=months;data.years=years;return this}function daysToMonths(days){return days*4800/146097}function monthsToDays(months){return months*146097/4800}function as(units){if(!this.isValid())return NaN;var days;var months;var milliseconds=this._milliseconds;units=normalizeUnits(units);if(units==="month"||units==="quarter"||units==="year"){days=this._days+milliseconds/864E5;months=this._months+daysToMonths(days);switch(units){case "month":return months;
case "quarter":return months/3;case "year":return months/12}}else{days=this._days+Math.round(monthsToDays(this._months));switch(units){case "week":return days/7+milliseconds/6048E5;case "day":return days+milliseconds/864E5;case "hour":return days*24+milliseconds/36E5;case "minute":return days*1440+milliseconds/6E4;case "second":return days*86400+milliseconds/1E3;case "millisecond":return Math.floor(days*864E5)+milliseconds;default:throw new Error("Unknown unit "+units);}}}function valueOf$1(){if(!this.isValid())return NaN;
return this._milliseconds+this._days*864E5+this._months%12*2592E6+toInt(this._months/12)*31536E6}function makeAs(alias){return function(){return this.as(alias)}}var asMilliseconds=makeAs("ms");var asSeconds=makeAs("s");var asMinutes=makeAs("m");var asHours=makeAs("h");var asDays=makeAs("d");var asWeeks=makeAs("w");var asMonths=makeAs("M");var asQuarters=makeAs("Q");var asYears=makeAs("y");function clone$1(){return createDuration(this)}function get$2(units){units=normalizeUnits(units);return this.isValid()?
this[units+"s"]():NaN}function makeGetter(name){return function(){return this.isValid()?this._data[name]:NaN}}var milliseconds=makeGetter("milliseconds");var seconds=makeGetter("seconds");var minutes=makeGetter("minutes");var hours=makeGetter("hours");var days=makeGetter("days");var months=makeGetter("months");var years=makeGetter("years");function weeks(){return absFloor(this.days()/7)}var round=Math.round;var thresholds={ss:44,s:45,m:45,h:22,d:26,M:11};function substituteTimeAgo(string,number,withoutSuffix,
isFuture,locale){return locale.relativeTime(number||1,!!withoutSuffix,string,isFuture)}function relativeTime$1(posNegDuration,withoutSuffix,locale){var duration=createDuration(posNegDuration).abs();var seconds=round(duration.as("s"));var minutes=round(duration.as("m"));var hours=round(duration.as("h"));var days=round(duration.as("d"));var months=round(duration.as("M"));var years=round(duration.as("y"));var a=seconds<=thresholds.ss&&["s",seconds]||seconds<thresholds.s&&["ss",seconds]||minutes<=1&&
["m"]||minutes<thresholds.m&&["mm",minutes]||hours<=1&&["h"]||hours<thresholds.h&&["hh",hours]||days<=1&&["d"]||days<thresholds.d&&["dd",days]||months<=1&&["M"]||months<thresholds.M&&["MM",months]||years<=1&&["y"]||["yy",years];a[2]=withoutSuffix;a[3]=+posNegDuration>0;a[4]=locale;return substituteTimeAgo.apply(null,a)}function getSetRelativeTimeRounding(roundingFunction){if(roundingFunction===undefined)return round;if(typeof roundingFunction==="function"){round=roundingFunction;return true}return false}
function getSetRelativeTimeThreshold(threshold,limit){if(thresholds[threshold]===undefined)return false;if(limit===undefined)return thresholds[threshold];thresholds[threshold]=limit;if(threshold==="s")thresholds.ss=limit-1;return true}function humanize(withSuffix){if(!this.isValid())return this.localeData().invalidDate();var locale=this.localeData();var output=relativeTime$1(this,!withSuffix,locale);if(withSuffix)output=locale.pastFuture(+this,output);return locale.postformat(output)}var abs$1=Math.abs;
function sign(x){return(x>0)-(x<0)||+x}function toISOString$1(){if(!this.isValid())return this.localeData().invalidDate();var seconds=abs$1(this._milliseconds)/1E3;var days=abs$1(this._days);var months=abs$1(this._months);var minutes,hours,years;minutes=absFloor(seconds/60);hours=absFloor(minutes/60);seconds%=60;minutes%=60;years=absFloor(months/12);months%=12;var Y=years;var M=months;var D=days;var h=hours;var m=minutes;var s=seconds?seconds.toFixed(3).replace(/\.?0+$/,""):"";var total=this.asSeconds();
if(!total)return"P0D";var totalSign=total<0?"-":"";var ymSign=sign(this._months)!==sign(total)?"-":"";var daysSign=sign(this._days)!==sign(total)?"-":"";var hmsSign=sign(this._milliseconds)!==sign(total)?"-":"";return totalSign+"P"+(Y?ymSign+Y+"Y":"")+(M?ymSign+M+"M":"")+(D?daysSign+D+"D":"")+(h||m||s?"T":"")+(h?hmsSign+h+"H":"")+(m?hmsSign+m+"M":"")+(s?hmsSign+s+"S":"")}var proto$2=Duration.prototype;proto$2.isValid=isValid$1;proto$2.abs=abs;proto$2.add=add$1;proto$2.subtract=subtract$1;proto$2.as=
as;proto$2.asMilliseconds=asMilliseconds;proto$2.asSeconds=asSeconds;proto$2.asMinutes=asMinutes;proto$2.asHours=asHours;proto$2.asDays=asDays;proto$2.asWeeks=asWeeks;proto$2.asMonths=asMonths;proto$2.asQuarters=asQuarters;proto$2.asYears=asYears;proto$2.valueOf=valueOf$1;proto$2._bubble=bubble;proto$2.clone=clone$1;proto$2.get=get$2;proto$2.milliseconds=milliseconds;proto$2.seconds=seconds;proto$2.minutes=minutes;proto$2.hours=hours;proto$2.days=days;proto$2.weeks=weeks;proto$2.months=months;proto$2.years=
years;proto$2.humanize=humanize;proto$2.toISOString=toISOString$1;proto$2.toString=toISOString$1;proto$2.toJSON=toISOString$1;proto$2.locale=locale;proto$2.localeData=localeData;proto$2.toIsoString=deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",toISOString$1);proto$2.lang=lang;addFormatToken("X",0,0,"unix");addFormatToken("x",0,0,"valueOf");addRegexToken("x",matchSigned);addRegexToken("X",matchTimestamp);addParseToken("X",function(input,array,config){config._d=
new Date(parseFloat(input,10)*1E3)});addParseToken("x",function(input,array,config){config._d=new Date(toInt(input))});hooks.version="2.24.0";setHookCallback(createLocal);hooks.fn=proto;hooks.min=min;hooks.max=max;hooks.now=now;hooks.utc=createUTC;hooks.unix=createUnix;hooks.months=listMonths;hooks.isDate=isDate;hooks.locale=getSetGlobalLocale;hooks.invalid=createInvalid;hooks.duration=createDuration;hooks.isMoment=isMoment;hooks.weekdays=listWeekdays;hooks.parseZone=createInZone;hooks.localeData=
getLocale;hooks.isDuration=isDuration;hooks.monthsShort=listMonthsShort;hooks.weekdaysMin=listWeekdaysMin;hooks.defineLocale=defineLocale;hooks.updateLocale=updateLocale;hooks.locales=listLocales;hooks.weekdaysShort=listWeekdaysShort;hooks.normalizeUnits=normalizeUnits;hooks.relativeTimeRounding=getSetRelativeTimeRounding;hooks.relativeTimeThreshold=getSetRelativeTimeThreshold;hooks.calendarFormat=getCalendarFormat;hooks.prototype=proto;hooks.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",
DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"};return hooks});"use strict";function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}function _iterableToArrayLimit(arr,i){var _i=null==arr?null:"undefined"!=typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_x,_r,_arr=[],_n=!0,_d=!1;try{if(_x=(_i=_i.call(arr)).next,0===i){if(Object(_i)!==_i)return;_n=!1}else for(;!(_n=(_s=_x.call(_i)).done)&&(_arr.push(_s.value),_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&null!=_i.return&&(_r=_i.return(),Object(_r)!==_r))return}finally{if(_d)throw _e;}}return _arr}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}
function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]}},e:function e(_e2){throw _e2;},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o)},n:function n(){var step=it.next();normalCompletion=step.done;return step},e:function e(_e3){didErr=true;err=_e3},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return()}finally{if(didErr)throw err;}}}}function _construct(Parent,args,Class){if(_isNativeReflectConstruct())_construct=Reflect.construct.bind();else _construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=
Function.bind.apply(Parent,a);var instance=new Constructor;if(Class)_setPrototypeOf(instance,Class.prototype);return instance};return _construct.apply(null,arguments)}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true}catch(e){return false}}function _setPrototypeOf(o,p){_setPrototypeOf=
Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(o,p){o.__proto__=p;return o};return _setPrototypeOf(o,p)}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o,
minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}function _iterableToArray(iter){if(typeof Symbol!=="undefined"&&iter[Symbol.iterator]!=null||iter["@@iterator"]!=null)return Array.from(iter)}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}
function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}(function(global,factory){(typeof exports==="undefined"?"undefined":
_typeof(exports))==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.DOMPurify=factory())})(void 0,function(){var entries=Object.entries,setPrototypeOf=Object.setPrototypeOf,isFrozen=Object.isFrozen,getPrototypeOf=Object.getPrototypeOf,getOwnPropertyDescriptor=Object.getOwnPropertyDescriptor;var freeze=Object.freeze,seal=Object.seal,create=Object.create;var _ref=
typeof Reflect!=="undefined"&&Reflect,apply=_ref.apply,construct=_ref.construct;if(!apply)apply=function apply(fun,thisValue,args){return fun.apply(thisValue,args)};if(!freeze)freeze=function freeze(x){return x};if(!seal)seal=function seal(x){return x};if(!construct)construct=function construct(Func,args){return _construct(Func,_toConsumableArray(args))};var arrayForEach=unapply(Array.prototype.forEach);var arrayPop=unapply(Array.prototype.pop);var arrayPush=unapply(Array.prototype.push);var stringToLowerCase=
unapply(String.prototype.toLowerCase);var stringToString=unapply(String.prototype.toString);var stringMatch=unapply(String.prototype.match);var stringReplace=unapply(String.prototype.replace);var stringIndexOf=unapply(String.prototype.indexOf);var stringTrim=unapply(String.prototype.trim);var regExpTest=unapply(RegExp.prototype.test);var typeErrorCreate=unconstruct(TypeError);function unapply(func){return function(thisArg){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<
_len;_key++)args[_key-1]=arguments[_key];return apply(func,thisArg,args)}}function unconstruct(func){return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return construct(func,args)}}function addToSet(set,array,transformCaseFunc){var _transformCaseFunc;transformCaseFunc=(_transformCaseFunc=transformCaseFunc)!==null&&_transformCaseFunc!==void 0?_transformCaseFunc:stringToLowerCase;if(setPrototypeOf)setPrototypeOf(set,null);
var l=array.length;while(l--){var element=array[l];if(typeof element==="string"){var lcElement=transformCaseFunc(element);if(lcElement!==element){if(!isFrozen(array))array[l]=lcElement;element=lcElement}}set[element]=true}return set}function clone(object){var newObject=create(null);var _iterator=_createForOfIteratorHelper(entries(object)),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var _step$value=_slicedToArray(_step.value,2),property=_step$value[0],value=_step$value[1];newObject[property]=
value}}catch(err){_iterator.e(err)}finally{_iterator.f()}return newObject}function lookupGetter(object,prop){while(object!==null){var desc=getOwnPropertyDescriptor(object,prop);if(desc){if(desc.get)return unapply(desc.get);if(typeof desc.value==="function")return unapply(desc.value)}object=getPrototypeOf(object)}function fallbackValue(element){console.warn("fallback value for",element);return null}return fallbackValue}var html$1=freeze(["a","abbr","acronym","address","area","article","aside","audio",
"b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option",
"output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]);var svg$1=freeze(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref",
"hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]);var svgFilters=freeze(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode",
"feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]);var svgDisallowed=freeze(["animate","color-profile","cursor","discard","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]);var mathMl$1=freeze(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts",
"mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover","mprescripts"]);var mathMlDisallowed=freeze(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]);var text=freeze(["#text"]);var html=freeze(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture",
"autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength",
"media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]);var svg=freeze(["accent-height",
"accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family",
"font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits",
"max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation",
"stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector",
"ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]);var mathMl=freeze(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan",
"rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]);var xml=freeze(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]);var MUSTACHE_EXPR=seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);var ERB_EXPR=seal(/<%[\w\W]*|[\w\W]*%>/gm);var TMPLIT_EXPR=seal(/\${[\w\W]*}/gm);var DATA_ATTR=seal(/^data-[\-\w.\u00B7-\uFFFF]/);var ARIA_ATTR=seal(/^aria-[\-\w]+$/);var IS_ALLOWED_URI=
seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);var IS_SCRIPT_OR_DATA=seal(/^(?:\w+script|data):/i);var ATTR_WHITESPACE=seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);var DOCTYPE_NAME=seal(/^html$/i);var EXPRESSIONS=Object.freeze({__proto__:null,MUSTACHE_EXPR:MUSTACHE_EXPR,ERB_EXPR:ERB_EXPR,TMPLIT_EXPR:TMPLIT_EXPR,DATA_ATTR:DATA_ATTR,ARIA_ATTR:ARIA_ATTR,IS_ALLOWED_URI:IS_ALLOWED_URI,IS_SCRIPT_OR_DATA:IS_SCRIPT_OR_DATA,ATTR_WHITESPACE:ATTR_WHITESPACE,
DOCTYPE_NAME:DOCTYPE_NAME});var getGlobal=function getGlobal(){return typeof window==="undefined"?null:window};var _createTrustedTypesPolicy=function _createTrustedTypesPolicy(trustedTypes,purifyHostElement){if(_typeof(trustedTypes)!=="object"||typeof trustedTypes.createPolicy!=="function")return null;var suffix=null;var ATTR_NAME="data-tt-policy-suffix";if(purifyHostElement&&purifyHostElement.hasAttribute(ATTR_NAME))suffix=purifyHostElement.getAttribute(ATTR_NAME);var policyName="dompurify"+(suffix?
"#"+suffix:"");try{return trustedTypes.createPolicy(policyName,{createHTML:function createHTML(html){return html},createScriptURL:function createScriptURL(scriptUrl){return scriptUrl}})}catch(_){console.warn("TrustedTypes policy "+policyName+" could not be created.");return null}};function createDOMPurify(){var window=arguments.length>0&&arguments[0]!==undefined?arguments[0]:getGlobal();var DOMPurify=function DOMPurify(root){return createDOMPurify(root)};DOMPurify.version="3.0.3";DOMPurify.removed=
[];if(!window||!window.document||window.document.nodeType!==9){DOMPurify.isSupported=false;return DOMPurify}var originalDocument=window.document;var currentScript=originalDocument.currentScript;var document=window.document;var DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,Element=window.Element,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=_window$NamedNodeMap===void 0?window.NamedNodeMap||window.MozNamedAttrMap:
_window$NamedNodeMap,HTMLFormElement=window.HTMLFormElement,DOMParser=window.DOMParser,trustedTypes=window.trustedTypes;var ElementPrototype=Element.prototype;var cloneNode=lookupGetter(ElementPrototype,"cloneNode");var getNextSibling=lookupGetter(ElementPrototype,"nextSibling");var getChildNodes=lookupGetter(ElementPrototype,"childNodes");var getParentNode=lookupGetter(ElementPrototype,"parentNode");if(typeof HTMLTemplateElement==="function"){var template=document.createElement("template");if(template.content&&
template.content.ownerDocument)document=template.content.ownerDocument}var trustedTypesPolicy;var emptyHTML="";var _document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,createDocumentFragment=_document.createDocumentFragment,getElementsByTagName=_document.getElementsByTagName;var importNode=originalDocument.importNode;var hooks={};DOMPurify.isSupported=typeof entries==="function"&&typeof getParentNode==="function"&&implementation&&implementation.createHTMLDocument!==
undefined;var MUSTACHE_EXPR=EXPRESSIONS.MUSTACHE_EXPR,ERB_EXPR=EXPRESSIONS.ERB_EXPR,TMPLIT_EXPR=EXPRESSIONS.TMPLIT_EXPR,DATA_ATTR=EXPRESSIONS.DATA_ATTR,ARIA_ATTR=EXPRESSIONS.ARIA_ATTR,IS_SCRIPT_OR_DATA=EXPRESSIONS.IS_SCRIPT_OR_DATA,ATTR_WHITESPACE=EXPRESSIONS.ATTR_WHITESPACE;var IS_ALLOWED_URI$1=EXPRESSIONS.IS_ALLOWED_URI;var ALLOWED_TAGS=null;var DEFAULT_ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(html$1),_toConsumableArray(svg$1),_toConsumableArray(svgFilters),_toConsumableArray(mathMl$1),
_toConsumableArray(text)));var ALLOWED_ATTR=null;var DEFAULT_ALLOWED_ATTR=addToSet({},[].concat(_toConsumableArray(html),_toConsumableArray(svg),_toConsumableArray(mathMl),_toConsumableArray(xml)));var CUSTOM_ELEMENT_HANDLING=Object.seal(Object.create(null,{tagNameCheck:{writable:true,configurable:false,enumerable:true,value:null},attributeNameCheck:{writable:true,configurable:false,enumerable:true,value:null},allowCustomizedBuiltInElements:{writable:true,configurable:false,enumerable:true,value:false}}));
var FORBID_TAGS=null;var FORBID_ATTR=null;var ALLOW_ARIA_ATTR=true;var ALLOW_DATA_ATTR=true;var ALLOW_UNKNOWN_PROTOCOLS=false;var ALLOW_SELF_CLOSE_IN_ATTR=true;var SAFE_FOR_TEMPLATES=false;var WHOLE_DOCUMENT=false;var SET_CONFIG=false;var FORCE_BODY=false;var RETURN_DOM=false;var RETURN_DOM_FRAGMENT=false;var RETURN_TRUSTED_TYPE=false;var SANITIZE_DOM=true;var SANITIZE_NAMED_PROPS=false;var SANITIZE_NAMED_PROPS_PREFIX="user-content-";var KEEP_CONTENT=true;var IN_PLACE=false;var USE_PROFILES={};var FORBID_CONTENTS=
null;var DEFAULT_FORBID_CONTENTS=addToSet({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]);var DATA_URI_TAGS=null;var DEFAULT_DATA_URI_TAGS=addToSet({},["audio","video","img","source","image","track"]);var URI_SAFE_ATTRIBUTES=null;var DEFAULT_URI_SAFE_ATTRIBUTES=addToSet({},["alt","class","for","id","label","name","pattern",
"placeholder","role","summary","title","value","style","xmlns"]);var MATHML_NAMESPACE="http://www.w3.org/1998/Math/MathML";var SVG_NAMESPACE="http://www.w3.org/2000/svg";var HTML_NAMESPACE="http://www.w3.org/1999/xhtml";var NAMESPACE=HTML_NAMESPACE;var IS_EMPTY_INPUT=false;var ALLOWED_NAMESPACES=null;var DEFAULT_ALLOWED_NAMESPACES=addToSet({},[MATHML_NAMESPACE,SVG_NAMESPACE,HTML_NAMESPACE],stringToString);var PARSER_MEDIA_TYPE;var SUPPORTED_PARSER_MEDIA_TYPES=["application/xhtml+xml","text/html"];
var DEFAULT_PARSER_MEDIA_TYPE="text/html";var transformCaseFunc;var CONFIG=null;var formElement=document.createElement("form");var isRegexOrFunction=function isRegexOrFunction(testValue){return testValue instanceof RegExp||testValue instanceof Function};var _parseConfig=function _parseConfig(cfg){if(CONFIG&&CONFIG===cfg)return;if(!cfg||_typeof(cfg)!=="object")cfg={};cfg=clone(cfg);PARSER_MEDIA_TYPE=SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE)===-1?PARSER_MEDIA_TYPE=DEFAULT_PARSER_MEDIA_TYPE:
PARSER_MEDIA_TYPE=cfg.PARSER_MEDIA_TYPE;transformCaseFunc=PARSER_MEDIA_TYPE==="application/xhtml+xml"?stringToString:stringToLowerCase;ALLOWED_TAGS="ALLOWED_TAGS"in cfg?addToSet({},cfg.ALLOWED_TAGS,transformCaseFunc):DEFAULT_ALLOWED_TAGS;ALLOWED_ATTR="ALLOWED_ATTR"in cfg?addToSet({},cfg.ALLOWED_ATTR,transformCaseFunc):DEFAULT_ALLOWED_ATTR;ALLOWED_NAMESPACES="ALLOWED_NAMESPACES"in cfg?addToSet({},cfg.ALLOWED_NAMESPACES,stringToString):DEFAULT_ALLOWED_NAMESPACES;URI_SAFE_ATTRIBUTES="ADD_URI_SAFE_ATTR"in
cfg?addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),cfg.ADD_URI_SAFE_ATTR,transformCaseFunc):DEFAULT_URI_SAFE_ATTRIBUTES;DATA_URI_TAGS="ADD_DATA_URI_TAGS"in cfg?addToSet(clone(DEFAULT_DATA_URI_TAGS),cfg.ADD_DATA_URI_TAGS,transformCaseFunc):DEFAULT_DATA_URI_TAGS;FORBID_CONTENTS="FORBID_CONTENTS"in cfg?addToSet({},cfg.FORBID_CONTENTS,transformCaseFunc):DEFAULT_FORBID_CONTENTS;FORBID_TAGS="FORBID_TAGS"in cfg?addToSet({},cfg.FORBID_TAGS,transformCaseFunc):{};FORBID_ATTR="FORBID_ATTR"in cfg?addToSet({},cfg.FORBID_ATTR,
transformCaseFunc):{};USE_PROFILES="USE_PROFILES"in cfg?cfg.USE_PROFILES:false;ALLOW_ARIA_ATTR=cfg.ALLOW_ARIA_ATTR!==false;ALLOW_DATA_ATTR=cfg.ALLOW_DATA_ATTR!==false;ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||false;ALLOW_SELF_CLOSE_IN_ATTR=cfg.ALLOW_SELF_CLOSE_IN_ATTR!==false;SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||false;WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||false;RETURN_DOM=cfg.RETURN_DOM||false;RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||false;RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||
false;FORCE_BODY=cfg.FORCE_BODY||false;SANITIZE_DOM=cfg.SANITIZE_DOM!==false;SANITIZE_NAMED_PROPS=cfg.SANITIZE_NAMED_PROPS||false;KEEP_CONTENT=cfg.KEEP_CONTENT!==false;IN_PLACE=cfg.IN_PLACE||false;IS_ALLOWED_URI$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI;NAMESPACE=cfg.NAMESPACE||HTML_NAMESPACE;CUSTOM_ELEMENT_HANDLING=cfg.CUSTOM_ELEMENT_HANDLING||{};if(cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck))CUSTOM_ELEMENT_HANDLING.tagNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
if(cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck))CUSTOM_ELEMENT_HANDLING.attributeNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;if(cfg.CUSTOM_ELEMENT_HANDLING&&typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements==="boolean")CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements=cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;if(SAFE_FOR_TEMPLATES)ALLOW_DATA_ATTR=false;if(RETURN_DOM_FRAGMENT)RETURN_DOM=true;if(USE_PROFILES){ALLOWED_TAGS=
addToSet({},_toConsumableArray(text));ALLOWED_ATTR=[];if(USE_PROFILES.html===true){addToSet(ALLOWED_TAGS,html$1);addToSet(ALLOWED_ATTR,html)}if(USE_PROFILES.svg===true){addToSet(ALLOWED_TAGS,svg$1);addToSet(ALLOWED_ATTR,svg);addToSet(ALLOWED_ATTR,xml)}if(USE_PROFILES.svgFilters===true){addToSet(ALLOWED_TAGS,svgFilters);addToSet(ALLOWED_ATTR,svg);addToSet(ALLOWED_ATTR,xml)}if(USE_PROFILES.mathMl===true){addToSet(ALLOWED_TAGS,mathMl$1);addToSet(ALLOWED_ATTR,mathMl);addToSet(ALLOWED_ATTR,xml)}}if(cfg.ADD_TAGS){if(ALLOWED_TAGS===
DEFAULT_ALLOWED_TAGS)ALLOWED_TAGS=clone(ALLOWED_TAGS);addToSet(ALLOWED_TAGS,cfg.ADD_TAGS,transformCaseFunc)}if(cfg.ADD_ATTR){if(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR)ALLOWED_ATTR=clone(ALLOWED_ATTR);addToSet(ALLOWED_ATTR,cfg.ADD_ATTR,transformCaseFunc)}if(cfg.ADD_URI_SAFE_ATTR)addToSet(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR,transformCaseFunc);if(cfg.FORBID_CONTENTS){if(FORBID_CONTENTS===DEFAULT_FORBID_CONTENTS)FORBID_CONTENTS=clone(FORBID_CONTENTS);addToSet(FORBID_CONTENTS,cfg.FORBID_CONTENTS,transformCaseFunc)}if(KEEP_CONTENT)ALLOWED_TAGS["#text"]=
true;if(WHOLE_DOCUMENT)addToSet(ALLOWED_TAGS,["html","head","body"]);if(ALLOWED_TAGS.table){addToSet(ALLOWED_TAGS,["tbody"]);delete FORBID_TAGS.tbody}if(cfg.TRUSTED_TYPES_POLICY){if(typeof cfg.TRUSTED_TYPES_POLICY.createHTML!=="function")throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');if(typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL!=="function")throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
trustedTypesPolicy=cfg.TRUSTED_TYPES_POLICY;emptyHTML=trustedTypesPolicy.createHTML("")}else{if(trustedTypesPolicy===undefined)trustedTypesPolicy=_createTrustedTypesPolicy(trustedTypes,currentScript);if(trustedTypesPolicy!==null&&typeof emptyHTML==="string")emptyHTML=trustedTypesPolicy.createHTML("")}if(freeze)freeze(cfg);CONFIG=cfg};var MATHML_TEXT_INTEGRATION_POINTS=addToSet({},["mi","mo","mn","ms","mtext"]);var HTML_INTEGRATION_POINTS=addToSet({},["foreignobject","desc","title","annotation-xml"]);
var COMMON_SVG_AND_HTML_ELEMENTS=addToSet({},["title","style","font","a","script"]);var ALL_SVG_TAGS=addToSet({},svg$1);addToSet(ALL_SVG_TAGS,svgFilters);addToSet(ALL_SVG_TAGS,svgDisallowed);var ALL_MATHML_TAGS=addToSet({},mathMl$1);addToSet(ALL_MATHML_TAGS,mathMlDisallowed);var _checkValidNamespace=function _checkValidNamespace(element){var parent=getParentNode(element);if(!parent||!parent.tagName)parent={namespaceURI:NAMESPACE,tagName:"template"};var tagName=stringToLowerCase(element.tagName);var parentTagName=
stringToLowerCase(parent.tagName);if(!ALLOWED_NAMESPACES[element.namespaceURI])return false;if(element.namespaceURI===SVG_NAMESPACE){if(parent.namespaceURI===HTML_NAMESPACE)return tagName==="svg";if(parent.namespaceURI===MATHML_NAMESPACE)return tagName==="svg"&&(parentTagName==="annotation-xml"||MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);return Boolean(ALL_SVG_TAGS[tagName])}if(element.namespaceURI===MATHML_NAMESPACE){if(parent.namespaceURI===HTML_NAMESPACE)return tagName==="math";if(parent.namespaceURI===
SVG_NAMESPACE)return tagName==="math"&&HTML_INTEGRATION_POINTS[parentTagName];return Boolean(ALL_MATHML_TAGS[tagName])}if(element.namespaceURI===HTML_NAMESPACE){if(parent.namespaceURI===SVG_NAMESPACE&&!HTML_INTEGRATION_POINTS[parentTagName])return false;if(parent.namespaceURI===MATHML_NAMESPACE&&!MATHML_TEXT_INTEGRATION_POINTS[parentTagName])return false;return!ALL_MATHML_TAGS[tagName]&&(COMMON_SVG_AND_HTML_ELEMENTS[tagName]||!ALL_SVG_TAGS[tagName])}if(PARSER_MEDIA_TYPE==="application/xhtml+xml"&&
ALLOWED_NAMESPACES[element.namespaceURI])return true;return false};var _forceRemove=function _forceRemove(node){arrayPush(DOMPurify.removed,{element:node});try{node.parentNode.removeChild(node)}catch(_){node.remove()}};var _removeAttribute=function _removeAttribute(name,node){try{arrayPush(DOMPurify.removed,{attribute:node.getAttributeNode(name),from:node})}catch(_){arrayPush(DOMPurify.removed,{attribute:null,from:node})}node.removeAttribute(name);if(name==="is"&&!ALLOWED_ATTR[name])if(RETURN_DOM||
RETURN_DOM_FRAGMENT)try{_forceRemove(node)}catch(_){}else try{node.setAttribute(name,"")}catch(_){}};var _initDocument=function _initDocument(dirty){var doc;var leadingWhitespace;if(FORCE_BODY)dirty="\x3cremove\x3e\x3c/remove\x3e"+dirty;else{var matches=stringMatch(dirty,/^[\r\n\t ]+/);leadingWhitespace=matches&&matches[0]}if(PARSER_MEDIA_TYPE==="application/xhtml+xml"&&NAMESPACE===HTML_NAMESPACE)dirty='\x3chtml xmlns\x3d"http://www.w3.org/1999/xhtml"\x3e\x3chead\x3e\x3c/head\x3e\x3cbody\x3e'+dirty+
"\x3c/body\x3e\x3c/html\x3e";var dirtyPayload=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;if(NAMESPACE===HTML_NAMESPACE)try{doc=(new DOMParser).parseFromString(dirtyPayload,PARSER_MEDIA_TYPE)}catch(_){}if(!doc||!doc.documentElement){doc=implementation.createDocument(NAMESPACE,"template",null);try{doc.documentElement.innerHTML=IS_EMPTY_INPUT?emptyHTML:dirtyPayload}catch(_){}}var body=doc.body||doc.documentElement;if(dirty&&leadingWhitespace)body.insertBefore(document.createTextNode(leadingWhitespace),
body.childNodes[0]||null);if(NAMESPACE===HTML_NAMESPACE)return getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0];return WHOLE_DOCUMENT?doc.documentElement:body};var _createIterator=function _createIterator(root){return createNodeIterator.call(root.ownerDocument||root,root,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,null,false)};var _isClobbered=function _isClobbered(elm){return elm instanceof HTMLFormElement&&(typeof elm.nodeName!=="string"||typeof elm.textContent!==
"string"||typeof elm.removeChild!=="function"||!(elm.attributes instanceof NamedNodeMap)||typeof elm.removeAttribute!=="function"||typeof elm.setAttribute!=="function"||typeof elm.namespaceURI!=="string"||typeof elm.insertBefore!=="function"||typeof elm.hasChildNodes!=="function")};var _isNode=function _isNode(object){return _typeof(Node)==="object"?object instanceof Node:object&&_typeof(object)==="object"&&typeof object.nodeType==="number"&&typeof object.nodeName==="string"};var _executeHook=function _executeHook(entryPoint,
currentNode,data){if(!hooks[entryPoint])return;arrayForEach(hooks[entryPoint],function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)})};var _sanitizeElements=function _sanitizeElements(currentNode){var content;_executeHook("beforeSanitizeElements",currentNode,null);if(_isClobbered(currentNode)){_forceRemove(currentNode);return true}var tagName=transformCaseFunc(currentNode.nodeName);_executeHook("uponSanitizeElement",currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS});if(currentNode.hasChildNodes()&&
!_isNode(currentNode.firstElementChild)&&(!_isNode(currentNode.content)||!_isNode(currentNode.content.firstElementChild))&&regExpTest(/<[/\w]/g,currentNode.innerHTML)&&regExpTest(/<[/\w]/g,currentNode.textContent)){_forceRemove(currentNode);return true}if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){if(!FORBID_TAGS[tagName]&&_basicCustomElementTest(tagName)){if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck,tagName))return false;if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof
Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))return false}if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]){var parentNode=getParentNode(currentNode)||currentNode.parentNode;var childNodes=getChildNodes(currentNode)||currentNode.childNodes;if(childNodes&&parentNode){var childCount=childNodes.length;for(var i=childCount-1;i>=0;--i)parentNode.insertBefore(cloneNode(childNodes[i],true),getNextSibling(currentNode))}}_forceRemove(currentNode);return true}if(currentNode instanceof Element&&!_checkValidNamespace(currentNode)){_forceRemove(currentNode);
return true}if((tagName==="noscript"||tagName==="noembed")&&regExpTest(/<\/no(script|embed)/i,currentNode.innerHTML)){_forceRemove(currentNode);return true}if(SAFE_FOR_TEMPLATES&&currentNode.nodeType===3){content=currentNode.textContent;content=stringReplace(content,MUSTACHE_EXPR," ");content=stringReplace(content,ERB_EXPR," ");content=stringReplace(content,TMPLIT_EXPR," ");if(currentNode.textContent!==content){arrayPush(DOMPurify.removed,{element:currentNode.cloneNode()});currentNode.textContent=
content}}_executeHook("afterSanitizeElements",currentNode,null);return false};var _isValidAttribute=function _isValidAttribute(lcTag,lcName,value){if(SANITIZE_DOM&&(lcName==="id"||lcName==="name")&&(value in document||value in formElement))return false;if(ALLOW_DATA_ATTR&&!FORBID_ATTR[lcName]&&regExpTest(DATA_ATTR,lcName));else if(ALLOW_ARIA_ATTR&&regExpTest(ARIA_ATTR,lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName])if(_basicCustomElementTest(lcTag)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof
RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck,lcTag)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck,lcName)||CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName))||lcName==="is"&&CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof
RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck,value)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));else return false;else if(URI_SAFE_ATTRIBUTES[lcName]);else if(regExpTest(IS_ALLOWED_URI$1,stringReplace(value,ATTR_WHITESPACE,"")));else if((lcName==="src"||lcName==="xlink:href"||lcName==="href")&&lcTag!=="script"&&stringIndexOf(value,"data:")===0&&DATA_URI_TAGS[lcTag]);else if(ALLOW_UNKNOWN_PROTOCOLS&&!regExpTest(IS_SCRIPT_OR_DATA,
stringReplace(value,ATTR_WHITESPACE,"")));else if(value)return false;else;return true};var _basicCustomElementTest=function _basicCustomElementTest(tagName){return tagName.indexOf("-")>0};var _sanitizeAttributes=function _sanitizeAttributes(currentNode){var attr;var value;var lcName;var l;_executeHook("beforeSanitizeAttributes",currentNode,null);var attributes=currentNode.attributes;if(!attributes)return;var hookEvent={attrName:"",attrValue:"",keepAttr:true,allowedAttributes:ALLOWED_ATTR};l=attributes.length;
while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;value=name==="value"?attr.value:stringTrim(attr.value);lcName=transformCaseFunc(name);hookEvent.attrName=lcName;hookEvent.attrValue=value;hookEvent.keepAttr=true;hookEvent.forceKeepAttr=undefined;_executeHook("uponSanitizeAttribute",currentNode,hookEvent);value=hookEvent.attrValue;if(hookEvent.forceKeepAttr)continue;_removeAttribute(name,currentNode);if(!hookEvent.keepAttr)continue;if(!ALLOW_SELF_CLOSE_IN_ATTR&&
regExpTest(/\/>/i,value)){_removeAttribute(name,currentNode);continue}if(SAFE_FOR_TEMPLATES){value=stringReplace(value,MUSTACHE_EXPR," ");value=stringReplace(value,ERB_EXPR," ");value=stringReplace(value,TMPLIT_EXPR," ")}var lcTag=transformCaseFunc(currentNode.nodeName);if(!_isValidAttribute(lcTag,lcName,value))continue;if(SANITIZE_NAMED_PROPS&&(lcName==="id"||lcName==="name")){_removeAttribute(name,currentNode);value=SANITIZE_NAMED_PROPS_PREFIX+value}if(trustedTypesPolicy&&_typeof(trustedTypes)===
"object"&&typeof trustedTypes.getAttributeType==="function")if(namespaceURI);else switch(trustedTypes.getAttributeType(lcTag,lcName)){case "TrustedHTML":value=trustedTypesPolicy.createHTML(value);break;case "TrustedScriptURL":value=trustedTypesPolicy.createScriptURL(value);break}try{if(namespaceURI)currentNode.setAttributeNS(namespaceURI,name,value);else currentNode.setAttribute(name,value);arrayPop(DOMPurify.removed)}catch(_){}}_executeHook("afterSanitizeAttributes",currentNode,null)};var _sanitizeShadowDOM=
function _sanitizeShadowDOM(fragment){var shadowNode;var shadowIterator=_createIterator(fragment);_executeHook("beforeSanitizeShadowDOM",fragment,null);while(shadowNode=shadowIterator.nextNode()){_executeHook("uponSanitizeShadowNode",shadowNode,null);if(_sanitizeElements(shadowNode))continue;if(shadowNode.content instanceof DocumentFragment)_sanitizeShadowDOM(shadowNode.content);_sanitizeAttributes(shadowNode)}_executeHook("afterSanitizeShadowDOM",fragment,null)};DOMPurify.sanitize=function(dirty){var cfg=
arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var body;var importedNode;var currentNode;var returnNode;IS_EMPTY_INPUT=!dirty;if(IS_EMPTY_INPUT)dirty="\x3c!--\x3e";if(typeof dirty!=="string"&&!_isNode(dirty))if(typeof dirty.toString==="function"){dirty=dirty.toString();if(typeof dirty!=="string")throw typeErrorCreate("dirty is not a string, aborting");}else throw typeErrorCreate("toString is not a function");if(!DOMPurify.isSupported)return dirty;if(!SET_CONFIG)_parseConfig(cfg);DOMPurify.removed=
[];if(typeof dirty==="string")IN_PLACE=false;if(IN_PLACE){if(dirty.nodeName){var tagName=transformCaseFunc(dirty.nodeName);if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName])throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");}}else if(dirty instanceof Node){body=_initDocument("\x3c!----\x3e");importedNode=body.ownerDocument.importNode(dirty,true);if(importedNode.nodeType===1&&importedNode.nodeName==="BODY")body=importedNode;else if(importedNode.nodeName==="HTML")body=importedNode;
else body.appendChild(importedNode)}else{if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&dirty.indexOf("\x3c")===-1)return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(dirty):dirty;body=_initDocument(dirty);if(!body)return RETURN_DOM?null:RETURN_TRUSTED_TYPE?emptyHTML:""}if(body&&FORCE_BODY)_forceRemove(body.firstChild);var nodeIterator=_createIterator(IN_PLACE?dirty:body);while(currentNode=nodeIterator.nextNode()){if(_sanitizeElements(currentNode))continue;if(currentNode.content instanceof
DocumentFragment)_sanitizeShadowDOM(currentNode.content);_sanitizeAttributes(currentNode)}if(IN_PLACE)return dirty;if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild)returnNode.appendChild(body.firstChild)}else returnNode=body;if(ALLOWED_ATTR.shadowroot||ALLOWED_ATTR.shadowrootmod)returnNode=importNode.call(originalDocument,returnNode,true);return returnNode}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;if(WHOLE_DOCUMENT&&
ALLOWED_TAGS["!doctype"]&&body.ownerDocument&&body.ownerDocument.doctype&&body.ownerDocument.doctype.name&&regExpTest(DOCTYPE_NAME,body.ownerDocument.doctype.name))serializedHTML="\x3c!DOCTYPE "+body.ownerDocument.doctype.name+"\x3e\n"+serializedHTML;if(SAFE_FOR_TEMPLATES){serializedHTML=stringReplace(serializedHTML,MUSTACHE_EXPR," ");serializedHTML=stringReplace(serializedHTML,ERB_EXPR," ");serializedHTML=stringReplace(serializedHTML,TMPLIT_EXPR," ")}return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?
trustedTypesPolicy.createHTML(serializedHTML):serializedHTML};DOMPurify.setConfig=function(cfg){_parseConfig(cfg);SET_CONFIG=true};DOMPurify.clearConfig=function(){CONFIG=null;SET_CONFIG=false};DOMPurify.isValidAttribute=function(tag,attr,value){if(!CONFIG)_parseConfig({});var lcTag=transformCaseFunc(tag);var lcName=transformCaseFunc(attr);return _isValidAttribute(lcTag,lcName,value)};DOMPurify.addHook=function(entryPoint,hookFunction){if(typeof hookFunction!=="function")return;hooks[entryPoint]=
hooks[entryPoint]||[];arrayPush(hooks[entryPoint],hookFunction)};DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint])return arrayPop(hooks[entryPoint])};DOMPurify.removeHooks=function(entryPoint){if(hooks[entryPoint])hooks[entryPoint]=[]};DOMPurify.removeAllHooks=function(){hooks={}};return DOMPurify}var purify=createDOMPurify();return purify})};
